
  <!DOCTYPE html>
  <html lang="en"  
    
      data-theme-mode="auto"
    
  >
  <head>
  
  <meta charset="utf-8">
  

  

  

  <script>window.REIMU_CONFIG = {};window.REIMU_CONFIG.icon_font = '4552607_0khxww3tj3q9';window.REIMU_CONFIG.clipboard_tips = {"success":{"en":"复制成功","zh-CN":"复制成功","zh-TW":"複製成功 (*^▽^*)","ja":"コピー成功 (*^▽^*)","pt-BR":"Copiado com sucesso (*^▽^*)"},"fail":{"en":"复制失败","zh-CN":"复制失败","zh-TW":"複製失敗 (ﾟ⊿ﾟ)ﾂ","ja":"コピー失敗 (ﾟ⊿ﾟ)ﾂ","pt-BR":"Falha ao copiar (ﾟ⊿ﾟ)ﾂ"},"copyright":{"enable":false,"count":50,"license_type":"by-nc-sa"}};window.REIMU_CONFIG.clipboard_tips.copyright.content = 'All articles on this blog are licensed under the BY-NC-SA license agreement unless otherwise stated. Please indicate the source when reprinting!';window.REIMU_CONFIG.code_block = {"expand":true};window.REIMU_CONFIG.base = 'http://example.com';</script>
  
  <title>
    Web3 实习计划 - 2025 夏季 |
    
    mX1@0_blog
  </title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
  
    <link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin><link rel="preload" as="style" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic&display=swap"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic&display=swap" media="print" onload="this.media&#x3D;&#39;all&#39;">
  
  
    <link rel="preload" href="//at.alicdn.com/t/c/font_4552607_0khxww3tj3q9.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  
  
    
<link rel="stylesheet" href="/css/loader.css">

  
  
    <meta name="description" content="Web3 实习计划 - 2025 夏季在这个Web3实习计划之前，其实我学过一些区块链的内容，但是也仅仅是知道一些概念性的东西，例如，PoW、PoS、defi等一些概念，所以参加这个实习计划也是为了更深入的学习Web3的内容，接下来是我的每日学习笔记 8月4日区块链基础概念区块链介绍区块链是一种去中心化的分布式账本技术，用于在网络节点之间安全、透明且不可篡改地记录事务数据  去中心化：区块链网络通">
<meta property="og:type" content="article">
<meta property="og:title" content="Web3 实习计划 - 2025 夏季">
<meta property="og:url" content="http://example.com/2025/08/04/web3-shi-xi-ji-hua-2025-xia-ji/index.html">
<meta property="og:site_name" content="mX1@0_blog">
<meta property="og:description" content="Web3 实习计划 - 2025 夏季在这个Web3实习计划之前，其实我学过一些区块链的内容，但是也仅仅是知道一些概念性的东西，例如，PoW、PoS、defi等一些概念，所以参加这个实习计划也是为了更深入的学习Web3的内容，接下来是我的每日学习笔记 8月4日区块链基础概念区块链介绍区块链是一种去中心化的分布式账本技术，用于在网络节点之间安全、透明且不可篡改地记录事务数据  去中心化：区块链网络通">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-04%20205327.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-05%20144514.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-05%20145026.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-05%20145933.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-05%20150754.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-05%20151348.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-05%20151843.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-05%20155308.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-05%20153732.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-09%20200259.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-11%20123802.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-11%20124451.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-11%20124904.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-11%20125811.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-11%20154641.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-14%20152454.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-14%20153536.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-14%20153629.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-15%20183046.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-19%20224746.png">
<meta property="article:published_time" content="2025-08-04T12:34:47.066Z">
<meta property="article:modified_time" content="2025-08-20T15:42:23.316Z">
<meta property="article:author" content="mX1@0">
<meta property="article:tag" content="实习计划">
<meta property="article:tag" content="Web3">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-04%20205327.png">
  
  
  
    <link rel="shortcut icon" href="/images/%E5%9B%BE1.jpg">
  
  
<link rel="stylesheet" href="/css/style.css">

  <link rel="preload" as="style" onload="this.onload&#x3D;null;this.rel&#x3D;&#39;stylesheet&#39;" href="https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.css" integrity="sha384-IfxC36XL&#x2F;toUyJ939C73PcgMuRzAZuIzZxE38drsmO5p6jD7ei+Zx&#x2F;1oA&#x2F;0l8ysE" crossorigin="anonymous">
  
  
  
  
    
<script src="https://npm.webcache.cn/pace-js@1.2.4/pace.min.js" integrity="sha384-k6YtvFUEIuEFBdrLKJ3YAUbBki333tj1CSUisai5Cswsg9wcLNaPzsTHDswp4Az8" crossorigin="anonymous"></script>

  
  
    
<link rel="stylesheet" href="https://npm.webcache.cn/@reimujs/aos@0.1.2/dist/aos.css" integrity="sha384-GMRP93c6Hkz9JVKGAuRR3nTS7M07RwPgTFenXiosjq2VbVgvdDNcz1g6Mkj8AONa" crossorigin="anonymous">

  
  
  
<meta name="generator" content="Hexo 7.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

  <body>
    
    
  <div id='loader'>
    <div class="loading-left-bg loading-bg"></div>
    <div class="loading-right-bg loading-bg"></div>
    <div class="spinner-box">
      <div class="loading-taichi rotate">
        
          <svg width="150" height="150" viewBox="0 0 1024 1024" class="icon" version="1.1" xmlns="https://www.w3.org/2000/svg" shape-rendering="geometricPrecision">
            <path d="M303.5 432A80 80 0 0 1 291.5 592A80 80 0 0 1 303.5 432z" fill="var(--red-1, #ff5252)" />
            <path d="M512 65A447 447 0 0 1 512 959L512 929A417 417 0 0 0 512 95A417 417 0 0 0 512 929L512 959A447 447 0 0 1 512 65z 
           M512 95A417 417 0 0 1 929 512A208.5 208.5 0 0 1 720.5 720.5L720.5 592A80 80 0 0 0 720.5 432A80 80 0 0 0 720.5 592L720.5 720.5A208.5 208.5 0 0 1 512 512A208.5 208.5 0 0 0 303.5 303.5A208.5 208.5 0 0 0 95 512A417 417 0 0 1 512 95z" fill="var(--red-1, #ff5252)" />
          </svg>
        
      </div>
      
      
        
      
      <div class="loading-word">加载中...</div>
    </div>
  </div>
  </div>
  <script>
    var time = null;
    var startLoading = () => {
      time = Date.now();
      document.getElementById('loader').classList.remove("loading");
    }
    var endLoading = () => {
      if (!time) {
        document.body.style.overflow = 'auto';
        document.getElementById('loader').classList.add("loading");
      } else {
        if (Date.now() - time > 500) {
          time = null;
          document.body.style.overflow = 'auto';
          document.getElementById('loader').classList.add("loading");
        } else {
          setTimeout(endLoading, 500 - (Date.now() - time));
          time = null;
        }
      }
    }
    window.addEventListener('DOMContentLoaded', endLoading);
    document.getElementById('loader').addEventListener('click', endLoading);
  </script>

<div id="copy-tooltip" style="pointer-events: none; opacity: 0; transition: all 0.2s ease; position: fixed;top: 50%;left: 50%;z-index: 999;transform: translate(-50%, -50%);color: white;background: rgba(0, 0, 0, 0.5);padding: 10px 15px;border-radius: 10px;">
</div>
<div id="heatmap-tooltip"></div>


    <div id="container">
      <div id="wrap">
        <div id="header-nav">
  <nav id="main-nav">
    
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
             
              &#xe62b;
             
          </div>
          <a class="main-nav-link" href="/">首页</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
             
              &#xe62b;
             
          </div>
          <a class="main-nav-link" href="/archives">归类</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
             
              &#xe62b;
             
          </div>
          <a class="main-nav-link" href="/about">关于</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
             
              &#xe62b;
             
          </div>
          <a class="main-nav-link" href="/friend">友链</a>
        </span>
      
    
    <a id="main-nav-toggle" class="nav-icon"></a>
  </nav>
  <nav id="sub-nav">
    
    
    
  </nav>
  
</div>
<header id="header">
  
    
      
        <picture>
          
        </picture>
        
          <img  fetchpriority="high" src="/images/%E7%8E%9B%E8%8E%8E%E6%8B%89%E8%92%82.jpg" alt="Web3 实习计划 - 2025 夏季">
        
      
    
  
  <div id="header-outer">
    <div id="header-title">
      
        
        
          <a href="/" id="logo">
            <h1 data-aos="slide-up">Web3 实习计划 - 2025 夏季</h1>
          </a>
        
      
      
        
        <h2 id="subtitle-wrap" data-aos="slide-down">
          
        </h2>
      
    </div>
  </div>
</header>

        <div id="content" class="sidebar-left"  >
          <aside id="sidebar">
  
  
  
  <div class="sidebar-wrapper wrap-sticky">
    <div class="sidebar-wrap" data-aos="fade-up">
      
        
          <div class="sidebar-toc-sidebar"><div class="sidebar-toc">
  <h3 class="toc-title">Contents</h3>
  <div class="sidebar-toc-wrapper toc-div-class" >
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Web3-%E5%AE%9E%E4%B9%A0%E8%AE%A1%E5%88%92-2025-%E5%A4%8F%E5%AD%A3"><span class="toc-text">Web3 实习计划 - 2025 夏季</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E6%9C%884%E6%97%A5"><span class="toc-text">8月4日</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-text">区块链基础概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E4%BB%8B%E7%BB%8D"><span class="toc-text">区块链介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E7%89%B9%E6%80%A7"><span class="toc-text">区块链特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-text">区块链的核心组成部分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E7%9A%84%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8C%BA%E5%9D%97%E9%93%BE"><span class="toc-text">去中心化的网络和区块链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%B4%E6%8C%81%E7%BD%91%E7%BB%9C%E8%BF%90%E8%A1%8C%E7%9A%84%E4%BB%A3%E5%B8%81%E6%BF%80%E5%8A%B1"><span class="toc-text">维持网络运行的代币激励</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E9%93%BE-%E7%A7%81%E9%93%BE-%E8%81%94%E7%9B%9F%E9%93%BE"><span class="toc-text">公链 私链 联盟链</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AC%E9%93%BE%EF%BC%88Public-Blockchain%EF%BC%89"><span class="toc-text">公链（Public Blockchain）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%81%E9%93%BE%EF%BC%88Private-Blockchain%EF%BC%89"><span class="toc-text">私链（Private Blockchain）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%94%E7%9B%9F%E9%93%BE%EF%BC%88Consortium-Blockchain%EF%BC%89"><span class="toc-text">联盟链（Consortium Blockchain）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93"><span class="toc-text">对比总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E4%BE%9D%E6%8D%AE"><span class="toc-text">选择依据</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E6%9C%885%E6%97%A5"><span class="toc-text">8月5日</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%A6%82%E8%A7%88"><span class="toc-text">以太坊概览</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%BB%8B%E7%BB%8D"><span class="toc-text">以太坊介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ethereum-%E4%B8%8E-Bitcoin-%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-text">Ethereum 与 Bitcoin 的差异</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%9A%84%E5%AE%9A%E4%BD%8D%E4%B8%8E%E6%BC%94%E8%BF%9B"><span class="toc-text">以太坊的定位与演进</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E5%9D%8A1-0%EF%BC%88PoW%E9%98%B6%E6%AE%B5%EF%BC%89"><span class="toc-text">以太坊1.0（PoW阶段）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E5%9D%8A2-0%E4%B8%8EThe-Merge%EF%BC%9A%E4%BB%8E%E5%8F%8C%E9%93%BE%E5%B9%B6%E8%A1%8C%E5%88%B0%E5%AE%8C%E7%BE%8E%E5%90%88%E5%B9%B6"><span class="toc-text">以太坊2.0与The Merge：从双链并行到完美合并</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AA%E6%9D%A5%E5%8D%87%E7%BA%A7%E8%B7%AF%E7%BA%BF"><span class="toc-text">未来升级路线</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%94%9F%E6%80%81%E6%A6%82%E8%A7%88%EF%BC%9AL1%E3%80%81L2%E3%80%81Sidechains-%E7%AD%89"><span class="toc-text">以太坊生态概览：L1、L2、Sidechains 等</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%96%87%E5%8C%96%E4%B8%8E%E4%BB%B7%E5%80%BC%E8%A7%82"><span class="toc-text">以太坊文化与价值观</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%EF%BC%9A%E4%BB%8E%E8%B4%A6%E6%88%B7%E5%88%B0%E6%89%A7%E8%A1%8C%E7%9A%84%E5%AE%8C%E6%95%B4%E9%93%BE%E8%B7%AF"><span class="toc-text">以太坊核心机制：从账户到执行的完整链路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unphishable%E9%92%93%E9%B1%BC%E6%94%BB%E9%98%B2%E6%8C%91%E6%88%98"><span class="toc-text">Unphishable钓鱼攻防挑战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E7%BA%A7"><span class="toc-text">初级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#No-0x0001-Web3-%E9%92%B1%E5%8C%85%E8%AE%BE%E7%BD%AE%E6%8C%87%E5%8D%97"><span class="toc-text">No.0x0001 Web3 钱包设置指南</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#No-0x0002-%E9%92%B1%E5%8C%85%E6%81%A2%E5%A4%8D%E5%8A%A9%E6%89%8B"><span class="toc-text">No.0x0002 钱包恢复助手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#No-0x0003-USDC-Permit-%E9%92%93%E9%B1%BC%E6%A8%A1%E6%8B%9F"><span class="toc-text">No.0x0003 USDC Permit 钓鱼模拟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#No-0x0004-%E4%B8%93%E5%B1%9E%E4%BB%A3%E5%B8%81%E7%A9%BA%E6%8A%95"><span class="toc-text">No.0x0004 专属代币空投</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#No-0x0005-USDT-%E6%8E%88%E6%9D%83%E9%92%93%E9%B1%BC%E6%A8%A1%E6%8B%9F"><span class="toc-text">No.0x0005 USDT 授权钓鱼模拟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#No-0x0006-%E5%81%87%E5%86%92%E4%BB%A3%E5%B8%81%E7%A9%BA%E6%8A%95%E9%92%93%E9%B1%BC%E6%94%BB%E5%87%BB"><span class="toc-text">No.0x0006 假冒代币空投钓鱼攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#No-0x0007-%E8%B6%85%E9%AB%98%E6%94%B6%E7%9B%8A%E8%B4%A8%E6%8A%BC%E5%B9%B3%E5%8F%B0"><span class="toc-text">No.0x0007 超高收益质押平台</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#No-0x0008-Telegram-%E4%BB%A3%E5%B8%81%E9%92%93%E9%B1%BC%E6%8C%91%E6%88%98"><span class="toc-text">No.0x0008 Telegram 代币钓鱼挑战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#No-0x0009-Punycode-%E9%92%93%E9%B1%BC%E6%94%BB%E5%87%BB"><span class="toc-text">No.0x0009 Punycode 钓鱼攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Punycode%EF%BC%9F"><span class="toc-text">什么是 Punycode？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#No-0x0010-%E5%89%AA%E8%B4%B4%E6%9D%BF%E9%92%93%E9%B1%BC%E6%8C%91%E6%88%98"><span class="toc-text">No.0x0010 剪贴板钓鱼挑战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#No-0x0011-Google-%E6%90%9C%E7%B4%A2%E5%B9%BF%E5%91%8A%E9%92%93%E9%B1%BC%E6%94%BB%E5%87%BB"><span class="toc-text">No.0x0011 Google 搜索广告钓鱼攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#No-0x0012-Microsoft-Teams-%E9%92%93%E9%B1%BC%E6%94%BB%E5%87%BB"><span class="toc-text">No.0x0012 Microsoft Teams 钓鱼攻击</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Microsoft-Teams-%E9%92%93%E9%B1%BC%E6%94%BB%E5%87%BB%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">Microsoft Teams 钓鱼攻击的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#No-0x0037-%E8%99%9A%E5%81%87%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F%E9%92%93%E9%B1%BC"><span class="toc-text">No.0x0037 虚假扩展程序钓鱼</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E7%BA%A7"><span class="toc-text">中级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#No-0x0013-TransferFrom-%E9%9B%B6%E5%80%BC%E8%BD%AC%E8%B4%A6%E9%92%93%E9%B1%BC%E6%8C%91%E6%88%98"><span class="toc-text">No.0x0013 TransferFrom 零值转账钓鱼挑战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%88%E9%AA%97%E8%80%85%E5%88%A9%E7%94%A8%E2%80%9C%E9%9B%B6%E5%80%BC%E8%BD%AC%E8%B4%A6%E2%80%9D%E4%BC%AA%E9%80%A0%E4%BA%A4%E6%98%93%E5%8E%86%E5%8F%B2%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E9%98%B2%E8%8C%83%E6%8E%AA%E6%96%BD"><span class="toc-text">诈骗者利用“零值转账”伪造交易历史的原理及防范措施</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86"><span class="toc-text">1. 攻击原理</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E6%9C%886%E6%97%A5"><span class="toc-text">8月6日</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MyFirstLayer2"><span class="toc-text">MyFirstLayer2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%85%AC%E9%93%BE%E7%93%B6%E9%A2%88"><span class="toc-text">1 公链瓶颈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1%E6%94%B9%E8%BF%9B%E5%B0%9D%E8%AF%95"><span class="toc-text">1.1改进尝试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%89%E9%9A%BE%E5%9B%B0%E5%A2%83"><span class="toc-text">1.2 区块链三难困境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-Layer-2"><span class="toc-text">1.3 Layer 2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Layer-2%E5%8F%91%E5%B1%95%E5%8F%B2"><span class="toc-text">2 Layer 2发展史</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E7%8A%B6%E6%80%81%E9%80%9A%E9%81%93%EF%BC%88State-channel%EF%BC%89"><span class="toc-text">2.1 状态通道（State channel）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E4%BE%A7%E9%93%BE%EF%BC%88Sidechain%EF%BC%89"><span class="toc-text">2.2 侧链（Sidechain）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-Plasma"><span class="toc-text">2.3 Plasma</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-Rollup"><span class="toc-text">2.4 Rollup</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E%EF%BC%88Zero-Knowledge-Proof-ZKP%EF%BC%89%E8%AF%A6%E8%A7%A3"><span class="toc-text">零知识证明（Zero-Knowledge Proof, ZKP）详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E%E7%9A%84%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="toc-text">1. 零知识证明的三大核心特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BB%8F%E5%85%B8%E7%B1%BB%E6%AF%94%EF%BC%9A%E6%B4%9E%E7%A9%B4%E5%AF%93%E8%A8%80"><span class="toc-text">2. 经典类比：洞穴寓言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E%E7%9A%84%E4%B8%A4%E7%A7%8D%E4%B8%BB%E8%A6%81%E7%B1%BB%E5%9E%8B"><span class="toc-text">3. 零知识证明的两种主要类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84-ZKP-%E6%8A%80%E6%9C%AF"><span class="toc-text">4. 区块链中的 ZKP 技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E%E7%9A%84%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8"><span class="toc-text">5. 零知识证明的区块链应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">6. 零知识证明的优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-Layer-2-%E5%AF%B9%E6%AF%94"><span class="toc-text">2.5 Layer 2 对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Rollup%E8%AF%A6%E6%83%85"><span class="toc-text">3 Rollup详情</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E5%A6%82%E4%BD%95%E5%8E%8B%E7%BC%A9"><span class="toc-text">3.1 如何压缩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%8E%8B%E7%BC%A9"><span class="toc-text">3.2 进一步压缩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-Optimistic-Rollup"><span class="toc-text">3.3 Optimistic Rollup</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-Zero-Knowledge-Proof"><span class="toc-text">3.4 Zero-Knowledge Proof</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-ZK-%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86-STARK-vs-SNARK"><span class="toc-text">3.5 ZK 技术原理 STARK vs SNARK</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#SNARK"><span class="toc-text">SNARK</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#STARK"><span class="toc-text">STARK</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-ZK-%E5%8F%91%E5%B1%95%E8%B7%AF%E7%BA%BF-ZK-VM-vs-ZK-EVM"><span class="toc-text">3.6 ZK 发展路线 ZK-VM vs ZK-EVM</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ZK-VM%EF%BC%9A%E4%BB%8E%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E%E7%9A%84%E8%A7%92%E5%BA%A6%E5%87%BA%E5%8F%91"><span class="toc-text">ZK-VM：从零知识证明的角度出发</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ZK-EVM%EF%BC%9A%E4%BB%8E-EVM-%E5%85%BC%E5%AE%B9%E6%80%A7%E7%9A%84%E8%A7%92%E5%BA%A6%E5%87%BA%E5%8F%91"><span class="toc-text">ZK-EVM：从 EVM 兼容性的角度出发</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%9C%AA%E6%9D%A5%E5%B1%95%E6%9C%9B"><span class="toc-text">4 未来展望</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E5%85%B6%E5%AE%83%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9AValidium-%E5%92%8C-Volition"><span class="toc-text">4.1 其它解决方案：Validium 和 Volition</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Validium"><span class="toc-text">Validium</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Volition"><span class="toc-text">Volition</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-Deneb-%E6%9B%B4%E6%96%B0%E4%B8%8E-Layer-2"><span class="toc-text">4.2 Deneb 更新与 Layer 2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E8%B4%A6%E6%88%B7%E6%8A%BD%E8%B1%A1%E4%B8%8E%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%BA%94%E7%94%A8"><span class="toc-text">4.3 账户抽象与大规模应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E5%B2%97%E4%BD%8D%E5%85%A8%E6%99%AF%E5%9B%BE"><span class="toc-text">区块链岗位全景图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%8A%80%E6%9C%AF%E5%B2%97"><span class="toc-text">一、技术岗</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88"><span class="toc-text">1. 前端工程师</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%90%8E%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88"><span class="toc-text">2. 后端工程师</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%B7%A5%E7%A8%8B%E5%B8%88"><span class="toc-text">3. 智能合约工程师</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E9%9D%9E%E6%8A%80%E6%9C%AF%E5%B2%97"><span class="toc-text">二、非技术岗</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BA%A7%E5%93%81%E4%B8%8E%E8%BF%90%E8%90%A5"><span class="toc-text">1. 产品与运营</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%A4%BE%E5%8C%BA%E7%AE%A1%E7%90%86"><span class="toc-text">2. 社区管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%A0%94%E7%A9%B6%E5%88%86%E6%9E%90"><span class="toc-text">3. 研究分析</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E6%9C%887%E6%97%A5"><span class="toc-text">8月7日</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%8C%E4%B8%9A%E8%B5%9B%E9%81%93%E5%85%A8%E8%A7%88"><span class="toc-text">行业赛道全览</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E6%9C%888%E6%97%A5"><span class="toc-text">8月8日</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CryptoZombiesx%E7%9A%84solidity%E5%AD%A6%E4%B9%A0"><span class="toc-text">CryptoZombiesx的solidity学习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Solidity-Beginner-to-Intermediate-Smart-Contracts"><span class="toc-text">Solidity: Beginner to Intermediate Smart Contracts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lesson1-%E6%90%AD%E5%BB%BA%E5%83%B5%E5%B0%B8%E5%B7%A5%E5%8E%82"><span class="toc-text">lesson1 搭建僵尸工厂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E5%90%88%E7%BA%A6"><span class="toc-text">第2章: 合约</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B4%E6%95%B0"><span class="toc-text">第3章: 状态变量和整数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97"><span class="toc-text">第4章: 数学运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">第5章: 结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E6%95%B0%E7%BB%84"><span class="toc-text">第6章: 数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><span class="toc-text">第7章: 定义函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-text">第8章: 使用结构体和数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-%E7%A7%81%E6%9C%89-%E5%85%AC%E5%85%B1%E5%87%BD%E6%95%B0"><span class="toc-text">第9章: 私有 &#x2F; 公共函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-%E5%87%BD%E6%95%B0%E7%9A%84%E6%9B%B4%E5%A4%9A%E5%B1%9E%E6%80%A7"><span class="toc-text">第10章: 函数的更多属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-Keccak256-%E5%92%8C-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">第11章: Keccak256 和 类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-%E6%94%BE%E5%9C%A8%E4%B8%80%E8%B5%B7"><span class="toc-text">第12章: 放在一起</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-%E4%BA%8B%E4%BB%B6"><span class="toc-text">第13章: 事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-Web3-js"><span class="toc-text">第14章: Web3.js</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E6%9C%889%E6%97%A5"><span class="toc-text">8月9日</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Chainlink%E9%A2%84%E8%A8%80%E6%9C%BA%E7%9A%84solidity%E8%AF%BE%E7%A8%8B"><span class="toc-text">Chainlink预言机的solidity课程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#solidity%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E5%87%BD%E6%95%B0%E3%80%81%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">solidity数据类型、函数、存储模式、数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#solidity%E7%9A%84%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-text">solidity的工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D"><span class="toc-text">工厂模式介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E5%90%88%E7%BA%A6%E6%96%B9%E5%BC%8F"><span class="toc-text">引入合约方式</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E6%9C%8810%E6%97%A5"><span class="toc-text">8月10日</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CryptoZombiesx%E7%9A%84solidity%E5%AD%A6%E4%B9%A0-1"><span class="toc-text">CryptoZombiesx的solidity学习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Solidity-Beginner-to-Intermediate-Smart-Contracts-1"><span class="toc-text">Solidity: Beginner to Intermediate Smart Contracts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lesson2-%E5%83%B5%E5%B0%B8%E6%94%BB%E5%87%BB%E4%BA%BA%E7%B1%BB"><span class="toc-text">lesson2 僵尸攻击人类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E6%98%A0%E5%B0%84%EF%BC%88Mapping%EF%BC%89%E5%92%8C%E5%9C%B0%E5%9D%80%EF%BC%88Address%EF%BC%89"><span class="toc-text">第2章: 映射（Mapping）和地址（Address）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-Msg-sender"><span class="toc-text">第3章: Msg.sender</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-Require"><span class="toc-text">第4章: Require</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E7%BB%A7%E6%89%BF%EF%BC%88Inheritance%EF%BC%89"><span class="toc-text">第5章: 继承（Inheritance）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E5%BC%95%E5%85%A5%EF%BC%88Import%EF%BC%89"><span class="toc-text">第6章: 引入（Import）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-Storage%E4%B8%8EMemory"><span class="toc-text">第7章: Storage与Memory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E5%83%B5%E5%B0%B8%E7%9A%84DNA"><span class="toc-text">第8章: 僵尸的DNA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-%E6%9B%B4%E5%A4%9A%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-text">第9章: 更多关于函数可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-%E5%83%B5%E5%B0%B8%E5%90%83%E4%BB%80%E4%B9%88"><span class="toc-text">第10章: 僵尸吃什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3"><span class="toc-text">第11章: 使用接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-%E5%A4%84%E7%90%86%E5%A4%9A%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">第12章: 处理多返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-%E5%A5%96%E5%8A%B1-Kitty-%E5%9F%BA%E5%9B%A0"><span class="toc-text">第13章: 奖励: Kitty 基因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-%E6%94%BE%E5%9C%A8%E4%B8%80%E8%B5%B7"><span class="toc-text">第14章: 放在一起</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E6%9C%8811%E6%97%A5"><span class="toc-text">8月11日</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Chainlink%E9%A2%84%E8%A8%80%E6%9C%BA%E7%9A%84solidity%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B"><span class="toc-text">Chainlink预言机的solidity进阶课程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E8%A8%80%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88Chainlink%EF%BC%89"><span class="toc-text">预言机网络（Chainlink）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%96%82%E4%BB%B7%EF%BC%88Data-Feed%EF%BC%89"><span class="toc-text">喂价（Data Feed）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Data-Feed-%E6%9E%B6%E6%9E%84"><span class="toc-text">Data Feed 架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Data-Feed-%E7%BB%93%E6%9E%84"><span class="toc-text">Data Feed 结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2%E4%B8%80%E4%B8%AAFundMe%E7%9A%84%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6"><span class="toc-text">部署一个FundMe的智能合约</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E8%B4%A6%E7%9A%84%E4%B8%89%E7%A7%8D%E7%B1%BB%E5%9E%8B"><span class="toc-text">转账的三种类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E6%AC%BE"><span class="toc-text">提款</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E9%94%81"><span class="toc-text">时间锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#modifier%E4%BF%AE%E6%94%B9%E5%99%A8"><span class="toc-text">modifier修改器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91"><span class="toc-text">智能合约开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Dapp-%E6%9E%B6%E6%9E%84%E5%92%8C%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B"><span class="toc-text">Dapp 架构和开发流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Dapp-%E6%9E%B6%E6%9E%84"><span class="toc-text">Dapp 架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dapp-%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B"><span class="toc-text">Dapp 开发流程</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E6%9C%8812%E6%97%A5"><span class="toc-text">8月12日</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CryptoZombiesx%E7%9A%84solidity%E5%AD%A6%E4%B9%A0-2"><span class="toc-text">CryptoZombiesx的solidity学习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Solidity-Beginner-to-Intermediate-Smart-Contracts-2"><span class="toc-text">Solidity: Beginner to Intermediate Smart Contracts</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lesson3-%E9%AB%98%E7%BA%A7-Solidity-%E7%90%86%E8%AE%BA"><span class="toc-text">lesson3 高级 Solidity 理论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-%E6%99%BA%E8%83%BD%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%B0%B8%E5%9B%BA%E6%80%A7"><span class="toc-text">第1章: 智能协议的永固性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-Ownable-Contracts"><span class="toc-text">第2章: Ownable Contracts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-onlyOwner-%E5%87%BD%E6%95%B0%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">第3章: onlyOwner 函数修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-Gas"><span class="toc-text">第4章: Gas</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E6%97%B6%E9%97%B4%E5%8D%95%E4%BD%8D"><span class="toc-text">第5章: 时间单位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E5%83%B5%E5%B0%B8%E5%86%B7%E5%8D%B4"><span class="toc-text">第6章: 僵尸冷却</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-%E5%85%AC%E6%9C%89%E5%87%BD%E6%95%B0%E5%92%8C%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-text">第7章: 公有函数和安全性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%87%BD%E6%95%B0%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">第8章: 进一步了解函数修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-%E5%83%B5%E5%B0%B8%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">第9章: 僵尸修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-%E5%88%A9%E7%94%A8-%E2%80%98View%E2%80%99-%E5%87%BD%E6%95%B0%E8%8A%82%E7%9C%81-Gas"><span class="toc-text">第10章: 利用 ‘View’ 函数节省 Gas</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-%E5%AD%98%E5%82%A8%E9%9D%9E%E5%B8%B8%E6%98%82%E8%B4%B5"><span class="toc-text">第11章: 存储非常昂贵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-For-%E5%BE%AA%E7%8E%AF"><span class="toc-text">第12章: For 循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-%E6%94%BE%E5%9C%A8%E4%B8%80%E8%B5%B7"><span class="toc-text">第13章: 放在一起</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lesson4-%E5%83%B5%E5%B0%B8%E4%BD%9C%E6%88%98%E7%B3%BB%E7%BB%9F"><span class="toc-text">lesson4 僵尸作战系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-%E5%8F%AF%E6%94%AF%E4%BB%98"><span class="toc-text">第1章: 可支付</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E6%8F%90%E7%8E%B0"><span class="toc-text">第2章: 提现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-%E5%83%B5%E5%B0%B8%E6%88%98%E6%96%97"><span class="toc-text">第3章: 僵尸战斗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="toc-text">第4章: 随机数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E5%83%B5%E5%B0%B8%E5%AF%B9%E6%88%98"><span class="toc-text">第5章: 僵尸对战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E9%87%8D%E6%9E%84%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91"><span class="toc-text">第6章: 重构通用逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-%E6%9B%B4%E5%A4%9A%E9%87%8D%E6%9E%84"><span class="toc-text">第7章: 更多重构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E5%9B%9E%E5%88%B0%E6%94%BB%E5%87%BB%EF%BC%81"><span class="toc-text">第8章: 回到攻击！</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-%E5%83%B5%E5%B0%B8%E7%9A%84%E8%BE%93%E8%B5%A2"><span class="toc-text">第9章: 僵尸的输赢</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-%E5%83%B5%E5%B0%B8%E8%83%9C%E5%88%A9%E4%BA%86-%F0%9F%98%84"><span class="toc-text">第10章: 僵尸胜利了 😄</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-%E5%83%B5%E5%B0%B8%E5%A4%B1%E8%B4%A5-%F0%9F%98%9E"><span class="toc-text">第11章: 僵尸失败 😞</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lesson5-ERC721-%E6%A0%87%E5%87%86%E5%92%8C%E5%8A%A0%E5%AF%86%E6%94%B6%E8%97%8F%E5%93%81"><span class="toc-text">lesson5 ERC721 标准和加密收藏品</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%B8%8A%E7%9A%84%E4%BB%A3%E5%B8%81"><span class="toc-text">第1章: 以太坊上的代币</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-ERC721-%E6%A0%87%E5%87%86-%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-text">第2章: ERC721 标准, 多重继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-balanceOf-%E5%92%8C-ownerOf"><span class="toc-text">第3章: balanceOf 和 ownerOf</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E9%87%8D%E6%9E%84"><span class="toc-text">第4章: 重构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-ERC721-%E8%BD%AC%E7%A7%BB%E6%A0%87%E5%87%86"><span class="toc-text">第5章: ERC721: 转移标准</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-ERC721-%E8%BD%AC%E7%A7%BB-%E7%BB%AD"><span class="toc-text">第6章: ERC721: 转移-续</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-ERC721-%E6%89%B9%E5%87%86"><span class="toc-text">第7章: ERC721: 批准</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-ERC721-takeOwnership"><span class="toc-text">第8章: ERC721: takeOwnership</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-%E9%A2%84%E9%98%B2%E6%BA%A2%E5%87%BA"><span class="toc-text">第9章: 预防溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-SafeMath-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86"><span class="toc-text">第10章: SafeMath 第二部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-SafeMath-%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86"><span class="toc-text">第11章: SafeMath 第三部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-SafeMath-%E7%AC%AC4%E9%83%A8%E5%88%86"><span class="toc-text">第12章: SafeMath 第4部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-%E6%B3%A8%E9%87%8A"><span class="toc-text">第13章: 注释</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B"><span class="toc-text">总结一下</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lesson6-%E5%BA%94%E7%94%A8%E5%89%8D%E7%AB%AF%E5%92%8C-Web3-js"><span class="toc-text">lesson6 应用前端和 Web3.js</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-%E4%BB%8B%E7%BB%8D-Web3-js"><span class="toc-text">第1章: 介绍 Web3.js</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-Web3-%E6%8F%90%E4%BE%9B%E8%80%85"><span class="toc-text">第2章: Web3 提供者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-%E5%92%8C%E5%90%88%E7%BA%A6%E5%AF%B9%E8%AF%9D"><span class="toc-text">第3章: 和合约对话</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E8%B0%83%E7%94%A8%E5%92%8C%E5%90%88%E7%BA%A6%E5%87%BD%E6%95%B0"><span class="toc-text">第4章: 调用和合约函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-MetaMask-%E5%92%8C%E8%B4%A6%E6%88%B7"><span class="toc-text">第5章: MetaMask 和账户</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#openzeppelin%E6%94%BB%E9%98%B2%E6%8C%91%E6%88%98"><span class="toc-text">openzeppelin攻防挑战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Hello-Ethernaut"><span class="toc-text">1 Hello Ethernaut</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Fallback"><span class="toc-text">2 Fallback</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Fallout"><span class="toc-text">3 Fallout</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E6%9C%8813%E6%97%A5"><span class="toc-text">8月13日</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91-1"><span class="toc-text">智能合约开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Dapp-%E6%9E%B6%E6%9E%84%E5%92%8C%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B-1"><span class="toc-text">Dapp 架构和开发流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Dapp-%E6%9E%B6%E6%9E%84-1"><span class="toc-text">Dapp 架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dapp-%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B-1"><span class="toc-text">Dapp 开发流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Solidity-%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E7%BC%96%E7%A8%8B"><span class="toc-text">Solidity 智能合约编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%B8%8E%E5%BC%80%E5%8F%91%E8%8C%83%E5%BC%8F"><span class="toc-text">基础语法与开发范式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3"><span class="toc-text">合约结构详解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80"><span class="toc-text">以太坊技术基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%90%E6%88%B7%E6%A8%A1%E5%9E%8B"><span class="toc-text">帐户模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Gas-%E6%9C%BA%E5%88%B6"><span class="toc-text">Gas 机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%98%93%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">交易生命周期</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chainlink%E9%A2%84%E8%A8%80%E6%9C%BA%E7%9A%84solidity%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B-1"><span class="toc-text">Chainlink预言机的solidity进阶课程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-text">虚函数：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2%E4%B8%80%E4%B8%AAToken%E5%90%88%E7%BA%A6"><span class="toc-text">部署一个Token合约</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E6%9C%8814%E6%97%A5"><span class="toc-text">8月14日</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Hardhat%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6"><span class="toc-text">Hardhat开发框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E9%83%A8%E7%BD%B2"><span class="toc-text">合约部署</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C-%E7%A7%81%E9%92%A5%E9%85%8D%E7%BD%AE"><span class="toc-text">网络&amp;私钥配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#env"><span class="toc-text">.env</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#env-enc"><span class="toc-text">env-enc</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hardhat-Verify"><span class="toc-text">Hardhat Verify</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E6%9C%8815%E6%97%A5"><span class="toc-text">8月15日</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Web-js"><span class="toc-text">Web.js</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA"><span class="toc-text">项目创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85vant-ui%E7%BB%84%E4%BB%B6%E5%BA%93"><span class="toc-text">配置安装vant-ui组件库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Web3%E8%BF%9E%E6%8E%A5%E5%88%B0%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%BD%91%E7%BB%9C"><span class="toc-text">Web3连接到以太坊网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Web3-js%E9%AB%98%E9%A2%91API"><span class="toc-text">Web3.js高频API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%A6%E5%8F%B7%E5%88%9B%E5%BB%BA"><span class="toc-text">账号创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%99%E9%A2%9D%E8%8E%B7%E5%8F%96"><span class="toc-text">余额获取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%BD%8D%E8%BD%AC%E6%8D%A2"><span class="toc-text">单位转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Eth%E8%BD%AC%E8%B4%A6"><span class="toc-text">Eth转账</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E6%9C%8816%E6%97%A5"><span class="toc-text">8月16日</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#DeFi"><span class="toc-text">DeFi</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Uniswap"><span class="toc-text">Uniswap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E4%BA%A4%E6%98%93%E6%89%80-vs-%E4%B8%AD%E5%BF%83%E5%8C%96%E4%BA%A4%E6%98%93%E6%89%80"><span class="toc-text">去中心化交易所 vs 中心化交易所</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Compound%EF%BC%9A%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E5%80%9F%E8%B4%B7%E5%8D%8F%E8%AE%AE"><span class="toc-text">Compound：去中心化借贷协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MakerDAO%EF%BC%88%E7%8E%B0%E5%B7%B2%E6%9B%B4%E5%90%8D%E4%B8%BA-Sky%EF%BC%89%EF%BC%9A%E7%A8%B3%E5%AE%9A%E5%B8%81%E7%B3%BB%E7%BB%9F"><span class="toc-text">MakerDAO（现已更名为 Sky）：稳定币系统</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NFT"><span class="toc-text">NFT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DAO%EF%BC%9A%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E8%87%AA%E6%B2%BB%E7%BB%84%E7%BB%87"><span class="toc-text">DAO：去中心化自治组织</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Nouns-DAO%EF%BC%9A%E7%A4%BE%E5%8C%BA%E9%A9%B1%E5%8A%A8%E7%9A%84-NFT-%E8%89%BA%E6%9C%AF-DAO"><span class="toc-text">Nouns DAO：社区驱动的 NFT 艺术 DAO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LXDAO%EF%BC%9A%E6%94%AF%E6%8C%81-Web3-%E5%85%AC%E5%85%B1%E7%89%A9%E5%93%81%E7%9A%84%E5%BB%BA%E8%AE%BE%E8%80%85"><span class="toc-text">LXDAO：支持 Web3 公共物品的建设者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConstitutionDAO%EF%BC%9A%E4%B8%80%E5%9C%BA%E7%96%AF%E7%8B%82%E7%9A%84%E6%8B%8D%E5%8D%96"><span class="toc-text">ConstitutionDAO：一场疯狂的拍卖</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E6%9C%8819%E6%97%A5"><span class="toc-text">8月19日</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E6%9C%8820%E6%97%A5"><span class="toc-text">8月20日</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%A6%E6%88%B7%E7%B3%BB%E7%BB%9F"><span class="toc-text">账户系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-text">简介</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%86%E7%A0%81%E3%80%81%E7%A7%81%E9%92%A5%E3%80%81keystore%E4%B8%8E%E5%8A%A9%E8%AE%B0%E8%AF%8D%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">密码、私钥、keystore与助记词的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%B4%A6%E6%88%B7"><span class="toc-text">创建账户</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#web3%E7%9B%B4%E6%8E%A5%E5%88%9B%E5%BB%BA%E8%B4%A6%E6%88%B7"><span class="toc-text">web3直接创建账户</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A9%E8%AE%B0%E8%AF%8D%E5%88%9B%E5%BB%BA%E8%B4%A6%E6%88%B7"><span class="toc-text">助记词创建账户</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E6%9C%8821%E6%97%A5"><span class="toc-text">8月21日</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Uniswap-1"><span class="toc-text">Uniswap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Uniswap-V2"><span class="toc-text">Uniswap V2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Uniswap-V3"><span class="toc-text">Uniswap V3</span></a></li></ol></li></ol></li></ol>
      
  </div>
</div>
</div>
          <div class="sidebar-common-sidebar hidden"><div class="sidebar-author">
  <img data-src="/avatar/avatar.webp" data-sizes="auto" alt="mX1@0" class="lazyload">
  <div class="sidebar-author-name">mX1@0</div>
  <div class="sidebar-description"></div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>Post</div>
    <div class="sidebar-state-number">54</div>
  </div>
  <div class="sidebar-state-category">
    <div>Category</div>
    <div class="sidebar-state-number">25</div>
  </div>
  <div class="sidebar-state-tag">
    <div>Tag</div>
    <div class="sidebar-state-number">65</div>
  </div>
</div>
<div class="sidebar-social">
  
    <div class="icon-twitter sidebar-social-icon">
      <a href=https://x.com/0xMx1a0 itemprop="url" target="_blank" aria-label="twitter" rel="noopener external nofollow noreferrer"></a>
    </div>
  
</div>
<div class="sidebar-menu">
  
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/" aria-label="首页"></a>
        <div class="sidebar-menu-icon icon rotate">
          
            &#xe62b;
          
        </div>
        <div class="sidebar-menu-link">首页</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/archives" aria-label="归类"></a>
        <div class="sidebar-menu-icon icon rotate">
          
            &#xe62b;
          
        </div>
        <div class="sidebar-menu-link">归类</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/about" aria-label="关于"></a>
        <div class="sidebar-menu-icon icon rotate">
          
            &#xe62b;
          
        </div>
        <div class="sidebar-menu-link">关于</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/friend" aria-label="友链"></a>
        <div class="sidebar-menu-icon icon rotate">
          
            &#xe62b;
          
        </div>
        <div class="sidebar-menu-link">友链</div>
      </div>
    
  
</div>
</div>
        
      
      
        
          <div class="sidebar-btn-wrapper" style="position:static">
            <div class="sidebar-toc-btn current"></div>
            <div class="sidebar-common-btn"></div>
          </div>
        
      
    </div>
  </div>

  <div class="sidebar-widget">
  
  </div>
  
</aside>

          <section id="main"><article id="post-Web3 实习计划 - 2025 夏季" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner" data-aos="fade-up">
    <div class="article-meta">
      <div class="article-date">
  <span class="article-date-link" data-aos="zoom-in">
    <time datetime="2025-08-04T12:34:47.066Z" itemprop="datePublished">2025-08-04</time>
    <time style="display: none;" id="post-update-time">2025-08-20</time>
  </span>
</div>

      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AC%94%E8%AE%B0%E5%AD%A6%E4%B9%A0/" data-aos="zoom-in">笔记学习</a>
  </div>


    </div>
    <div class="hr-line"></div>
    

    <div class="e-content article-entry" itemprop="articleBody">
      
      
        <h1 id="Web3-实习计划-2025-夏季"><a href="#Web3-实习计划-2025-夏季" class="headerlink" title="Web3 实习计划 - 2025 夏季"></a>Web3 实习计划 - 2025 夏季</h1><p>在这个Web3实习计划之前，其实我学过一些区块链的内容，但是也仅仅是知道一些概念性的东西，例如，PoW、PoS、defi等一些概念，所以参加这个实习计划也是为了更深入的学习Web3的内容，接下来是我的每日学习笔记</p>
<h1 id="8月4日"><a href="#8月4日" class="headerlink" title="8月4日"></a>8月4日</h1><h2 id="区块链基础概念"><a href="#区块链基础概念" class="headerlink" title="区块链基础概念"></a>区块链基础概念</h2><h3 id="区块链介绍"><a href="#区块链介绍" class="headerlink" title="区块链介绍"></a>区块链介绍</h3><p>区块链是一种<strong>去中心化</strong>的<strong>分布式账本</strong>技术，用于在网络节点之间安全、透明且不可篡改地记录事务数据</p>
<ul>
<li>去中心化：区块链网络通常分布在全球，每个节点都将会存储一份相同的区块链数据。没有人能够控制全部的节点，因此这份区块链数据将会一直存在。</li>
</ul>
<h3 id="区块链特性"><a href="#区块链特性" class="headerlink" title="区块链特性"></a>区块链特性</h3><ol>
<li>不可篡改</li>
</ol>
<p>你无法改变历史信息，因为每个区块包含了上一个区块的摘要并串联起来，如果你修改了历史的区块，你将必须修改后面的全部区块。所以交易一旦上链，就无法再更改</p>
<ol start="2">
<li>公开透明、匿名</li>
</ol>
<p>在区块链上的信息全部公开透明。每个人都可以顺着区块和链找到历史上所有的记录来查看你的钱包余额。可以在区块链浏览器上进行查看</p>
<ol start="3">
<li>快速交易</li>
</ol>
<p>无论金额多少以及你在什么地方，只要你的交易记录被打包在区块链中，交易就自动完成。相比传统的跨国汇款非常快速便捷</p>
<h3 id="区块链的核心组成部分"><a href="#区块链的核心组成部分" class="headerlink" title="区块链的核心组成部分"></a>区块链的核心组成部分</h3><h4 id="去中心化的网络和区块链"><a href="#去中心化的网络和区块链" class="headerlink" title="去中心化的网络和区块链"></a><strong>去中心化的网络和区块链</strong></h4><p>区块链将会有一条链来记录全部的信息，这条链将存在对应的去中心化网络中。 去中心化的网络，将由无数节点提供服务来维持网络运行。节点通过计算验证交易获得代币奖励</p>
<h4 id="维持网络运行的代币激励"><a href="#维持网络运行的代币激励" class="headerlink" title="维持网络运行的代币激励"></a><strong>维持网络运行的代币激励</strong></h4><p>去中心化的网络由无数节点提供服务来维持网络运行，整合区块并合并到链上的操作称为<strong>挖矿</strong>。维持这些服务的人一般称之为<strong>矿工</strong>。矿工们维持网络运行会得到代币奖励以及燃料费（Gas Fee）。 你使用这个网络进行交易、转账、铸造 NFT 等等，均需要支付代币</p>
<h3 id="公链-私链-联盟链"><a href="#公链-私链-联盟链" class="headerlink" title="公链 私链 联盟链"></a>公链 私链 联盟链</h3><p>区块链根据访问权限与治理模式，大致可分为三类。按照去中心化程度从高到低排列</p>
<p><img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-04%20205327.png"></p>
<h4 id="公链（Public-Blockchain）"><a href="#公链（Public-Blockchain）" class="headerlink" title="公链（Public Blockchain）"></a>公链（Public Blockchain）</h4><ul>
<li><strong>特点</strong>：<ul>
<li><strong>完全开放</strong>：任何人可参与读写、验证交易或成为节点。</li>
<li><strong>去中心化</strong>：无单一控制方，数据公开透明，不可篡改。</li>
<li><strong>激励机制</strong>：通常通过代币（如比特币、以太坊）奖励矿工/验证者。</li>
<li><strong>性能较低</strong>：因共识机制（如PoW、PoS）需全局节点验证，交易速度较慢。</li>
</ul>
</li>
<li><strong>典型应用</strong>：<ul>
<li>加密货币（比特币、以太坊）。</li>
<li>去中心化应用（DApp）、DeFi、NFT等开放生态。</li>
</ul>
</li>
<li><strong>代表案例</strong>：<br>  Bitcoin、Ethereum、Solana。</li>
</ul>
<h4 id="私链（Private-Blockchain）"><a href="#私链（Private-Blockchain）" class="headerlink" title="私链（Private Blockchain）"></a>私链（Private Blockchain）</h4><ul>
<li><strong>特点</strong>：<ul>
<li><strong>权限封闭</strong>：由单一组织或实体控制，参与者需授权。</li>
<li><strong>中心化</strong>：节点由管理者指定，交易验证效率高。</li>
<li><strong>隐私性强</strong>：数据仅对授权方可见，适合企业内部使用。</li>
<li><strong>无代币激励</strong>：通常无需挖矿，节点由组织自行维护。</li>
</ul>
</li>
<li><strong>典型应用</strong>：<ul>
<li>企业数据管理、内部审计、供应链追踪等。</li>
<li>对隐私和效率要求高的封闭场景。</li>
</ul>
</li>
<li><strong>代表案例</strong>：<br>  Hyperledger Fabric（可配置为私链）、R3 Corda。</li>
</ul>
<h4 id="联盟链（Consortium-Blockchain）"><a href="#联盟链（Consortium-Blockchain）" class="headerlink" title="联盟链（Consortium Blockchain）"></a>联盟链（Consortium Blockchain）</h4><ul>
<li><strong>特点</strong>：<ul>
<li><strong>部分去中心化</strong>：由多个组织联合管理（如银行、企业联盟）。</li>
<li><strong>准入机制</strong>：节点需许可加入，但参与者间平等协作。</li>
<li><strong>平衡效率与信任</strong>：共识机制（如PBFT）比公链更快，兼顾一定透明度。</li>
<li><strong>部分公开</strong>：数据可对成员共享，对外保密。</li>
</ul>
</li>
<li><strong>典型应用</strong>：<ul>
<li>跨机构业务（跨境支付、贸易金融）。</li>
<li>行业协作（物流、医疗数据共享）。</li>
</ul>
</li>
<li><strong>代表案例</strong>：<br>  Hyperledger Fabric、FISCO BCOS、Quorum。</li>
</ul>
<h4 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h4><table>
<thead>
<tr>
<th align="left"><strong>维度</strong></th>
<th align="left"><strong>公链</strong></th>
<th align="left"><strong>联盟链</strong></th>
<th align="left"><strong>私链</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>控制权</strong></td>
<td align="left">无中心主体</td>
<td align="left">多组织共同治理</td>
<td align="left">单一组织控制</td>
</tr>
<tr>
<td align="left"><strong>参与权限</strong></td>
<td align="left">完全开放</td>
<td align="left">需许可加入</td>
<td align="left">严格授权</td>
</tr>
<tr>
<td align="left"><strong>透明度</strong></td>
<td align="left">全网公开</td>
<td align="left">成员间透明</td>
<td align="left">仅内部可见</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left">低（TPS低，延迟高）</td>
<td align="left">中（优化共识机制）</td>
<td align="left">高（中心化处理）</td>
</tr>
<tr>
<td align="left"><strong>用例</strong></td>
<td align="left">加密货币、开放生态</td>
<td align="left">跨机构协作</td>
<td align="left">企业内部管理</td>
</tr>
</tbody></table>
<h4 id="选择依据"><a href="#选择依据" class="headerlink" title="选择依据"></a>选择依据</h4><ul>
<li><strong>公链</strong>：适合需要完全去中心化和信任透明的场景。</li>
<li><strong>联盟链</strong>：适合多组织协作且需平衡效率与隐私的行业。</li>
<li><strong>私链</strong>：适合单一组织追求高效可控的私有化应用。</li>
</ul>
<h1 id="8月5日"><a href="#8月5日" class="headerlink" title="8月5日"></a>8月5日</h1><table>
<thead>
<tr>
<th>今日学习内容</th>
</tr>
</thead>
<tbody><tr>
<td>以太坊概览</td>
</tr>
<tr>
<td>unphishable钓鱼攻防挑战-初级</td>
</tr>
</tbody></table>
<h2 id="以太坊概览"><a href="#以太坊概览" class="headerlink" title="以太坊概览"></a>以太坊概览</h2><h3 id="以太坊介绍"><a href="#以太坊介绍" class="headerlink" title="以太坊介绍"></a>以太坊介绍</h3><p>以太坊（Ethereum）被称为“区块链 2.0”，它不仅是一种加密货币（以太币 ETH），更是一台支持智能合约的“全球共享计算机”。通过代码自动执行规则，开发者可以在区块链上构建去中心化金融（DeFi）、数字艺术品（NFT）和去中心化自治组织（DAO）等创新应用，无需依赖银行或中心化平台。</p>
<p>以太坊的核心创新在于 <strong>智能合约</strong>（Smart Contracts） 。<u>智能合约是存储在区块链上的可执行代码，能够在满足预设条件时自动执行操作，无需人工干预</u>。这一特性使得以太坊不仅是数字货币的载体，更是构建去中心化应用（Dapps）、去中心化金融（DeFi）、非同质化代币（NFT）等生态系统的基础设施。</p>
<h3 id="Ethereum-与-Bitcoin-的差异"><a href="#Ethereum-与-Bitcoin-的差异" class="headerlink" title="Ethereum 与 Bitcoin 的差异"></a>Ethereum 与 Bitcoin 的差异</h3><table>
<thead>
<tr>
<th align="center">维度</th>
<th align="left">比特币（Bitcoin）</th>
<th align="left">以太坊（Ethereum）</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>目标与定位</strong></td>
<td align="left">去中心化的<strong>数字货币</strong>，强调安全、稳定和稀缺性（总量 2100 万枚）</td>
<td align="left">去中心化平台，支持<strong>智能合约</strong>和 Dapps，定位为“区块链 2.0”</td>
</tr>
<tr>
<td align="center"><strong>编程能力</strong></td>
<td align="left">脚本语言有限，仅支持简单的交易验证逻辑</td>
<td align="left">图灵完备的编程语言（如 Solidity），可开发复杂智能合约</td>
</tr>
<tr>
<td align="center"><strong>共识机制</strong></td>
<td align="left">工作量证明（PoW），矿工通过算力竞争记账权</td>
<td align="left">从 PoW 转向权益证明（PoS），通过 The Merge 实现能源效率优化</td>
</tr>
<tr>
<td align="center"><strong>交易速度</strong></td>
<td align="left">每 10 分钟生成一个区块，交易确认较慢</td>
<td align="left">区块时间约 12 秒，交易确认更快，适合高频应用</td>
</tr>
<tr>
<td align="center"><strong>经济模型</strong></td>
<td align="left">总量固定，强调抗通胀属性</td>
<td align="left">供应灵活，通过 EIP-1559 等机制可能呈现通缩趋势</td>
</tr>
</tbody></table>
<h3 id="以太坊的定位与演进"><a href="#以太坊的定位与演进" class="headerlink" title="以太坊的定位与演进"></a>以太坊的定位与演进</h3><h4 id="以太坊1-0（PoW阶段）"><a href="#以太坊1-0（PoW阶段）" class="headerlink" title="以太坊1.0（PoW阶段）"></a>以太坊1.0（PoW阶段）</h4><p>这个阶段就是挖矿，和比特币的机制相同，同样的消耗电力和处理交易速度慢、费用高</p>
<h4 id="以太坊2-0与The-Merge：从双链并行到完美合并"><a href="#以太坊2-0与The-Merge：从双链并行到完美合并" class="headerlink" title="以太坊2.0与The Merge：从双链并行到完美合并"></a>以太坊2.0与The Merge：从双链并行到完美合并</h4><blockquote>
<p><strong>The Merge 完整故事</strong>：</p>
<ol>
<li><p><strong>2020 年 12 月：信标链启动</strong></p>
<p> 以太坊团队首先创建了一条全新的<strong>信标链（Beacon Chain）</strong>，专门运行 PoS 共识机制。此时：</p>
<ul>
<li>以太坊主网继续使用 PoW 挖矿</li>
<li>信标链独立运行 PoS 验证</li>
<li>两条链并行存在，互不干扰</li>
</ul>
</li>
<li><p><strong>2022 年 9 月：历史性合并</strong></p>
<p> 2022 年 9 月 15 日，<strong>The Merge</strong> 发生：</p>
<ul>
<li>以太坊主网“关闭”了 PoW 挖矿引擎</li>
<li>将共识机制“插接”到信标链的 PoS 系统</li>
<li>从此，以太坊主网由信标链保护安全</li>
</ul>
</li>
<li><p><strong>合并后的新架构</strong></p>
<p> 现在的以太坊实际上是两层结构：</p>
<ul>
<li><strong>执行层</strong>：处理交易、智能合约（原主网）</li>
<li><strong>共识层</strong>：管理验证者、确定区块顺序（信标链）</li>
</ul>
</li>
</ol>
</blockquote>
<p><strong>PoS机制详解：</strong></p>
<p><strong>验证者如何工作</strong>：</p>
<ul>
<li><strong>准入门槛</strong>：质押 32 ETH 成为验证者</li>
<li><strong>工作方式</strong>：系统随机选择验证者来提议和验证区块</li>
<li><strong>奖励机制</strong>：验证者获得新发行的 ETH + 交易费用（gas）</li>
<li><strong>惩罚机制</strong>：作恶者质押的 ETH 被销毁（Slashing）</li>
</ul>
<p><strong>相比 PoW 的优势</strong>：</p>
<ul>
<li>**能耗降低 99.95%**：无需大量电力和硬件</li>
<li><strong>经济安全性</strong>：攻击成本约需控制全网 67% 的质押 ETH（价值数百亿美元）</li>
<li><strong>最终确定性</strong>：区块确认更快、更可靠</li>
</ul>
<h4 id="未来升级路线"><a href="#未来升级路线" class="headerlink" title="未来升级路线"></a>未来升级路线</h4><p>暂时学不懂</p>
<h3 id="以太坊生态概览：L1、L2、Sidechains-等"><a href="#以太坊生态概览：L1、L2、Sidechains-等" class="headerlink" title="以太坊生态概览：L1、L2、Sidechains 等"></a>以太坊生态概览：L1、L2、Sidechains 等</h3><p>以太坊的生态系统由多层架构组成，包括 <strong>L1（主网）、L2（二层扩展解决方案）、侧链（Sidechains）</strong> 等，共同支持高吞吐量和低费用的交易处理。</p>
<ol>
<li>Layer 1（L1）<ul>
<li><strong>以太坊主网</strong>：核心区块链，负责最终安全性与共识。</li>
<li><strong>EVM</strong>：以太坊虚拟机，执行智能合约代码。</li>
<li><strong>账户系统</strong>：外部账户（EOA）与合约账户（CA）共同构成网络基础。</li>
</ul>
</li>
<li>Layer 2（L2）<ul>
<li>Rollup：通过将交易批量处理后提交至 L1，降低 Gas 费。<ul>
<li><strong>Optimistic Rollup</strong>：假设交易合法，仅在争议时验证。</li>
<li><strong>ZK Rollup</strong>：通过零知识证明验证交易，无需链上争议。</li>
</ul>
</li>
</ul>
</li>
<li><strong>侧链（Sidechains）</strong>：独立运行的链，通过<strong>桥接</strong>与主网交互。</li>
<li><strong>以太坊生态分层架构</strong></li>
</ol>
<blockquote>
<p><strong>1. Optimistic Rollup（乐观汇总）</strong></p>
<p><strong>核心思想</strong></p>
<p>“默认信任，争议时验证” —— 假设所有提交到链上的交易是合法的，仅在有人提出质疑时进行验证。</p>
<p><strong>工作流程</strong></p>
<ol>
<li><strong>交易打包</strong>：<ul>
<li>用户将交易发送给排序器（Sequencer），排序器批量打包交易并生成状态根（State Root），提交到主链（如以太坊）。</li>
<li>主链仅存储交易数据（Calldata），不立即验证。</li>
</ul>
</li>
<li><strong>挑战期（Fraud Proof）</strong>：<ul>
<li>提交后有一段挑战期（通常 <strong>7天</strong>），任何人可质疑交易有效性。</li>
<li>如果发现无效交易，验证者提交欺诈证明（Fraud Proof），触发链上计算并回滚错误状态。</li>
</ul>
</li>
<li><strong>最终确认</strong>：<ul>
<li>若挑战期内无争议，交易最终确认。</li>
</ul>
</li>
</ol>
<p> <strong>优点</strong></p>
<ul>
<li><strong>兼容性强</strong>：支持任意智能合约（EVM 兼容）。</li>
<li><strong>Gas 成本低</strong>：仅需提交数据，无需复杂计算。</li>
<li><strong>开发门槛低</strong>：无需零知识证明（ZKP）专业知识。</li>
</ul>
<p> <strong>缺点</strong></p>
<ul>
<li><strong>提款延迟</strong>：用户需等待挑战期结束（7天）才能提取资金。</li>
<li><strong>中心化风险</strong>：依赖排序器（Sequencer）快速打包交易。</li>
<li><strong>安全依赖诚实多数</strong>：若无人监控并提交欺诈证明，恶意交易可能通过。</li>
</ul>
<p> <strong>代表项目</strong></p>
<ul>
<li><strong>Optimism</strong>、<strong>Arbitrum</strong>（EVM 兼容，主打 DeFi 生态）。</li>
</ul>
<hr>
<p> <strong>2. ZK Rollup（零知识证明汇总）</strong></p>
<p><strong>核心思想</strong></p>
<p>“数学证明，即时验证” —— 每批交易通过零知识证明（ZKP）验证有效性，无需争议期。</p>
<p><strong>工作流程</strong></p>
<ol>
<li><strong>交易打包</strong>：<ul>
<li>排序器收集交易，生成状态变更和有效性证明（ZK-SNARK/STARK）。</li>
<li>将证明和状态根提交到主链。</li>
</ul>
</li>
<li><strong>链上验证</strong>：<ul>
<li>主链验证 ZKP，确保交易合法后立即更新状态。</li>
<li>无需挑战期，交易即时确认。</li>
</ul>
</li>
</ol>
<p><strong>优点</strong></p>
<ul>
<li><strong>即时最终性</strong>：无提款延迟，资金可立即提取。</li>
<li><strong>更高安全性</strong>：依赖数学证明，无需诚实多数假设。</li>
<li><strong>隐私性</strong>：可选择性隐藏交易细节（如 Zcash 风格隐私交易）。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><strong>计算资源消耗大</strong>：生成 ZKP 需要高性能硬件。</li>
<li><strong>EVM 兼容性有限</strong>：早期仅支持简单逻辑，现逐步改进（如 zkEVM）。</li>
<li><strong>开发复杂度高</strong>：需密码学专业知识。</li>
</ul>
<p><strong>代表项目</strong></p>
<ul>
<li><strong>zkSync</strong>、<strong>StarkNet</strong>、<strong>Scroll</strong>（专注 zkEVM 兼容）。</li>
</ul>
</blockquote>
<p>以太坊生态可以分为以下几个层次：</p>
<ol>
<li><strong>应用层（Application Layer）</strong></li>
</ol>
<p>用户直接交互的应用和界面：</p>
<ul>
<li><strong>DeFi 应用</strong>：Uniswap（去中心化交易所）、Aave（借贷协议）、Compound（借贷协议）</li>
<li><strong>NFT 平台</strong>：OpenSea、Foundation、SuperRare</li>
<li><strong>钱包应用</strong>：MetaMask、Coinbase Wallet、Rainbow</li>
<li><strong>DAO 工具</strong>：Snapshot、Aragon、Colony</li>
</ul>
<ol start="2">
<li><strong>协议层（Protocol Layer）</strong></li>
</ol>
<p>以太坊的核心基础设施：</p>
<ul>
<li><strong>共识层客户端</strong>：Prysm、Lighthouse、Nimbus、Teku</li>
<li><strong>执行层客户端</strong>：Geth、Nethermind、Erigon、Besu</li>
<li><strong>核心协议</strong>：EVM、状态管理、Gas 机制</li>
</ul>
<ol start="3">
<li><strong>扩展层（Scaling Layer）</strong></li>
</ol>
<p>提升性能和降低成本的解决方案：</p>
<ul>
<li><strong>Layer 2 Rollups</strong>：Arbitrum、Optimism、Polygon zkEVM、zkSync Era</li>
<li><strong>侧链</strong>：Polygon PoS、xDAI（Gnosis Chain）</li>
<li><strong>状态通道</strong>：Lightning Network for Ethereum</li>
</ul>
<h3 id="以太坊文化与价值观"><a href="#以太坊文化与价值观" class="headerlink" title="以太坊文化与价值观"></a>以太坊文化与价值观</h3><p>核心价值观</p>
<ol>
<li><strong>去中心化治理（Decentralization）</strong><ul>
<li>没有单一的控制者或权威机构</li>
<li>社区通过公开讨论和 EIP（以太坊改进提案）机制共同决策</li>
<li>验证者遍布全球，防止权力集中</li>
</ul>
</li>
<li><strong>无需许可与开放性（Permissionless &amp; Open）</strong><ul>
<li>任何人都可以使用、开发、部署智能合约</li>
<li>开源代码，透明可审计</li>
<li>无身份、地域、财富限制的参与门槛</li>
</ul>
</li>
<li><strong>抗审查性（Censorship Resistance）</strong><ul>
<li>交易和智能合约不受政府或机构干预</li>
<li>通过分布式验证确保网络弹性</li>
<li>支持言论自由和经济自由</li>
</ul>
</li>
<li><strong>密码朋克精神（Cypherpunk Ethos）</strong><ul>
<li>代码即法律：用算法和数学构建信任</li>
<li>密码学保护隐私和自主权</li>
<li>技术驱动的社会变革，而非政治手段</li>
</ul>
</li>
<li><strong>公共物品导向（Public Goods Orientation）</strong><ul>
<li>优先考虑生态系统整体利益</li>
<li>支持开源项目和基础设施建设</li>
<li>通过各种资助计划推动创新</li>
</ul>
</li>
<li><strong>可持续发展理念</strong><ul>
<li>The Merge 体现了对环境责任的承诺</li>
<li>长期主义思维，注重技术的可持续演进</li>
<li>平衡创新速度与网络稳定性</li>
</ul>
</li>
</ol>
<h3 id="以太坊核心机制：从账户到执行的完整链路"><a href="#以太坊核心机制：从账户到执行的完整链路" class="headerlink" title="以太坊核心机制：从账户到执行的完整链路"></a>以太坊核心机制：从账户到执行的完整链路</h3><p>以太坊三个关键机制：<strong>账户系统</strong>、<strong>Gas 模型</strong> 和 <strong>以太坊虚拟机（EVM）</strong>。</p>
<p>（1）账户系统：你的数字身份</p>
<p><strong>账户系统</strong> 包含由私钥控制的 <strong>外部账户（EOA）</strong> 和由智能合约代码控制的 <strong>合约账户（CA）</strong> 。</p>
<p>想象你第一次接触以太坊——你需要一个“数字钱包”来参与网络。这个钱包的核心是 <strong>外部账户（EOA）</strong> ，它由一对密钥（私钥和公钥）生成，就像银行账户的密码和账号。私钥是你控制账户的“钥匙”，必须严格保密；公钥通过加密算法生成一个唯一的地址（如 <code>0xAbc...123</code>），你可以把它分享给朋友接收转账。</p>
<p>除了用户控制的 EOA，还有 <strong>合约账户（CA）</strong> 。它们不像 EOA 那样受私钥控制，而是由代码驱动。比如，你部署一个智能合约（如一个 NFT 市场），区块链会自动生成一个 CA 地址（如 <code>0xDef...456</code>）。这个账户不能主动发起交易，只能通过 EOA 触发——比如你点击“购买 NFT”按钮时，EOA 向 CA 发送交易，CA 的代码自动执行出货逻辑。</p>
<p>每个账户都包含四个关键字段：</p>
<ul>
<li><strong>Nonce</strong>：防止重复交易的计数器（EOA 记录发送次数，CA 记录创建合约次数）。</li>
<li><strong>余额</strong>：账户持有的 ETH 数量（单位为 Wei）。</li>
<li><strong>CodeHash</strong>：EOA 为空哈希，CA 存储合约字节码的哈希值。</li>
<li><strong>StorageRoot</strong>：记录账户数据的 Merkle 树根哈希（如 NFT 归属关系）。</li>
</ul>
<p>（2）Gas 模型：交易的燃料费</p>
<p>当你用钱包使用自己的 EOA 发起一笔交易（比如转账或操作合约），这件事当然 <strong>不会是免费的</strong>，你需要支付“燃料费”——也就是 <strong>Gas</strong>。</p>
<p>Gas 费用 = <strong>用多少 × 每单位多少钱</strong>，就像你打车一样：</p>
<ul>
<li><strong>Gas Limit（限额）</strong>：你最多愿意“烧”多少燃料。 比如你觉得最多可能需要 15 万单位，就设置 150,000。</li>
<li><strong>Gas Price（单价）</strong>：每单位燃料多少钱，用 Gwei 表示（1 Gwei = 0.000000001 ETH）。 网络越拥堵，价格越贵，就像打车高峰期加价。</li>
</ul>
<p>所以，<strong>总费用 = Gas Limit × Gas Price</strong>。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">假设你设置 Gas Limit 为 150 000，Gas Price 为 100 Gwei，总费用就是 0.015 ETH。如果实际消耗 120 000 Gas，剩余 30 000 Gas × 100 Gwei = 0.003 ETH 会退还给你。</span><br></pre></td></tr></tbody></table></figure>

<p>Gas 的存在有两个目的：</p>
<ul>
<li><strong>激励矿工/验证者</strong>：你给得越多（Gas Price 越高），他们越愿意优先处理你的交易。</li>
<li><strong>防止资源滥用</strong>：如果有人想让合约死循环，Gas 会用光，交易失败，系统不会被拖垮。</li>
</ul>
<p><u>在 EIP-1559 升级后，Gas Price 被拆分了：</u></p>
<p>以前，Gas Price 全部给矿工。 现在，分成两部分：</p>
<ul>
<li><strong>基础费用（Base Fee）</strong>：每个区块都会有，自动计算，直接销毁（直接消失）来帮助 ETH 通缩，毕竟物以稀为贵。</li>
<li><strong>小费（Tip）</strong>：你额外加的钱，用来鼓励矿工优先处理你。</li>
</ul>
<p>（3）以太坊虚拟机（EVM）：代码的执行引擎</p>
<p>EVM（Ethereum Virtual Machine）是 <strong>以太坊的“大脑”</strong>，是专门用来<strong>运行智能合约的虚拟计算机</strong>。它运行在每个节点上，确保整个网络在处理代码时，<strong>结果都一致、可信任</strong>。</p>
<p>EVM 的核心特点：</p>
<ul>
<li><strong>图灵完备</strong>：就像真正的电脑一样，EVM 可以执行各种逻辑，比如 if 判断、循环等。</li>
<li><strong>全球同步</strong>：每个矿工/节点都会自己执行一遍合约代码，保证结果一样。</li>
<li><strong>隔离安全</strong>：EVM 把合约“关”在一个小房间里运行，不允许它乱访问用户的数据和网络，保护隐私和安全。</li>
</ul>
<h2 id="Unphishable钓鱼攻防挑战"><a href="#Unphishable钓鱼攻防挑战" class="headerlink" title="Unphishable钓鱼攻防挑战"></a>Unphishable钓鱼攻防挑战</h2><p>挑战地址：<a target="_blank" rel="noopener" href="http://unphishable.io/">unphishable.io</a> </p>
<h3 id="初级"><a href="#初级" class="headerlink" title="初级"></a>初级</h3><h3 id="No-0x0001-Web3-钱包设置指南"><a href="#No-0x0001-Web3-钱包设置指南" class="headerlink" title="No.0x0001 Web3 钱包设置指南"></a>No.0x0001 Web3 钱包设置指南</h3><p>第一关就是创建一个MetaMask的小狐狸钱包，在这之前我就有一个钱包里。这关也重点强调了助记词的重要性。非常重要！！千万不能泄露，接下来一关我就中招了！</p>
<p>安全存储助记词方法附上：</p>
<ul>
<li>将其写在纸上（多份副本）</li>
<li>存放在安全、防水、防火的地方</li>
<li>考虑使用金属备份解决方案以提高耐久性</li>
<li>切勿以数字方式存储（不要拍照、不要云存储、不要电子邮件）</li>
<li>切勿与任何人分享，包括”支持人员”</li>
</ul>
<p>还有一个点就是要领取Holesky的测试币，找了几个水龙头都不是很好弄，看群里的小伙伴都是用Google水龙头领测试币，但是我的就用不了，Google的水龙头搞抽象，无法领取，问了群里大佬说他是这样的。不过最后找到一个好用的水龙头，不仅之前领了Sepolia的测试币，现在也领了Holesky的测试币，附上地址</p>
<p><a target="_blank" rel="noopener" href="https://www.alchemy.com/faucets/ethereum-sepolia">https://www.alchemy.com/faucets/ethereum-sepolia</a></p>
<p>但是应该是需要eth主网上有一定量的以太币（0.001 ETH）才能在这里领测试币</p>
<p>领完测试币，连接钱包，这关就结束了</p>
<h3 id="No-0x0002-钱包恢复助手"><a href="#No-0x0002-钱包恢复助手" class="headerlink" title="No.0x0002 钱包恢复助手"></a>No.0x0002 钱包恢复助手</h3><p>这是一个ai对话界面，功能是钱包恢复，然后让你输入你的助记词，我看到了这样的字样 “请放心，这是一个安全的环境，您的信息将被加密处理。”然后还真的去找了我的助记词给他添上了，我还特意用ai查了这个平台是否靠谱，结果输入进入，告诉我我被钓鱼了。身为一个学安全的人，我自认为安全意识还是有点的，但是也可能是我还没意识到这个挑战是在做个什么，所以被骗+1。</p>
<p>所以！！永远不要向任何人透露您的助记词，无论他们声称是谁</p>
<h3 id="No-0x0003-USDC-Permit-钓鱼模拟"><a href="#No-0x0003-USDC-Permit-钓鱼模拟" class="headerlink" title="No.0x0003 USDC Permit 钓鱼模拟"></a>No.0x0003 USDC Permit 钓鱼模拟</h3><p>这一个内容就到了我要学习的地方，之前没听过。开始学！</p>
<p>因为一开始还不知道所以还是点了授权，被骗+1</p>
<blockquote>
<p>知识点：</p>
<p><strong>通过使用 EIP-2612 的 <code>permit</code> 签名功能</strong>，用户可以在不预先进行链上授权交易（即无需支付 Gas 费）的情况下，授权第三方合约使用自己的代币（如 USDC、DAI 等）。这是以太坊上一种更高效、更省 Gas 的授权方式，尤其适合优化用户体验（UX）和批量操作。</p>
<p><strong>1. EIP-2612 <code>permit</code> 的核心机制</strong></p>
<p> <strong>（1）传统授权（<code>approve</code>）的问题</strong></p>
<ul>
<li>需要发送一笔链上交易（支付 Gas）。</li>
<li>用户必须提前授权，导致交互流程变长。</li>
</ul>
<p> <strong>（2）<code>permit</code> 的改进</strong></p>
<p>✅ <strong>免 Gas 授权</strong>：用户签署一条链下消息（签名），第三方合约可凭此签名直接获得代币使用权，无需用户预先发送 <code>approve</code> 交易。<br>✅ <strong>单次有效</strong>：签名可设置过期时间（<code>deadline</code>），避免长期风险。<br>✅ <strong>兼容 ERC-20</strong>：无需修改代币标准，只需代币合约实现 <code>permit</code> 函数。</p>
<p> <strong>2. <code>permit</code> 的工作原理</strong></p>
<p> <strong>（1）用户签署离线消息</strong></p>
<p>用户对以下数据进行签名（使用 EIP-712 结构化签名）：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  owner: "0x用户地址",       // 代币持有者</span><br><span class="line">  spender: "0x合约地址",    // 被授权方（如 Uniswap）</span><br><span class="line">  value: 1000000,          // 授权数量（如 1 USDC = 1e6）</span><br><span class="line">  nonce: 123,              // 防止重放攻击</span><br><span class="line">  deadline: 1698765432     // 过期时间（UNIX 时间戳）</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p> <strong>（2）第三方合约提交签名</strong></p>
<p>合约调用代币的 <code>permit</code> 方法，传入签名数据：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">token.permit(owner, spender, value, deadline, v, r, s);</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><code>v, r, s</code> 是签名的 ECDSA 参数。</li>
<li>代币合约验证签名，并更新授权状态（相当于执行了 <code>approve</code>）。</li>
</ul>
<p> <strong>3. 安全注意事项</strong></p>
<p> <strong>✅ 优点</strong></p>
<ul>
<li><strong>节省 Gas</strong>：用户只需签一次名，无需单独发 <code>approve</code> 交易。</li>
<li><strong>更短交互流程</strong>：适合钱包内直接签名授权。</li>
</ul>
<p> <strong>⚠️ 风险</strong></p>
<ul>
<li><strong>签名钓鱼</strong>：恶意 DApp 可能诱导用户签署高额 <code>permit</code>（检查 <code>value</code> 和 <code>spender</code>）。</li>
<li><strong>过期时间失效</strong>：若 <code>deadline</code> 过长，签名可能被重复使用（建议设置较短有效期）。</li>
</ul>
</blockquote>
<p>我的理解就是 授权第三方合约使用自己的代币，然后可以省去gas费用</p>
<p>这个签名将允许攻击者控制您的 USDC 代币！通过使用 EIP-2612 permit 签名，攻击者可以：</p>
<ul>
<li>获得对您所有 USDC 的完全访问权限</li>
<li>在未来任何时间转移您的代币</li>
<li>无需您进一步批准即可花费您的资金</li>
</ul>
<p>安全检查要点</p>
<ul>
<li><p>检查 Permit 类型，了解授权范围</p>
</li>
<li><p>验证 Spender 地址是否为可信来源</p>
</li>
<li><p>注意授权金额，警惕无限制授权</p>
</li>
<li><p>确认网站来源的可信度</p>
</li>
</ul>
<p>所以此处不能进行授权</p>
<h3 id="No-0x0004-专属代币空投"><a href="#No-0x0004-专属代币空投" class="headerlink" title="No.0x0004 专属代币空投"></a>No.0x0004 专属代币空投</h3><p>此交易实际上是向合约 0xbe535a82f2c3895bdaceb3ffe6b9b80ac2f832a0 发送 0.5 ETH，而不是领取任何代币。</p>
<p>函数选择器 0x5fba79f5 调用了一个名为 SecurityUpdate() 的函数，该函数可能会将您的资金转移给攻击者。</p>
<p><strong>在真实情况下，永远不要在不了解交易内容的情况下签署交易！</strong></p>
<h3 id="No-0x0005-USDT-授权钓鱼模拟"><a href="#No-0x0005-USDT-授权钓鱼模拟" class="headerlink" title="No.0x0005 USDT 授权钓鱼模拟"></a>No.0x0005 USDT 授权钓鱼模拟</h3><p>挑战：请小心真实的授权请求</p>
<p> <strong>授权风险提示：</strong></p>
<ul>
<li>除了 approve 外，也要当心 increaseAllowance 函数</li>
<li>increaseAllowance 同样可以增加代币授权额度</li>
<li>一些钓鱼网站会通过这个方式来掩饰其真实意图</li>
</ul>
<p>💡 安全建议：永远不要给不明来源的网站无限授权！</p>
<blockquote>
<p><code>increaseAllowance</code> 是 <strong>ERC-20 代币标准</strong> 中的一个扩展函数，用于<strong>安全地增加</strong>某个地址（<code>spender</code>）的代币授权额度。它是对传统 <code>approve</code> 方法的改进，旨在避免潜在的安全风险（如前端竞态条件攻击）。</p>
<p> <strong>传统 <code>approve</code> 的问题</strong></p>
<ul>
<li><p><strong>竞态条件（Race Condition）</strong><br>  如果用户连续发起两笔 <code>approve</code> 交易（例如先授权 100，再改为 200），矿工可能以相反顺序打包交易，导致最终授权额度被意外覆盖（变成 100 而非 200）。</p>
<p>  solidity</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 危险操作：可能被覆盖</span><br><span class="line">approve(spender, 100);  // 交易1</span><br><span class="line">approve(spender, 200);  // 交易2</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p> <strong><code>increaseAllowance</code> 的解决方案</strong></p>
<p>✅ <strong>增量调整</strong>：基于当前授权额度增加数值，而非直接覆盖。<br>✅ <strong>安全操作</strong>：避免竞态条件，适合前端交互。</p>
</blockquote>
<h3 id="No-0x0006-假冒代币空投钓鱼攻击"><a href="#No-0x0006-假冒代币空投钓鱼攻击" class="headerlink" title="No.0x0006 假冒代币空投钓鱼攻击"></a>No.0x0006 假冒代币空投钓鱼攻击</h3><p>挑战：识别真假域名</p>
<ul>
<li>场景描述</li>
</ul>
<p>某天，你收到一封电子邮件，声称你有资格获得UNI代币的空投！邮件中包含一个链接，引导你到一个看似合法的网站。你点击了该链接，并看到以下交易记录：</p>
<img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-05%20144514.png" style="zoom:67%;">

<p>仔细观察上面的交易记录。这种钓鱼攻击通常利用视觉上相似的字符（如用数字”1”替代字母”i”）来欺骗用户。</p>
<p><strong>安全建议</strong></p>
<ul>
<li>始终逐字符检查域名</li>
<li>警惕使用数字代替字母的域名（例如，用’1’代替’i’）</li>
<li>收藏官方网站而不是点击电子邮件中的链接</li>
<li>使用密码管理器，它只会在合法域名上自动填充</li>
<li>安装警告钓鱼网站的浏览器扩展</li>
</ul>
<h3 id="No-0x0007-超高收益质押平台"><a href="#No-0x0007-超高收益质押平台" class="headerlink" title="No.0x0007 超高收益质押平台"></a>No.0x0007 超高收益质押平台</h3><p>挑战：了解如何识别可疑的质押合约</p>
<p>某些可疑的质押合约可能会引导您进行 <strong>approve</strong> 授权，表面上看似只为了质押特定金额，实际上却请求对整个代币余额的完全访问权限。一旦授权成功，攻击者即可任意转走您的所有资产。</p>
<img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-05%20145026.png" style="zoom:67%;">

<p>如上图，存在approve方法需要谨慎！！</p>
<blockquote>
<p><code>approve</code> 是 <strong>ERC-20 代币标准</strong> 中的一个核心方法，用于授权另一个地址（通常是智能合约）代表你支配一定数量的代币。它是 DeFi（去中心化金融）交互的基础，但错误使用可能导致资金风险。</p>
</blockquote>
<h3 id="No-0x0008-Telegram-代币钓鱼挑战"><a href="#No-0x0008-Telegram-代币钓鱼挑战" class="headerlink" title="No.0x0008 Telegram 代币钓鱼挑战"></a>No.0x0008 Telegram 代币钓鱼挑战</h3><p>挑战：学习识别和避免 Telegram 上的助记词钓鱼攻击</p>
<p>风险点依旧是提供助记词，所以千万不要给别人提供自己钱包的助记词！！！</p>
<img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-05%20145933.png" style="zoom:67%;">



<h3 id="No-0x0009-Punycode-钓鱼攻击"><a href="#No-0x0009-Punycode-钓鱼攻击" class="headerlink" title="No.0x0009 Punycode 钓鱼攻击"></a>No.0x0009 Punycode 钓鱼攻击</h3><p>挑战：识别 Punycode 钓鱼域名</p>
<ul>
<li>场景描述</li>
</ul>
<p>您收到一封电子邮件，声称是来自 Trezor（一个知名的硬件钱包品牌）的重要安全更新通知。电子邮件中的链接看起来像是指向官方 Trezor 网站，但实际上是一个精心伪装的钓鱼网站。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">trẹzor.com</span><br><span class="line">看起来像正常的 Trezor 域名</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<h4 id="什么是-Punycode？"><a href="#什么是-Punycode？" class="headerlink" title="什么是 Punycode？"></a>什么是 Punycode？</h4><p>Punycode 是一种编码系统，允许将非 ASCII 字符（如西里尔字母、中文等）转换为 ASCII 字符，以便在域名系统中使用。攻击者经常利用视觉上相似的字符创建看似合法的域名。 例如，某些特殊字符看起来与拉丁字母几乎相同，但它们是不同的字符： 你可以使用 <a target="_blank" rel="noopener" href="https://www.punycoder.com/">Punycoder</a> 来转换 Unicode 和 Punycode 域名。</p>
<table>
<thead>
<tr>
<th align="left">显示域名</th>
<th align="left">实际 Punycode 域名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">trẹzor.com</td>
<td align="left">xn–trzor-o51b.com</td>
<td align="left">使用特殊字符替换了某些字母</td>
</tr>
</tbody></table>
</blockquote>
<p>所以 trezor的官方域名应该为trezor.io</p>
<p>防御方式：</p>
<ul>
<li>直接在浏览器中输入已知的官方网址，而不是点击电子邮件中的链接</li>
<li>使用书签保存常用的重要网站</li>
<li>安装可以检测 Punycode 域名的浏览器扩展</li>
<li>注意域名中不寻常的字符或拼写</li>
</ul>
<h3 id="No-0x0010-剪贴板钓鱼挑战"><a href="#No-0x0010-剪贴板钓鱼挑战" class="headerlink" title="No.0x0010 剪贴板钓鱼挑战"></a>No.0x0010 剪贴板钓鱼挑战</h3><p>挑战：识别剪贴板型钓鱼攻击</p>
<ul>
<li>场景描述</li>
</ul>
<p>您需要转账 1 ETH 到朋友的钱包。他们已经分享了他们的钱包地址，您正在使用加密货币转账界面进行转账。</p>
<img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-05%20150754.png" style="zoom:50%;">



<p>复制粘贴之后，发现钱包地址与之前的不同了</p>
<ul>
<li>攻击原理：</li>
</ul>
<ol>
<li>攻击者创建一个看似合法的网站</li>
<li>当你点击”复制”按钮时，恶意JavaScript代码会秘密替换复制的地址</li>
<li>如果粘贴后没有验证地址，你可能会将资金发送给攻击者</li>
</ol>
<ul>
<li><p>防御方式：</p>
<ul>
<li><p>粘贴后务必再次检查地址</p>
</li>
<li><p>考虑使用带有地址验证的硬件钱包</p>
</li>
<li><p>在电脑上复制敏感信息（如钱包地址）时要特别小心 - 即使使用Ctrl+C，恶意软件也可能篡改你的剪贴板内容</p>
</li>
</ul>
</li>
</ul>
<h3 id="No-0x0011-Google-搜索广告钓鱼攻击"><a href="#No-0x0011-Google-搜索广告钓鱼攻击" class="headerlink" title="No.0x0011 Google 搜索广告钓鱼攻击"></a>No.0x0011 Google 搜索广告钓鱼攻击</h3><p>挑战：识别 Google 搜索广告钓鱼</p>
<ul>
<li>场景描述</li>
</ul>
<p>您想要使用 Lido Finance 质押 ETH。在 Google 上搜索”Lido Finance”时看到这些结果。您能识别出哪个是合法网站，哪个是钓鱼网站吗？</p>
<img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-05%20151348.png" style="zoom:67%;">

<p>看第一条的左上角有一个Ad，是广告的意思，怀疑是钓鱼网站</p>
<p>辨别网站真伪的方法：</p>
<ul>
<li>攻击者经常购买与热门加密货币项目相关的 Google 广告，这些广告会出现在搜索结果的顶部，标记为”赞助”或”广告”。</li>
<li>这些广告通常使用与官方网站非常相似的域名，但有细微的差别，例如：<ul>
<li>使用不同的顶级域名（如用 .is 代替 .fi）</li>
<li>在域名中添加或删除字母</li>
<li>使用连字符或用数字替换字母</li>
<li>当用户点击这些广告时，他们会被引导到看起来与官方网站完全相同的钓鱼网站，这些网站旨在窃取资金或私钥。</li>
</ul>
</li>
</ul>
<h3 id="No-0x0012-Microsoft-Teams-钓鱼攻击"><a href="#No-0x0012-Microsoft-Teams-钓鱼攻击" class="headerlink" title="No.0x0012 Microsoft Teams 钓鱼攻击"></a>No.0x0012 Microsoft Teams 钓鱼攻击</h3><p>本页面模拟攻击者如何创建虚假的 Microsoft Teams 网站来分发恶意软件和窃取敏感信息。</p>
<img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-05%20151843.png" style="zoom:67%;">

<p>本示例中的钓鱼指标</p>
<ul>
<li><strong>可疑 URL</strong>：注意域名是 “microsoft-meet.com” 而不是 “teams.microsoft.com”</li>
<li><strong>简化界面</strong>：与真实的 Teams 登录相比，虚假页面具有简化的界面</li>
<li><strong>缺乏安全功能</strong>：缺少 Microsoft 通常包含的安全元素</li>
<li><strong>加入按钮</strong>：突出的 “在 Teams 应用程序中加入” 按钮可能会导致恶意软件下载</li>
</ul>
<p>安全提示</p>
<ul>
<li>在输入凭据或下载软件之前，始终验证 URL。</li>
<li>仅从官方 Microsoft 网站或应用商店下载 Microsoft Teams。</li>
<li>对任何异常的安装过程或请求保持警惕。</li>
<li>如果您下载了可疑的软件包，可以在打开之前使用 <a target="_blank" rel="noopener" href="https://www.virustotal.com/">VirusTotal.com</a> 进行扫描。但请注意，即使没有检测到威胁（0 检测），也不能保证绝对安全。</li>
</ul>
<blockquote>
<h2 id="Microsoft-Teams-钓鱼攻击的工作原理"><a href="#Microsoft-Teams-钓鱼攻击的工作原理" class="headerlink" title="Microsoft Teams 钓鱼攻击的工作原理"></a>Microsoft Teams 钓鱼攻击的工作原理</h2><p>攻击者创建令人信服的 Microsoft Teams 登录页面或更新通知的复制品，诱骗用户下载恶意软件或泄露其凭据。这些攻击变得越来越复杂，针对个人和组织。</p>
<p>风险1：数据泄露</p>
<p>通过虚假 Teams 更新安装的恶意软件可以访问您设备上的敏感文件，可能导致未经授权访问个人和公司数据。这可能导致知识产权盗窃、机密信息泄露和合规违规。</p>
<p>风险2：凭据盗窃</p>
<p>当用户在虚假 Teams 网站上输入其 Microsoft 凭据时，攻击者会捕获这些信息以获取对电子邮件、OneDrive、SharePoint 和其他 Microsoft 365 服务的访问权限。这可能导致账户被接管并进一步危及组织资源。</p>
<p>风险3：钱包资金耗尽</p>
<p>对于从同一设备访问加密货币钱包或金融服务的用户，通过虚假 Teams 更新安装的恶意软件可能包含扫描钱包凭据的功能，导致数字资产被盗。</p>
</blockquote>
<h3 id="No-0x0037-虚假扩展程序钓鱼"><a href="#No-0x0037-虚假扩展程序钓鱼" class="headerlink" title="No.0x0037 虚假扩展程序钓鱼"></a>No.0x0037 虚假扩展程序钓鱼</h3><p>挑战：识别出虚假扩展程序</p>
<img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-05%20155308.png" style="zoom: 50%;">

<p>扩展程序安全最佳实践：</p>
<ul>
<li>始终从官方网站下载：直接访问官方网站（例如 metamask.io），而不是在扩展商店中搜索。虚假或恶意扩展程序可能出现在搜索结果中，甚至出现在官方扩展商店中，有时会模仿真实扩展程序的名称、图标或品牌。通过访问官方网站，您可以确保获得正宗、安全的版本，避免落入可能危及您安全和资产的仿冒或诈骗列表的陷阱。</li>
<li>检查用户数量和评论：官方扩展程序拥有大量用户和普遍积极的评论</li>
<li>仔细阅读权限：只授予必要的权限</li>
<li>保持扩展程序更新：定期更新通常包含安全补丁</li>
<li>删除未使用的扩展程序：通过删除不再使用的扩展程序来减少攻击面</li>
</ul>
<h3 id="中级"><a href="#中级" class="headerlink" title="中级"></a>中级</h3><h3 id="No-0x0013-TransferFrom-零值转账钓鱼挑战"><a href="#No-0x0013-TransferFrom-零值转账钓鱼挑战" class="headerlink" title="No.0x0013 TransferFrom 零值转账钓鱼挑战"></a>No.0x0013 TransferFrom 零值转账钓鱼挑战</h3><p>挑战：学习识别和避免零值转账诈骗</p>
<p><img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-05%20153732.png"></p>
<p>发现我的钱包地址和发送方发送到接收方的地址不同</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我的钱包：		   	0x1234ab7890123456781232345678901234567890</span><br><span class="line">发送方的发送到的地址：	0x1234ab789012345678abc2345678901234567890</span><br></pre></td></tr></tbody></table></figure>

<p>诈骗者经常使用零值转账来创建与伪造地址的虚假交易历史，让受害者以为该地址为可信地址，从而做到地址混淆，让受害者向攻击方地址进行转账。</p>
<p>如何保护自己：</p>
<ul>
<li><strong>始终验证完整地址</strong>，而不仅仅是开头和结尾</li>
<li>警惕看起来与您之前交互过的地址相似的地址</li>
<li>仔细检查交易历史，包括零值转账</li>
<li>使用钱包的地址簿功能标记可信地址</li>
<li>考虑使用带有地址验证功能的硬件钱包</li>
</ul>
<blockquote>
<h3 id="诈骗者利用“零值转账”伪造交易历史的原理及防范措施"><a href="#诈骗者利用“零值转账”伪造交易历史的原理及防范措施" class="headerlink" title="诈骗者利用“零值转账”伪造交易历史的原理及防范措施"></a><strong>诈骗者利用“零值转账”伪造交易历史的原理及防范措施</strong></h3><h4 id="1-攻击原理"><a href="#1-攻击原理" class="headerlink" title="1. 攻击原理"></a><strong>1. 攻击原理</strong></h4><p>诈骗者通过发送 <strong>零值转账（0 ETH 或 0 代币）</strong> 到 <strong>伪造地址</strong>，目的是在区块链浏览器（如 Etherscan）上制造虚假的交易历史，诱导受害者误认为该地址是可信的。具体手法如下：</p>
<ul>
<li><strong>伪造交易历史</strong>：<br>  攻击者向目标地址（如 <code>0x123...abc</code>）发送多笔 <code>0 ETH</code> 转账，使该地址在 Etherscan 上显示与“知名地址”（如交易所、项目方）有交互记录。<ul>
<li>例如：攻击者可能伪造一个与 <strong>Uniswap 路由合约</strong> 相似的地址，并提前用零值转账制造“活跃记录”。</li>
</ul>
</li>
<li><strong>地址混淆（Address Poisoning）</strong>：<br>  攻击者生成一个与受害者常用地址 <strong>开头和结尾相似</strong> 的地址（如 <code>0x1234...5678</code> vs <code>0x1234...9876</code>），并发送零值转账，使受害者在复制粘贴时误选错误地址。</li>
<li><strong>诱导转账</strong>：<br>  当受害者看到该地址有“历史交易”时，可能误以为是合法地址，从而将资金转入诈骗者的钱包。</li>
</ul>
</blockquote>
<h1 id="8月6日"><a href="#8月6日" class="headerlink" title="8月6日"></a>8月6日</h1><table>
<thead>
<tr>
<th>今日学习内容</th>
</tr>
</thead>
<tbody><tr>
<td>MyFirstLayer2 部分学习</td>
</tr>
<tr>
<td>区块链岗位全景图</td>
</tr>
</tbody></table>
<h2 id="MyFirstLayer2"><a href="#MyFirstLayer2" class="headerlink" title="MyFirstLayer2"></a>MyFirstLayer2</h2><h3 id="1-公链瓶颈"><a href="#1-公链瓶颈" class="headerlink" title="1 公链瓶颈"></a>1 公链瓶颈</h3><h4 id="1-1改进尝试"><a href="#1-1改进尝试" class="headerlink" title="1.1改进尝试"></a>1.1改进尝试</h4><p>为了保证参与门槛足够低，比特币将全网同步的出块时间控制在 10 分钟，平均 TPS （每秒可处理交易笔数）仅有个位数。以太坊出块时间约 12 秒，平均 TPS 也仅有十几笔。这对比于传统 Web2 的经济活动来说，远远不够用</p>
<p>提高区块链性能的两个尝试：</p>
<ul>
<li><p><u>增大单个区块的大小，容纳更多的交易</u></p>
<p>  这样做会引起区块账本的快速膨胀，参与验证的机器性能要求越来越高，提高了参与门槛，导致整个网络去中心化程度和安全性渐渐降低。从 BTC 分叉出来的 BCH（Bitcoin Cash） 将区块大小从 1MB 提升至 32MB，BSV（Bitcoin Satoshi’s Vision） 则是更激进地取消了区块大小上限，允许无限多的信息融入一个区块。</p>
</li>
<li><p><u>降低出块的时间，追求一定时间内出更多的块来处理更多的交易</u></p>
<p>  这样对节点的网络条件提出了更高要求，提高了参与门槛。并且影响了全网数据同步的稳定性，因为物理上相隔较远的节点集群容易对最新的区块产生分歧，导致分叉。分叉链总需要竞争出新的最长链，抛弃其中的一条分支，导致过去一段时间内的许多交易被重写，这就是“区块重组”现象，Polygon 在 2023 年发生过 157 个区块的重组事件。</p>
</li>
</ul>
<p>此外，还有一些公链试图用更激进的方式改善性能：</p>
<ul>
<li><p><u>使用数量更少的超级节点通讯：</u></p>
<p>  超级节点的性能更强大，网络带宽更好更稳定，因此彼此之间能实现超高速的通讯，但这显然降低了去中心化程度。如 Fanton 有 51 个共识节点，BSC、EOS、TRON 则仅有 21 个超级节点。</p>
</li>
<li><p><u>用特殊的共识机制提升性能：</u></p>
<p>  共识机制决定了全网节点对出块方式如何达成共识，一些特殊的机制也许可以提高出块速度，但共识机制越复杂，就对机器性能要求越高，也更容易出现单点故障导致整个系统出错。如 Solana，全网节点依赖随机选出的单个 Leader 节点来协调，因此获得了极高的理论 TPS 上限，但对节点性能要求变得非常高，并多次发生全网宕机的安全性事故。</p>
</li>
</ul>
<p>目前高性能公链的探索成果，普遍获得了将 TPS 提升至 100 ~ 1000 的成绩，但共识节点数量也降低为几十个至一千多个不等。对比于以太坊分布全球的近万个共识节点 ，高性能公链在性能提高了一两个数量级的同时，去中心化程度也下降了一两个数量级。</p>
<h4 id="1-2-区块链三难困境"><a href="#1-2-区块链三难困境" class="headerlink" title="1.2 区块链三难困境"></a>1.2 区块链三难困境</h4><p>由于区块链的底层特性，存在一个不可能三角悖论。区块链不可能三角（Blockchain Trilemma）是指在设计区块链系统时，存在三个目标之间的矛盾，这三个目标分别是去中心化、安全性和可扩展性（性能）</p>
<ol>
<li><strong>去中心化</strong>（Decentralization）：指的是在区块链系统中，所有的节点都具有相同的权力，没有单一的中心化权威节点进行控制。这个目标是区块链的核心特性，也是保证系统安全性和抗攻击性的基础。</li>
<li><strong>安全性</strong>（Security）：指的是在区块链系统中，保证交易的真实性、完整性、不可篡改性和抗攻击性等方面的安全。这个目标是区块链系统的重要保障，也是确保系统可靠性和信任度的基础。</li>
<li><strong>可扩展性</strong>（Scalability）：可扩展性即性能，指的是在区块链系统中，支持足够大量的交易、节点和用户等系统扩展。这个目标是区块链系统的重要需求，也是确保系统能够满足现实需求的基础。</li>
</ol>
<p>这三个目标之间存在矛盾关系。例如，在追求更高的去中心化的情况下，需要所有节点都保存完整的区块链数据，但是这会导致系统的可扩展性降低。相反，在追求更高的可扩展性的情况下，需要牺牲一定的去中心化；还比如采用分片技术 [1] 来扩容，但是可能导致节点同步数据困难，更容易发生故障，导致安全性降低。</p>
<p><strong>高安全性和高可扩展性</strong></p>
<p>追求安全性和可扩展性（即性能），往往采用少数超级节点进行通讯，超级节点拥有更强的性能和更好的网络环境，彼此之间能实现超高速的通讯。但参与门槛过高，牺牲了去中心化程度。</p>
<p>代表区块链：BSC、EOS、TRON 等区块链采用了少数高性能节点维护网络，仅有 21 个超级节点进行记账。</p>
<p><strong>高可扩展性和高去中心化</strong></p>
<p>追求可扩展性（即性能）和去中心化程度，为保证去中心化采用了较多验证节点，为了追求性能提高了出块速度，或采用了特殊的共识机制。但提高出块速度容易导致大规模区块重组，更复杂的共识机制容易导致全网宕机等安全事故，牺牲了安全性。</p>
<p>代表区块链：Polygon 在 2023 年发生了 157 个区块的大规模重组；Solana 多次出现全网宕机的事故。</p>
<p><strong>高去中心化和高安全性</strong></p>
<p>追求去中心化程度和安全性，采用更多的节点和更公平的出块方式，值得信赖。但为了允许低性能节点参与验证，协调全球网络延迟，导致每秒可处理的交易数较低，牺牲了性能。</p>
<p>代表区块链：BTC、ETH 追求了极致的安全可靠和去中心化，但处理交易的速度较低，BTC 约为 7 笔/秒，ETH 约为 10 - 20 笔/秒。</p>
<h4 id="1-3-Layer-2"><a href="#1-3-Layer-2" class="headerlink" title="1.3 Layer 2"></a>1.3 Layer 2</h4><p>事实上，有一种方法可以克服区块链三难困境。而工程实践上，我们可以通过增加层级的方式来优化三者的矛盾，增加层级实现了业务解耦，降低了原先层级的负担。</p>
<p>增加第二层网络（Layer 2 ），来分摊一层网络（Layer 1）的负担，达到扩容的目的。</p>
<blockquote>
<p>Layer 2 即二层网络，是在一层网络的基础上搭建的，用各种技术手段帮助底层公链扩容的解决方案</p>
</blockquote>
<h3 id="2-Layer-2发展史"><a href="#2-Layer-2发展史" class="headerlink" title="2 Layer 2发展史"></a>2 Layer 2发展史</h3><h4 id="2-1-状态通道（State-channel）"><a href="#2-1-状态通道（State-channel）" class="headerlink" title="2.1 状态通道（State channel）"></a>2.1 状态通道（State channel）</h4><blockquote>
<p>假设 Alice 经常在一家咖啡店消费，如果每次买一杯 5 美元的咖啡，都需要支付 0.5 美元的手续费，这也太痛苦了。那么假如 Alice 和咖啡店能达成共识，每次买咖啡时付给咖啡店一张签了名的欠条，一段时间后咖啡店攒了足够多的欠条，将欠条算好总金额一次性兑现，这样交易成本就可以大幅降低，对双方都有利。这种思路就是最早的二层网络，也就是状态通道的原理。</p>
</blockquote>
<p><strong>状态通道</strong> 是一种区块链扩容技术，允许用户在链下进行高频、低成本的交互，仅在开启和关闭通道时与区块链交互，从而实现近乎即时、零摩擦的交易。状态通道使用了<strong>多签技术</strong> [1]，允许两个个体之间提前存入一笔资金锁定在智能合约中，建立一个内部通道，然后双方可以在通道内进行多笔小额转账，速度极快，成本极低，再在一段时间后用转账证明一次性提款。状态通道也是比特币的 Lightning Network（闪电网络），以太坊的 Raiden Network（雷电网络）背后的底层技术。</p>
<blockquote>
<p>[1] 多签技术（Multi-sig）：即多重签名技术，是指需要多个授权方共同授权才能完成交易，提高了交易的安全性和可靠性。如公司财库的资金要求三人之中的至少两人签名（2/3）才能动用，状态通道中则要求同时拥有双方的签名（2/2）才能生效，多签也允许出现更多 n/m 的授权条件。</p>
</blockquote>
<blockquote>
<p><strong>1. 核心原理</strong></p>
<p> <strong>(1) 基本流程</strong></p>
<ol>
<li><strong>开启通道</strong>：<ul>
<li>双方将资金锁定在链上的智能合约中（如存入 10 ETH）。</li>
<li>生成初始状态（如 Alice: 6 ETH，Bob: 4 ETH），并签名确认。</li>
</ul>
</li>
<li><strong>链下交易</strong>：<ul>
<li>双方通过签名消息更新状态（如 Alice 转 1 ETH 给 Bob → Alice:5, Bob:5）。</li>
<li><strong>无需矿工/验证者</strong>，交易即时生效。</li>
</ul>
</li>
<li><strong>关闭通道</strong>：<ul>
<li>将最终状态提交到链上，合约根据最新状态分配资金。</li>
<li>若有争议（如一方提交过期状态），可挑战并惩罚作弊者。</li>
</ul>
</li>
</ol>
<p><strong>(2) 技术关键点</strong></p>
<ul>
<li><strong>多签名验证</strong>：每次状态更新需双方签名。</li>
<li><strong>时间锁（Timelock）</strong>：防止旧状态被恶意提交。</li>
<li><strong>欺诈证明（Fraud Proof）</strong>：允许诚实方在争议期举证。</li>
</ul>
<p><strong>2. 为什么需要状态通道？</strong></p>
<table>
<thead>
<tr>
<th align="center"><strong>问题</strong></th>
<th align="center"><strong>状态通道解决方案</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">链上交易慢且昂贵</td>
<td align="center">链下交易零成本，即时确认</td>
</tr>
<tr>
<td align="center">区块链吞吐量有限</td>
<td align="center">支持无限次链下交互</td>
</tr>
<tr>
<td align="center">隐私性差</td>
<td align="center">交易细节仅在参与者间传递</td>
</tr>
</tbody></table>
<hr>
<p><strong>3. 典型应用场景</strong></p>
<p> <strong>(1) 高频微支付</strong></p>
<ul>
<li><strong>案例</strong>：<ul>
<li>按秒计费的视频流服务（如每小时支付 0.001 ETH）。</li>
<li>游戏内道具实时交易。</li>
</ul>
</li>
</ul>
<p> <strong>(2) 链下投票与治理</strong></p>
<ul>
<li><strong>案例</strong>：<ul>
<li>DAO 成员在通道内频繁投票，最终结果上链。</li>
</ul>
</li>
</ul>
<p><strong>(3) 隐私保护交易</strong></p>
<ul>
<li><strong>案例</strong>：<ul>
<li>双方链下协商价格，仅公开最终交易。</li>
</ul>
</li>
</ul>
<p><strong>4.优缺点</strong></p>
<p> <strong>✅ 优点</strong></p>
<ul>
<li><strong>零延迟</strong>：交易即时完成。</li>
<li><strong>零 Gas 费</strong>：链下交互无需付费。</li>
<li><strong>隐私性</strong>：交易细节不上链。</li>
</ul>
<p><strong>❌ 缺点</strong></p>
<ul>
<li><strong>通道管理复杂</strong>：需预先锁定资金。</li>
<li><strong>适用性有限</strong>：仅适合固定参与者间的交互。</li>
<li><strong>流动性要求</strong>：长期占用资金。</li>
</ul>
</blockquote>
<p>状态通道技术本质上是使用了<strong>中心化的节点</strong>，用户在链上质押一笔较大额的资金，然后在链下用签了名的“欠条”进行付款，积攒了一定量的“欠条”之后，任何一方都可以选择关闭通道进行结算。链上的智能合约只认可同时拥有双方签名的转账信息，Alice 和咖啡店都拥有自己的签名，再加上“欠条”上对方的签名，才能凑齐签名<strong>通过多签验证</strong>，因此无法提取不属于自己的资金。</p>
<p>但这样做产生了 2 个新的问题：</p>
<ol>
<li>Alice 和咖啡店之间攒“欠条”的约定仅适合于最简单的转账交易，去中心化金融要实现的交易比转账复杂得多，那么<strong>想要实现更复杂的交易要怎么办呢</strong>？为了解决这个问题，引出了<strong>侧链</strong>方案。</li>
<li>Alice 可以给咖啡店发送资金，若超市与咖啡店有通道，也可以借助咖啡店向超市发送资金，但是<strong>如何给未参与雷电网络的个体发送资金呢</strong>？这个问题，则引出了 <strong>Plasma</strong> 方案。</li>
</ol>
<h4 id="2-2-侧链（Sidechain）"><a href="#2-2-侧链（Sidechain）" class="headerlink" title="2.2 侧链（Sidechain）"></a>2.2 侧链（Sidechain）</h4><p>为了解决<strong>状态通道无法执行复杂交易</strong>的问题，侧链方案进入人们视野。</p>
<p><strong>侧链</strong>可以理解为一条相对独立的区块链，它们往往采用与主链（一般是以太坊）类似的架构，方便主链上的项目迁移至侧链。</p>
<p>我们可以在主链的智能合约内锁定一定量的资产，然后在侧链上铸造等量资产，实现“原子交换”。用这种方式将资产存入侧链，在侧链上进行各种交易，然后在必要时转移回主链。</p>
<p><strong>侧链核心特性</strong></p>
<table>
<thead>
<tr>
<th align="center"><strong>特性</strong></th>
<th align="center"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>独立性</strong></td>
<td align="center">拥有自己的共识机制（如 PoA、PoS）、区块参数和智能合约。</td>
</tr>
<tr>
<td align="center"><strong>双向锚定</strong></td>
<td align="center">资产可从主链锁定后映射到侧链，也能反向返回。</td>
</tr>
<tr>
<td align="center"><strong>互操作性</strong></td>
<td align="center">通过桥接协议（Bridge）与主链通信。</td>
</tr>
<tr>
<td align="center"><strong>定制化</strong></td>
<td align="center">可针对特定需求优化（如高TPS、低Gas费、隐私增强）。</td>
</tr>
</tbody></table>
<p>侧链会进行一定的定制化，获得更高的性能，帮助主链分担交易压力。</p>
<ul>
<li>采用 <strong>POS</strong> 共识机制（Proof of Stake），大幅提高了出块速度以达到扩容的目的。如 Polygon 侧链，将出块时间缩短至 2 秒。</li>
<li>采用 <strong>POA</strong> 共识机制（Proof of Authority），用更少的经过授权的超级节点进行通信，以实现侧链上的超高性能。如负责游戏资产交易的 Ronin 侧链，因游戏内的 NFT 资产本就比较中心化，所以这种更中心化的方案也可以接受。</li>
</ul>
<p><strong>侧链的工作原理</strong></p>
<p><strong>(1) 资产跨链流程（以以太坊 ↔ Polygon 为例）</strong></p>
<ol>
<li><strong>存款（主链 → 侧链）</strong><ul>
<li>用户将 ETH 存入主链的桥合约，合约锁定资产并生成证明。</li>
<li>侧链验证证明后，在侧链上 mint 等量的封装资产（如 WETH）。</li>
</ul>
</li>
<li><strong>提款（侧链 → 主链）</strong><ul>
<li>用户销毁侧链的 WETH，提交销毁证明到主链桥合约。</li>
<li>主链合约验证后解锁原始 ETH。</li>
</ul>
</li>
</ol>
<p><strong>(2) 共识机制差异</strong></p>
<ul>
<li><strong>主链</strong>：通常采用高安全共识（如以太坊的 PoS）。</li>
<li><strong>侧链</strong>：可能使用更高效的共识（如 Polygon PoS 链的 Bor 共识）。</li>
</ul>
<p><strong>为什么需要侧链？</strong></p>
<table>
<thead>
<tr>
<th align="center"><strong>主链瓶颈</strong></th>
<th align="center"><strong>侧链解决方案</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">低TPS（如以太坊15 TPS）</td>
<td align="center">侧链可达数千 TPS（如 Polygon 7,000 TPS）。</td>
</tr>
<tr>
<td align="center">高Gas费</td>
<td align="center">侧链交易成本极低（如 BSC 的 $0.01 交易费）。</td>
</tr>
<tr>
<td align="center">功能限制</td>
<td align="center">侧链可定制模块（如隐私交易、游戏专用链）。</td>
</tr>
</tbody></table>
<p> <strong>典型侧链项目</strong></p>
<table>
<thead>
<tr>
<th align="center"><strong>侧链</strong></th>
<th align="center"><strong>锚定主链</strong></th>
<th align="center"><strong>特点</strong></th>
<th align="center"><strong>用例</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>Polygon PoS</strong></td>
<td align="center">以太坊</td>
<td align="center">高TPS，EVM兼容</td>
<td align="center">DeFi、NFT</td>
</tr>
<tr>
<td align="center"><strong>Gnosis Chain</strong></td>
<td align="center">以太坊</td>
<td align="center">注重去中心化，xDai 合并</td>
<td align="center">支付、DAO</td>
</tr>
<tr>
<td align="center"><strong>Liquid Network</strong></td>
<td align="center">比特币</td>
<td align="center">联邦桥接，支持机密交易</td>
<td align="center">比特币快速结算</td>
</tr>
<tr>
<td align="center"><strong>Ronin</strong></td>
<td align="center">以太坊</td>
<td align="center">Axie Infinity 游戏专用链</td>
<td align="center">GameFi</td>
</tr>
</tbody></table>
<p><strong>侧链的安全风险</strong></p>
<p><strong>(1) 桥接攻击</strong></p>
<ul>
<li><strong>案例</strong>：2022 年 Ronin 桥被盗 6.25 亿美元（私钥泄露）。</li>
<li><strong>防御</strong>：使用多重签名、零知识证明桥（如 zkBridge）。</li>
</ul>
<p><strong>(2) 共识中心化</strong></p>
<ul>
<li>部分侧链（如 BSC）由少数节点控制，可能被操纵。</li>
</ul>
<p><strong>(3) 资产锚定失效</strong></p>
<ul>
<li>若桥合约漏洞导致双向锚定断裂，侧链资产可能脱钩。</li>
</ul>
<p>侧链通过 <strong>牺牲部分主链安全性</strong> 换取高性能和低成本，是区块链生态的重要扩容手段。用户在使用时需权衡<strong>效率、成本与风险</strong>，优先选择经过时间验证的侧链和桥接协议。</p>
<h4 id="2-3-Plasma"><a href="#2-3-Plasma" class="headerlink" title="2.3 Plasma"></a>2.3 Plasma</h4><p>随着状态通道和侧链方案在实践中暴露出不足，Plasma 方案被提出并得到重视，它解决了前面两者暴露出的两个问题：</p>
<ul>
<li><strong>无法给未参与的个体发送资金</strong>：未加入 Plasma 链的账户也可以收到资金，然后自行提取到 Layer 1。</li>
<li><strong>无法继承 Layer 1 安全性</strong>：Plasma 定期向主链提交信息，以继承 Layer 1 安全性。</li>
</ul>
<p><strong>Plasma</strong> 是以太坊创始人 <strong>Vitalik Buterin</strong> 和 <strong>Joseph Poon</strong> 在 2017 年提出的一种 <strong>区块链扩容方案</strong>，旨在通过构建多层链下结构（“子链”），将大部分交易从<u>主链（如以太坊）卸载到子链上处理</u>，从而显著提升吞吐量并降低交易成本。尽管后期因技术复杂性被 Rollup 取代，但 Plasma 的设计思想仍对 Layer2 发展影响深远。</p>
<p><strong>Plasma 的核心思想</strong></p>
<p> <strong>(1) 分层结构</strong></p>
<ul>
<li><strong>主链（Root Chain）</strong>：以太坊等底层区块链，负责最终结算和争议仲裁。</li>
<li><strong>子链（Plasma Chain）</strong>：独立的链下区块链，处理高频交易，定期向主链提交状态承诺（Merkle Root）。</li>
</ul>
<p><strong>(2) 关键机制</strong></p>
<ul>
<li><strong>状态承诺</strong>：子链将交易批量打包后，生成 Merkle Root 并提交到主链。</li>
<li><strong>欺诈证明（Fraud Proof）</strong>：若子链作恶（如篡改交易），用户可提交证明至主链，触发惩罚和状态回滚。</li>
<li><strong>资金退出（Exit）</strong>：用户需通过主链的“退出游戏”机制安全取回资金。</li>
</ul>
<p><strong>Plasma 的工作原理</strong></p>
<p><strong>(1) 存款（主链 → Plasma 链）</strong></p>
<ol>
<li>用户将资产（如 ETH）锁定在主链的 Plasma 智能合约中。</li>
<li>Plasma 链生成对应的资产凭证（如 1:1 映射的代币）。</li>
</ol>
<p><strong>(2) 链下交易（Plasma 链内）</strong></p>
<ul>
<li>用户在 Plasma 链上自由交易（如转账、支付），无需主链确认。</li>
<li>子链区块生产者（Operator）定期将交易打包，并提交 Merkle Root 到主链。</li>
</ul>
<p><strong>(3) 提款（Plasma 链 → 主链）</strong></p>
<ol>
<li>用户发起提款请求，启动 <strong>7天挑战期</strong>（类似 Optimistic Rollup）。</li>
<li>若无争议，主链释放锁定的资产；若有欺诈，提交证明取消提款。</li>
</ol>
<p><strong>Plasma 的优缺点</strong></p>
<p><strong>✅ 优点</strong></p>
<ul>
<li><strong>高吞吐量</strong>：交易在子链处理，主链仅存储压缩数据。</li>
<li><strong>低成本</strong>：Gas 费由子链承担，主链仅需极低开销。</li>
<li><strong>安全性继承</strong>：依赖主链的<strong>欺诈证明机制</strong>确保资金安全。</li>
</ul>
<p> <strong>❌ 缺点</strong></p>
<ul>
<li><strong>退出延迟</strong>：提款需等待挑战期（7天），流动性受限。</li>
<li><strong>数据可用性问题</strong>：**<u>若子链运营商隐藏数据，用户无法构造欺诈证明。</u>**</li>
<li><strong>通用性差</strong>：难以支持复杂智能合约（仅适合支付等简单逻辑）。</li>
</ul>
<p><strong>为什么 Plasma 逐渐被淘汰？</strong></p>
<ol>
<li><strong>数据可用性问题</strong>：用户无法获取子链完整数据时，无法挑战无效交易。</li>
<li><strong>用户体验差</strong>：提款延迟长，且需主动监控欺诈。</li>
<li><strong>Rollup 的崛起</strong>：<ul>
<li><strong>ZK Rollup</strong> 通过零知识证明解决数据问题。</li>
<li><strong>Optimistic Rollup</strong> 保留欺诈证明但强制数据上链，平衡安全与成本。</li>
</ul>
</li>
</ol>
<blockquote>
<p>默克尔树利用了哈希算法（Hash Algorithm），每个子节点的内容，都影响着上一个节点的哈希值。因此保存在默克尔树内的数据，若被改变了哪怕一个字符，都将导致上方一连串节点的哈希值改变，最终传导至默克尔树的根部也发生改变。任何人都可以自行运算哈希算法来检查计算出的哈希值与公开的哈希值是否对应，以此确认内容是否被篡改。</p>
</blockquote>
<h4 id="2-4-Rollup"><a href="#2-4-Rollup" class="headerlink" title="2.4 Rollup"></a>2.4 Rollup</h4><p>虽然 Plasma 最终未能大规模使用，但它的一些理念在后续的 Layer 2 方案中被吸收和发展。</p>
<p>既然困扰 Plasma 最大的问题是<strong>数据可用性</strong>，也就是监督者不容易获取交易数据以进行检验的问题。那我们如果不仅仅上传一个根证明，而是把必要的关键数据通通上传至 Layer 1 ，是不是就解决了这个棘手问题呢？</p>
<p>这个思路带来了目前最具可行性的 Layer 2 扩容方案： Rollup。Rollup 意为“打包”，也就是将一段时间内发生的交易先进行压缩，再进行打包，然后周期性地上传至主网。目前主流的 Rollup 方案分为两大路线，分别为 <strong>Optimistic Rollup</strong>（乐观的 Rollup）与 <strong>Zero-knowledge Rollup</strong>（零知识证明的 Rollup）。</p>
<ul>
<li>Optimistic Rollup：OP-Rollup 是将一段时间内的所有交易细节全部压缩打包，定期发送至 Layer 1。这种机制乐观地相信大部分交易都是诚实的，继承了 Plasma 挑战期和欺诈证明机制。</li>
<li>Zero-knowledge Rollup：ZK-Rollup 一般是将一段时间内的交易计算完成后，将状态变化的结果压缩打包，并附上交易已经在 Layer 2 被正确执行的零知识证明，定期发送至 Layer 1。用零知识证明代替监督者，依赖数学而非验证者（Rely on Math, not Validators）。</li>
</ul>
<p><strong>Rollup 的核心思想</strong></p>
<p><strong>(1) 链下执行 + 链上验证</strong></p>
<ul>
<li><strong>链下</strong>：交易在 Rollup 链（Layer2）上执行。</li>
<li><strong>链上</strong>：交易数据（或有效性证明）提交到主链（Layer1），确保安全性。</li>
</ul>
<p><strong>(2) 数据压缩</strong></p>
<ul>
<li>Rollup 将多笔交易压缩为 <strong>单个批次</strong>，减少链上存储开销。</li>
<li>例如：1000 笔交易 → 1 个 Rollup 区块 → 1 笔主链交易。</li>
</ul>
<p><strong>Rollup 的两种类型</strong></p>
<p><strong>(1) Optimistic Rollup（乐观汇总）</strong></p>
<ul>
<li><strong>假设交易合法</strong>，默认不验证，依赖 <strong>欺诈证明（Fraud Proof）</strong> 争议机制。</li>
<li><strong>特点</strong>：<ul>
<li>兼容 EVM（如 Arbitrum、Optimism）。</li>
<li>提款需等待 <strong>7天挑战期</strong>。</li>
<li>成本低，适合通用智能合约。</li>
</ul>
</li>
</ul>
<p><strong>工作流程</strong>：</p>
<ol>
<li>交易在 Layer2 执行。</li>
<li>排序器（Sequencer）将交易数据（Calldata）提交到主链。</li>
<li>若有欺诈，验证者在挑战期内提交证明，回滚错误状态。</li>
</ol>
<p><strong>(2) ZK Rollup（零知识证明汇总）</strong></p>
<ul>
<li>每批交易生成 <strong>零知识证明（ZK-SNARK/STARK）</strong>，主链即时验证。</li>
<li><strong>特点</strong>：<ul>
<li>无需挑战期，提款即时到账。</li>
<li>证明生成计算量大，早期难兼容 EVM（现 zkEVM 已突破）。</li>
<li>隐私性更强（可隐藏交易细节）。</li>
</ul>
</li>
</ul>
<p><strong>工作流程</strong>：</p>
<ol>
<li>交易在 Layer2 执行。</li>
<li>生成有效性证明（Proof）并提交到主链。</li>
<li>主链验证证明后，更新状态。</li>
</ol>
<p><strong>Rollup 的优缺点</strong></p>
<p><strong>✅ 优点</strong></p>
<ul>
<li><strong>高扩展性</strong>：吞吐量提升百倍。</li>
<li><strong>安全性</strong>：依赖主链验证，抗审查。</li>
<li><strong>低成本</strong>：Gas 费仅为链上的 1/10~1/100。</li>
</ul>
<p><strong>❌ 缺点</strong></p>
<ul>
<li><strong>Optimistic 的延迟</strong>：提款需等待 7 天（可通过流动性提供商缓解）。</li>
<li><strong>ZK 的硬件需求</strong>：证明生成需要高性能服务器。</li>
<li><strong>中心化风险</strong>：排序器可能被垄断（逐步去中心化中）。</li>
</ul>
<blockquote>
<h3 id="零知识证明（Zero-Knowledge-Proof-ZKP）详解"><a href="#零知识证明（Zero-Knowledge-Proof-ZKP）详解" class="headerlink" title="零知识证明（Zero-Knowledge Proof, ZKP）详解"></a><strong>零知识证明（Zero-Knowledge Proof, ZKP）详解</strong></h3><p><strong>零知识证明</strong> 是一种密码学技术，允许一方（证明者）向另一方（验证者）<strong>证明某个陈述的真实性</strong>，而无需透露任何额外信息。其核心思想是：<strong>“我知道一个秘密，但我不会告诉你秘密是什么”</strong>。</p>
<p>在区块链领域，ZKP 是隐私保护（如 Zcash）和扩容（如 ZK Rollup）的核心技术。</p>
<h4 id="1-零知识证明的三大核心特性"><a href="#1-零知识证明的三大核心特性" class="headerlink" title="1. 零知识证明的三大核心特性"></a><strong>1. 零知识证明的三大核心特性</strong></h4><ol>
<li><strong>完备性（Completeness）</strong>：<ul>
<li>如果陈述为真，诚实验证者一定会被说服。</li>
</ul>
</li>
<li><strong>可靠性（Soundness）</strong>：<ul>
<li>如果陈述为假，作弊的证明者无法欺骗验证者。</li>
</ul>
</li>
<li><strong>零知识性（Zero-Knowledge）</strong>：<ul>
<li>验证者除了“陈述为真”外，无法获取任何其他信息。</li>
</ul>
</li>
</ol>
<h4 id="2-经典类比：洞穴寓言"><a href="#2-经典类比：洞穴寓言" class="headerlink" title="2. 经典类比：洞穴寓言"></a><strong>2. 经典类比：洞穴寓言</strong></h4><p>假设有一个环形洞穴，中间有一道需要密码才能打开的门。</p>
<ul>
<li><strong>证明者</strong>知道密码，想向<strong>验证者</strong>证明这一点，但不想泄露密码。</li>
<li><strong>过程</strong>：<ol>
<li>验证者站在洞口，随机要求证明者从左侧（A）或右侧（B）进入。</li>
<li>证明者无论从哪边进入，都能用密码开门并从另一侧出来。</li>
<li>重复多次后，验证者确信证明者确实知道密码，但始终不知道密码是什么。</li>
</ol>
</li>
</ul>
<h4 id="3-零知识证明的两种主要类型"><a href="#3-零知识证明的两种主要类型" class="headerlink" title="3. 零知识证明的两种主要类型"></a>3. 零知识证明的两种主要类型</h4><p><strong>(1) 交互式零知识证明（Interactive ZKP）</strong></p>
<ul>
<li>需要多轮通信（如洞穴寓言中的多次进出）。</li>
<li><strong>缺点</strong>：效率低，不适合区块链。</li>
</ul>
<p><strong>(2) 非交互式零知识证明（Non-Interactive ZKP, NIZK）</strong></p>
<ul>
<li>证明者生成单次证明，验证者可随时检查。</li>
<li><strong>区块链常用</strong>：如 ZK-SNARKs、ZK-STARKs。</li>
</ul>
<h4 id="4-区块链中的-ZKP-技术"><a href="#4-区块链中的-ZKP-技术" class="headerlink" title="4. 区块链中的 ZKP 技术"></a><strong>4. 区块链中的 ZKP 技术</strong></h4><p> <strong>(1) ZK-SNARKs（简洁非交互式知识论证）</strong></p>
<ul>
<li><strong>特点</strong>：<ul>
<li>证明体积小（约 200 字节），验证速度快。</li>
<li>需要“可信设置”（Trusted Setup），存在潜在风险。</li>
</ul>
</li>
<li><strong>应用</strong>：<ul>
<li><strong>Zcash</strong>（隐私转账）。</li>
<li><strong>zkSync</strong>（ZK Rollup）。</li>
</ul>
</li>
</ul>
<p> <strong>(2) ZK-STARKs</strong></p>
<ul>
<li><strong>特点</strong>：<ul>
<li>无需可信设置，抗量子计算。</li>
<li>证明体积较大（约 100 KB），但验证速度仍快。</li>
</ul>
</li>
<li><strong>应用</strong>：<ul>
<li><strong>StarkNet</strong>（以太坊 Layer2）。</li>
</ul>
</li>
</ul>
<p><strong>(3) Bulletproofs</strong></p>
<ul>
<li><strong>特点</strong>：<ul>
<li>无需可信设置，适合范围证明（如 Confidential Transactions）。</li>
</ul>
</li>
<li><strong>应用</strong>：<ul>
<li><strong>Monero</strong>（隐私币）。</li>
</ul>
</li>
</ul>
<h4 id="5-零知识证明的区块链应用"><a href="#5-零知识证明的区块链应用" class="headerlink" title="5. 零知识证明的区块链应用"></a><strong>5. 零知识证明的区块链应用</strong></h4><p><strong>(1) 隐私保护</strong></p>
<ul>
<li><strong>匿名交易</strong>：Zcash 使用 ZK-SNARKs 隐藏发送方、接收方和金额。</li>
<li><strong>身份验证</strong>：证明年龄 &gt;18 岁，而无需透露出生日期。</li>
</ul>
<p> <strong>(2) 扩容（ZK Rollup）</strong></p>
<ul>
<li><u>将数千笔交易打包，生成 ZKP 证明提交到主链，验证者只需检查证明即可确认有效性。</u></li>
<li><strong>代表项目</strong>：zkSync、StarkNet、Scroll。</li>
</ul>
<p><strong>(3) 去中心化存储验证</strong></p>
<ul>
<li>证明文件已正确存储，而无需下载全部数据（如 Filecoin）。</li>
</ul>
<h4 id="6-零知识证明的优缺点"><a href="#6-零知识证明的优缺点" class="headerlink" title="6. 零知识证明的优缺点"></a><strong>6. 零知识证明的优缺点</strong></h4><p><strong>✅ 优点</strong></p>
<ul>
<li><strong>隐私性</strong>：隐藏敏感数据（如交易详情）。</li>
<li><strong>扩展性</strong>：减少链上计算负担（如 ZK Rollup）。</li>
<li><strong>安全性</strong>：数学上无法伪造证明。</li>
</ul>
<p><strong>❌ 挑战</strong></p>
<ul>
<li><strong>计算密集型</strong>：生成证明需要高性能硬件。</li>
<li><strong>可信设置（ZK-SNARKs）</strong>：初始参数若泄露，可能伪造证明。</li>
<li><strong>开发门槛高</strong>：需要密码学专业知识。</li>
</ul>
</blockquote>
<h4 id="2-5-Layer-2-对比"><a href="#2-5-Layer-2-对比" class="headerlink" title="2.5 Layer 2 对比"></a>2.5 Layer 2 对比</h4><p><strong>核心特性对比</strong></p>
<table>
<thead>
<tr>
<th align="center"><strong>维度</strong></th>
<th align="center"><strong>State Channel</strong></th>
<th align="center"><strong>Sidechain</strong></th>
<th align="center"><strong>Plasma</strong></th>
<th align="center"><strong>Rollup</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>安全性</strong></td>
<td align="center">依赖最终结算</td>
<td align="center">依赖侧链共识</td>
<td align="center">依赖主链欺诈证明</td>
<td align="center">继承主链安全性</td>
</tr>
<tr>
<td align="center"><strong>交易速度</strong></td>
<td align="center">即时（链下）</td>
<td align="center">较快（依赖侧链性能）</td>
<td align="center">较快（链下执行）</td>
<td align="center">较快（链下执行）</td>
</tr>
<tr>
<td align="center"><strong>成本</strong></td>
<td align="center">链下免费，仅开/关通道付费</td>
<td align="center">低（侧链Gas费）</td>
<td align="center">极低</td>
<td align="center">极低（数据压缩）</td>
</tr>
<tr>
<td align="center"><strong>去中心化</strong></td>
<td align="center">需预存资金，参与者固定</td>
<td align="center">可变（PoA/PoS）</td>
<td align="center">依赖运营商</td>
<td align="center">逐步去中心化</td>
</tr>
<tr>
<td align="center"><strong>数据存储</strong></td>
<td align="center">仅最终状态上链</td>
<td align="center">独立链上存储</td>
<td align="center">仅提交Merkle Root</td>
<td align="center">交易数据全上链（Rollup）</td>
</tr>
<tr>
<td align="center"><strong>适用场景</strong></td>
<td align="center">高频小额支付（如游戏）</td>
<td align="center">独立生态（如GameFi）</td>
<td align="center">简单支付/资产转移</td>
<td align="center">通用智能合约</td>
</tr>
</tbody></table>
<p><strong>工作原理对比</strong></p>
<p><strong>(1) State Channel（状态通道）</strong></p>
<ul>
<li><strong>流程</strong>：<ol>
<li>双方锁定资金在主链。</li>
<li>链下无限次交易（仅双方签名）。</li>
<li>最终结算状态上链。</li>
</ol>
</li>
<li><strong>例子</strong>：比特币闪电网络、以太坊的Raiden Network。</li>
</ul>
<p><strong>(2) Sidechain（侧链）</strong></p>
<ul>
<li><strong>流程</strong>：<ol>
<li>资产通过桥锁定在主链，映射到侧链。</li>
<li>侧链独立运行（自有共识机制）。</li>
<li>提款时反向桥接回主链。</li>
</ol>
</li>
<li><strong>例子</strong>：Polygon PoS链、Ronin（Axie Infinity侧链）。</li>
</ul>
<p> <strong>(3) Plasma</strong></p>
<ul>
<li><strong>流程</strong>：<ol>
<li>资产锁定在主链Plasma合约。</li>
<li>子链处理交易，定期提交Merkle Root到主链。</li>
<li>提款需挑战期（防欺诈）。</li>
</ol>
</li>
<li><strong>例子</strong>：早期OMG Network（已转向Rollup）。</li>
</ul>
<p> <strong>(4) Rollup</strong></p>
<ul>
<li><strong>流程</strong>：<ol>
<li>交易在链下执行并压缩。</li>
<li>数据批量提交到主链（Optimistic需欺诈证明，ZK需有效性证明）。</li>
</ol>
</li>
<li><strong>例子</strong>：Optimism（OP）、Arbitrum、zkSync。</li>
</ul>
<p><strong>安全性对比</strong></p>
<table>
<thead>
<tr>
<th align="center"><strong>方案</strong></th>
<th align="center"><strong>安全模型</strong></th>
<th align="center"><strong>主要风险</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>State Channel</strong></td>
<td align="center">依赖参与者诚实</td>
<td align="center">对手方离线时资金可能锁定</td>
</tr>
<tr>
<td align="center"><strong>Sidechain</strong></td>
<td align="center">依赖侧链共识</td>
<td align="center">桥接攻击（如Ronin被盗6.25亿美元）</td>
</tr>
<tr>
<td align="center"><strong>Plasma</strong></td>
<td align="center">主链欺诈证明</td>
<td align="center">数据不可用性问题（运营商隐藏数据）</td>
</tr>
<tr>
<td align="center"><strong>Rollup</strong></td>
<td align="center">继承主链安全</td>
<td align="center">Optimistic的7天延迟，ZK的证明中心化</td>
</tr>
</tbody></table>
<p><strong>优缺点总结</strong></p>
<table>
<thead>
<tr>
<th align="center"><strong>方案</strong></th>
<th align="center"><strong>优点</strong></th>
<th align="center"><strong>缺点</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>State Channel</strong></td>
<td align="center">零延迟，零Gas费，隐私性好</td>
<td align="center">仅限固定参与者，需预存资金</td>
</tr>
<tr>
<td align="center"><strong>Sidechain</strong></td>
<td align="center">高性能，灵活定制</td>
<td align="center">安全性依赖侧链，桥接风险</td>
</tr>
<tr>
<td align="center"><strong>Plasma</strong></td>
<td align="center">高吞吐量，低成本</td>
<td align="center">退出延迟长，不支持复杂逻辑</td>
</tr>
<tr>
<td align="center"><strong>Rollup</strong></td>
<td align="center">继承主链安全，支持智能合约</td>
<td align="center">Optimistic有延迟，ZK开发门槛高</td>
</tr>
</tbody></table>
<p><strong>未来趋势</strong></p>
<ul>
<li><strong>Rollup 主导</strong>：Optimistic 和 ZK Rollup 成为以太坊扩容主流。</li>
<li><strong>State Channel 小众化</strong>：仅用于特定场景（如微支付）。</li>
<li><strong>Sidechain 专用化</strong>：游戏、社交等垂直领域。</li>
<li><strong>Plasma 淘汰</strong>：被 Rollup 取代（因数据可用性问题）。</li>
</ul>
<h3 id="3-Rollup详情"><a href="#3-Rollup详情" class="headerlink" title="3 Rollup详情"></a>3 Rollup详情</h3><h4 id="3-1-如何压缩"><a href="#3-1-如何压缩" class="headerlink" title="3.1 如何压缩"></a>3.1 如何压缩</h4><p>以 OP-Rollup 的为例，我们要向 Layer 1 上传一段时间内的所有交易详情，如果不对这部分数据进行高度压缩，那分担负载的效果就非常小了。我们以单笔交易为例，它身上其实有许多可改进的空间。</p>
<p>比如一笔常见的转账交易，它的原数交易数据可能是以下这样的：</p>
<p><strong>4232f461</strong>000000000000000000000000<strong>7ea2be2df7ba6e54b1a9c70676f668455e329d29</strong>000000000000000000000000<strong>d548a5e31de2b4c2681a58a3be5302abcae4bc57</strong>00000000000000000000<strong>000000000000000000000000000000000000000186a0</strong></p>
<p>（<strong>Method ID</strong> / 零填充[1] / <strong>代币合约地址</strong> / 零填充 / <strong>收款的账户地址</strong> / 零填充 / <strong>提币数量</strong>）</p>
<blockquote>
<p> [1]零填充：之所以要填充零占用空间，是因为以太坊中的交易数据是固定长度编码的，比如 Method ID 占用 128 位（32 个十六进制字母），地址和金额占用 256 位（64 个十六进制字母），不够长的信息字段需要填充 0 以保持数据对齐和一致性。</p>
</blockquote>
<p><u><strong>原始交易数据可以通过以下手段压缩：</strong></u></p>
<ol>
<li>用<strong>科学计数法</strong>把转账数量压缩成 64 位数据，并删除不必要的 0。（数量的精度会略微下降，但实践中影响不大）</li>
<li>调用的方法如果很常见，可以删除所调用的 Method ID，因为如“转账一笔 ERC20 [3] 代币”的交易，可以通过交易内容的特征推测</li>
<li>常用行为设置绿色通道（Helper ID）：大部分发送代币的行为都是如 USDC、WETH 等常用代币，可以用更短的一个 Helper ID，来表示调用方法是“发送”，发送的代币是“USDC”这两个信息。</li>
<li>登记一个“电话簿”，记录收款人地址，将 40 位的地址压缩为第 XXX 页的第 X 个地址。</li>
<li>如果发送的是 ETH，连 Helper ID 都可以省掉。</li>
</ol>
<p>最终我们需要上传至 Layer 1 的数据从一段非常长的信息</p>
<p><strong>4232f461</strong>000000000000000000000000<strong>7ea2be2df7ba6e54b1a9c70676f668455e329d29</strong>000000000000000000000000<strong>d548a5e31de2b4c2681a58a3be5302abcae4bc57</strong>00000000000000000000<strong>000000000000000000000000000000000000000186a0</strong></p>
<p>变为了</p>
<p><strong>059c57</strong>0186a0</p>
<p>（<strong>收款账户“电话簿”编号</strong> / 提币数量）</p>
<p><strong>数据压缩过程</strong></p>
<ol>
<li><strong>原始状态</strong></li>
</ol>
<p><u>原始交易数据未经压缩</u></p>
<blockquote>
<p><strong>4232f461</strong>000000000000000000000000<strong>7ea2be2df7ba6e54b1a9c70676f668455e329d29</strong>000000000000000000000000<strong>d548a5e31de2b4c2681a58a3be5302abcae4bc57</strong>00000000000000000000<strong>000000000000000000000000000000000000000186a0</strong></p>
</blockquote>
<p>（Method ID / 零填充 / 代币合约地址 / 零填充  / 收款的账户地址 / 零填充 / 提币数量）</p>
<ol start="2">
<li><strong>压缩状态1</strong></li>
</ol>
<p><u>用<strong>科学计数法</strong>把转账数量压缩成 64 位数据，并删除不必要的 0。（数量的精度会略微下降，但实践中影响不大）</u></p>
<blockquote>
<p><strong>4232f461</strong>7ea2be2df7ba6e54b1a9c70676f668455e329d29<strong>d548a5e31de2b4c2681a58a3be5302abcae4bc57</strong>0186a0</p>
</blockquote>
<p>（Method ID / 代币合约地址 / 收款的账户地址 / 提币数量）</p>
<ol start="3">
<li><strong>压缩状态2</strong></li>
</ol>
<p><u>调用的方法如果很常见，可以删除所调用的 Method ID，因为如“转账一笔 ERC20 [3] 代币”的交易，可以通过交易内容的特征推测</u></p>
<blockquote>
<p><strong>7ea2be2df7ba6e54b1a9c70676f668455e329d29</strong>d548a5e31de2b4c2681a58a3be5302abcae4bc57<strong>0186a0</strong></p>
</blockquote>
<p>（代币合约地址 / 收款的账户地址 / 提币数量）</p>
<ol start="4">
<li><strong>压缩状态3</strong></li>
</ol>
<p><u>常用行为设置绿色通道（Helper ID）：大部分发送代币的行为都是如 USDC、WETH 等常用代币，可以用更短的一个 Helper ID，来表示调用方法是“发送”，发送的代币是“USDC”这两个信息。</u></p>
<blockquote>
<p><strong>0000ee</strong>d548a5e31de2b4c2681a58a3be5302abcae4bc57<strong>0186a0</strong></p>
</blockquote>
<p>（Helper ID / 收款的账户地址 / 提币数量）</p>
<ol start="5">
<li><strong>压缩状态4</strong></li>
</ol>
<p><u>登记一个“电话簿”，记录收款人地址，将 40 位的地址压缩为第 XXX 页的第 X 个地址。</u></p>
<blockquote>
<p><strong>0000ee</strong>059c01<strong>0186a0</strong></p>
</blockquote>
<p>（Helper ID / 收款账户“电话簿”编号 / 提币数量）</p>
<ol start="6">
<li><strong>压缩状态5</strong></li>
</ol>
<p><u>如果发送的是 ETH，连 Helper ID 都可以省掉。</u></p>
<blockquote>
<p><strong>059c01</strong>0186a0</p>
</blockquote>
<p>（收款账户“电话簿”编号 / 提币数量）</p>
<p>Layer 1 存储数据的成本是非常高昂的，Layer 2 的执行成本绝大部分的都消耗在了这一步，因此压缩需要上传的数据上可以显著降低 Layer 2 整体的交易成本。</p>
<h4 id="3-2-进一步压缩"><a href="#3-2-进一步压缩" class="headerlink" title="3.2 进一步压缩"></a>3.2 进一步压缩</h4><p>数据压缩是个远早于区块链就存在的技术，除了前面对交易的定制化压缩之外，还有许多压缩算法能帮助进一步压缩数据空间。</p>
<p>比如我们生活中往往都接触过 zip、rar、7z 压缩包，它们就是使用了压缩算法将各种文件的体积减小。 Optimism 的 Zlib 压缩算法、 Arbitrum 的 Brotli 压缩算法都能起到类似的作用。</p>
<h4 id="3-3-Optimistic-Rollup"><a href="#3-3-Optimistic-Rollup" class="headerlink" title="3.3 Optimistic Rollup"></a>3.3 Optimistic Rollup</h4><p>Optimistic Rollup 是“乐观的打包”，它假设绝大部分的参与者都是诚实的，允许一批数量较少的验证者节点（Validator），对交易进行收集、排序、验证。同时还设置了挑战者的角色（Challenger），其职责是监督验证者提交的信息是否诚实。</p>
<p>OP-Rollup 会定期向主网上传两种数据：</p>
<ul>
<li>状态根（State Root）: 状态根可以快速确认 Layer 2 小账本的内容是否被篡改。</li>
<li>压缩后的全部交易数据：包含各种交易细节，比如交易附带的“用户签名”。</li>
</ul>
<p>虽然上传了近段时间的全部交易详情，但以太坊主网并不负责直接验证这些交易，只起到一个公示的作用。</p>
<p>与 Plasma 类似，OP-Rollup 也使用默克尔树的形式保存了一个“小账本”，记录了全体账户的所有状态（账户余额）。如果我们相信目前的交易验证者（Validator）都是诚实的，那么状态根能快速确认当前 Layer 2 的小账本记录的内容是否被篡改，确保安全性。</p>
<p>反之，假如我们对目前的交易合法性产生质疑，任何第三方都可以在主网获取最近一段时间内所有交易的副本，重新验证之后，将自己验证的结果与 Layer 2 的小账本的记录做对比，确认小账本上的记录均为合法。如果发现作恶，挑战者就可以在 Layer 1 提交欺诈证明来改写 Layer 2 的状态。挑战成功后，不诚实的验证者将受到惩罚，挑战者将获得奖励。同时，受影响的交易将被回滚 [1]，进行重新验证。</p>
<blockquote>
<p>[1] 回滚的影响范围取决于具体 Layer 2 的设计机制。有些选择仅回滚无效的交易；有些选择将受影响的区块变为孤块，从未受影响的区块后继续，这将导致一段时间内的交易都将被回滚，进行重新验证；有些选择用多轮挑战等其他手段，缩小需要回滚的范围。</p>
</blockquote>
<p>这个过程中，负责监督的挑战者（Challenger）是直接与 Layer 1 的智能合约交互的，一层对二层的状态有着最终裁决权。</p>
<p>这种设计之下，即使只有一个诚实的挑战者，也足以确保整个 Layer 2 的交易安全。不过代价是 OP-Rollup 必须提供一个退出窗口期，让挑战者有时间去检验并提交欺诈证明，因此使用官方桥从 OP-Rollup 网络提款往往需要 7 - 14 天的等待期。</p>
<p>OP-Rollup 的逻辑简单易懂，而且上传了全部交易细节，因此对 EVM [2] （以太坊虚拟机）的兼容性也非常好，很有利于落地实施。但漫长的挑战期实在是太痛苦了，有办法解决<strong>退出等待时间过长的问题</strong>吗？</p>
<blockquote>
<p>[2] EVM 即 Ethereum Virtual Machine，是以太坊中智能合约的执行环境。虚拟机（Virtual Machine）是通过软件模拟的具有完整硬件系统功能的、运行在隔离环境中的完整计算机系统。开发者不必关心底层细节如何实现，只要在以太坊虚拟机中开发，就能确保代码执行环境的一致性。</p>
</blockquote>
<h4 id="3-4-Zero-Knowledge-Proof"><a href="#3-4-Zero-Knowledge-Proof" class="headerlink" title="3.4 Zero-Knowledge Proof"></a>3.4 Zero-Knowledge Proof</h4><p>造成漫长等待期的原因，是因为 OP-Rollup 需要人的参与（挑战者扮演的角色）。如果能让整个过程不需要人的参与，只需要算法的参与，那就完美了。</p>
<p><strong>零知识证明</strong>是指向他人证明某个命题为真，但又不透露“该命题为真”之外的任何信息。例如，有一个环形的长廊，在走廊中间某处有一道安装了密码锁的门。如果 A 要向 B 证明自己拥有该门的密码，无需向 B 展示自己打开密码锁的过程。只需要让 B 看着 A 从入口进入走廊，然后又从另一侧的出口走出走廊，就可以完全证明 A 拥有密码，同时免除了暴露密码的风险。</p>
<p><strong>零知识证明具备以下性质</strong>：</p>
<ol>
<li>完备性（Completeness）：若命题为真，任何证明者可以向验证者提出令人信服的证据，即“真的可被验证”。</li>
<li>可靠性（Soundness）：若命题为假，则不存在不诚实的证明者能骗过验证者，即“假的会被发现”。</li>
<li>零知识性（Zero-knowledge）：证明某个命题为真，但又不透露“该命题为真”之外的其他任何信息。</li>
</ol>
<p>工程实践上我们还要求零知识证明的算法拥有以下性质：</p>
<ol>
<li>简洁性（Succinctness）：证明很小且验证速度快。</li>
<li>零知识（Zero Knowledge）：可以隐藏计算的输入信息。</li>
</ol>
<p>ZK-Rollup 会周期性向主网上传 3 种数据：</p>
<ul>
<li>状态根：状态根可以快速确认 Layer 2 小账本的内容是否被篡改。</li>
<li>交易数据：经过压缩和聚合的交易数据，例如将多个交易合并为一批次的状态变化结果。通过使用零知识证明保证交易的安全性，可以舍弃一些不必要的信息，例如前面提到的“用户签名”。</li>
<li>有效性证明：即零知识证明，让 Layer 1 的智能合约在经过简单验证后，就能确认交易已经被正确执行。</li>
</ul>
<p>ZK-Rollup 与 OP-Rollup 最大的不同，就在于 <u>Layer 1 是否对 Layer 2 上传的数据进行验证</u>。</p>
<p>ZK-Rollup 方案依靠 Layer 1 上的智能合约，用很小的代价检验 ZK Proof 的有效性，如果检验通过则表示这批交易已经被正确执行，那就更新状态。如果检验不通过，则拒绝这一批次的交易。</p>
<p>OP-Rollup 则完全将 Layer 1 当成了解决数据可用性的公告板，依赖挑战者的监督，两者的安全性和交易确认速度都会产生明显差异。</p>
<p>ZK-Rollup 的优点显而易见：</p>
<ul>
<li>依靠数学而非验证者，安全性更有保障，并且确认时间更短。</li>
<li>更高的压缩率，让 Layer 2 的扩容上限更高。</li>
</ul>
<h4 id="3-5-ZK-技术原理-STARK-vs-SNARK"><a href="#3-5-ZK-技术原理-STARK-vs-SNARK" class="headerlink" title="3.5 ZK 技术原理 STARK vs SNARK"></a>3.5 ZK 技术原理 STARK vs SNARK</h4><p><u><strong>本内容暂时无法理解</strong></u></p>
<p><strong>ZK-Rollup 的基础组件</strong></p>
<p>ZK-Rollup 用了一些特定的数学工具，来实现在不透露原始输入数据的情况下确保交易已被正确执行，它通常包含以下主要技术：</p>
<ul>
<li>KZG 多项式承诺：因两个多项式最多拥有 n2 个交点，而定义域却存在极多的点，那么我们只需要检查有限的若干次，就能确信对方确实以正确的多项式进行了计算。若将信息编码在多项式中，则靠多次确认多项式在特定点上的输出结果，即可确认交易已被正确验证（确认过程原本是需要交互的，但可用其他方法变为非交互式）。</li>
<li>哈希算法：能将任意长度的数据映射为固定长度的哈希值，用于压缩证明。</li>
<li>椭圆曲线加密：可以将椭圆曲线上的两个点用难以预测的方式映射起来，用于构建证明系统。可用来进行一些复杂的证明，比如在不公开哈希值的情况下证明两个哈希相等。</li>
<li>随机数等其它组件：用于随机数来确认起始需要检查的点，并用类似“上一个哈希影响下一个哈希”的方式确认一连串需要检查的点，以确保检查点的随机性与非交互性。</li>
</ul>
<h5 id="SNARK"><a href="#SNARK" class="headerlink" title="SNARK"></a><strong>SNARK</strong></h5><p>目前零知识证明主要有两种技术路线，SNARK 与 STARK。SNARK 出现更早，更加成熟，目前被更多的项目方采用。</p>
<p>SNARK：Succinct Non-Interactive Argument of Knowledge</p>
<ol>
<li>简洁（Succinct）：验证速度快于计算证明。</li>
<li>非交互式（Non-Interactive）：无需证明者与验证者之间进行交互。如比特币的公私钥对也是一种零知识证明，但它要求私钥拥有者对一段文字进行签名才能证明自己拥有私钥，这需要发生一次交互。</li>
<li>统计学上的可靠（Argument）：相对于数学上绝对的证明(即 100% 可靠)，实现了统计学上的可靠（如 99.99999999%）。</li>
<li>包含信息（Knowledge）：可将某些信息编码进零知识证明中，如一笔交易已被正确执行。</li>
</ol>
<h5 id="STARK"><a href="#STARK" class="headerlink" title="STARK"></a><strong>STARK</strong></h5><p>STARK：Scalable Transparent Argument of Knowledge</p>
<ol>
<li>可扩展的（Scalable）：在进行大规模交易的证明时，验证时间仍然较短。</li>
<li>透明的（Transparent）：随机数公开可验证，无需像 SNARK 一样设置初始可信环境。</li>
<li>统计学上的可靠（Argument）：相对于数学上绝对的证明(即 100% 可靠)，实现了统计学上的可靠（如 99.99999999%）。</li>
<li>包含信息（Knowledge）：可将某些信息编码进零知识证明中，如一笔交易已被正确执行。</li>
</ol>
<p>对比两条技术路线，STARK 在 Layer 2 上处理大量交易时，其零知识证明生成速度和验证速度更快的特点将具有优势，并且具有抗量子性 [1]，无需初始可信环境 [2]，更加安全。而 SNARK 发展时间更久更成熟，将会更早取得应用。</p>
<p>SNARK 证明体积更小，并且随着技术发展，已经可以在升级后沿用最初的可信环境，在安全性上不会显著弱于 STARK。SNARK 与 STARK 的关系更像是 OP-Rollup 与 ZK-Rollup 之间的关系，前者可能更早落地，后者拥有更大潜力。</p>
<p>从底层技术路线去研究 ZK-Rollup 显得有点复杂了，<strong>有更简单的方式去理解 ZK-Rollup 吗</strong>？</p>
<blockquote>
<p>[1] 抗量子性指能够在量子计算机攻击下保证信息安全。传统的加密算法（如 RSA、DSA 和 ECC 等）可能在将来的大规模量子计算机上被有效地破解，因此需要使用新的抗量子密码学算法来替代，确保加密在未来的量子计算机时代仍然安全。</p>
<p>[2] 初始可信环境是指在协议部署的最初，需要信任部署者诚实地部署了一个安全环境。比如参与部署的多个实体中，有一人销毁了自己的私钥，即可确认初始信息没有任何人能掌控。初始可信环境主要与随机数有关，零知识证明的计算过程非常依赖随机数作为输入，但如果初始的随机数被掌握，可能使得后续的计算变得可预测，产生被攻击的风险。</p>
</blockquote>
<h4 id="3-6-ZK-发展路线-ZK-VM-vs-ZK-EVM"><a href="#3-6-ZK-发展路线-ZK-VM-vs-ZK-EVM" class="headerlink" title="3.6 ZK 发展路线 ZK-VM vs ZK-EVM"></a>3.6 ZK 发展路线 ZK-VM vs ZK-EVM</h4><h5 id="ZK-VM：从零知识证明的角度出发"><a href="#ZK-VM：从零知识证明的角度出发" class="headerlink" title="ZK-VM：从零知识证明的角度出发"></a><strong>ZK-VM：从零知识证明的角度出发</strong></h5><p>第一种思路是从零知识证明技术出发，<strong>专门开发适用于零知识证明的算法，从而构建一个 ZK-VM [1] （零知识虚拟机），而不是原生兼容 EVM 的 ZK-EVM [2] （零知识以太坊虚拟机）</strong>，在此基础上尽可能实现 EVM 兼容。</p>
<p>StarkWare 和 zkSync 都采用了这种路线。StarkWare 的 Cairo 语言和 zkSync 的 Zinc 语言都是原生的零知识编程语言，甚至前者的账户地址系统与以太坊也存在很大的差异。</p>
<p>这种路线的优点是能够充分发挥零知识证明的潜力，实现最大化的扩展性。但缺点是开发者需要学习新的编程语言，并且现有项目需要将 Solidity 语言 [3] 的代码转换为 ZK-VM 的代码，这个过程中可能出现许多意想不到的问题，需要重新调试，重新审计。</p>
<h5 id="ZK-EVM：从-EVM-兼容性的角度出发"><a href="#ZK-EVM：从-EVM-兼容性的角度出发" class="headerlink" title="ZK-EVM：从 EVM 兼容性的角度出发"></a><strong>ZK-EVM：从 EVM 兼容性的角度出发</strong></h5><p>反过来我们也可以从兼容 EVM 这个目的出发，<strong>将 EVM 的交易在操作码 [4] 层面切割成更小的步骤，对每个步骤去找对应的零知识证明算法，力求实现完全的 EVM 兼容。</strong> 这样做可以使开发者几乎无感地切换到二层网络，方便现有项目迁移，最大程度地保留目前的 EVM 生态成果。Scroll 和 Polygon Hermez 都采用了这种思路。</p>
<p>但是这种路线的缺点也显而易见，EVM 上的交易并非为零知识而设计，因此这种方法往往生成的证明体积较大，所需的时间也更长。</p>
<p>读到这里，我们已经了解了 Rollup 的当前进展。特别是零知识证明技术，令人感到十分神奇，使 Rollup 具备了非常大的潜力。但是仅仅通过 Rollup 实现扩容仍然存在上限，<strong>未来我们还有其他提升的空间吗</strong>？</p>
<blockquote>
<p>[1] VM（Virtual Machine）即虚拟机，一个由软件模拟硬件的可控代码执行环境。 ZK-VM（Zero Knowledge - Virtual Machine） 是适应于零知识证明的虚拟机。</p>
<p>[2] ZK-EVM（Zero Knowledge - Ethereum Virtual Machine）是指利用了零知识证明技术的以太坊虚拟机，与原始的以太坊虚拟机有良好的兼容性。</p>
<p>[3] Solidity 语言是以太坊原生的开发语言，大部分运行在以太坊网络上的智能合约均采用 Solidity 编写。</p>
<p>[4] 计算机能直接读懂的语言是 0 和 1 ，操作码（Opcode）是非常底层的，与硬件（或是虚拟机中的虚拟硬件）直接交流的代码。操作码是指令集中每个指令的唯一标识符，在计算机执行指令时，用于识别具体指令的一个数字或符号。例如，在 x86 指令集中，加法指令（ADD）有一个特定的操作码，用于标识该指令。</p>
<p>此外还有一些相关概念：</p>
<ol>
<li>指令集（Instruction Set）： 指令集是一种用于编程的低级语言，它是计算机硬件能够理解和执行的一组指令。每种处理器都有自己的指令集，这些指令集定义了处理器可以执行的基本操作，如数据移动、算术和逻辑运算、条件分支等。指令集也被称为指令集架构（ISA，Instruction Set Architecture）。</li>
<li>字节码（Bytecode）： 字节码是一种中间代码，介于源代码和机器代码之间。字节码通常由虚拟机（如 Java 虚拟机，JVM）执行，而不是直接由硬件执行。字节码的目的是提供一种平台无关的代码表示形式，这样不同平台上的虚拟机都可以执行相同的字节码。字节码通常比源代码更接近机器代码，但仍需要经过解释或编译为特定硬件的指令集。</li>
</ol>
<p>指令集是计算机硬件能够执行的一组基本操作，每个操作都有一个唯一的操作码（Opcode）。字节码是一种平台无关的中间代码形式，它在执行时需要虚拟机将其转换为特定硬件的指令集。在这个过程中，字节码中的指令也会有相应的操作码。总之，操作码是指令的标识符，它在指令集和字节码中都有应用。</p>
</blockquote>
<h3 id="4-未来展望"><a href="#4-未来展望" class="headerlink" title="4 未来展望"></a>4 未来展望</h3><h4 id="4-1-其它解决方案：Validium-和-Volition"><a href="#4-1-其它解决方案：Validium-和-Volition" class="headerlink" title="4.1 其它解决方案：Validium 和 Volition"></a>4.1 其它解决方案：Validium 和 Volition</h4><p>纵览二层扩容方案的发展历程，其实都源自于<strong>数据可用性</strong>影响了安全性与实用性。</p>
<ol>
<li>侧链方案，数据对主链来说不可用，所以无法继承主链安全性。</li>
<li>Plasma 方案，状态根可以保障链下账本的不被篡改，但具体交易数据对一层网络来说也不可用，导致资金退出困难。</li>
<li>OP-Rollup 方案，让所有交易的详细数据都存在一层网络上，确保了全部交易数据的可用性，从而确保二层网络的安全。</li>
<li>ZK-Rollup 方案，提供关键交易数据以及能证明链下交易已经被正确执行的零知识证明，实现安全性的同时，还能一定程度保证隐私性。Rely on Math，Not Validator.</li>
</ol>
<p>那么基于<strong>零知识证明和数据可用性的新组合</strong>，我们可以得到 Validium 和 Volition （由 StarkNet 提出）两种未来可行的方案。</p>
<h5 id="Validium"><a href="#Validium" class="headerlink" title="Validium"></a>Validium</h5><p>ZK-Rollup 仍向主网上传了交易数据，那如果我们进一步牺牲一点点安全性，连交易数据也不上传到一层，仅上传状态根和证明交易已被正确执行的零知识证明，由二层网络自行解决交易数据的保存，就可以进一步降低交易成本，这就是 Validium。</p>
<p>它有点像零知识版的 Plasma，Plasma 需要用户参与监督交易是否被诚实执行，而采用了零知识证明之后，不诚实的交易无法生成证明，极大地提升了节点作恶的难度。并且因为交易数据对于一层网络来说完全不可用，Validium 将具有更高的隐私性。</p>
<h5 id="Volition"><a href="#Volition" class="headerlink" title="Volition"></a>Volition</h5><p>Volition 是 Validium 方案的改进版本，允许用户可以自行选择其交易数据是否在一层网络可用，涉及大额资金的交易可以采用成本略高但安全性更好的交易上链模式。资金量较小的、更追求隐私的交易可以使用交易记录不上链的模式。</p>
<blockquote>
<p><strong>1. Validium：链下数据 + ZK 证明</strong></p>
<p><strong>核心特点</strong></p>
<ul>
<li><strong>数据存储</strong>：交易数据存储在链外（由第三方委员会或去中心化网络维护，如 StarkEx 的 DAC）。</li>
<li><strong>安全性依赖</strong>：依赖数据可用性委员会（DAC）的诚实性，若委员会作恶可能冻结资金（但无法盗取，因 ZK 证明保证状态正确）。</li>
<li><strong>优势</strong>：<ul>
<li>极低的交易成本（无需支付以太坊主网的数据存储费用）。</li>
<li>高吞吐量（适合高频交易场景，如交易所、游戏）。</li>
</ul>
</li>
<li><strong>劣势</strong>：<ul>
<li>牺牲部分去中心化（需信任 DAC）。</li>
<li>用户无法独立验证数据（需委员会配合提供数据）。</li>
</ul>
</li>
</ul>
<p><strong>典型应用</strong></p>
<ul>
<li><strong>dYdX</strong>（V3 版本）：采用 Validium 模式处理现货交易，降低手续费。</li>
<li><strong>Immutable X</strong>：为 NFT 交易提供零 Gas 费体验。</li>
</ul>
<hr>
<p><strong>2. Volition：用户自选数据存储模式</strong></p>
<p> <strong>核心特点</strong></p>
<ul>
<li><strong>混合架构</strong>：允许用户为每笔交易选择数据存储方式：<ul>
<li><strong>ZK-Rollup 模式</strong>：数据上链（高安全性，高成本）。</li>
<li><strong>Validium 模式</strong>：数据链下（低成本，依赖 DAC）。</li>
</ul>
</li>
<li><strong>灵活性</strong>：同一应用中，不同用户（甚至同一用户的不同交易）可自由选择模式。</li>
<li><strong>优势</strong>：<ul>
<li>平衡安全性与成本（例如，大额交易选 Rollup，小额选 Validium）。</li>
<li>无需迁移即可切换模式。</li>
</ul>
</li>
<li><strong>劣势</strong>：<ul>
<li>实现复杂度较高。</li>
</ul>
</li>
</ul>
<p><strong>典型应用</strong></p>
<ul>
<li><strong>StarkEx</strong>（StarkWare 的引擎）：支持 Volition，供开发者灵活配置。</li>
<li><strong>Sorare</strong>（梦幻足球 NFT 平台）：对普通用户用 Validium，对机构用户用 Rollup。</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th align="center"><strong>维度</strong></th>
<th align="center"><strong>Validium</strong></th>
<th align="center"><strong>Volition</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>数据存储</strong></td>
<td align="center">强制链下（DAC）</td>
<td align="center">用户可选链上（Rollup）或链下（Validium）</td>
</tr>
<tr>
<td align="center"><strong>安全性</strong></td>
<td align="center">依赖 DAC</td>
<td align="center">用户自主控制安全等级</td>
</tr>
<tr>
<td align="center"><strong>成本</strong></td>
<td align="center">极低（无链上数据费）</td>
<td align="center">按需支付（Rollup 模式更贵）</td>
</tr>
<tr>
<td align="center"><strong>适用场景</strong></td>
<td align="center">高频、低价值交易（如交易所）</td>
<td align="center">需灵活性的应用（如混合型 DeFi/NFT）</td>
</tr>
<tr>
<td align="center"><strong>代表项目</strong></td>
<td align="center">dYdX V3, Immutable X</td>
<td align="center">StarkEx 生态项目（如 Sorare）</td>
</tr>
</tbody></table>
<h4 id="4-2-Deneb-更新与-Layer-2"><a href="#4-2-Deneb-更新与-Layer-2" class="headerlink" title="4.2 Deneb 更新与 Layer 2"></a>4.2 Deneb 更新与 Layer 2</h4><p>以太坊 Deneb 更新（原 EIP-4844 ）是以太坊扩容路线 DankSharding 的前置步骤，旨在保证以太坊信标链安全性的前提下，为 Layer 2 扩容提供更大的储存资源。</p>
<p>Deneb 更新添加了一种新的交易：Blob 交易（大型二进制对象 Binary Large Object）。在主链上只留存指针，指针指向一个 Blob 块，上面可以储存约 128KB 的二进制数据。</p>
<p>以太坊矿工只负责在一段时间内（如一个月）保存 Blob 上的数据，通过随机抽样的方式确保 Blob 上二进制数据的真实性，但不验证存在 Blob 上的交易。</p>
<p>Blob 交易看起来对常规交易的扩容没有帮助，但这对于 Layer 2 打包的交易数据来说简直是完美契合。Layer 2 原先定期上传给 Layer 1 上的打包交易数据本来就不会执行，只是起到保障数据可用性的作用。</p>
<p>而 Blob 本身就相当于一个公示板，消息在公示板上的存续时间超过了 OP-Rollup 的挑战期，实践上完全够用，存储成本却降低了许多，这将促使 Layer 2 的交易成本进一步降低。</p>
<p>Blob 增加的唯一缺憾是超过保存期之后，Layer 2 如果想保存自己的全部历史交易数据，需要用另外的方案自行解决这些数据的可用性问题。</p>
<p>总体来说，Deneb 更新之后，Layer 2 将可以在保证安全性的同时进一步降低交易成本，变得更具实用价值。</p>
<p>探索到这里，<strong>我们增加了这么多性能，在应用层能有什么提升吗？</strong> 还是单纯只是量的堆积？</p>
<h4 id="4-3-账户抽象与大规模应用"><a href="#4-3-账户抽象与大规模应用" class="headerlink" title="4.3 账户抽象与大规模应用"></a>4.3 账户抽象与大规模应用</h4><p>钱包毫无疑问是 Web3 最重要的流量入口，是用户进入 Web3 世界最重要的工具，大部分用户主要接触到的钱包都是 EOA 钱包（外部拥有账户），即通过私钥和助记词掌握整个钱包的权限（如 MetaMask、Coinbase Wallet、Trust Wallet 等），这种 EOA 钱包有如下问题：</p>
<ol>
<li>高学习成本：用户需要了解复杂的非对称加密知识，理解任何人拥有私钥就能拥有账户，失去私钥就是失去资金的控制权。</li>
<li>单点失效问题：私钥泄露丢失，或忘记密码时，既不能用手机或邮箱，也不能柜面处理用身份证件恢复，资产将永久丢失。</li>
<li>风险控制难度较高：存在很多恶意攻击手段，试图盗取私钥；或在不盗取私钥的前提下，用恶意授权、恶意签名等方式盗取用户资产。新用户需要漫长的学习，具备谨慎的使用习惯才能保护资产安全。</li>
<li>不支持智能合约：无法实现复杂多样的高级功能，如多签、批量发送代币等等。</li>
</ol>
<p><strong>账户抽象</strong>（Account Abstraction）本质上是个智能合约钱包。是指将某些功能和具体实现细节抽象出来，用一系列的智能合约模拟出一个“账户”的效果，脱离了 EOA 账户用私钥控制地址的底层原理，允许其它更人性化的确认账户所有权的方式，并让整个账户的功能更加灵活。它解决了现有 EOA 账户的问题：</p>
<ol>
<li>更符合现有的账户使用习惯：可以像传统 Web2 服务一样登陆，使用邮箱、手机短信、两步验证等验证方法。</li>
<li>更多安全保障机制：出现安全风险时可以紧急暂停账户功能，并采用社交恢复等手段重新掌握账户控制权。</li>
<li>可以接入第三方安全模块：接入专业的风控模块，过滤风险操作，从底层降低被攻击的可能。</li>
<li>支持智能合约的更多功能：让用户在不具备代码能力的情况下使用多签、批量发送多种代币、批量授权额度等等操作。</li>
</ol>
<p>甚至还增加了许多新的可能：</p>
<ol>
<li>代理支付 Gas 费：允许第三方支付 Gas 费，可以由钱包运营商补贴 Gas 费来吸引用户，钱包作为入口展现商业价值，用户享受更便宜的服务。</li>
<li>条件交易：在满足一定条件时自动执行某些交易。</li>
<li>跨链操作：可以和跨链桥智能合约实现原生的交互，更灵活地实现资产跨链和其他跨链交互。</li>
<li>更多 DeFi 场景：账户抽象为 DeFi 提供了更多可能，如批量交易、自动借贷、流动性挖矿等。</li>
</ol>
<p>账户抽象极大地拓展了以太坊的可能性，但账户抽象的问题在于一切交易都基于智能合约完成，Gas 成本较高，这让它在以太坊主网上显得过于昂贵。</p>
<p>Layer 2 作为一个执行层，天然适配账户抽象，用户不会感知到私钥甚至不会感知到 Gas 费的存在。智能合约钱包本身就是程序，能引入风控等第三方服务，让转账和交互变得安全，有更多的丰富业务场景可以实现。可以说将来区块链技术的大规模应用技术离不开账户抽象，而账户抽象需要成本更低的 Layer 2 才能成立。</p>
<h2 id="区块链岗位全景图"><a href="#区块链岗位全景图" class="headerlink" title="区块链岗位全景图"></a>区块链岗位全景图</h2><h3 id="一、技术岗"><a href="#一、技术岗" class="headerlink" title="一、技术岗"></a>一、技术岗</h3><h4 id="1-前端工程师"><a href="#1-前端工程师" class="headerlink" title="1. 前端工程师"></a>1. 前端工程师</h4><ol>
<li><p><strong>主要职责：</strong></p>
<ul>
<li>设计和开发基于区块链技术的前端应用，支持去中心化平台的交互。</li>
<li>通过 React、Vue 等框架实现高效的用户界面，支持钱包连接、交易签名、信息验证等功能。</li>
<li>集成并优化智能合约的前端交互，确保链上数据与用户界面的无缝连接。</li>
<li>与后端团队协作，基于 GraphQL 或 RESTful API 获取链上和链下数据。</li>
<li>持续优化前端性能，提升用户体验，确保在不同设备和浏览器上的兼容性。</li>
<li>关注 Web3 技术趋势，参与技术评审与分享，不断优化产品架构与代码质量。</li>
</ul>
</li>
<li><p><strong>职位要求：</strong></p>
<ul>
<li>本科及以上学历，计算机科学或相关专业，具备扎实的计算机基础。</li>
<li>精通 HTML、CSS、JavaScript，熟悉 React、Vue 等前端框架，能够独立构建复杂的 UI 界面。</li>
<li>熟悉 Web3.js、Viem、Metamask 等 Web3 技术栈，能够与智能合约进行交互。（现在 Ethers.js / Web3.js 已经不怎么使用了，大家现在基本上都是用的 Viem）</li>
<li>了解常用的区块链网络，如以太坊、Solana 等，具备 Dapp 开发经验者优先。</li>
<li>熟悉 Git 版本管理工具，具备良好的代码编写规范，注重代码可维护性。</li>
<li>良好的沟通能力和团队协作精神，能够在快速发展的环境中高效工作。</li>
<li>具有良好的问题解决能力，能在面对复杂的技术难题时，提出创新的解决方案。</li>
<li>有开源项目或 Web3 相关项目的经验优先。</li>
</ul>
 <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 常用技术栈</span></span><br><span class="line">- HTML5</span><br><span class="line">- CSS3</span><br><span class="line">- JavaScript (ES6+)</span><br><span class="line">- React / Vue</span><br><span class="line">- TypeScript</span><br><span class="line">- Next.js</span><br><span class="line">- Ethers.js / Web3.js / Viem</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h4 id="2-后端工程师"><a href="#2-后端工程师" class="headerlink" title="2. 后端工程师"></a>2. 后端工程师</h4><ol>
<li><p><strong>主要职责：</strong></p>
<ul>
<li>设计、开发和维护去中心化应用（Dapp）的后端服务，包括链上数据交互、智能合约集成和事务处理。</li>
<li>与前端团队合作，确保前后端数据交互的高效性和稳定性，支持多种 Web3 钱包（如 Metamask）的集成。</li>
<li>基于 Node.js、Python 等技术栈构建高性能的 RESTful 或 GraphQL API，以支持 Web3 平台的需求。</li>
<li>与智能合约团队合作，确保智能合约与后端服务的无缝连接，优化链上数据的读取和写入效率。</li>
<li>优化后端性能，确保系统的高可用性、高吞吐量和低延迟，满足高并发访问需求。</li>
<li>定期进行系统架构和代码的评审，不断提升代码质量与技术标准。</li>
<li>参与 Web3 技术的前沿研究，保持对新兴区块链技术的学习和应用，推动公司技术迭代。</li>
</ul>
</li>
<li><p><strong>职位要求：</strong></p>
<ul>
<li>本科及以上学历，计算机科学或相关专业，具备扎实的计算机基础。</li>
<li>精通 Node.js、Go、Python 等后端开发语言，具有构建高并发、分布式系统的经验。</li>
<li>熟悉 Viem、Web3.js、Ethers.js 等 Web3 工具，能够与区块链进行交互并处理链上数据。</li>
<li>具备 RESTful API 或 GraphQL 开发经验，能够设计高效的 API 服务，支持前端与区块链的交互。</li>
<li>熟悉数据库技术，具备 MySQL、PostgreSQL 或 NoSQL 数据库的开发与优化经验。</li>
<li>对智能合约有一定的了解，具备与智能合约交互、读取链上数据等相关经验。</li>
<li>熟悉消息队列（如 RabbitMQ、Kafka）及事件驱动架构，能够处理异步事务。</li>
<li>熟悉容器化技术（如 Docker、Kubernetes），具备 CI/CD 经验者优先。</li>
<li>良好的代码编写规范与文档写作能力，具备良好的团队协作精神和沟通能力。</li>
<li>有 Web3 项目开发经验或开源贡献者优先。</li>
</ul>
 <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 常用技术栈</span></span><br><span class="line">- Node.js / Go / Python</span><br><span class="line">- Viem / Web3.js / Ethers.js</span><br><span class="line">- RESTful API / GraphQL</span><br><span class="line">- MySQL / PostgreSQL</span><br><span class="line">- Docker / Kubernetes</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h4 id="3-智能合约工程师"><a href="#3-智能合约工程师" class="headerlink" title="3. 智能合约工程师"></a>3. 智能合约工程师</h4><ol>
<li><p><strong>主要职责：</strong></p>
<ul>
<li>设计、开发和部署智能合约，确保合约在区块链网络上的安全性、可靠性和高效性。</li>
<li>使用 Solidity 编写智能合约，涵盖各类去中心化应用的需求，如 NFT、DeFi、DAO 等。</li>
<li>与团队合作，定义智能合约的功能需求，并根据需求设计合适的智能合约架构。</li>
<li>部署智能合约至区块链网络（如以太坊、Polygon、Arbitrum、Base 等），并确保合约的高效执行。</li>
<li>编写智能合约的单元测试，进行代码审计与安全性测试，确保合约代码无漏洞，避免潜在的安全风险。</li>
<li>优化智能合约性能，减少 Gas 费用。</li>
<li>研究和应用最新的区块链技术和智能合约最佳实践，推动技术的持续进步。</li>
<li>与前端和后端开发团队紧密协作，确保智能合约与其他系统组件的顺畅集成。</li>
<li>为团队成员提供智能合约相关的技术支持和指导，推动团队的技术提升。</li>
</ul>
</li>
<li><p><strong>职位要求：</strong></p>
<ul>
<li>本科及以上学历，计算机科学或相关专业，具备扎实的计算机基础。</li>
<li>3 年以上智能合约开发经验，熟练使用 Solidity 或类似的智能合约开发语言。</li>
<li>熟悉 Ethereum、Polygon、Arbitrum、Base 等主流区块链平台，能够在这些平台上部署和维护智能合约。</li>
<li>了解智能合约开发的安全性问题，具备智能合约审计和漏洞修复经验，熟悉常见的攻击模式（如重入攻击、溢出、权限管理等）。</li>
<li>熟悉区块链的基本原理，理解 Gas 费用、交易确认、区块链共识机制等概念。</li>
<li>熟练使用 Foundry、Hardhat、Remix 等智能合约开发框架，具备项目开发、测试与部署经验。</li>
<li>具备一定的 Viem、Web3.js、Ethers.js 等 Web3 工具使用经验，能够与前端或其他系统进行无缝集成。</li>
<li>熟悉 IPFS、NFT、Token 标准（ERC-20、ERC-721、ERC-1155 等）及去中心化身份（DID）等 Web3 相关技术。</li>
<li>具有良好的代码编写规范，注重代码的可读性和可维护性。</li>
<li>良好的沟通能力和团队协作精神，能够在快速发展的环境中有效工作。</li>
</ul>
 <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 常用技术栈</span></span><br><span class="line">- Solidity</span><br><span class="line">- Remix</span><br><span class="line">- Foundry / Hardhat</span><br><span class="line">- Phalcon / Tenderly</span><br><span class="line">- Yul</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h3 id="二、非技术岗"><a href="#二、非技术岗" class="headerlink" title="二、非技术岗"></a>二、非技术岗</h3><h4 id="1-产品与运营"><a href="#1-产品与运营" class="headerlink" title="1. 产品与运营"></a>1. 产品与运营</h4><ol>
<li>职位描述：<ul>
<li>在 Web3 产品生命周期中负责协调产品发布、用户反馈收集和持续改进流程，以提升用户体验和产品迭代效率。</li>
<li>执行以用户获取、留存和参与度提升为目标的增长战略，并监控实施效果。</li>
<li>与产品、技术、市场及合规团队紧密合作，确保产品上市（go-to-market）策略与各部门需求保持一致。</li>
<li>持续分析运营数据，跟踪关键绩效指标（KPIs），并根据数据提出优化建议。</li>
</ul>
</li>
<li>职位要求：<ul>
<li>熟悉产品上线（Go-to-market）全流程，擅长跨部门资源协调与项目推进。</li>
<li>具备扎实的数据分析能力，能熟练使用 SQL、Excel 或其他数据工具进行数据统计和洞察提炼。</li>
</ul>
</li>
</ol>
<h4 id="2-社区管理"><a href="#2-社区管理" class="headerlink" title="2. 社区管理"></a>2. 社区管理</h4><ol>
<li><p>职位描述</p>
<ul>
<li>构建并管理 Telegram、Twitter（X）、Discord 等社交平台的社区，实现持续的用户互动与增长；</li>
<li>组织线上 AMA（问答）、活动、竞赛等形式多样的社区互动，以提升用户活跃度和品牌粘性；</li>
<li>跟踪社区健康度指标和情感分析，定期向管理层汇报洞察与优化建议；</li>
<li>与营销团队协作，制定并执行内容日历，发布社区公告和运营手册。</li>
</ul>
</li>
<li><p>职位要求</p>
<ul>
<li>Web3、DAO 或 NFT 社区管理经验，深刻理解去中心化应用生态；</li>
<li>出色的文案撰写与沟通能力，能够有效引导社区讨论并快速响应用户反馈；</li>
<li>熟练使用社区数据分析工具，能够监测并解读用户行为与舆情动态；</li>
<li>具备活动策划与执行能力，能够独立组织线上及线下社区活动。</li>
</ul>
 <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 常用平台</span></span><br><span class="line">- Telegram</span><br><span class="line">- Twitter (X)</span><br><span class="line">- Discord</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h4 id="3-研究分析"><a href="#3-研究分析" class="headerlink" title="3. 研究分析"></a>3. 研究分析</h4><ol>
<li><p>职位描述</p>
<ul>
<li>收集、整理并分析 Web3 行业市场与用户数据，编写可行性研究报告，为产品与运营提供决策支持；</li>
<li>跟踪区块链协议技术演进及生态动态，撰写深度研究报告或白皮书；</li>
<li>进行竞争对手分析，评估市场趋势与用户行为模式，为战略规划提供数据驱动的建议；</li>
<li>支持项目的加密经济模型设计与博弈论分析，以保证项目的经济激励合理性。</li>
</ul>
</li>
<li><p>职位要求</p>
<ul>
<li>熟练使用 Excel、SPSS 或 Python 等数据分析工具，具备定量和定性研究方法经验；</li>
<li>深入了解区块链生态、DeFi 协议及加密经济学原理；</li>
<li>优秀的报告撰写与演示能力，能够清晰传达研究结论与建议；</li>
<li>精通链上数据分析工具（Glassnode、Token Terminal）。</li>
</ul>
 <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 常用工具</span></span><br><span class="line">- Excel</span><br><span class="line">- SPSS</span><br><span class="line">- Python</span><br><span class="line">- Glassnode</span><br><span class="line">- Token Terminal</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h1 id="8月7日"><a href="#8月7日" class="headerlink" title="8月7日"></a>8月7日</h1><table>
<thead>
<tr>
<th>今日学习内容</th>
</tr>
</thead>
<tbody><tr>
<td>MyFirstLayer2  剩余学习</td>
</tr>
<tr>
<td>行业赛道全览</td>
</tr>
</tbody></table>
<h2 id="行业赛道全览"><a href="#行业赛道全览" class="headerlink" title="行业赛道全览"></a>行业赛道全览</h2><h1 id="8月8日"><a href="#8月8日" class="headerlink" title="8月8日"></a>8月8日</h1><table>
<thead>
<tr>
<th>今日学习内容</th>
</tr>
</thead>
<tbody><tr>
<td>安全与合规</td>
</tr>
<tr>
<td>CryptoZombiesx的solidity学习/Solidity: Beginner to Intermediate Smart Contracts/lesson1搭建僵尸工厂</td>
</tr>
</tbody></table>
<h2 id="CryptoZombiesx的solidity学习"><a href="#CryptoZombiesx的solidity学习" class="headerlink" title="CryptoZombiesx的solidity学习"></a>CryptoZombiesx的solidity学习</h2><h3 id="Solidity-Beginner-to-Intermediate-Smart-Contracts"><a href="#Solidity-Beginner-to-Intermediate-Smart-Contracts" class="headerlink" title="Solidity: Beginner to Intermediate Smart Contracts"></a>Solidity: Beginner to Intermediate Smart Contracts</h3><h3 id="lesson1-搭建僵尸工厂"><a href="#lesson1-搭建僵尸工厂" class="headerlink" title="lesson1 搭建僵尸工厂"></a>lesson1 搭建僵尸工厂</h3><h3 id="第2章-合约"><a href="#第2章-合约" class="headerlink" title="第2章: 合约"></a>第2章: 合约</h3><p>从最基本的开始入手:</p>
<p>Solidity 的代码都包裹在<strong>合约</strong>里面. 一份<code>合约</code>就是以太应币应用的基本模块， 所有的变量和函数都属于一份合约, 它是你所有应用的起点.</p>
<p>一份名为 <code>HelloWorld</code> 的空合约如下:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract HelloWorld {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>版本指令</strong></p>
<p>所有的 Solidity 源码都必须冠以 “version pragma” — 标明 Solidity 编译器的版本. 以避免将来新的编译器可能破坏你的代码。</p>
<p>例如: <code>pragma solidity ^0.4.19;</code> (当前 Solidity 的最新版本是 0.4.19).</p>
<p>综上所述， 下面就是一个最基本的合约 — 每次建立一个新的项目时的第一段代码:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract HelloWorld {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实战演习</strong></p>
<p>为了建立我们的僵尸部队， 让我们先建立一个基础合约，称为 <code>ZombieFactory</code>。</p>
<ol>
<li>在右边的输入框里输入 <code>0.4.19</code>，我们的合约基于这个版本的编译器。</li>
<li>建立一个空合约 <code>ZombieFactory</code>。</li>
</ol>
<p>一切完毕，点击下面 “答案” . 如果没效果，点击 “提示”。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第3章-状态变量和整数"><a href="#第3章-状态变量和整数" class="headerlink" title="第3章: 状态变量和整数"></a>第3章: 状态变量和整数</h3><p>真棒！我们已经为我们的合约做了一个外壳， 下面学习 Solidity 中如何使用变量。</p>
<p><strong>状态变量</strong>是被永久地保存在合约中。也就是说它们被写入以太币区块链中. 想象成写入一个数据库。</p>
<p>例子:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">contract Example {</span><br><span class="line">  // 这个无符号整数将会永久的被保存在区块链中</span><br><span class="line">  uint myUnsignedInteger = 100;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在上面的例子中，定义 <code>myUnsignedInteger</code> 为 <code>uint</code> 类型，并赋值100。</p>
<p><strong>无符号整数: <code>uint</code></strong></p>
<p><code>uint</code> 无符号数据类型， 指<strong>其值不能是负数</strong>，对于有符号的整数存在名为 <code>int</code> 的数据类型。</p>
<blockquote>
<p>注: Solidity中， <code>uint</code> 实际上是 <code>uint256</code>代名词， 一个256位的无符号整数。你也可以定义位数少的uints — <code>uint8</code>， <code>uint16</code>， <code>uint32</code>， 等…… 但一般来讲你愿意使用简单的 <code>uint</code>， 除非在某些特殊情况下，这我们后面会讲。</p>
</blockquote>
<p><strong>实战演习</strong></p>
<p>我们的僵尸DNA将由一个十六位数字组成。</p>
<p>定义 <code>dnaDigits</code> 为 <code>uint</code> 数据类型, 并赋值 <code>16</code>。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第4章-数学运算"><a href="#第4章-数学运算" class="headerlink" title="第4章: 数学运算"></a>第4章: 数学运算</h3><p>在 Solidity 中，数学运算很直观明了，与其它程序设计语言相同:</p>
<ul>
<li>加法: <code>x + y</code></li>
<li>减法: <code>x - y</code>,</li>
<li>乘法: <code>x * y</code></li>
<li>除法: <code>x / y</code></li>
<li>取模 / 求余: <code>x % y</code> <em>(例如, <code>13 % 5</code> 余 <code>3</code>, 因为13除以5，余3)</em></li>
</ul>
<p>Solidity 还支持 *<strong>乘方操作*</strong> (如：x 的 y次方） // 例如： 5 ** 2 = 25</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint x = 5 ** 2; // equal to 5^2 = 25</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实战演习</strong></p>
<p>为了保证我们的僵尸的DNA只含有16个字符，我们先造一个<code>uint</code>数据，让它等于10^16。这样一来以后我们可以用模运算符 <code>%</code> 把一个整数变成16位。</p>
<ol>
<li>建立一个<code>uint</code>类型的变量，名字叫<code>dnaModulus</code>, 令其等于 <strong>10 的 <code>dnaDigits</code> 次方</strong>.</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第5章-结构体"><a href="#第5章-结构体" class="headerlink" title="第5章: 结构体"></a>第5章: 结构体</h3><p>有时你需要更复杂的数据类型，Solidity 提供了 <strong>结构体</strong>:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct Person {</span><br><span class="line">  uint age;</span><br><span class="line">  string name;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>结构体允许你生成一个更复杂的数据类型，它有多个属性。</p>
<blockquote>
<p>注：我们刚刚引进了一个新类型, <code>string</code>。 字符串用于保存任意长度的 UTF-8 编码数据。 如： <code>string greeting = "Hello world!"</code>。</p>
</blockquote>
<p><strong>实战演习</strong></p>
<p>在我们的程序中，我们将创建一些僵尸！每个僵尸将拥有多个属性，所以这是一个展示结构体的完美例子。</p>
<ol>
<li>建立一个<code>struct</code> 命名为 <code>Zombie</code>.</li>
<li>我们的 <code>Zombie</code> 结构体有两个属性： <code>name</code> (类型为 <code>string</code>), 和 <code>dna</code> (类型为 <code>uint</code>)。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第6章-数组"><a href="#第6章-数组" class="headerlink" title="第6章: 数组"></a>第6章: 数组</h3><p>如果你想建立一个集合，可以用 <strong>数组</strong>这样的数据类型. Solidity 支持两种数组: <strong>静态</strong>数组和<strong>动态</strong>数组:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 固定长度为2的静态数组:</span><br><span class="line">uint[2] fixedArray;</span><br><span class="line">// 固定长度为5的string类型的静态数组:</span><br><span class="line">string[5] stringArray;</span><br><span class="line">// 动态数组，长度不固定，可以动态添加元素:</span><br><span class="line">uint[] dynamicArray;</span><br></pre></td></tr></tbody></table></figure>

<p>你也可以建立一个 <strong>结构体</strong>类型的数组 例如，上一章提到的 <code>Person</code>:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person[] people; // 这是动态数组，我们可以不断添加元素</span><br></pre></td></tr></tbody></table></figure>

<p>记住：状态变量被永久保存在区块链中。所以在你的合约中创建动态数组来保存成结构的数据是非常有意义的。</p>
<p><strong>公共数组</strong></p>
<p>你可以定义 <code>public</code> 数组, Solidity 会自动创建 <strong>getter</strong> 方法. 语法如下:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person[] public people;</span><br></pre></td></tr></tbody></table></figure>

<p>其它的合约可以从这个数组读取数据（但不能写入数据），所以这在合约中是一个有用的保存公共数据的模式。</p>
<p><strong>实战演习</strong></p>
<p>为了把一个僵尸部队保存在我们的APP里，并且能够让其它APP看到这些僵尸，我们需要一个公共数组。</p>
<ol>
<li>创建一个数据类型为 <code>Zombie</code> 的结构体数组，用 <code>public</code> 修饰，命名为：<code>zombies</code>.</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第7章-定义函数"><a href="#第7章-定义函数" class="headerlink" title="第7章: 定义函数"></a>第7章: 定义函数</h3><p>在 Solidity 中函数定义的句法如下:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function eatHamburgers(string _name, uint _amount) {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这是一个名为 <code>eatHamburgers</code> 的函数，它接受两个参数：一个 <code>string</code>类型的 和 一个 <code>uint</code>类型的。现在函数内部还是空的。</p>
<blockquote>
<p>注：: 习惯上函数里的变量都是以(<code>_</code>)开头 (但不是硬性规定) 以区别全局变量。我们整个教程都会沿用这个习惯。</p>
</blockquote>
<p>我们的函数定义如下:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eatHamburgers("vitalik", 100);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实战演习</strong></p>
<p>在我们的应用里，我们要能创建一些僵尸，让我们写一个函数做这件事吧！</p>
<ol>
<li>建立一个函数 <code>createZombie</code>。 它有两个参数: <strong>_name</strong> (类型为<code>string</code>), 和 <strong>_dna</strong> (类型为<code>uint</code>)。</li>
</ol>
<p>暂时让函数空着——我们在后面会增加内容。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    function createZombie(string _name, uint _dna) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第8章-使用结构体和数组"><a href="#第8章-使用结构体和数组" class="headerlink" title="第8章: 使用结构体和数组"></a>第8章: 使用结构体和数组</h3><p><strong>创建新的结构体</strong></p>
<p>还记得上个例子中的 <code>Person</code> 结构吗？</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Person {</span><br><span class="line">  uint age;</span><br><span class="line">  string name;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Person[] public people;</span><br></pre></td></tr></tbody></table></figure>

<p>现在我们学习创建新的 <code>Person</code> 结构，然后把它加入到名为 <code>people</code> 的数组中.</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个新的Person:</span><br><span class="line">Person satoshi = Person(172, "Satoshi");</span><br><span class="line"></span><br><span class="line">// 将新创建的satoshi添加进people数组:</span><br><span class="line">people.push(satoshi);</span><br></pre></td></tr></tbody></table></figure>

<p>你也可以两步并一步，用一行代码更简洁:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">people.push(Person(16, "Vitalik"));</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注：<code>array.push()</code> 在数组的 <strong>尾部</strong> 加入新元素 ，所以元素在数组中的顺序就是我们添加的顺序， 如:</p>
</blockquote>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uint[] numbers;</span><br><span class="line">numbers.push(5);</span><br><span class="line">numbers.push(10);</span><br><span class="line">numbers.push(15);</span><br><span class="line">// The `numbers` array is now equal to [5, 10, 15]</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实战演习</strong></p>
<p>让我们创建名为createZombie的函数来做点儿什么吧。</p>
<ol>
<li>在函数体里新创建一个 <code>Zombie</code>， 然后把它加入 <code>zombies</code> 数组中。 新创建的僵尸的 <code>name</code> 和 <code>dna</code>，来自于函数的参数。</li>
<li>让我们用一行代码简洁地完成它。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    function createZombie(string _name, uint _dna) {</span><br><span class="line">        zombies.push(Zombie(_name, _dna));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第9章-私有-公共函数"><a href="#第9章-私有-公共函数" class="headerlink" title="第9章: 私有 / 公共函数"></a>第9章: 私有 / 公共函数</h3><p>Solidity 定义的函数的属性默认为<code>公共</code>。 这就意味着任何一方 (或其它合约) 都可以调用你合约里的函数。</p>
<p>显然，不是什么时候都需要这样，而且这样的合约易于受到攻击。 所以将自己的函数定义为<code>私有</code>是一个好的编程习惯，只有当你需要外部世界调用它时才将它设置为<code>公共</code>。</p>
<p>如何定义一个私有的函数呢？</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uint[] numbers;</span><br><span class="line"></span><br><span class="line">function _addToArray(uint _number) private {</span><br><span class="line">  numbers.push(_number);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这意味着只有我们合约中的其它函数才能够调用这个函数，给 <code>numbers</code> 数组添加新成员。</p>
<p>可以看到，在**<u>函数名字后面使用关键字 <code>private</code> 即可</u><strong>。</strong><u>和函数的参数类似，私有函数的名字用(<code>_</code>)起始。</u>**</p>
<p><strong>实战演习</strong></p>
<p>我们合约的函数 <code>createZombie</code> 的默认属性是公共的，这意味着任何一方都可以调用它去创建一个僵尸。 咱们来把它变成私有吧！</p>
<ol>
<li>变 <code>createZombie</code> 为私有函数，不要忘记遵守命名的规矩哦！</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    function _createZombie(string _name, uint _dna) private {</span><br><span class="line">        zombies.push(Zombie(_name, _dna));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第10章-函数的更多属性"><a href="#第10章-函数的更多属性" class="headerlink" title="第10章: 函数的更多属性"></a>第10章: 函数的更多属性</h3><p>本章中我们将学习函数的返回值和修饰符。</p>
<p><strong>返回值</strong></p>
<p>要想函数返回一个数值，按如下定义：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string greeting = "What's up dog";</span><br><span class="line"></span><br><span class="line">function sayHello() public returns (string) {</span><br><span class="line">  return greeting;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Solidity 里，函数的定义里可包含返回值的数据类型(如本例中 <code>string</code>)。</p>
<p><strong>函数的修饰符</strong></p>
<p>上面的函数实际上没有改变 Solidity 里的状态，即，它没有改变任何值或者写任何东西。</p>
<p>这种情况下我们可以把函数定义为 <strong>view</strong>, 意味着它只能读取数据不能更改数据:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function sayHello() public view returns (string) {</span><br></pre></td></tr></tbody></table></figure>

<p>Solidity 还支持 <strong>pure</strong> 函数, 表明这个函数甚至都不访问应用里的数据，例如：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function _multiply(uint a, uint b) private pure returns (uint) {</span><br><span class="line">  return a * b;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><u><strong>这个函数甚至都不读取应用里的状态 — 它的返回值完全取决于它的输入参数，在这种情况下我们把函数定义为 pure.</strong></u></p>
<blockquote>
<p>注：可能很难记住何时把函数标记为 pure/view。 幸运的是， Solidity 编辑器会给出提示，提醒你使用这些修饰符。</p>
</blockquote>
<p><strong>实战演习</strong></p>
<p>我们想建立一个帮助函数，它根据一个字符串随机生成一个DNA数据。</p>
<ol>
<li>创建一个 <code>private</code> 函数，命名为 <code>_generateRandomDna</code>。它只接收一个输入变量 <code>_str</code> (类型 <code>string</code>), 返回一个 <code>uint</code> 类型的数值。</li>
<li>此函数只读取我们合约中的一些变量，所以标记为<code>view</code>。</li>
<li>函数内部暂时留空，以后我们再添加代码。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    function _createZombie(string _name, uint _dna) private {</span><br><span class="line">        zombies.push(Zombie(_name, _dna));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function _generateRandomDna(string _str) private view returns (uint) {</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第11章-Keccak256-和-类型转换"><a href="#第11章-Keccak256-和-类型转换" class="headerlink" title="第11章: Keccak256 和 类型转换"></a>第11章: Keccak256 和 类型转换</h3><p>如何让 <code>_generateRandomDna</code> 函数返回一个全(半) 随机的 <code>uint</code>?</p>
<p>Ethereum 内部有一个散列函数<code>keccak256</code>，它用了SHA3版本。一个散列函数基本上就是把一个字符串转换为一个256位的16进制数字。字符串的一个微小变化会引起散列数据极大变化。</p>
<p>这在 Ethereum 中有很多应用，但是现在我们只是用它造一个伪随机数。</p>
<p>例子:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//6e91ec6b618bb462a4a6ee5aa2cb0e9cf30f7a052bb467b0ba58b8748c00d2e5</span><br><span class="line">keccak256("aaaab");</span><br><span class="line">//b1f078126895a1424524de5321b339ab00408010b7cf0e6ed451514981e58aa9</span><br><span class="line">keccak256("aaaac");</span><br></pre></td></tr></tbody></table></figure>

<p>显而易见，输入字符串只改变了一个字母，输出就已经天壤之别了。</p>
<blockquote>
<p>注: 在区块链中<strong>安全地</strong>产生一个随机数是一个很难的问题， 本例的方法不安全，但是在我们的Zombie DNA算法里不是那么重要，已经很好地满足我们的需要了。</p>
</blockquote>
<p><strong>类型转换</strong></p>
<p>有时你需要变换数据类型。例如:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">uint8 a = 5;</span><br><span class="line">uint b = 6;</span><br><span class="line">// 将会抛出错误，因为 a * b 返回 uint, 而不是 uint8:</span><br><span class="line">uint8 c = a * b;</span><br><span class="line">// 我们需要将 b 转换为 uint8:</span><br><span class="line">uint8 c = a * uint8(b);</span><br></pre></td></tr></tbody></table></figure>

<p>上面, <code>a * b</code> 返回类型是 <code>uint</code>, 但是当我们尝试用 <code>uint8</code> 类型接收时, 就会造成潜在的错误。如果把它的数据类型转换为 <code>uint8</code>, 就可以了，编译器也不会出错。</p>
<p><strong>实战演习</strong></p>
<p>给 <code>_generateRandomDna</code> 函数添加代码! 它应该完成如下功能:</p>
<ol>
<li>第一行代码取 <code>_str</code> 的 <code>keccak256</code> 散列值生成一个伪随机十六进制数，类型转换为 <code>uint</code>, 最后保存在类型为 <code>uint</code> 名为 <code>rand</code> 的变量中。</li>
<li>我们只想让我们的DNA的长度为16位 (还记得 <code>dnaModulus</code>?)。所以第二行代码应该 <code>return</code> 上面计算的数值对 <code>dnaModulus</code> 求余数(<code>%</code>)。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    function _createZombie(string _name, uint _dna) private {</span><br><span class="line">        zombies.push(Zombie(_name, _dna));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function _generateRandomDna(string _str) private view returns (uint) {</span><br><span class="line">        uint rand = uint(keccak256(_str));</span><br><span class="line">        return rand % dnaModulus;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第12章-放在一起"><a href="#第12章-放在一起" class="headerlink" title="第12章: 放在一起"></a>第12章: 放在一起</h3><p>我们就快完成我们的随机僵尸制造器了，来写一个公共的函数把所有的部件连接起来。</p>
<p>写一个公共函数，它有一个参数，用来接收僵尸的名字，之后用它生成僵尸的DNA。</p>
<p><strong>实战演习</strong></p>
<ol>
<li>创建一个 <code>public</code> 函数，命名为 <code>createRandomZombie</code>. 它将被传入一个变量 <code>_name</code> (数据类型是 <code>string</code>)。 *(注: 定义公共函数 <code>public</code> 和定义一个私有 <code>private</code> 函数的做法一样)*。</li>
<li>函数的第一行应该调用 <code>_generateRandomDna</code> 函数，传入 <code>_name</code> 参数, 结果保存在一个类型为 <code>uint</code> 的变量里，命名为 <code>randDna</code>。</li>
<li>第二行调用 <code>_createZombie</code> 函数， 传入参数： <code>_name</code> 和 <code>randDna</code>。</li>
<li>整个函数应该是4行代码 (包括函数的结束符号 <code>}</code> )。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line"></span><br><span class="line">    // 这里建立事件</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    function _createZombie(string _name, uint _dna) private {</span><br><span class="line">        zombies.push(Zombie(_name, _dna));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function _generateRandomDna(string _str) private view returns (uint) {</span><br><span class="line">        uint rand = uint(keccak256(_str));</span><br><span class="line">        return rand % dnaModulus;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function createRandomZombie(string _name) public {</span><br><span class="line">        uint randDna = _generateRandomDna(_name);</span><br><span class="line">        _createZombie(_name, randDna);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第13章-事件"><a href="#第13章-事件" class="headerlink" title="第13章: 事件"></a>第13章: 事件</h3><p>我们的合约几乎就要完成了！让我们加上一个<strong>事件</strong>.</p>
<p><strong>事件</strong> 是合约和区块链通讯的一种机制。你的前端应用“监听”某些事件，并做出反应。</p>
<p>例子:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 这里建立事件</span><br><span class="line">event IntegersAdded(uint x, uint y, uint result);</span><br><span class="line"></span><br><span class="line">function add(uint _x, uint _y) public {</span><br><span class="line">  uint result = _x + _y;</span><br><span class="line">  //触发事件，通知app</span><br><span class="line">  IntegersAdded(_x, _y, result);</span><br><span class="line">  return result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>你的 app 前端可以监听这个事件。JavaScript 实现如下:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YourContract.IntegersAdded(function(error, result) {</span><br><span class="line">  // 干些事</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实战演习</strong></p>
<p>我们想每当一个僵尸创造出来时，我们的前端都能监听到这个事件，并将它显示出来。</p>
<p>1。 定义一个 <code>事件</code> 叫做 <code>NewZombie</code>。 它有3个参数: <code>zombieId</code> (<code>uint</code>)， <code>name</code> (<code>string</code>)， 和 <code>dna</code> (<code>uint</code>)。</p>
<p>2。 修改 <code>_createZombie</code> 函数使得当新僵尸造出来并加入 <code>zombies</code>数组后，生成事件<code>NewZombie</code>。</p>
<p>3。 需要定义僵尸<code>id</code>。 <code>array.push()</code> 返回数组的长度类型是<code>uint</code> - 因为数组的第一个元素的索引是 0， <code>array.push() - 1</code> 将是我们加入的僵尸的索引。 <code>zombies.push() - 1</code> 就是 <code>id</code>，数据类型是 <code>uint</code>。在下一行中你可以把它用到 <code>NewZombie</code> 事件中。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line">	</span><br><span class="line">	// 这里建立事件</span><br><span class="line">    event NewZombie(uint zombieId, string name, uint dna);</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    function _createZombie(string _name, uint _dna) private {</span><br><span class="line">        uint id = zombies.push(Zombie(_name, _dna)) - 1;</span><br><span class="line">        //// 这里触发事件</span><br><span class="line">        NewZombie(id, _name, _dna);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function _generateRandomDna(string _str) private view returns (uint) {</span><br><span class="line">        uint rand = uint(keccak256(_str));</span><br><span class="line">        return rand % dnaModulus;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function createRandomZombie(string _name) public {</span><br><span class="line">        uint randDna = _generateRandomDna(_name);</span><br><span class="line">        _createZombie(_name, randDna);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第14章-Web3-js"><a href="#第14章-Web3-js" class="headerlink" title="第14章: Web3.js"></a>第14章: Web3.js</h3><p>我们的 Solidity 合约完工了！ 现在我们要写一段 JavaScript 前端代码来调用这个合约。</p>
<p>以太坊有一个 JavaScript 库，名为<strong>Web3.js</strong>。</p>
<p>在后面的课程里，我们会进一步地教你如何安装一个合约，如何设置Web3.js。 但是现在我们通过一段代码来了解 Web3.js 是如何和我们发布的合约交互的吧。</p>
<p>如果下面的代码你不能全都理解，不用担心。</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面是调用合约的方式:</span></span><br><span class="line"><span class="keyword">var</span> abi = <span class="comment">/* abi是由编译器生成的 */</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">ZombieFactoryContract</span> = web3.<span class="property">eth</span>.<span class="title function_">contract</span>(abi)</span><br><span class="line"><span class="keyword">var</span> contractAddress = <span class="comment">/* 发布之后在以太坊上生成的合约地址 */</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">ZombieFactory</span> = <span class="title class_">ZombieFactoryContract</span>.<span class="title function_">at</span>(contractAddress)</span><br><span class="line"><span class="comment">// `ZombieFactory` 能访问公共的函数以及事件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 某个监听文本输入的监听器:</span></span><br><span class="line">$(<span class="string">"#ourButton"</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params">e</span>) {</span><br><span class="line">  <span class="keyword">var</span> name = $(<span class="string">"#nameInput"</span>).<span class="title function_">val</span>()</span><br><span class="line">  <span class="comment">//调用合约的 `createRandomZombie` 函数:</span></span><br><span class="line">  <span class="title class_">ZombieFactory</span>.<span class="title function_">createRandomZombie</span>(name)</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听 `NewZombie` 事件, 并且更新UI</span></span><br><span class="line"><span class="keyword">var</span> event = <span class="title class_">ZombieFactory</span>.<span class="title class_">NewZombie</span>(<span class="keyword">function</span>(<span class="params">error, result</span>) {</span><br><span class="line">  <span class="keyword">if</span> (error) <span class="keyword">return</span></span><br><span class="line">  <span class="title function_">generateZombie</span>(result.<span class="property">zombieId</span>, result.<span class="property">name</span>, result.<span class="property">dna</span>)</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 Zombie 的 dna, 更新图像</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">generateZombie</span>(<span class="params">id, name, dna</span>) {</span><br><span class="line">  <span class="keyword">let</span> dnaStr = <span class="title class_">String</span>(dna)</span><br><span class="line">  <span class="comment">// 如果dna少于16位,在它前面用0补上</span></span><br><span class="line">  <span class="keyword">while</span> (dnaStr.<span class="property">length</span> &lt; <span class="number">16</span>)</span><br><span class="line">    dnaStr = <span class="string">"0"</span> + dnaStr</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> zombieDetails = {</span><br><span class="line">    <span class="comment">// 前两位数构成头部.我们可能有7种头部, 所以 % 7</span></span><br><span class="line">    <span class="comment">// 得到的数在0-6,再加上1,数的范围变成1-7</span></span><br><span class="line">    <span class="comment">// 通过这样计算：</span></span><br><span class="line">    <span class="attr">headChoice</span>: dnaStr.<span class="title function_">substring</span>(<span class="number">0</span>, <span class="number">2</span>) % <span class="number">7</span> + <span class="number">1</span>，</span><br><span class="line">    <span class="comment">// 我们得到的图片名称从head1.png 到 head7.png</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来的两位数构成眼睛, 眼睛变化就对11取模:</span></span><br><span class="line">    <span class="attr">eyeChoice</span>: dnaStr.<span class="title function_">substring</span>(<span class="number">2</span>, <span class="number">4</span>) % <span class="number">11</span> + <span class="number">1</span>,</span><br><span class="line">    <span class="comment">// 再接下来的两位数构成衣服，衣服变化就对6取模:</span></span><br><span class="line">    <span class="attr">shirtChoice</span>: dnaStr.<span class="title function_">substring</span>(<span class="number">4</span>, <span class="number">6</span>) % <span class="number">6</span> + <span class="number">1</span>,</span><br><span class="line">    <span class="comment">//最后6位控制颜色. 用css选择器: hue-rotate来更新</span></span><br><span class="line">    <span class="comment">// 360度:</span></span><br><span class="line">    <span class="attr">skinColorChoice</span>: <span class="built_in">parseInt</span>(dnaStr.<span class="title function_">substring</span>(<span class="number">6</span>, <span class="number">8</span>) / <span class="number">100</span> * <span class="number">360</span>),</span><br><span class="line">    <span class="attr">eyeColorChoice</span>: <span class="built_in">parseInt</span>(dnaStr.<span class="title function_">substring</span>(<span class="number">8</span>, <span class="number">10</span>) / <span class="number">100</span> * <span class="number">360</span>),</span><br><span class="line">    <span class="attr">clothesColorChoice</span>: <span class="built_in">parseInt</span>(dnaStr.<span class="title function_">substring</span>(<span class="number">10</span>, <span class="number">12</span>) / <span class="number">100</span> * <span class="number">360</span>),</span><br><span class="line">    <span class="attr">zombieName</span>: name,</span><br><span class="line">    <span class="attr">zombieDescription</span>: <span class="string">"A Level 1 CryptoZombie"</span>,</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> zombieDetails</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们的 JavaScript 所做的就是获取由<code>zombieDetails</code> 产生的数据, 并且利用浏览器里的 JavaScript 神奇功能 (我们用 Vue.js)，置换出图像以及使用CSS过滤器。在后面的课程中，你可以看到全部的代码。</p>
<h1 id="8月9日"><a href="#8月9日" class="headerlink" title="8月9日"></a>8月9日</h1><table>
<thead>
<tr>
<th>今日学习内容</th>
</tr>
</thead>
<tbody><tr>
<td>安全与合规</td>
</tr>
<tr>
<td>Chainlink预言机的solidity课程</td>
</tr>
</tbody></table>
<h2 id="Chainlink预言机的solidity课程"><a href="#Chainlink预言机的solidity课程" class="headerlink" title="Chainlink预言机的solidity课程"></a>Chainlink预言机的solidity课程</h2><h3 id="solidity数据类型、函数、存储模式、数据结构"><a href="#solidity数据类型、函数、存储模式、数据结构" class="headerlink" title="solidity数据类型、函数、存储模式、数据结构"></a>solidity数据类型、函数、存储模式、数据结构</h3><p>今天主要看了B站Chainlink预言机的solidity课程，然后跟着使用remix工具，进行简单的合约编写以及部署，学习到的包括数据结构、函数等内容，在昨天的CryptoZombiesx的课程中也都学过一遍，所以也就算是复习一遍了。</p>
<p>还有就是你觉得这个课程讲的真的很好，不仅讲解了密码学中包括公私钥加密原理，甚至还讲解了助记词产生过程以及助记词生成私钥的过程。强烈推荐！！</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.30;</span><br><span class="line"></span><br><span class="line">contract HelloWorld{</span><br><span class="line">    string strVar = "HelloWorld";</span><br><span class="line">    struct Info {</span><br><span class="line">        string phrase;</span><br><span class="line">        uint256 id;</span><br><span class="line">        address addr; </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Info[] infos;		//结构体数组</span><br><span class="line"></span><br><span class="line">    mapping(uint256 id =&gt; Info info) infoMapping;</span><br><span class="line"></span><br><span class="line">    function seyHello(uint256 _id) public view returns(string memory){</span><br><span class="line">    	//通过判断是否存在地址，从而判断是否写入成功</span><br><span class="line">    	//Mapping方式</span><br><span class="line">        if(infoMapping[_id].addr == address(0x0)){</span><br><span class="line">            return addinfo(strVar);</span><br><span class="line">        }</span><br><span class="line">        else {</span><br><span class="line">            return addinfo(infoMapping[_id].phrase);</span><br><span class="line">        }</span><br><span class="line">		//for遍历方式，在infos数组很大时，遍历查询的消耗大，所以建议使用mapping键值对查询</span><br><span class="line">        // for(uint256 i=0; i &lt; infos.length; i++ ){</span><br><span class="line">        //     if(infos[i].id == _id){</span><br><span class="line">        //         return addinfo(infos[i].phrase);</span><br><span class="line">        //     }</span><br><span class="line">        // }</span><br><span class="line">        // return addinfo(strVar);</span><br><span class="line">    }</span><br><span class="line">    function setHelloWorld(string memory newString, uint256 _id) public {</span><br><span class="line">        Info memory info = Info(newString, _id, msg.sender);</span><br><span class="line">        infoMapping[_id] = info; </span><br><span class="line">    } </span><br><span class="line">    function addinfo(string memory helloWorldStr) internal pure returns(string memory){</span><br><span class="line">        return string.concat(helloWorldStr," from xxx's contract.");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>SPDX-License-Identifier：明确声明其使用的开源许可证。它通常以注释的形式出现在文件头部，帮助开发者、法律团队和自动化工具快速识别代码的许可条款</p>
<p>view：函数中只有读取操作，没有修改操作</p>
<p>pure：函数中种只需要进行运算，不需要读取任何变量</p>
<p>四个可见度标识符：</p>
<img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-09%20200259.png" style="zoom:67%;">

<p><strong>存储模式</strong>：</p>
<p>永久性存储：storage</p>
<p>暂时性存储（交易结束后值就消失了）：memory、calldata</p>
<p>1、storage：永久存在合约内，合约中声明的默认是该类型，但不需要显示写出该关键词</p>
<p>2、memory：变量在运行时可以更改</p>
<p>3、calldata：变量在运行时不能更改，例如函数传参，用calldata传参数，函数中该值是不能改变的</p>
<p>4、stack</p>
<p>5、codes</p>
<p>6、logs</p>
<p><strong>数据结构</strong>：</p>
<p>1、struct：结构体</p>
<p>2、array：数组</p>
<p>3、mapping：映射（键值对表示）</p>
<h3 id="solidity的工厂模式"><a href="#solidity的工厂模式" class="headerlink" title="solidity的工厂模式"></a>solidity的工厂模式</h3><h4 id="工厂模式介绍"><a href="#工厂模式介绍" class="headerlink" title="工厂模式介绍"></a>工厂模式介绍</h4><p>在 Solidity 中，<strong>工厂模式（Factory Pattern）</strong> 是一种常用的智能合约设计模式，用于 <strong>动态创建和管理其他合约的实例</strong>。工厂合约（Factory Contract）负责部署子合约（Child Contracts），通常用于以下场景：</p>
<ul>
<li>批量创建相同逻辑的合约（如代币、NFT、多签钱包等）。</li>
<li>降低重复部署的成本（通过复用逻辑合约）。</li>
<li>统一管理子合约地址。</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">contract Factory {</span><br><span class="line">      Child[] children;</span><br><span class="line">      function createChild(uint data){</span><br><span class="line">         Child child = new Child(data);</span><br><span class="line">         children.push(child);</span><br><span class="line">      }</span><br><span class="line">}</span><br><span class="line">contract Child{</span><br><span class="line">     uint data;</span><br><span class="line">     constructor(uint _data){</span><br><span class="line">        data = _data;</span><br><span class="line">     }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h4 id="引入合约方式"><a href="#引入合约方式" class="headerlink" title="引入合约方式"></a>引入合约方式</h4><p>直接引入同一个文件系统下的合约</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import { HelloWorld } from "./test.sol";</span><br></pre></td></tr></tbody></table></figure>

<p>也可以直接引入网上的URL以及可以精准写入sol文件中具体的合约名称</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import { HelloWorld } from "https://11111/test.sol";</span><br></pre></td></tr></tbody></table></figure>

<p>在实际应用中，涉及到公司的内容，会有更专业的引入方式，通过引入包的方式</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import { HelloWorld } from "@companyName/product/contract";</span><br></pre></td></tr></tbody></table></figure>





<h1 id="8月10日"><a href="#8月10日" class="headerlink" title="8月10日"></a>8月10日</h1><table>
<thead>
<tr>
<th>今日学习内容</th>
</tr>
</thead>
<tbody><tr>
<td>CryptoZombiesx的solidity学习/Solidity: Beginner to Intermediate Smart Contracts/lesson2 僵尸攻击人类</td>
</tr>
</tbody></table>
<h2 id="CryptoZombiesx的solidity学习-1"><a href="#CryptoZombiesx的solidity学习-1" class="headerlink" title="CryptoZombiesx的solidity学习"></a>CryptoZombiesx的solidity学习</h2><h3 id="Solidity-Beginner-to-Intermediate-Smart-Contracts-1"><a href="#Solidity-Beginner-to-Intermediate-Smart-Contracts-1" class="headerlink" title="Solidity: Beginner to Intermediate Smart Contracts"></a>Solidity: Beginner to Intermediate Smart Contracts</h3><h3 id="lesson2-僵尸攻击人类"><a href="#lesson2-僵尸攻击人类" class="headerlink" title="lesson2 僵尸攻击人类"></a>lesson2 僵尸攻击人类</h3><h3 id="第2章-映射（Mapping）和地址（Address）"><a href="#第2章-映射（Mapping）和地址（Address）" class="headerlink" title="第2章: 映射（Mapping）和地址（Address）"></a>第2章: 映射（Mapping）和地址（Address）</h3><p>我们通过给数据库中的僵尸指定“主人”， 来支持“多玩家”模式。</p>
<p>如此一来，我们需要引入2个新的数据类型：<code>mapping</code>（映射） 和 <code>address</code>（地址）。</p>
<p><strong>Addresses （地址）</strong></p>
<p>以太坊区块链由 <strong>_ account _</strong> (账户)组成，你可以把它想象成银行账户。一个帐户的余额是 <strong><em>以太</em></strong> （在以太坊区块链上使用的币种），你可以和其他帐户之间支付和接受以太币，就像你的银行帐户可以电汇资金到其他银行帐户一样。</p>
<p>每个帐户都有一个“地址”，你可以把它想象成银行账号。这是账户唯一的标识符，它看起来长这样：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0cE446255506E92DF41614C46F1d6df9Cc969183</span><br></pre></td></tr></tbody></table></figure>

<p>（这是 CryptoZombies 团队的地址，如果你喜欢 CryptoZombies 的话，请打赏我们一些以太币！😉）</p>
<p>我们将在后面的课程中介绍地址的细节，现在你只需要了解<strong>地址属于特定用户（或智能合约）的</strong>。</p>
<p>所以我们可以指定“地址”作为僵尸主人的 ID。当用户通过与我们的应用程序交互来创建新的僵尸时，新僵尸的所有权被设置到调用者的以太坊地址下。</p>
<p><strong>Mapping（映射）</strong></p>
<p>在第1课中，我们看到了 <strong>结构体</strong> 和 <strong>数组</strong> 。 <strong>映射</strong> 是另一种在 Solidity 中存储有组织数据的方法。</p>
<p>映射是这样定义的：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//对于金融应用程序，将用户的余额保存在一个 uint类型的变量中：</span><br><span class="line">mapping (address =&gt; uint) public accountBalance;</span><br><span class="line">//或者可以用来通过userId 存储/查找的用户名</span><br><span class="line">mapping (uint =&gt; string) userIdToName;</span><br></pre></td></tr></tbody></table></figure>

<p>映射本质上是存储和查找数据所用的<strong>键-值对</strong>。在第一个例子中，键是一个 <code>address</code>，值是一个 <code>uint</code>，在第二个例子中，键是一个<code>uint</code>，值是一个 <code>string</code>。</p>
<p><strong>实战演习</strong></p>
<p>为了存储僵尸的所有权，我们会使用到两个映射：一个记录僵尸拥有者的地址，另一个记录某地址所拥有僵尸的数量。</p>
<p>1.创建一个叫做 <code>zombieToOwner</code> 的映射。其键是一个<code>uint</code>（我们将根据它的 id 存储和查找僵尸），值为 <code>address</code>。映射属性为<code>public</code>。</p>
<p>2.创建一个名为 <code>ownerZombieCount</code> 的映射，其中键是 <code>address</code>，值是 <code>uint</code>。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 在这里定义映射</span><br><span class="line">mapping (uint =&gt; address ) public zombieToOwner;</span><br><span class="line">mapping ( address =&gt; uint) ownerZombieCount;</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第3章-Msg-sender"><a href="#第3章-Msg-sender" class="headerlink" title="第3章: Msg.sender"></a>第3章: Msg.sender</h3><p>现在有了一套映射来记录僵尸的所有权了，我们可以修改 <code>_createZombie</code> 方法来运用它们。</p>
<p>为了做到这一点，我们要用到 <code>msg.sender</code>。</p>
<p><strong>msg.sender</strong></p>
<p>在 Solidity 中，有一些全局变量可以被所有函数调用。 其中一个就是 <code>msg.sender</code>，它指的是当前调用者（或智能合约）的 <code>address</code>。</p>
<blockquote>
<p>注意：在 Solidity 中，功能执行始终需要从外部调用者开始。 一个合约只会在区块链上什么也不做，除非有人调用其中的函数。所以 <code>msg.sender</code>总是存在的。</p>
</blockquote>
<p>以下是使用 <code>msg.sender</code> 来更新 <code>mapping</code> 的例子：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mapping (address =&gt; uint) favoriteNumber;</span><br><span class="line"></span><br><span class="line">function setMyNumber(uint _myNumber) public {</span><br><span class="line">  // 更新我们的 `favoriteNumber` 映射来将 `_myNumber`存储在 `msg.sender`名下</span><br><span class="line">  favoriteNumber[msg.sender] = _myNumber;</span><br><span class="line">  // 存储数据至映射的方法和将数据存储在数组相似</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function whatIsMyNumber() public view returns (uint) {</span><br><span class="line">  // 拿到存储在调用者地址名下的值</span><br><span class="line">  // 若调用者还没调用 setMyNumber， 则值为 `0`</span><br><span class="line">  return favoriteNumber[msg.sender];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在这个小小的例子中，任何人都可以调用 <code>setMyNumber</code> 在我们的合约中存下一个 <code>uint</code> 并且与他们的地址相绑定。 然后，他们调用 <code>whatIsMyNumber</code> 就会返回他们存储的 <code>uint</code>。</p>
<p>使用 <code>msg.sender</code> 很安全，因为它具有以太坊区块链的安全保障 —— 除非窃取与以太坊地址相关联的私钥，否则是没有办法修改其他人的数据的。</p>
<p><strong>实战演习</strong></p>
<p>我们来修改第1课的 <code>_createZombie</code> 方法，将僵尸分配给函数调用者吧。</p>
<ol>
<li>首先，在得到新的僵尸 <code>id</code> 后，更新 <code>zombieToOwner</code> 映射，在 <code>id</code> 下面存入 <code>msg.sender</code>。</li>
<li>然后，我们为这个 <code>msg.sender</code> 名下的 <code>ownerZombieCount</code> 加 1。</li>
</ol>
<p>跟在 JavaScript 中一样， 在 Solidity 中你也可以用 <code>++</code> 使 <code>uint</code> 递增。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uint number = 0;</span><br><span class="line">number++;</span><br><span class="line">// `number` 现在是 `1`了</span><br></pre></td></tr></tbody></table></figure>

<p>修改两行代码即可。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function _createZombie(string _name, uint _dna) private {</span><br><span class="line">        uint id = zombies.push(Zombie(_name, _dna)) - 1;</span><br><span class="line">        // 从这里开始</span><br><span class="line">        zombieToOwner[id] = msg.sender;</span><br><span class="line">        ownerZombieCount[msg.sender]++;</span><br><span class="line">        NewZombie(id, _name, _dna);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第4章-Require"><a href="#第4章-Require" class="headerlink" title="第4章: Require"></a>第4章: Require</h3><p>在第一课中，我们成功让用户通过调用 <code>createRandomZombie</code>函数 并输入一个名字来创建新的僵尸。 但是，如果用户能持续调用这个函数来创建出无限多个僵尸加入他们的军团，这游戏就太没意思了！</p>
<p>于是，我们作出限定：每个玩家只能调用一次这个函数。 这样一来，新玩家可以在刚开始玩游戏时通过调用它，为其军团创建初始僵尸。</p>
<p>我们怎样才能限定每个玩家只调用一次这个函数呢？</p>
<p>答案是使用<code>require</code>。 <code>require</code>使得函数在执行过程中，当不满足某些条件时抛出错误，并停止执行：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function sayHiToVitalik(string _name) public returns (string) {</span><br><span class="line">  // 比较 _name 是否等于 "Vitalik". 如果不成立，抛出异常并终止程序</span><br><span class="line">  // (敲黑板: Solidity 并不支持原生的字符串比较, 我们只能通过比较</span><br><span class="line">  // 两字符串的 keccak256 哈希值来进行判断)</span><br><span class="line">  require(keccak256(_name) == keccak256("Vitalik"));</span><br><span class="line">  // 如果返回 true, 运行如下语句</span><br><span class="line">  return "Hi!";</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果你这样调用函数 <code>sayHiToVitalik（“Vitalik”）</code> ,它会返回“Hi！”。而如果调用的时候使用了其他参数，它则会抛出错误并停止执行。</p>
<p>因此，在调用一个函数之前，用 <code>require</code> 验证前置条件是非常有必要的。</p>
<p><strong>实战演习</strong></p>
<p>在我们的僵尸游戏中，我们不希望用户通过反复调用 <code>createRandomZombie</code> 来給他们的军队创建无限多个僵尸 —— 这将使得游戏非常无聊。</p>
<p>我们使用了 <code>require</code> 来确保这个函数只有在每个用户第一次调用它的时候执行，用以创建初始僵尸。</p>
<ol>
<li>在 <code>createRandomZombie</code> 的前面放置 <code>require</code> 语句。 使得函数先检查 <code>ownerZombieCount [msg.sender]</code> 的值为 <code>0</code> ，不然就抛出一个错误。</li>
</ol>
<blockquote>
<p>注意：在 Solidity 中，关键词放置的顺序并不重要</p>
<ul>
<li>虽然参数的两个位置是等效的。 但是，由于我们的答案检查器比较呆板，它只能认定其中一个为正确答案</li>
<li>于是在这里，我们就约定把<code>ownerZombieCount [msg.sender]</code>放前面吧</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function createRandomZombie(string _name) public {</span><br><span class="line">        // start here</span><br><span class="line">        require(ownerZombieCount[msg.sender] == 0);</span><br><span class="line">        uint randDna = _generateRandomDna(_name);</span><br><span class="line">        _createZombie(_name, randDna);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第5章-继承（Inheritance）"><a href="#第5章-继承（Inheritance）" class="headerlink" title="第5章: 继承（Inheritance）"></a>第5章: 继承（Inheritance）</h3><p>我们的游戏代码越来越长。 当代码过于冗长的时候，最好将代码和逻辑分拆到多个不同的合约中，以便于管理。</p>
<p>有个让 Solidity 的代码易于管理的功能，就是合约 *<strong>inheritance*</strong> (继承)：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract Doge {</span><br><span class="line">  function catchphrase() public returns (string) {</span><br><span class="line">    return "So Wow CryptoDoge";</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">contract BabyDoge is Doge {</span><br><span class="line">  function anotherCatchphrase() public returns (string) {</span><br><span class="line">    return "Such Moon BabyDoge";</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>由于 <code>BabyDoge</code> 是从 <code>Doge</code> 那里 *<strong>inherits*</strong> （继承)过来的。 这意味着当你编译和部署了 <code>BabyDoge</code>，它将可以访问 <code>catchphrase()</code> 和 <code>anotherCatchphrase()</code>和其他我们在 <code>Doge</code> 中定义的其他公共函数。</p>
<p>这可以用于逻辑继承（比如表达子类的时候，<code>Cat</code> 是一种 <code>Animal</code>）。 但也可以简单地将类似的逻辑组合到不同的合约中以组织代码。</p>
<p><strong>实战演习</strong></p>
<p>在接下来的章节中，我们将要为僵尸实现各种功能，让它可以“猎食”和“繁殖”。 通过将这些运算放到父类 <code>ZombieFactory</code> 中，使得所有 <code>ZombieFactory</code> 的继承者合约都可以使用这些方法。</p>
<ol>
<li>在 <code>ZombieFactory</code> 下创建一个叫 <code>ZombieFeeding</code> 的合约，它是继承自 `ZombieFactory 合约的。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Start here</span><br><span class="line">contract ZombieFeeding is ZombieFactory {</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第6章-引入（Import）"><a href="#第6章-引入（Import）" class="headerlink" title="第6章: 引入（Import）"></a>第6章: 引入（Import）</h3><p>哇！你有没有注意到，我们只是清理了下右边的代码，现在你的编辑器的顶部就多了个选项卡。 尝试点击它的标签，看看会发生什么吧！</p>
<p>代码已经够长了，我们把它分成多个文件以便于管理。 通常情况下，当 Solidity 项目中的代码太长的时候我们就是这么做的。</p>
<p>在 Solidity 中，当你有多个文件并且想把一个文件导入另一个文件时，可以使用 <code>import</code> 语句：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import "./someothercontract.sol";</span><br><span class="line"></span><br><span class="line">contract newContract is SomeOtherContract {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这样当我们在合约（contract）目录下有一个名为 <code>someothercontract.sol</code> 的文件（ <code>./</code> 就是同一目录的意思），它就会被编译器导入。</p>
<p><strong>实战演习</strong></p>
<p>现在我们已经建立了一个多文件架构，并用 <code>import</code> 来读取来自另一个文件中合约的内容：</p>
<p>1.将 <code>zombiefactory.sol</code> 导入到我们的新文件 <code>zombiefeeding.sol</code> 中。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// put import statement here</span><br><span class="line">import "./zombiefactory.sol";</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第7章-Storage与Memory"><a href="#第7章-Storage与Memory" class="headerlink" title="第7章: Storage与Memory"></a>第7章: Storage与Memory</h3><p>在 Solidity 中，有两个地方可以存储变量 —— <code>storage</code> 或 <code>memory</code>。</p>
<p><strong>Storage</strong> 变量是指**<u>永久存储</u><strong>在区块链中的变量。 <strong>Memory</strong> 变量则是</strong><u>临时的</u>**，当外部函数对某合约调用完成时，内存型变量即被移除。 你可以把它想象成存储在你电脑的硬盘或是RAM中数据的关系。</p>
<p>大多数时候你都用不到这些关键字，默认情况下 Solidity 会自动处理它们。 状态变量（在函数之外声明的变量）默认为“存储”形式，并永久写入区块链；而在函数内部声明的变量是“内存”型的，它们函数调用结束后消失。</p>
<p>然而也有一些情况下，你需要手动声明存储类型，主要用于处理函数内的 <strong>结构体</strong> 和 <strong>数组</strong> 时：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">contract SandwichFactory {</span><br><span class="line">  struct Sandwich {</span><br><span class="line">    string name;</span><br><span class="line">    string status;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  Sandwich[] sandwiches;</span><br><span class="line"></span><br><span class="line">  function eatSandwich(uint _index) public {</span><br><span class="line">    // Sandwich mySandwich = sandwiches[_index];</span><br><span class="line"></span><br><span class="line">    // ^ 看上去很直接，不过 Solidity 将会给出警告</span><br><span class="line">    // 告诉你应该明确在这里定义 `storage` 或者 `memory`。</span><br><span class="line"></span><br><span class="line">    // 所以你应该明确定义 `storage`:</span><br><span class="line">    Sandwich storage mySandwich = sandwiches[_index];</span><br><span class="line">    // ...这样 `mySandwich` 是指向 `sandwiches[_index]`的指针</span><br><span class="line">    // 在存储里，另外...</span><br><span class="line">    mySandwich.status = "Eaten!";</span><br><span class="line">    // ...这将永久把 `sandwiches[_index]` 变为区块链上的存储</span><br><span class="line"></span><br><span class="line">    // 如果你只想要一个副本，可以使用`memory`:</span><br><span class="line">    Sandwich memory anotherSandwich = sandwiches[_index + 1];</span><br><span class="line">    // ...这样 `anotherSandwich` 就仅仅是一个内存里的副本了</span><br><span class="line">    // 另外</span><br><span class="line">    anotherSandwich.status = "Eaten!";</span><br><span class="line">    // ...将仅仅修改临时变量，对 `sandwiches[_index + 1]` 没有任何影响</span><br><span class="line">    // 不过你可以这样做:</span><br><span class="line">    sandwiches[_index + 1] = anotherSandwich;</span><br><span class="line">    // ...如果你想把副本的改动保存回区块链存储</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果你还没有完全理解究竟应该使用哪一个，也不用担心 —— 在本教程中，我们将告诉你何时使用 <code>storage</code> 或是 <code>memory</code>，并且当你不得不使用到这些关键字的时候，Solidity 编译器也发警示提醒你的。</p>
<p>现在，只要知道在某些场合下也需要你显式地声明 <code>storage</code> 或 <code>memory</code>就够了！</p>
<p><strong>实战演习</strong></p>
<p>是时候给我们的僵尸增加“猎食”和“繁殖”功能了！</p>
<p>当一个僵尸猎食其他生物体时，它自身的DNA将与猎物生物的DNA结合在一起，形成一个新的僵尸DNA。</p>
<ol>
<li>创建一个名为 <code>feedAndMultiply</code> 的函数。 使用两个参数：<code>_zombieId</code>（ <code>uint</code>类型 ）和<code>_targetDna</code> （也是 <code>uint</code> 类型）。 设置属性为 <code>public</code> 的。</li>
<li>我们不希望别人用我们的僵尸去捕猎。 首先，我们确保对自己僵尸的所有权。 通过添加一个<code>require</code> 语句来确保 <code>msg.sender</code> 只能是这个僵尸的主人（类似于我们在 <code>createRandomZombie</code> 函数中做过的那样）。</li>
</ol>
<blockquote>
<p>注意：同样，因为我们的答案检查器比较呆萌，只认识把 <code>msg.sender</code> 放在前面的答案，如果你切换了参数的顺序，它就不认得了。 但你正常编码时，如何安排参数顺序都是正确的。</p>
</blockquote>
<ol>
<li>为了获取这个僵尸的DNA，我们的函数需要声明一个名为 <code>myZombie</code> 数据类型为<code>Zombie</code>的本地变量（这是一个 <code>storage</code> 型的指针）。 将其值设定为在 <code>zombies</code> 数组中索引为<code>_zombieId</code>所指向的值。</li>
</ol>
<p>到目前为止，包括函数结束符 <code>}</code> 的那一行， 总共4行代码。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Start here</span><br><span class="line">    function feedAndMultiply(uint _zombieId, uint _targetDna) public{</span><br><span class="line">        require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">        Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第8章-僵尸的DNA"><a href="#第8章-僵尸的DNA" class="headerlink" title="第8章: 僵尸的DNA"></a>第8章: 僵尸的DNA</h3><p>我们来把 <code>feedAndMultiply</code> 函数写完吧。</p>
<p>获取新的僵尸DNA的公式很简单：计算猎食僵尸DNA和被猎僵尸DNA之间的平均值。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function testDnaSplicing() public {</span><br><span class="line">  uint zombieDna = 2222222222222222;</span><br><span class="line">  uint targetDna = 4444444444444444;</span><br><span class="line">  uint newZombieDna = (zombieDna + targetDna) / 2;</span><br><span class="line">  // newZombieDna 将等于 3333333333333333</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以后，我们也可以让函数变得更复杂些，比方给新的僵尸的 DNA 增加一些随机性之类的。但现在先从最简单的开始 —— 以后还可以回来完善它嘛。</p>
<p><strong>实战演习</strong></p>
<ol>
<li>首先我们确保 <code>_targetDna</code> 不长于16位。要做到这一点，我们可以设置 <code>_targetDna</code> 为 <code>_targetDna ％ dnaModulus</code> ，并且只取其最后16位数字。</li>
<li>接下来为我们的函数声明一个名叫 <code>newDna</code> 的 <code>uint</code>类型的变量，并将其值设置为 <code>myZombie</code>的 DNA 和 <code>_targetDna</code> 的平均值（如上例所示）。</li>
</ol>
<blockquote>
<p>注意：您可以用 <code>myZombie.name</code> 或 <code>myZombie.dna</code> 访问 <code>myZombie</code> 的属性。</p>
</blockquote>
<ol>
<li>一旦我们计算出新的DNA，再调用 <code>_createZombie</code> 就可以生成新的僵尸了。如果你忘了调用这个函数所需要的参数，可以查看 <code>zombiefactory.sol</code> 选项卡。请注意，需要先给它命名，所以现在我们把新的僵尸的名字设为<code>NoName</code> - 我们回头可以编写一个函数来更改僵尸的名字。</li>
</ol>
<blockquote>
<p>注意：对于 Solidity 高手，你可能会注意到我们的代码存在一个问题。别担心，下一章会解决这个问题的 ;）</p>
</blockquote>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function feedAndMultiply(uint _zombieId, uint _targetDna) public {</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    // start here</span><br><span class="line">    _targetDna = _targetDna % dnaModulus;</span><br><span class="line">    uint newDna = (myZombie.dna + _targetDna) / 2;</span><br><span class="line">    _createZombie("NoName", newDna);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第9章-更多关于函数可见性"><a href="#第9章-更多关于函数可见性" class="headerlink" title="第9章: 更多关于函数可见性"></a>第9章: 更多关于函数可见性</h3><p><strong>我们上一课的代码有问题！</strong></p>
<p>编译的时候编译器就会报错。</p>
<p>错误在于，我们尝试从 <code>ZombieFeeding</code> 中调用 <code>_createZombie</code> 函数，但 <code>_createZombie</code> 却是 <code>ZombieFactory</code> 的 <code>private</code> （私有）函数。这意味着任何继承自 <code>ZombieFactory</code> 的子合约都不能访问它。</p>
<p><strong>internal 和 external</strong></p>
<p>除 <code>public</code> 和 <code>private</code> 属性之外，Solidity 还使用了另外两个描述函数可见性的修饰词：<code>internal</code>（内部） 和 <code>external</code>（外部）。</p>
<p><code>internal</code> 和 <code>private</code> 类似，不过， 如果某个合约继承自其父合约，这个合约即可以访问父合约中定义的“内部”函数。（嘿，这听起来正是我们想要的那样！）。</p>
<p><code>external</code> 与<code>public</code> 类似，只不过这些函数只能在合约之外调用 - 它们不能被合约内的其他函数调用。稍后我们将讨论什么时候使用 <code>external</code> 和 <code>public</code>。</p>
<p>声明函数 <code>internal</code> 或 <code>external</code> 类型的语法，与声明 <code>private</code> 和 <code>public</code>类 型相同：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">contract Sandwich {</span><br><span class="line">  uint private sandwichesEaten = 0;</span><br><span class="line"></span><br><span class="line">  function eat() internal {</span><br><span class="line">    sandwichesEaten++;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">contract BLT is Sandwich {</span><br><span class="line">  uint private baconSandwichesEaten = 0;</span><br><span class="line"></span><br><span class="line">  function eatWithBacon() public returns (string) {</span><br><span class="line">    baconSandwichesEaten++;</span><br><span class="line">    // 因为eat() 是internal 的，所以我们能在这里调用</span><br><span class="line">    eat();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实战演习</strong></p>
<ol>
<li><p>将 <code>_createZombie()</code> 函数的属性从 <code>private</code> 改为 <code>internal</code> ， 使得其他的合约也能访问到它。</p>
<p> 我们已经成功把你的注意力集中在到<code>zombiefactory.sol</code>这个选项卡上啦。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 在这里修改函数的功能</span><br><span class="line">    function _createZombie(string _name, uint _dna) internal {</span><br><span class="line">        uint id = zombies.push(Zombie(_name, _dna)) - 1;</span><br><span class="line">        zombieToOwner[id] = msg.sender;</span><br><span class="line">        ownerZombieCount[msg.sender]++;</span><br><span class="line">        NewZombie(id, _name, _dna);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第10章-僵尸吃什么"><a href="#第10章-僵尸吃什么" class="headerlink" title="第10章: 僵尸吃什么?"></a>第10章: 僵尸吃什么?</h3><p>是时候让我们的僵尸去捕猎！ 那僵尸最喜欢的食物是什么呢？</p>
<p>Crypto 僵尸喜欢吃的是…</p>
<p><strong>CryptoKitties！</strong> 😱😱😱</p>
<p>（正经点，我可不是开玩笑😆）</p>
<p>为了做到这一点，我们要读出 CryptoKitties 智能合约中的 kittyDna。这些数据是公开存储在区块链上的。区块链是不是很酷？</p>
<p>别担心 —— 我们的游戏并不会伤害到任何真正的CryptoKitty。 我们只 <em>读取</em> CryptoKitties 数据，但却无法在物理上删除它。</p>
<p><strong>与其他合约的交互</strong></p>
<p>如果我们的合约需要和区块链上的其他的合约会话，则需先定义一个 <strong>interface</strong> (接口)。</p>
<p>先举一个简单的栗子。 假设在区块链上有这么一个合约：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract LuckyNumber {</span><br><span class="line">  mapping(address =&gt; uint) numbers;</span><br><span class="line"></span><br><span class="line">  function setNum(uint _num) public {</span><br><span class="line">    numbers[msg.sender] = _num;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  function getNum(address _myAddress) public view returns (uint) {</span><br><span class="line">    return numbers[_myAddress];</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这是个很简单的合约，您可以用它存储自己的幸运号码，并将其与您的以太坊地址关联。 这样其他人就可以通过您的地址查找您的幸运号码了。</p>
<p>现在假设我们有一个外部合约，使用 <code>getNum</code> 函数可读取其中的数据。</p>
<p>首先，我们定义 <code>LuckyNumber</code> 合约的 <strong>interface</strong> ：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract NumberInterface {</span><br><span class="line">  function getNum(address _myAddress) public view returns (uint);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>请注意，这个过程虽然看起来像在定义一个合约，但其实内里不同：</p>
<p>首先，我们只声明了要与之交互的函数 —— 在本例中为 <code>getNum</code> —— 在其中我们没有使用到任何其他的函数或状态变量。</p>
<p>其次，我们并没有使用大括号（<code>{</code> 和 <code>}</code>）定义函数体，我们单单用分号（<code>;</code>）结束了函数声明。这使它看起来像一个合约框架。</p>
<p>编译器就是靠这些特征认出它是一个接口的。</p>
<p>在我们的 app 代码中使用这个接口，合约就知道其他合约的函数是怎样的，应该如何调用，以及可期待什么类型的返回值。</p>
<p>在下一课中，我们将真正调用其他合约的函数。目前我们只要声明一个接口，用于调用 CryptoKitties 合约就行了。</p>
<p><strong>实战演习</strong></p>
<p>我们已经为你查看过了 CryptoKitties 的源代码，并且找到了一个名为 <code>getKitty</code>的函数，它返回所有的加密猫的数据，包括它的“基因”（我们的僵尸游戏要用它生成新的僵尸）。</p>
<p>该函数如下所示：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function getKitty(uint256 _id) external view returns (</span><br><span class="line">    bool isGestating,</span><br><span class="line">    bool isReady,</span><br><span class="line">    uint256 cooldownIndex,</span><br><span class="line">    uint256 nextActionAt,</span><br><span class="line">    uint256 siringWithId,</span><br><span class="line">    uint256 birthTime,</span><br><span class="line">    uint256 matronId,</span><br><span class="line">    uint256 sireId,</span><br><span class="line">    uint256 generation,</span><br><span class="line">    uint256 genes</span><br><span class="line">) {</span><br><span class="line">    Kitty storage kit = kitties[_id];</span><br><span class="line"></span><br><span class="line">    // if this variable is 0 then it's not gestating</span><br><span class="line">    isGestating = (kit.siringWithId != 0);</span><br><span class="line">    isReady = (kit.cooldownEndBlock &lt;= block.number);</span><br><span class="line">    cooldownIndex = uint256(kit.cooldownIndex);</span><br><span class="line">    nextActionAt = uint256(kit.cooldownEndBlock);</span><br><span class="line">    siringWithId = uint256(kit.siringWithId);</span><br><span class="line">    birthTime = uint256(kit.birthTime);</span><br><span class="line">    matronId = uint256(kit.matronId);</span><br><span class="line">    sireId = uint256(kit.sireId);</span><br><span class="line">    generation = uint256(kit.generation);</span><br><span class="line">    genes = kit.genes;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个函数看起来跟我们习惯的函数不太一样。 它竟然返回了…一堆不同的值！ 如果您用过 JavaScript 之类的编程语言，一定会感到奇怪 —— 在 Solidity中，您可以让一个函数返回多个值。</p>
<p>现在我们知道这个函数长什么样的了，就可以用它来创建一个接口：</p>
<p>1.定义一个名为 <code>KittyInterface</code> 的接口。 请注意，因为我们使用了 <code>contract</code> 关键字， 这过程看起来就像创建一个新的合约一样。</p>
<p>2.在interface里定义了 <code>getKitty</code> 函数（不过是复制/粘贴上面的函数，但在 <code>returns</code> 语句之后用分号，而不是大括号内的所有内容。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Create KittyInterface here</span><br><span class="line">contract KittyInterface {</span><br><span class="line">    function getKitty(uint256 _id) external view returns (</span><br><span class="line">    bool isGestating,</span><br><span class="line">    bool isReady,</span><br><span class="line">    uint256 cooldownIndex,</span><br><span class="line">    uint256 nextActionAt,</span><br><span class="line">    uint256 siringWithId,</span><br><span class="line">    uint256 birthTime,</span><br><span class="line">    uint256 matronId,</span><br><span class="line">    uint256 sireId,</span><br><span class="line">    uint256 generation,</span><br><span class="line">    uint256 genes</span><br><span class="line">    );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第11章-使用接口"><a href="#第11章-使用接口" class="headerlink" title="第11章: 使用接口"></a>第11章: 使用接口</h3><p>继续前面 <code>NumberInterface</code> 的例子，我们既然将接口定义为：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract NumberInterface {</span><br><span class="line">  function getNum(address _myAddress) public view returns (uint);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们可以在合约中这样使用：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">contract MyContract {</span><br><span class="line">  address NumberInterfaceAddress = 0xab38...;</span><br><span class="line">  // ^ 这是FavoriteNumber合约在以太坊上的地址</span><br><span class="line">  NumberInterface numberContract = NumberInterface(NumberInterfaceAddress);</span><br><span class="line">  // 现在变量 `numberContract` 指向另一个合约对象</span><br><span class="line"></span><br><span class="line">  function someFunction() public {</span><br><span class="line">    // 现在我们可以调用在那个合约中声明的 `getNum`函数:</span><br><span class="line">    uint num = numberContract.getNum(msg.sender);</span><br><span class="line">    // ...在这儿使用 `num`变量做些什么</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过这种方式，只要将您合约的可见性设置为<code>public</code>(公共)或<code>external</code>(外部)，它们就可以与以太坊区块链上的任何其他合约进行交互。</p>
<p><strong>实战演习</strong></p>
<p>我们来建个自己的合约去读取另一个智能合约– CryptoKitties 的内容吧！</p>
<ol>
<li>我已经将代码中 CryptoKitties 合约的地址保存在一个名为 <code>ckAddress</code> 的变量中。在下一行中，请创建一个名为 <code>kittyContract</code> 的 KittyInterface，并用 <code>ckAddress</code> 为它初始化 —— 就像我们为 <code>numberContract</code>所做的一样。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">contract ZombieFeeding is ZombieFactory {</span><br><span class="line"></span><br><span class="line">  address ckAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;</span><br><span class="line">  // Initialize kittyContract here using `ckAddress` from above</span><br><span class="line">    KittyInterface kittyContract = KittyInterface(ckAddress);</span><br><span class="line"></span><br><span class="line">  function feedAndMultiply(uint _zombieId, uint _targetDna) public {</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    _targetDna = _targetDna % dnaModulus;</span><br><span class="line">    uint newDna = (myZombie.dna + _targetDna) / 2;</span><br><span class="line">    _createZombie("NoName", newDna);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第12章-处理多返回值"><a href="#第12章-处理多返回值" class="headerlink" title="第12章: 处理多返回值"></a>第12章: 处理多返回值</h3><p><code>getKitty</code> 是我们所看到的第一个返回多个值的函数。我们来看看是如何处理的：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function multipleReturns() internal returns(uint a, uint b, uint c) {</span><br><span class="line">  return (1, 2, 3);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function processMultipleReturns() external {</span><br><span class="line">  uint a;</span><br><span class="line">  uint b;</span><br><span class="line">  uint c;</span><br><span class="line">  // 这样来做批量赋值:</span><br><span class="line">  (a, b, c) = multipleReturns();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 或者如果我们只想返回其中一个变量:</span><br><span class="line">function getLastReturnValue() external {</span><br><span class="line">  uint c;</span><br><span class="line">  // 可以对其他字段留空:</span><br><span class="line">  (,,c) = multipleReturns();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实战演习</strong></p>
<p>是时候与 CryptoKitties 合约交互起来了！</p>
<p>我们来定义一个函数，从 kitty 合约中获取它的基因：</p>
<ol>
<li><p>创建一个名为 <code>feedOnKitty</code> 的函数。它需要2个 <code>uint</code> 类型的参数，<code>_zombieId</code> 和<code>_kittyId</code> ，这是一个 <code>public</code> 类型的函数。</p>
</li>
<li><p>函数首先要声明一个名为 <code>kittyDna</code> 的 <code>uint</code>。</p>
<blockquote>
<p>注意：在我们的 <code>KittyInterface</code> 中，<code>genes</code> 是一个 <code>uint256</code> 类型的变量，但是如果你记得，我们在第一课中提到过，<code>uint</code> 是 <code>uint256</code> 的别名，也就是说它们是一回事。</p>
</blockquote>
</li>
<li><p>这个函数接下来调用 <code>kittyContract.getKitty</code>函数, 传入 <code>_kittyId</code> ，将返回的 <code>genes</code> 存储在 <code>kittyDna</code> 中。记住 —— <code>getKitty</code> 会返回一大堆变量。 （确切地说10个 - 我已经为你数过了，不错吧！）。但是我们只关心最后一个– <code>genes</code>。数逗号的时候小心点哦！</p>
</li>
<li><p>最后，函数调用了 <code>feedAndMultiply</code> ，并传入了 <code>_zombieId</code> 和 <code>kittyDna</code> 两个参数。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// define function here</span><br><span class="line">    function feedOnKitty(uint _zombieId, uint _kittyId) public{</span><br><span class="line">        uint kittyDna;</span><br><span class="line">        (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId);</span><br><span class="line">        feedAndMultiply(_zombieId,kittyDna);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第13章-奖励-Kitty-基因"><a href="#第13章-奖励-Kitty-基因" class="headerlink" title="第13章: 奖励: Kitty 基因"></a>第13章: 奖励: Kitty 基因</h3><p>我们的功能逻辑主体已经完成了…现在让我们来添一个奖励功能吧。</p>
<p>这样吧，给从小猫制造出的僵尸添加些特征，以显示他们是猫僵尸。</p>
<p>要做到这一点，咱们在新僵尸的DNA中添加一些特殊的小猫代码。</p>
<p>还记得吗，第一课中我们提到，我们目前只使用16位DNA的前12位数来指定僵尸的外观。所以现在我们可以使用最后2个数字来处理“特殊”的特征。</p>
<p>这样吧，把猫僵尸DNA的最后两个数字设定为<code>99</code>（因为猫有9条命）。所以在我们这么来写代码：<code>如果</code>这个僵尸是一只猫变来的，就将它DNA的最后两位数字设置为<code>99</code>。</p>
<p><strong>if 语句</strong></p>
<p>if语句的语法在 Solidity 中，与在 JavaScript 中差不多：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function eatBLT(string sandwich) public {</span><br><span class="line">  // 看清楚了，当我们比较字符串的时候，需要比较他们的 keccak256 哈希码</span><br><span class="line">  if (keccak256(sandwich) == keccak256("BLT")) {</span><br><span class="line">    eat();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实战演习</strong></p>
<p>让我们在我们的僵尸代码中实现小猫的基因。</p>
<ol>
<li><p>首先，我们修改下 <code>feedAndMultiply</code> 函数的定义，给它传入第三个参数：一条名为 <code>_species</code> 的字符串。</p>
</li>
<li><p>接下来，在我们计算出新的僵尸的DNA之后，添加一个 <code>if</code> 语句来比较 <code>_species</code> 和字符串 <code>"kitty"</code> 的 <code>keccak256</code> 哈希值。</p>
</li>
<li><p>在 <code>if</code> 语句中，我们用 <code>99</code> 替换了新僵尸DNA的最后两位数字。可以这么做：<code>newDna = newDna - newDna % 100 + 99;</code>。</p>
<blockquote>
<p>解释：假设 <code>newDna</code> 是 <code>334455</code>。那么 <code>newDna % 100</code> 是 <code>55</code>，所以 <code>newDna - newDna % 100</code> 得到 <code>334400</code>。最后加上 <code>99</code> 可得到 <code>334499</code>。</p>
</blockquote>
</li>
<li><p>最后，我们修改了 <code>feedOnKitty</code> 中的函数调用。当它调用 <code>feedAndMultiply</code> 时，增加 <code>“kitty”</code> 作为最后一个参数。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 这里修改函数定义</span><br><span class="line">  function feedAndMultiply(uint _zombieId, uint _targetDna, string _species) public {</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    _targetDna = _targetDna % dnaModulus;</span><br><span class="line">    uint newDna = (myZombie.dna + _targetDna) / 2;</span><br><span class="line">    // 这里增加一个 if 语句</span><br><span class="line">    if(keccak256(_species) == keccak256("kitty")){</span><br><span class="line">        newDna = newDna - newDna % 100 + 99;</span><br><span class="line">    }</span><br><span class="line">    _createZombie("NoName", newDna);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  function feedOnKitty(uint _zombieId, uint _kittyId) public {</span><br><span class="line">    uint kittyDna;</span><br><span class="line">    (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId);</span><br><span class="line">    // 并修改函数调用</span><br><span class="line">    feedAndMultiply(_zombieId, kittyDna,"kitty");</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第14章-放在一起"><a href="#第14章-放在一起" class="headerlink" title="第14章: 放在一起"></a>第14章: 放在一起</h3><p>至此，你已经学完第二课了！</p>
<p>查看下→_→的演示，看看他们怎么运行起来得吧。继续，你肯定等不及看完这一页😉。点击小猫，攻击！看到你斩获一个新的小猫僵尸了吧！</p>
<p><strong>JavaScript 实现</strong></p>
<p>我们只用编译和部署 <code>ZombieFeeding</code>，就可以将这个合约部署到以太坊了。我们最终完成的这个合约继承自 <code>ZombieFactory</code>，因此它可以访问自己和父辈合约中的所有 public 方法。</p>
<p>我们来看一个与我们的刚部署的合约进行交互的例子， 这个例子使用了 JavaScript 和 web3.js：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">var abi = /* abi generated by the compiler */</span><br><span class="line">var ZombieFeedingContract = web3.eth.contract(abi)</span><br><span class="line">var contractAddress = /* our contract address on Ethereum after deploying */</span><br><span class="line">var ZombieFeeding = ZombieFeedingContract.at(contractAddress)</span><br><span class="line"></span><br><span class="line">// 假设我们有我们的僵尸ID和要攻击的猫咪ID</span><br><span class="line">let zombieId = 1;</span><br><span class="line">let kittyId = 1;</span><br><span class="line"></span><br><span class="line">// 要拿到猫咪的DNA，我们需要调用它的API。这些数据保存在它们的服务器上而不是区块链上。</span><br><span class="line">// 如果一切都在区块链上，我们就不用担心它们的服务器挂了，或者它们修改了API，</span><br><span class="line">// 或者因为不喜欢我们的僵尸游戏而封杀了我们</span><br><span class="line">let apiUrl = "https://api.cryptokitties.co/kitties/" + kittyId</span><br><span class="line">$.get(apiUrl, function(data) {</span><br><span class="line">  let imgUrl = data.image_url</span><br><span class="line">  // 一些显示图片的代码</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">// 当用户点击一只猫咪的时候:</span><br><span class="line">$(".kittyImage").click(function(e) {</span><br><span class="line">  // 调用我们合约的 `feedOnKitty` 函数</span><br><span class="line">  ZombieFeeding.feedOnKitty(zombieId, kittyId)</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">// 侦听来自我们合约的新僵尸事件好来处理</span><br><span class="line">ZombieFactory.NewZombie(function(error, result) {</span><br><span class="line">  if (error) return</span><br><span class="line">  // 这个函数用来显示僵尸:</span><br><span class="line">  generateZombie(result.zombieId, result.name, result.dna)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实战演习</strong></p>
<p>选择一只你想猎食的小猫。你自家僵尸的 DNA 会和小猫的 DNA 结合，生成一个新的小猫僵尸，加入你的军团！</p>
<p>看到新僵尸上那可爱的猫咪腿了么？这是新僵尸最后DNA中最后两位数字 <code>99</code> 的功劳！</p>
<p>你想要的话随时可以重新开始。捕获了一只猫咪僵尸，你一定很高兴吧！（不过你只能持有一只），继续前进到下一章，完成第二课吧！</p>
<h1 id="8月11日"><a href="#8月11日" class="headerlink" title="8月11日"></a>8月11日</h1><table>
<thead>
<tr>
<th>今日学习内容</th>
</tr>
</thead>
<tbody><tr>
<td>Chainlink预言机的solidity进阶课程部分内容</td>
</tr>
<tr>
<td>智能合约开发部分内容</td>
</tr>
</tbody></table>
<h2 id="Chainlink预言机的solidity进阶课程"><a href="#Chainlink预言机的solidity进阶课程" class="headerlink" title="Chainlink预言机的solidity进阶课程"></a>Chainlink预言机的solidity进阶课程</h2><h3 id="预言机网络（Chainlink）"><a href="#预言机网络（Chainlink）" class="headerlink" title="预言机网络（Chainlink）"></a>预言机网络（Chainlink）</h3><p><img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-11%20123802.png"></p>
<p><strong>Chainlink</strong> 是一个 <strong>去中心化的预言机网络（Decentralized Oracle Network）</strong>，主要解决区块链无法直接获取外部数据的问题。图中展示的是其如何为 <strong>现代Web3应用</strong> 提供多链、多服务的支持。</p>
<p>（1）Chainlink Web3 服务</p>
<table>
<thead>
<tr>
<th align="left"><strong>服务类型</strong></th>
<th align="left"><strong>功能</strong></th>
<th align="left"><strong>具体产品</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Data</strong></td>
<td align="left">提供链外数据（如价格、天气等）</td>
<td align="left">• Feeds（价格预言机） • Functions（链上请求API） • Data Stream（实时数据流）</td>
</tr>
<tr>
<td align="left"><strong>Compute</strong></td>
<td align="left">提供可验证的随机数和自动化执行</td>
<td align="left">• VRF（可验证随机数） • Automation（智能合约自动化）</td>
</tr>
<tr>
<td align="left"><strong>Cross-chain</strong></td>
<td align="left">跨链通信和数据传输</td>
<td align="left">CCIP（跨链互操作协议）</td>
</tr>
</tbody></table>
<p>（2）连接对象</p>
<ul>
<li><strong>区块链（Blockchain）</strong>：支持多链（图中标注 1.1/1.2 可能指不同链版本或主网/测试网）。</li>
<li><strong>合约与资产（Contracts &amp; Assets）</strong>：如DeFi协议、NFT项目等。</li>
<li><strong>Web2系统</strong>：传统企业数据、API服务和遗留系统（如银行支付网关）。</li>
</ul>
<h3 id="喂价（Data-Feed）"><a href="#喂价（Data-Feed）" class="headerlink" title="喂价（Data Feed）"></a>喂价（Data Feed）</h3><h4 id="Data-Feed-架构"><a href="#Data-Feed-架构" class="headerlink" title="Data Feed 架构"></a>Data Feed 架构</h4><p><img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-11%20124451.png"></p>
<p>DON：去中心化的预言机网络</p>
<p>DON从数据提供商那里获取数据，将数据在DON网络中进行一次聚合，聚合之后将数据写入链上所部署的ChainLink Data Feed 合约中，用户合约可以通过Data Feed 合约的地址进行调用，从而获取到当前代币的价格</p>
<h4 id="Data-Feed-结构"><a href="#Data-Feed-结构" class="headerlink" title="Data Feed 结构"></a>Data Feed 结构</h4><p><img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-11%20124904.png"></p>
<p>Aggregator：聚合合约，用于收集链下的数据，将其存入到transmission中</p>
<p>通过查看chainlink文档中，Data Feed合约内容，用户可以通过调用合约中的getChainlinkDataFeedLatestAnswer函数来获取代币实时数据，合约会返回一个answer值，就是链下代币值。</p>
<img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-11%20125811.png" style="zoom:67%;">



<h3 id="部署一个FundMe的智能合约"><a href="#部署一个FundMe的智能合约" class="headerlink" title="部署一个FundMe的智能合约"></a>部署一个FundMe的智能合约</h3><p>需求：</p>
<ol>
<li>创建一个收款函数</li>
<li>记录投资人并且查看</li>
<li>在锁定期内，达到目标值，生产商可以提款</li>
<li>在锁定期内，未达到目标值，投资人可以退款</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.20;</span><br><span class="line">import {AggregatorV3Interface} from "@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol";</span><br><span class="line"></span><br><span class="line">//1.创建一个收款函数</span><br><span class="line">//2.记录投资人并且查看 </span><br><span class="line">//3.在锁定期内，达到目标值，生产商可以提款</span><br><span class="line">//4.在锁定期内，未达到目标值，投资人可以退款</span><br><span class="line"></span><br><span class="line">contract FundMe {</span><br><span class="line">    mapping (address =&gt; uint256) public fundersToAmount;</span><br><span class="line"></span><br><span class="line">    uint256 constant MINIMUM_VALUE = 100 * 10 ** 18;   //USD</span><br><span class="line"></span><br><span class="line">    AggregatorV3Interface internal dataFeed;</span><br><span class="line"></span><br><span class="line">    uint256 constant TARGET = 1000 * 10 ** 18;</span><br><span class="line"></span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    constructor(){</span><br><span class="line">        dataFeed = AggregatorV3Interface(0x694AA1769357215DE4FAC081bf1f309aDC325306);</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    function fund() external  payable {</span><br><span class="line">        require(convertEthToUsd(msg.value) &gt;= MINIMUM_VALUE, "Send more ETH");</span><br><span class="line">        fundersToAmount[msg.sender] = msg.value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function getChainlinkDataFeedLatestAnswer() public view returns (int) {</span><br><span class="line">        // prettier-ignore</span><br><span class="line">        (</span><br><span class="line">            //uint80 roundId,</span><br><span class="line">            int answer,</span><br><span class="line">            //uint256 startedAt,</span><br><span class="line">            //uint256 updatedAt,</span><br><span class="line">            //uint80 answeredInRound</span><br><span class="line">        ) = dataFeed.latestRoundData();</span><br><span class="line">        return answer;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function convertEthToUsd(uint256 ethAmount) internal view returns(uint256){</span><br><span class="line">        uint256 ethPrice = uint256(getChainlinkDataFeedLatestAnswer());</span><br><span class="line">        return ethAmount * ethPrice / (10**8);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function getFund() external {</span><br><span class="line">        require(convertEthToUsd(address(this).balance) &gt;= TARGET,"Target is not reached");</span><br><span class="line">        require(msg.sender == owner, "this funciton can only be called by owner");</span><br><span class="line">        //transfer</span><br><span class="line">        // payable(msg.sender).transfer(address(this).balance);</span><br><span class="line"></span><br><span class="line">        //send</span><br><span class="line">        // bool success = payable(msg.sender).send(address(this).balance);</span><br><span class="line">        // require(success, "tx failed");</span><br><span class="line"></span><br><span class="line">        //call </span><br><span class="line">        bool success;</span><br><span class="line">        (success, ) = payable(msg.sender).call{value: address(this).balance}("");</span><br><span class="line">        require(success ,"transfer tx failed");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function transformOwnerShip(address newOwner) public {</span><br><span class="line">        require(msg.sender == owner, "this funciton can only be called by owner");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function refund() external {</span><br><span class="line">        require(convertEthToUsd(address(this).balance) &lt; TARGET,"Target is reached");</span><br><span class="line">        require(fundersToAmount[msg.sender] != 0, "there is no fund for you");</span><br><span class="line">        bool success;</span><br><span class="line">        (success, ) = payable(msg.sender).call{value: fundersToAmount[msg.sender]}("");</span><br><span class="line">        require(success ,"transfer tx failed");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>payable：要有这个参数才能执行收款</p>
<p>创建一个构造函数，去chainlink中找到价格信息来源地址</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">constructor(){</span><br><span class="line">		//sepolia testnet</span><br><span class="line">        dataFeed = AggregatorV3Interface(0x694AA1769357215DE4FAC081bf1f309aDC325306);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-11%20154641.png"></p>
<p>写一个新的函数用于转换ETH和USD</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> function fund() external  payable {</span><br><span class="line">        require(convertEthToUsd(msg.value) &gt;= MINIMUM_VALUE, "Send more ETH");	//如果不满足执行回退，返回"Send more ETH"</span><br><span class="line">        fundersToAmount[msg.sender] = msg.value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">function convertEthToUsd(uint256 ethAmount) internal view returns(uint256){</span><br><span class="line">        uint256 ethPrice = uint256(getChainlinkDataFeedLatestAnswer());</span><br><span class="line">        return ethAmount * ethPrice / (10**8);</span><br><span class="line">        // ETH / USD    precision= 10 ** 8</span><br><span class="line">        // X / ETH 		precision= 10 ** 18</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>注意：getChainlinkDataFeedLatestAnswer()获得的值是一个int类型的，需要强制转换为uint256类型</p>
<h4 id="转账的三种类型"><a href="#转账的三种类型" class="headerlink" title="转账的三种类型"></a>转账的三种类型</h4><ol>
<li>transfer：失败则直接回退</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">结构：addr.transfer(value)</span><br><span class="line">payable(msg.sender).transfer(address(this).balance);</span><br></pre></td></tr></tbody></table></figure>

<table>
<thead>
<tr>
<th align="left">代码片段</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>address(this).balance</code></td>
<td align="left">获取当前合约地址持有的 ETH 余额（单位：wei，1 ETH = 10¹⁸ wei）</td>
</tr>
<tr>
<td align="left"><code>payable(msg.sender)</code></td>
<td align="left">将调用者地址转换为可接收 ETH 的 <code>payable</code> 类型</td>
</tr>
<tr>
<td align="left"><code>.transfer(...)</code></td>
<td align="left">向目标地址发送 ETH（自动处理 wei 单位，失败时回滚交易）</td>
</tr>
</tbody></table>
<ol start="2">
<li>send：失败返回false布尔值</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">结构：addr.send(value)</span><br><span class="line">bool success = payable(msg.sender).send(address(this).balance);</span><br><span class="line">require(success, "tx failed");</span><br></pre></td></tr></tbody></table></figure>

<ol start="3">
<li>call：可以在转账的同时带上数据，返回函数返回值以及布尔值</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">结构：(bool ,result) = addr.call{value: value}("")</span><br><span class="line">bool success;</span><br><span class="line">(success, ) = payable(msg.sender).call{value: address(this).balance}("");</span><br><span class="line">没有调用函数 所以""内为空，也没有函数返回值，result可以制空</span><br></pre></td></tr></tbody></table></figure>

<h4 id="提款"><a href="#提款" class="headerlink" title="提款"></a>提款</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function refund() external {</span><br><span class="line">        require(convertEthToUsd(address(this).balance) &lt; TARGET,"Target is reached");</span><br><span class="line">        require(fundersToAmount[msg.sender] != 0, "there is no fund for you");</span><br><span class="line">        bool success;</span><br><span class="line">        (success, ) = payable(msg.sender).call{value: fundersToAmount[msg.sender]}("");</span><br><span class="line">        require(success ,"transfer tx failed");</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>这个函数存在一个bug，就是一个人将自己的存款提出后，未对该账户进行清零，导致这个人可以继续refund，提取别人的存款</p>
<p>改进，加一句提款后清零账户，fundersToAmount[msg.sender] = 0</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function refund() external {</span><br><span class="line">        require(convertEthToUsd(address(this).balance) &lt; TARGET,"Target is reached");</span><br><span class="line">        require(fundersToAmount[msg.sender] != 0, "there is no fund for you");</span><br><span class="line">        bool success;</span><br><span class="line">        (success, ) = payable(msg.sender).call{value: fundersToAmount[msg.sender]}("");</span><br><span class="line">        require(success ,"transfer tx failed");</span><br><span class="line">        fundersToAmount[msg.sender] = 0		//</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>



<h4 id="时间锁"><a href="#时间锁" class="headerlink" title="时间锁"></a>时间锁</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint256 deploymentTimestamp;		//合约部署时候的时间戳（针对于1970年1月1日算起）</span><br><span class="line">uint256 lockTime;					//秒为单位	</span><br></pre></td></tr></tbody></table></figure>

<p>在solidity中没有专门的时间类型，使用整形数据类型。</p>
<p>修改构造函数，初始化时间戳和需要锁定时间</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">constructor(uint256 _lockTime){</span><br><span class="line">        dataFeed = AggregatorV3Interface(0x694AA1769357215DE4FAC081bf1f309aDC325306);</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        deploymentTimestamp = block.timestamp;		//</span><br><span class="line">        lockTime = _lockTime;						//</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>更改fund函数</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function fund() external  payable {</span><br><span class="line">        require(convertEthToUsd(msg.value) &gt;= MINIMUM_VALUE, "Send more ETH");</span><br><span class="line">        require(block.timestamp &lt; deploymentTimestamp + lockTime, "window is closed");//</span><br><span class="line">        fundersToAmount[msg.sender] = msg.value;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>更改getfund函数</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function getFund() external {</span><br><span class="line">        require(convertEthToUsd(address(this).balance) &gt;= TARGET,"Target is not reached");</span><br><span class="line">        require(msg.sender == owner, "this funciton can only be called by owner");</span><br><span class="line">        require(block.timestamp &gt;= deploymentTimestamp + lockTime, "window is not closed"); 	//</span><br></pre></td></tr></tbody></table></figure>

<p>更改refund函数，更改处于getfund相同</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function refund() external windowClose {</span><br><span class="line">        require(convertEthToUsd(address(this).balance) &lt; TARGET,"Target is reached");</span><br><span class="line">        require(fundersToAmount[msg.sender] != 0, "there is no fund for you");</span><br></pre></td></tr></tbody></table></figure>



<h4 id="modifier修改器"><a href="#modifier修改器" class="headerlink" title="modifier修改器"></a>modifier修改器</h4><p>统一处理require函数</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">modifier windowClose(){</span><br><span class="line">	require(block.timestamp &gt;= deploymentTimestamp + lockTime, "window is not closed");</span><br><span class="line">	_;			//函数剩余内容，此处证明require要先于其他函数内容执行</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果_;在前面</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">modifier windowClose(){</span><br><span class="line">	_;	    //函数剩余内容先执行，再执行require</span><br><span class="line">	require(block.timestamp &gt;= deploymentTimestamp + lockTime, "window is not closed");</span><br><span class="line">			</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>











<h2 id="智能合约开发"><a href="#智能合约开发" class="headerlink" title="智能合约开发"></a>智能合约开发</h2><h3 id="Dapp-架构和开发流程"><a href="#Dapp-架构和开发流程" class="headerlink" title="Dapp 架构和开发流程"></a>Dapp 架构和开发流程</h3><p>Dapp：去中心化应用，运行在区块链或分布式网络上，应用的逻辑和数据是由多个参与者共同维护。</p>
<h4 id="Dapp-架构"><a href="#Dapp-架构" class="headerlink" title="Dapp 架构"></a>Dapp 架构</h4><p>三个核心部分：</p>
<ol>
<li><strong>前端（User Interface）</strong>：</li>
</ol>
<ul>
<li>前端是 Dapp 与用户交互的界面，通常由 HTML、CSS 和 JavaScript（如 React、Vue 等框架）构建。与传统 Web 应用不同，Dapp 前端会连接区块链来调用智能合约，呈现数据和执行交易。</li>
<li>前端还需要集成区块链钱包（如 MetaMask）来进行身份验证和签署交易，确保用户的隐私和安全。</li>
</ul>
<ol start="2">
<li><strong>智能合约（Smart Contracts）</strong>：</li>
</ol>
<ul>
<li>智能合约是 Dapp 的核心，它定义了应用的业务逻辑，并部署在区块链上。智能合约通过执行自动化的规则来确保交易和操作的透明性与不可篡改性。</li>
<li>在以太坊平台上，智能合约通常使用 <strong>Solidity</strong> 编程语言编写，并通过 <strong>Ethereum Virtual Machine (EVM)</strong> 执行。</li>
</ul>
<ol start="3">
<li><strong>数据检索器（Indexer）</strong>：</li>
</ol>
<ul>
<li>智能合约通常以 <code>Event</code> 形式释放日志事件，比如释放代表 NFT 转移的 <code>Transfer</code> 事件，数据检索器会检索这些数据并将其写入到 PostgreSQL 等传统数据库中</li>
<li>Dapp 在前端进行数据展示时需要检索器内的数据。一个简单的示例是某 NFT 项目需要展示用户持有的所有 NFT，但是 NFT 合约并不会提供通过输入地址参数返回该地址下的所有 NFT 的函数，此时我们可以运行数据检索器将 <code>Transfer</code> 事件读取后写入传统数据库内，前端可以在传统数据库内检索用户持有的 NFT 数据</li>
</ul>
<ol start="4">
<li><strong>区块链和去中心化存储（Blockchain &amp; Decentralized Storage）</strong>：</li>
</ol>
<ul>
<li>区块链用于存储智能合约的状态数据及交易记录。去中心化存储如 <strong>IPFS</strong>（InterPlanetary File System）或 <strong>Arweave</strong>，用于存储大规模的非结构化数据（如图片、文档等），确保数据不易丢失和篡改。</li>
<li>通过使用去中心化存储，Dapp 确保所有数据在多个节点上备份，保证数据的持久性和去中心化特性。</li>
</ul>
<h4 id="Dapp-开发流程"><a href="#Dapp-开发流程" class="headerlink" title="Dapp 开发流程"></a>Dapp 开发流程</h4><ol>
<li><p><strong>需求分析与规划</strong></p>
<p> 在开发 Dapp 之前，首先需要进行需求分析和规划，明确应用的目标和功能。此阶段包括：</p>
<ul>
<li><strong>确定功能需求</strong>：需要定义用户可以进行的操作，比如转账、查询余额、创建投票等。</li>
<li><strong>选择区块链平台</strong>：决定在哪个平台上构建 Dapp（如以太坊、Solana、Polygon 等），这通常取决于目标用户群、交易成本、可扩展性等因素。</li>
<li><strong>设计用户体验（UX）</strong>：定义 Dapp 的界面设计和交互流程，确保用户能够轻松使用应用并与区块链交互。</li>
</ul>
</li>
<li><p><strong>智能合约开发</strong></p>
<p> 智能合约是 Dapp 的核心，负责执行去中心化的业务逻辑和存储重要的数据。在这一阶段，开发者需要：</p>
<ul>
<li><strong>编写智能合约</strong>：使用 <strong>Solidity</strong> 或其他智能合约语言编写合约，确保合约的功能满足需求分析中定义的要求。</li>
<li><strong>编写测试用例</strong>：为智能合约编写单元测试，确保合约逻辑正确、无漏洞。</li>
<li><strong>审计和优化</strong>：对合约进行安全审计，确保合约的安全性，避免常见漏洞（如重入攻击、整数溢出等）。</li>
</ul>
</li>
<li><p><strong>检索器开发</strong></p>
<p> 检索器是<u><strong>获取链上数据的核心</strong></u>，<u><strong>负责捕获智能合约释放的事件并以合理的方式将其存入数据库</strong></u>的不同的表内部。在这一阶段，开发者需要:</p>
<ul>
<li><strong>确定功能需要的数据内容</strong>: 前端使用的数据大部份都直接来自检索器，所以开发者需要确定前端工程师所需要的数据</li>
<li><strong>编写检索器程序</strong>: 目前主流的检索器框架，如 ponder 和 subgraph 都是用了 TypeScript 语言作为检索器的程序编写语言，开发者主要编写事件数据清理以及事件数据写入数据库的代码</li>
<li><strong>部署和运维</strong>: 编写程序完成后，一般使用 Docker 部署到云服务器中，当然目前很多检索器框架也提供 SaaS 服务，同时检索器作为一个常规的数据库应用需要运维</li>
</ul>
</li>
<li><p><strong>前端开发</strong></p>
<p> 前端是用户与 Dapp 交互的主要界面，因此开发前端时需要：</p>
<ul>
<li><strong>选择前端框架</strong>：可以使用现代前端框架（如 <strong>React</strong>、<strong>Vue</strong>）来构建 UI。前端将通过 JavaScript 与智能合约进行交互。</li>
<li><strong>连接钱包</strong>：通过集成 <strong>MetaMask</strong> 等 Web3 钱包，用户可以连接到 Dapp，并授权其与智能合约交互。</li>
<li><strong>显示区块链数据</strong>：前端需要从区块链和检索器内获取数据（如账户余额、交易记录），并通过用户界面展示。</li>
<li><strong>处理交易签名与确认</strong>：当用户发起交易时，前端需要与钱包进行交互，获取用户的签名并将交易发送到区块链。</li>
</ul>
</li>
<li><p><strong>与区块链交互</strong></p>
<p> 前端和智能合约通过 <strong>Viem</strong>（推荐）、<strong>Ethers.js</strong> 或 <strong>Wagmi</strong> 等现代化库进行交互。这些库提供更好的 TypeScript 支持和性能优化：</p>
<ul>
<li><strong>读取数据</strong>：前端通过智能合约的公共函数读取区块链上的状态数据（如余额、合约信息）。</li>
<li><strong>发送交易</strong>：当用户发起交易时，前端需要通过钱包签署交易并发送到区块链，执行合约中的某个功能（如转账）。</li>
</ul>
</li>
<li><p><strong>部署与上线</strong></p>
<p> 一旦开发完成，Dapp 进入部署阶段。具体步骤包括：</p>
<ul>
<li><strong>部署智能合约</strong>：推荐使用 <strong>Hardhat</strong> 或 <strong>Foundry</strong>（现代化开发工具）将智能合约部署到测试网（如 <strong>Sepolia</strong>、<strong>Holesky</strong>）或主网。</li>
<li><strong>前端部署</strong>：将前端应用部署到去中心化平台（如 <strong>IPFS</strong>）或传统的 Web 服务（Vercel）。</li>
<li><strong>发布和维护</strong>：将 Dapp 上线，进行用户反馈收集，定期更新合约和前端，修复潜在问题。</li>
</ul>
</li>
</ol>
<h1 id="8月12日"><a href="#8月12日" class="headerlink" title="8月12日"></a>8月12日</h1><table>
<thead>
<tr>
<th>今日学习内容</th>
</tr>
</thead>
<tbody><tr>
<td>CryptoZombiesx的solidity学习\Solidity: Beginner to Intermediate Smart Contracts\lesson3 高级 Solidity 理论</td>
</tr>
<tr>
<td>CryptoZombiesx的solidity学习\Solidity: Beginner to Intermediate Smart Contracts\lesson4 僵尸作战系统</td>
</tr>
<tr>
<td>CryptoZombiesx的solidity学习\Solidity: Beginner to Intermediate Smart Contracts\lesson5 ERC721 标准和加密收藏品</td>
</tr>
<tr>
<td>openzeppelin攻防挑战前三关</td>
</tr>
</tbody></table>
<h2 id="CryptoZombiesx的solidity学习-2"><a href="#CryptoZombiesx的solidity学习-2" class="headerlink" title="CryptoZombiesx的solidity学习"></a>CryptoZombiesx的solidity学习</h2><h2 id="Solidity-Beginner-to-Intermediate-Smart-Contracts-2"><a href="#Solidity-Beginner-to-Intermediate-Smart-Contracts-2" class="headerlink" title="Solidity: Beginner to Intermediate Smart Contracts"></a>Solidity: Beginner to Intermediate Smart Contracts</h2><h2 id="lesson3-高级-Solidity-理论"><a href="#lesson3-高级-Solidity-理论" class="headerlink" title="lesson3 高级 Solidity 理论"></a>lesson3 高级 Solidity 理论</h2><h3 id="第1章-智能协议的永固性"><a href="#第1章-智能协议的永固性" class="headerlink" title="第1章: 智能协议的永固性"></a>第1章: 智能协议的永固性</h3><p>到现在为止，我们讲的 Solidity 和其他语言没有质的区别，它长得也很像 JavaScript。</p>
<p>但是，在有几点以太坊上的 DApp 跟普通的应用程序有着天壤之别。</p>
<p>第一个例子，在你把智能协议传上以太坊之后，它就变得<strong>不可更改</strong>, 这种永固性意味着你的代码永远不能被调整或更新。</p>
<p>你编译的程序会一直，永久的，不可更改的，存在以太坊上。这就是 Solidity 代码的安全性如此重要的一个原因。如果你的智能协议有任何漏洞，即使你发现了也无法补救。你只能让你的用户们放弃这个智能协议，然后转移到一个新的修复后的合约上。</p>
<p>但这恰好也是智能合约的一大优势。代码说明一切。如果你去读智能合约的代码，并验证它，你会发现，一旦函数被定义下来，每一次的运行，程序都会严格遵照函数中原有的代码逻辑一丝不苟地执行，完全不用担心函数被人篡改而得到意外的结果。</p>
<p><strong>外部依赖关系</strong></p>
<p>在第2课中，我们将加密小猫（CryptoKitties）合约的地址硬编码到 DApp 中去了。有没有想过，如果加密小猫出了点问题，比方说，集体消失了会怎么样？ 虽然这种事情几乎不可能发生，但是，如果小猫没了，我们的 DApp 也会随之失效 – 因为我们在 DApp 的代码中用“硬编码”的方式指定了加密小猫的地址，如果这个根据地址找不到小猫，我们的僵尸也就吃不到小猫了，而按照前面的描述，我们却没法修改合约去应付这个变化！</p>
<p>因此，我们不能硬编码，而要采用“函数”，以便于 DApp 的关键部分可以以参数形式修改。</p>
<p>比方说，我们不再一开始就把猎物地址给写入代码，而是写个函数 <code>setKittyContractAddress</code>, 运行时再设定猎物的地址，这样我们就可以随时去锁定新的猎物，也不用担心加密小猫集体消失了。</p>
<p><strong>实战演习</strong></p>
<p>请修改第2课的代码，使得可以通过程序更改 CryptoKitties 合约地址。</p>
<ol>
<li>删除采用硬编码 方式的 <code>ckAddress</code> 代码行。</li>
<li>之前创建 <code>kittyContract</code> 变量的那行代码，修改为对 <code>kittyContract</code> 变量的声明 – 暂时不给它指定具体的实例。</li>
<li>创建名为 <code>setKittyContractAddress</code> 的函数， 它带一个参数 <code>_address</code>（<code>address</code>类型）， 可见性设为<code>external</code>。</li>
<li>在函数内部，添加一行代码，将 <code>kittyContract</code> 变量设置为返回值：<code>KittyInterface（_address）</code>。</li>
</ol>
<blockquote>
<p>注意：你可能会注意到这个功能有个安全漏洞，别担心 - 咱们到下一章里解决它;）</p>
</blockquote>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract ZombieFeeding is ZombieFactory {</span><br><span class="line"></span><br><span class="line">  // 1. 移除这一行:</span><br><span class="line">  //address ckAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;</span><br><span class="line">  // 2. 只声明变量:</span><br><span class="line">  KittyInterface kittyContract;</span><br><span class="line"></span><br><span class="line">  // 3. 增加 setKittyContractAddress 方法</span><br><span class="line">  function setKittyContractAddress(address _address) external{</span><br><span class="line">    kittyContract = KittyInterface(_address);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第2章-Ownable-Contracts"><a href="#第2章-Ownable-Contracts" class="headerlink" title="第2章: Ownable Contracts"></a>第2章: Ownable Contracts</h3><p>上一章中，您有没有发现任何安全漏洞呢？</p>
<p>呀！<code>setKittyContractAddress</code> 可见性居然申明为“外部的”（<code>external</code>），岂不是任何人都可以调用它！ 也就是说，任何调用该函数的人都可以更改 CryptoKitties 合约的地址，使得其他人都没法再运行我们的程序了。</p>
<p>我们确实是希望这个地址能够在合约中修改，但我可没说让每个人去改它呀。</p>
<p>要对付这样的情况，通常的做法是指定合约的“所有权” - 就是说，给它指定一个主人（没错，就是您），只有主人对它享有特权。</p>
<p><strong>OpenZeppelin库的<code>Ownable</code> 合约</strong></p>
<p>下面是一个 <code>Ownable</code> 合约的例子： 来自 <strong>_ OpenZeppelin _</strong> Solidity 库的 <code>Ownable</code> 合约。 OpenZeppelin 是主打安保和社区审查的智能合约库，您可以在自己的 DApps中引用。等把这一课学完，您不要催我们发布下一课，最好利用这个时间把 OpenZeppelin 的网站看看，保管您会学到很多东西！</p>
<p>把楼下这个合约读读通，是不是还有些没见过代码？别担心，我们随后会解释。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @title Ownable</span><br><span class="line"> * @dev The Ownable contract has an owner address, and provides basic authorization control</span><br><span class="line"> * functions, this simplifies the implementation of "user permissions".</span><br><span class="line"> */</span><br><span class="line">contract Ownable {</span><br><span class="line">  address public owner;</span><br><span class="line">  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev The Ownable constructor sets the original `owner` of the contract to the sender</span><br><span class="line">   * account.</span><br><span class="line">   */</span><br><span class="line">  function Ownable() public {</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev Throws if called by any account other than the owner.</span><br><span class="line">   */</span><br><span class="line">  modifier onlyOwner() {</span><br><span class="line">    require(msg.sender == owner);</span><br><span class="line">    _;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev Allows the current owner to transfer control of the contract to a newOwner.</span><br><span class="line">   * @param newOwner The address to transfer ownership to.</span><br><span class="line">   */</span><br><span class="line">  function transferOwnership(address newOwner) public onlyOwner {</span><br><span class="line">    require(newOwner != address(0));</span><br><span class="line">    OwnershipTransferred(owner, newOwner);</span><br><span class="line">    owner = newOwner;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>下面有没有您没学过的东东？</p>
<ul>
<li>构造函数：<code>function Ownable()</code>是一个 <strong>_ constructor_</strong> (构造函数)，构造函数不是必须的，它与合约同名，构造函数一生中唯一的一次执行，就是在合约最初被创建的时候。</li>
<li>函数修饰符：<code>modifier onlyOwner()</code>。 修饰符跟函数很类似，不过是用来修饰其他已有函数用的， 在其他语句执行前，为它检查下先验条件。 在这个例子中，我们就可以写个修饰符 <code>onlyOwner</code> 检查下调用者，确保只有合约的主人才能运行本函数。我们下一章中会详细讲述修饰符，以及那个奇怪的<code>_;</code>。</li>
<li><code>indexed</code> 关键字：别担心，我们还用不到它。</li>
</ul>
<p>所以<code>Ownable</code> 合约基本都会这么干：</p>
<ol>
<li>合约创建，构造函数先行，将其 <code>owner</code> 设置为<code>msg.sender</code>（其部署者）</li>
<li>为它加上一个修饰符 <code>onlyOwner</code>，它会限制陌生人的访问，将访问某些函数的权限锁定在 <code>owner</code> 上。</li>
<li>允许将合约所有权转让给他人。</li>
</ol>
<p><code>onlyOwner</code> 简直人见人爱，大多数人开发自己的 Solidity DApps，都是从复制/粘贴 <code>Ownable</code> 开始的，从它再继承出的子类，并在之上进行功能开发。</p>
<p>既然我们想把 <code>setKittyContractAddress</code> 限制为 <code>onlyOwner</code> ，我们也要做同样的事情。</p>
<p><strong>实战演习</strong></p>
<p>首先，将 <code>Ownable</code> 合约的代码复制一份到新文件 <code>ownable.sol</code> 中。 接下来，创建一个 <code>ZombieFactory</code>，继承 <code>Ownable</code>。</p>
<p>1.在程序中导入 <code>ownable.sol</code> 的内容。 如果您不记得怎么做了，参考下 <code>zombiefeeding.sol</code>。</p>
<p>2.修改 <code>ZombieFactory</code> 合约， 让它继承自 <code>Ownable</code>。 如果您不记得怎么做了，看看 <code>zombiefeeding.sol</code>。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 1. 在这里导入</span><br><span class="line">import "./ownable.sol";</span><br><span class="line">// 2. 在这里继承:</span><br><span class="line">contract ZombieFactory is Ownable{</span><br><span class="line"></span><br><span class="line">    event NewZombie(uint zombieId, string name, uint dna);</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第3章-onlyOwner-函数修饰符"><a href="#第3章-onlyOwner-函数修饰符" class="headerlink" title="第3章: onlyOwner 函数修饰符"></a>第3章: onlyOwner 函数修饰符</h3><p>现在我们有了个基本版的合约 <code>ZombieFactory</code> 了，它继承自 <code>Ownable</code> 接口，我们也可以给 <code>ZombieFeeding</code> 加上 <code>onlyOwner</code> 函数修饰符。</p>
<p>这就是合约继承的工作原理。记得：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZombieFeeding 是个 ZombieFactory</span><br><span class="line">ZombieFactory 是个 Ownable</span><br></pre></td></tr></tbody></table></figure>

<p>因此 <code>ZombieFeeding</code> 也是个 <code>Ownable</code>, 并可以通过 <code>Ownable</code> 接口访问父类中的函数/事件/修饰符。往后，<code>ZombieFeeding</code> 的继承者合约们同样也可以这么延续下去。</p>
<p><strong>函数修饰符</strong></p>
<p>函数修饰符看起来跟函数没什么不同，不过关键字<code>modifier</code> 告诉编译器，这是个<code>modifier(修饰符)</code>，而不是个<code>function(函数)</code>。它不能像函数那样被直接调用，只能被添加到函数定义的末尾，用以改变函数的行为。</p>
<p>咱们仔细读读 <code>onlyOwner</code>:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @dev 调用者不是‘主人’，就会抛出异常</span><br><span class="line"> */</span><br><span class="line">modifier onlyOwner() {</span><br><span class="line">  require(msg.sender == owner);</span><br><span class="line">  _;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>onlyOwner</code> 函数修饰符是这么用的：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">contract MyContract is Ownable {</span><br><span class="line">  event LaughManiacally(string laughter);</span><br><span class="line"></span><br><span class="line">  //注意！ `onlyOwner`上场 :</span><br><span class="line">  function likeABoss() external onlyOwner {</span><br><span class="line">    LaughManiacally("Muahahahaha");</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注意 <code>likeABoss</code> 函数上的 <code>onlyOwner</code> 修饰符。 当你调用 <code>likeABoss</code> 时，<strong>首先执行</strong> <code>onlyOwner</code> 中的代码， 执行到 <code>onlyOwner</code> 中的 <code>_;</code> 语句时，程序再返回并执行 <code>likeABoss</code> 中的代码。</p>
<p>可见，尽管函数修饰符也可以应用到各种场合，但最常见的还是放在函数执行之前添加快速的 <code>require</code>检查。</p>
<p>因为给函数添加了修饰符 <code>onlyOwner</code>，使得<strong>唯有合约的主人</strong>（也就是部署者）才能调用它。</p>
<blockquote>
<p>注意：主人对合约享有的特权当然是正当的，不过也可能被恶意使用。比如，万一，主人添加了个后门，允许他偷走别人的僵尸呢？</p>
</blockquote>
<blockquote>
<p>所以非常重要的是，部署在以太坊上的 DApp，并不能保证它真正做到去中心，你需要阅读并理解它的源代码，才能防止其中没有被部署者恶意植入后门；作为开发人员，如何做到既要给自己留下修复 bug 的余地，又要尽量地放权给使用者，以便让他们放心你，从而愿意把数据放在你的 DApp 中，这确实需要个微妙的平衡。</p>
</blockquote>
<p><strong>实战演习</strong></p>
<p>现在我们可以限制第三方对 <code>setKittyContractAddress</code>的访问，除了我们自己，谁都无法去修改它。</p>
<ol>
<li>将 <code>onlyOwner</code> 函数修饰符添加到 <code>setKittyContractAddress</code> 中。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 修改这个函数:</span><br><span class="line">function setKittyContractAddress(address _address) external onlyOwner {</span><br><span class="line">  kittyContract = KittyInterface(_address);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第4章-Gas"><a href="#第4章-Gas" class="headerlink" title="第4章: Gas"></a>第4章: Gas</h3><p>厉害！现在我们懂了如何在禁止第三方修改我们的合约的同时，留个后门给咱们自己去修改。</p>
<p>让我们来看另一种使得 Solidity 编程语言与众不同的特征：</p>
<p><strong>Gas - 驱动以太坊DApps的能源</strong></p>
<p>在 Solidity 中，你的用户想要每次执行你的 DApp 都需要支付一定的 ***gas***，gas 可以用以太币购买，因此，用户每次跑 DApp 都得花费以太币。</p>
<p>一个 DApp 收取多少 gas 取决于功能逻辑的复杂程度。每个操作背后，都在计算完成这个操作所需要的计算资源，（比如，存储数据就比做个加法运算贵得多）， 一次操作所需要花费的 *<strong>gas*</strong> 等于这个操作背后的所有运算花销的总和。</p>
<p>由于运行你的程序需要花费用户的真金白银，在以太坊中代码的编程语言，比其他任何编程语言都更强调优化。同样的功能，使用笨拙的代码开发的程序，比起经过精巧优化的代码来，运行花费更高，这显然会给成千上万的用户带来大量不必要的开销。</p>
<p>*<em>为什么要用 <em>gas* 来驱动？</em></em></p>
<p>以太坊就像一个巨大、缓慢、但非常安全的电脑。当你运行一个程序的时候，网络上的每一个节点都在进行相同的运算，以验证它的输出 —— 这就是所谓的“去中心化” 由于数以千计的节点同时在验证着每个功能的运行，这可以确保它的数据不会被被监控，或者被刻意修改。</p>
<p>可能会有用户用无限循环堵塞网络，抑或用密集运算来占用大量的网络资源，为了防止这种事情的发生，以太坊的创建者为以太坊上的资源制定了价格，想要在以太坊上运算或者存储，你需要先付费。</p>
<blockquote>
<p>注意：如果你使用侧链，倒是不一定需要付费，比如咱们在 Loom Network 上构建的 CryptoZombies 就免费。你不会想要在以太坊主网上玩儿“魔兽世界”吧？ - 所需要的 gas 可能会买到你破产。但是你可以找个算法理念不同的侧链来玩它。我们将在以后的课程中咱们会讨论到，什么样的 DApp 应该部署在太坊主链上，什么又最好放在侧链。</p>
</blockquote>
<p><strong>省 gas 的招数：结构封装 （Struct packing）</strong></p>
<p>在第1课中，我们提到除了基本版的 <code>uint</code> 外，还有其他变种 <code>uint</code>：<code>uint8</code>，<code>uint16</code>，<code>uint32</code>等。</p>
<p>通常情况下我们不会考虑使用 <code>uint</code> 变种，因为无论如何定义 <code>uint</code>的大小，Solidity 为它保留256位的存储空间。例如，使用 <code>uint8</code> 而不是<code>uint</code>（<code>uint256</code>）不会为你节省任何 gas。</p>
<p>除非，<u><strong>把 <code>uint</code> 绑定到 <code>struct</code> 里面</strong></u>。</p>
<p>如果一个 <code>struct</code> 中有多个 <code>uint</code>，则尽可能使用较小的 <code>uint</code>, Solidity 会将这些 <code>uint</code> 打包在一起，从而占用较少的存储空间。例如：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct NormalStruct {</span><br><span class="line">  uint a;</span><br><span class="line">  uint b;</span><br><span class="line">  uint c;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">struct MiniMe {</span><br><span class="line">  uint32 a;</span><br><span class="line">  uint32 b;</span><br><span class="line">  uint c;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 因为使用了结构打包，`mini` 比 `normal` 占用的空间更少</span><br><span class="line">NormalStruct normal = NormalStruct(10, 20, 30);</span><br><span class="line">MiniMe mini = MiniMe(10, 20, 30); </span><br></pre></td></tr></tbody></table></figure>

<p>所以，当 <code>uint</code> 定义在一个 <code>struct</code> 中的时候，尽量使用最小的整数子类型以节约空间。 **<u>并且把同样类型的变量放一起</u>**（即在 struct 中将把变量按照类型依次放置），<u>这样 Solidity 可以将存储空间最小化</u>。例如，有两个 <code>struct</code>：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint c; uint32 a; uint32 b;` 和 `uint32 a; uint c; uint32 b;</span><br></pre></td></tr></tbody></table></figure>

<p>前者比后者需要的gas更少，因为前者把<code>uint32</code>放一起了。</p>
<p><strong>实战演习</strong></p>
<p>在本课中，咱们给僵尸添2个新功能：<code>level</code> 和 <code>readyTime</code> - 后者是用来实现一个“冷却定时器”，以限制僵尸猎食的频率。</p>
<p>让我们回到 <code>zombiefactory.sol</code>。</p>
<ol>
<li>为 <code>Zombie</code> 结构体 添加两个属性：<code>level</code>（<code>uint32</code>）和<code>readyTime</code>（<code>uint32</code>）。因为希望同类型数据打成一个包，所以把它们放在结构体的末尾。</li>
</ol>
<p>32位足以保存僵尸的级别和时间戳了，这样比起使用普通的<code>uint</code>（256位），可以更紧密地封装数据，从而为我们省点 gas。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">contract ZombieFactory is Ownable {</span><br><span class="line"></span><br><span class="line">    event NewZombie(uint zombieId, string name, uint dna);</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">        //在这里添加数据</span><br><span class="line">        uint32 level;</span><br><span class="line">        uint32 readyTime;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第5章-时间单位"><a href="#第5章-时间单位" class="headerlink" title="第5章: 时间单位"></a>第5章: 时间单位</h3><p><code>level</code> 属性表示僵尸的级别。以后，在我们创建的战斗系统中，打胜仗的僵尸会逐渐升级并获得更多的能力。</p>
<p><code>readyTime</code> 稍微复杂点。我们希望增加一个“冷却周期”，表示僵尸在两次猎食或攻击之之间必须等待的时间。如果没有它，僵尸每天可能会攻击和繁殖1,000次，这样游戏就太简单了。</p>
<p>为了记录僵尸在下一次进击前需要等待的时间，我们使用了 Solidity 的时间单位。</p>
<p><strong>时间单位</strong></p>
<p>Solidity 使用自己的本地时间单位。</p>
<p>变量 <code>now</code> 将返回当前的unix时间戳（自1970年1月1日以来经过的秒数）。我写这句话时 unix 时间是 <code>1515527488</code>。</p>
<blockquote>
<p>注意：Unix时间传统用一个32位的整数进行存储。这会导致“2038年”问题，当这个32位的unix时间戳不够用，产生溢出，使用这个时间的遗留系统就麻烦了。所以，如果我们想让我们的 DApp 跑够20年，我们可以使用64位整数表示时间，但为此我们的用户又得支付更多的 gas。真是个两难的设计啊！</p>
</blockquote>
<p>Solidity 还包含<code>秒(seconds)</code>，<code>分钟(minutes)</code>，<code>小时(hours)</code>，<code>天(days)</code>，<code>周(weeks)</code> 和 <code>年(years)</code> 等时间单位。它们都会转换成对应的秒数放入 <code>uint</code> 中。所以 <code>1分钟</code> 就是 <code>60</code>，<code>1小时</code>是 <code>3600</code>（60秒×60分钟），<code>1天</code>是<code>86400</code>（24小时×60分钟×60秒），以此类推。</p>
<p>下面是一些使用时间单位的实用案例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">uint lastUpdated;</span><br><span class="line"></span><br><span class="line">// 将‘上次更新时间’ 设置为 ‘现在’</span><br><span class="line">function updateTimestamp() public {</span><br><span class="line">  lastUpdated = now;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 如果到上次`updateTimestamp` 超过5分钟，返回 'true'</span><br><span class="line">// 不到5分钟返回 'false'</span><br><span class="line">function fiveMinutesHavePassed() public view returns (bool) {</span><br><span class="line">  return (now &gt;= (lastUpdated + 5 minutes));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>有了这些工具，我们可以为僵尸设定“冷静时间”功能。</p>
<p><strong>实战演习</strong></p>
<p>现在咱们给DApp添加一个“冷却周期”的设定，让僵尸两次攻击或捕猎之间必须等待 <strong>1天</strong>。</p>
<ol>
<li><p>声明一个名为 <code>cooldownTime</code> 的<code>uint</code>，并将其设置为 <code>1 days</code>。（没错，”1 days“使用了复数， 否则通不过编译器）</p>
</li>
<li><p>因为在上一章中我们给 <code>Zombie</code> 结构体中添加 <code>level</code> 和 <code>readyTime</code> 两个参数，所以现在创建一个新的 <code>Zombie</code> 结构体时，需要修改 <code>_createZombie()</code>，在其中把新旧参数都初始化一下。</p>
<p> 修改 <code>zombies.push</code> 那一行， 添加加2个参数：<code>1</code>（表示当前的 <code>level</code> ）和<code>uint32（now + cooldownTime）</code>（现在+冷却时间，表示下次允许攻击的时间 <code>readyTime</code>）。</p>
</li>
</ol>
<blockquote>
<p>注意：必须使用 <code>uint32（...）</code> 进行强制类型转换，因为 <code>now</code> 返回类型 <code>uint256</code>。所以我们需要明确将它转换成一个 <code>uint32</code> 类型的变量。</p>
</blockquote>
<p><code>now + cooldownTime</code> 将等于当前的unix时间戳（以秒为单位）加上”1天“里的秒数 - 这将等于从现在起1天后的unix时间戳。然后我们就比较，看看这个僵尸的 <code>readyTime</code>是否大于 <code>now</code>，以决定再次启用僵尸的时机有没有到来。</p>
<p>下一章中，我们将讨论如何通过 <code>readyTime</code> 来规范僵尸的行为。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 1. 在这里定义 `cooldownTime`</span><br><span class="line">uint cooldownTime = 1 days;</span><br><span class="line">    </span><br><span class="line">function _createZombie(string _name, uint _dna) internal {</span><br><span class="line">        // 2. 修改下面这行:</span><br><span class="line">        uint id = zombies.push(Zombie(_name, _dna, 1, uint32(now + cooldownTime))) - 1;</span><br><span class="line">        zombieToOwner[id] = msg.sender;</span><br><span class="line">        ownerZombieCount[msg.sender]++;</span><br><span class="line">        NewZombie(id, _name, _dna);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第6章-僵尸冷却"><a href="#第6章-僵尸冷却" class="headerlink" title="第6章: 僵尸冷却"></a>第6章: 僵尸冷却</h3><p>现在，<code>Zombie</code> 结构体中定义好了一个 <code>readyTime</code> 属性，让我们跳到 <code>zombiefeeding.sol</code>， 去实现一个”冷却周期定时器“。</p>
<p>按照以下步骤修改 <code>feedAndMultiply</code>：</p>
<ol>
<li>”捕猎“行为会触发僵尸的”冷却周期“</li>
<li>僵尸在这段”冷却周期“结束前不可再捕猎小猫</li>
</ol>
<p>这将限制僵尸，防止其无限制地捕猎小猫或者整天不停地繁殖。将来，当我们增加战斗功能时，我们同样用”冷却周期“限制僵尸之间打斗的频率。</p>
<p>首先，我们要定义一些辅助函数，设置并检查僵尸的 <code>readyTime</code>。</p>
<p><strong>将结构体作为参数传入</strong></p>
<p>由于结构体的存储指针可以以参数的方式传递给一个 <code>private</code> 或 <code>internal</code> 的函数，因此结构体可以在多个函数之间相互传递。</p>
<p>遵循这样的语法：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function _doStuff(Zombie storage _zombie) internal {</span><br><span class="line">  // do stuff with _zombie</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这样我们可以将某僵尸的引用直接传递给一个函数，而不用是通过参数传入僵尸ID后，函数再依据ID去查找。</p>
<p><strong>实战演习</strong></p>
<ol>
<li>先定义一个 <code>_triggerCooldown</code> 函数。它要求一个参数，<code>_zombie</code>，表示一某个僵尸的存储指针。这个函数可见性设置为 <code>internal</code>。</li>
<li>在函数中，把 <code>_zombie.readyTime</code> 设置为 <code>uint32（now + cooldownTime）</code>。</li>
<li>接下来，创建一个名为 <code>_isReady</code> 的函数。这个函数的参数也是名为 <code>_zombie</code> 的 <code>Zombie storage</code>。这个功能只具有 <code>internal</code> 可见性，并返回一个 <code>bool</code> 值。</li>
<li>函数计算返回<code>(_zombie.readyTime &lt;= now)</code>，值为 <code>true</code> 或 <code>false</code>。这个功能的目的是判断下次允许猎食的时间是否已经到了。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 1. 在这里定义 `_triggerCooldown` 函数</span><br><span class="line">  function _triggerCooldown(Zombie storage _zombie) internal {</span><br><span class="line">    _zombie.readyTime = uint32(now + cooldownTime);</span><br><span class="line">  }</span><br><span class="line">  // 2. 在这里定义 `_isReady` 函数</span><br><span class="line">  function _isReady(Zombie storage _zombie) internal view returns(bool){</span><br><span class="line">    return (_zombie.readyTime &lt;= now);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第7章-公有函数和安全性"><a href="#第7章-公有函数和安全性" class="headerlink" title="第7章: 公有函数和安全性"></a>第7章: 公有函数和安全性</h3><p>现在来修改 <code>feedAndMultiply</code> ，实现冷却周期。</p>
<p>回顾一下这个函数，前一课上我们将其可见性设置为<code>public</code>。你必须仔细地检查所有声明为 <code>public</code> 和 <code>external</code>的函数，一个个排除用户滥用它们的可能，谨防安全漏洞。请记住，如果这些函数没有类似 <code>onlyOwner</code> 这样的函数修饰符，用户能利用各种可能的参数去调用它们。</p>
<p>检查完这个函数，用户就可以直接调用这个它，并传入他们所希望的 <code>_targetDna</code> 或 <code>species</code> 。打个游戏还得遵循这么多的规则，还能不能愉快地玩耍啊！</p>
<p>仔细观察，这个函数只需被 <code>feedOnKitty()</code> 调用，因此，想要防止漏洞，最简单的方法就是设其可见性为 <code>internal</code>。</p>
<p><strong>实战演习</strong></p>
<ol>
<li>目前函数 <code>feedAndMultiply</code> 可见性为 <code>public</code>。我们将其改为 <code>internal</code> 以保障合约安全。因为我们不希望用户调用它的时候塞进一堆乱七八糟的 DNA。</li>
<li><code>feedAndMultiply</code> 过程需要参考 <code>cooldownTime</code>。首先，在找到 <code>myZombie</code> 之后，添加一个 <code>require</code> 语句来检查 <code>_isReady()</code> 并将 <code>myZombie</code> 传递给它。这样用户必须等到僵尸的 <code>冷却周期</code> 结束后才能执行 <code>feedAndMultiply</code> 功能。</li>
<li>在函数结束时，调用 <code>_triggerCooldown(myZombie)</code>，标明捕猎行为触发了僵尸新的冷却周期。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 1. 使这个函数的可见性为 internal</span><br><span class="line">  function feedAndMultiply(uint _zombieId, uint _targetDna, string species) internal {</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    // 2. 在这里为 `_isReady` 增加一个检查</span><br><span class="line">    require(_isReady(myZombie));</span><br><span class="line">    _targetDna = _targetDna % dnaModulus;</span><br><span class="line">    uint newDna = (myZombie.dna + _targetDna) / 2;</span><br><span class="line">    if (keccak256(species) == keccak256("kitty")) {</span><br><span class="line">      newDna = newDna - newDna % 100 + 99;</span><br><span class="line">    }</span><br><span class="line">    _createZombie("NoName", newDna);</span><br><span class="line">    // 3. 调用 `_triggerCooldown`</span><br><span class="line">    _triggerCooldown(myZombie);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第8章-进一步了解函数修饰符"><a href="#第8章-进一步了解函数修饰符" class="headerlink" title="第8章: 进一步了解函数修饰符"></a>第8章: 进一步了解函数修饰符</h3><p>相当不错！我们的僵尸现在有了“冷却定时器”功能。</p>
<p>接下来，我们将添加一些辅助方法。我们为您创建了一个名为 <code>zombiehelper.sol</code> 的新文件，并且将 <code>zombiefeeding.sol</code> 导入其中，这让我们的代码更整洁。</p>
<p>我们打算让僵尸在达到一定水平后，获得特殊能力。但是达到这个小目标，我们还需要学一学什么是“函数修饰符”。</p>
<p><strong>带参数的函数修饰符</strong></p>
<p>之前我们已经读过一个简单的函数修饰符了：<code>onlyOwner</code>。函数修饰符也可以带参数。例如：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 存储用户年龄的映射</span><br><span class="line">mapping (uint =&gt; uint) public age;</span><br><span class="line"></span><br><span class="line">// 限定用户年龄的修饰符</span><br><span class="line">modifier olderThan(uint _age, uint _userId) {</span><br><span class="line">  require(age[_userId] &gt;= _age);</span><br><span class="line">  _;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 必须年满16周岁才允许开车 (至少在美国是这样的).</span><br><span class="line">// 我们可以用如下参数调用`olderThan` 修饰符:</span><br><span class="line">function driveCar(uint _userId) public olderThan(16, _userId) {</span><br><span class="line">  // 其余的程序逻辑</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>看到了吧， <code>olderThan</code> 修饰符可以像函数一样接收参数，是“宿主”函数 <code>driveCar</code> 把参数传递给它的修饰符的。</p>
<p>来，我们自己生产一个修饰符，通过传入的<code>level</code>参数来限制僵尸使用某些特殊功能。</p>
<p><strong>实战演习</strong></p>
<ol>
<li>在<code>ZombieHelper</code> 中，创建一个名为 <code>aboveLevel</code> 的<code>modifier</code>，它接收2个参数， <code>_level</code> (<code>uint</code>类型) 以及 <code>_zombieId</code> (<code>uint</code>类型)。</li>
<li>运用函数逻辑确保僵尸 <code>zombies[_zombieId].level</code> 大于或等于 <code>_level</code>。</li>
<li>记住，修饰符的最后一行为 <code>_;</code>，表示修饰符调用结束后返回，并执行调用函数余下的部分。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import "./zombiefeeding.sol";</span><br><span class="line"></span><br><span class="line">contract ZombieHelper is ZombieFeeding {</span><br><span class="line"></span><br><span class="line">  // 在这里开始</span><br><span class="line">  modifier aboveLevel(uint _level, uint _zombieId){</span><br><span class="line">    require(zombies[_zombieId].level &gt;= _level);</span><br><span class="line">    _;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第9章-僵尸修饰符"><a href="#第9章-僵尸修饰符" class="headerlink" title="第9章: 僵尸修饰符"></a>第9章: 僵尸修饰符</h3><p>现在让我们设计一些使用 <code>aboveLevel</code> 修饰符的函数。</p>
<p>作为游戏，您得有一些措施激励玩家们去升级他们的僵尸：</p>
<ul>
<li>2级以上的僵尸，玩家可给他们改名。</li>
<li>20级以上的僵尸，玩家能给他们定制的 DNA。</li>
</ul>
<p>是实现这些功能的时候了。以下是上一课的示例代码，供参考：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 存储用户年龄的映射</span><br><span class="line">mapping (uint =&gt; uint) public age;</span><br><span class="line"></span><br><span class="line">// 限定用户年龄的修饰符</span><br><span class="line">modifier olderThan(uint _age, uint _userId) {</span><br><span class="line">  require (age[_userId] &gt;= _age);</span><br><span class="line">  _;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 必须年满16周岁才允许开车 (至少在美国是这样的).</span><br><span class="line">// 我们可以用如下参数调用`olderThan` 修饰符:</span><br><span class="line">function driveCar(uint _userId) public olderThan(16, _userId) {</span><br><span class="line">  // 其余的程序逻辑</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实战演习</strong></p>
<ol>
<li>创建一个名为 <code>changeName</code> 的函数。它接收2个参数：<code>_zombieId</code>（<code>uint</code>类型）以及 <code>_newName</code>（<code>string</code>类型），可见性为 <code>external</code>。它带有一个 <code>aboveLevel</code> 修饰符，调用的时候通过 <code>_level</code> 参数传入<code>2</code>， 当然，别忘了同时传 <code>_zombieId</code> 参数。</li>
<li>在这个函数中，首先我们用 <code>require</code> 语句，验证 <code>msg.sender</code> 是否就是 <code>zombieToOwner [_zombieId]</code>。</li>
<li>然后函数将 <code>zombies[_zombieId] .name</code> 设置为 <code>_newName</code>。</li>
<li>在 <code>changeName</code> 下创建另一个名为 <code>changeDna</code> 的函数。它的定义和内容几乎和 <code>changeName</code> 相同，不过它第二个参数是 <code>_newDna</code>（<code>uint</code>类型），在修饰符 <code>aboveLevel</code> 的 <code>_level</code> 参数中传递 <code>20</code> 。现在，他可以把僵尸的 <code>dna</code> 设置为 <code>_newDna</code> 了。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 在这里开始</span><br><span class="line">  function changeName(uint _zombieId, string _newName) external aboveLevel(2, _zombieId){</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    zombies[_zombieId].name = _newName;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  function changeDna(uint _zombieId, uint _newDna) external aboveLevel(20, _zombieId){</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    zombies[_zombieId].dna = _newDna;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第10章-利用-‘View’-函数节省-Gas"><a href="#第10章-利用-‘View’-函数节省-Gas" class="headerlink" title="第10章: 利用 ‘View’ 函数节省 Gas"></a>第10章: 利用 ‘View’ 函数节省 Gas</h3><p>酷炫！现在高级别僵尸可以拥有特殊技能了，这一定会鼓动我们的玩家去打怪升级的。你喜欢的话，回头我们还能添加更多的特殊技能。</p>
<p>现在需要添加的一个功能是：我们的 DApp 需要一个方法来查看某玩家的整个僵尸军团 - 我们称之为 <code>getZombiesByOwner</code>。</p>
<p>实现这个功能只需从区块链中读取数据，所以它可以是一个 <code>view</code> 函数。这让我们不得不回顾一下“gas优化”这个重要话题。</p>
<p><strong>“view” 函数不花 “gas”</strong></p>
<p>当玩家从外部调用一个<code>view</code>函数，是不需要支付一分 gas 的。</p>
<p>这是因为 <code>view</code> 函数不会真正改变区块链上的任何数据 - 它们只是读取。因此用 <code>view</code> 标记一个函数，意味着告诉 <code>web3.js</code>，运行这个函数只需要查询你的本地以太坊节点，而不需要在区块链上创建一个事务（事务需要运行在每个节点上，因此花费 gas）。</p>
<p>稍后我们将介绍如何在自己的节点上设置 web3.js。但现在，你关键是要记住，在所能只读的函数上标记上表示“只读”的“<code>external view</code> 声明，就能为你的玩家减少在 DApp 中 gas 用量。</p>
<blockquote>
<p>注意：如果一个 <code>view</code> 函数在另一个函数的内部被调用，而调用函数与 <code>view</code> 函数的不属于同一个合约，也会产生调用成本。这是因为如果主调函数在以太坊创建了一个事务，它仍然需要逐个节点去验证。所以标记为 <code>view</code> 的函数只有在外部调用时才是免费的。</p>
</blockquote>
<p><strong>实战演习</strong></p>
<p>我们来写一个”返回某玩家的整个僵尸军团“的函数。当我们从 <code>web3.js</code> 中调用它，即可显示某一玩家的个人资料页。</p>
<p>这个函数的逻辑有点复杂，我们需要好几个章节来描述它的实现。</p>
<ol>
<li>创建一个名为 <code>getZombiesByOwner</code> 的新函数。它有一个名为 <code>_owner</code> 的 <code>address</code> 类型的参数。</li>
<li>将其申明为 <code>external view</code> 函数，这样当玩家从 <code>web3.js</code> 中调用它时，不需要花费任何 gas。</li>
<li>函数需要返回一个<code>uint []</code>（<code>uint</code>数组）。</li>
</ol>
<p>先这么声明着，我们将在下一章中填充函数体。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 在这里创建你的函数</span><br><span class="line"> function getZombiesByOwner(address _owner) external view returns(uint[]){</span><br><span class="line"></span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第11章-存储非常昂贵"><a href="#第11章-存储非常昂贵" class="headerlink" title="第11章: 存储非常昂贵"></a>第11章: 存储非常昂贵</h3><p>Solidity 使用<code>storage</code>(存储)是相当昂贵的，”写入“操作尤其贵。</p>
<p>这是因为，无论是写入还是更改一段数据， 这都将永久性地写入区块链。”永久性“啊！需要在全球数千个节点的硬盘上存入这些数据，随着区块链的增长，拷贝份数更多，存储量也就越大。这是需要成本的！</p>
<p>为了降低成本，不到万不得已，避免将数据写入存储。这也会导致效率低下的编程逻辑 - 比如每次调用一个函数，都需要在 <code>memory</code>(内存) 中重建一个数组，而不是简单地将上次计算的数组给存储下来以便快速查找。</p>
<p>在大多数编程语言中，遍历大数据集合都是昂贵的。但是在 Solidity 中，使用一个标记了<code>external view</code>的函数，遍历比 <code>storage</code> 要便宜太多，因为 <code>view</code> 函数不会产生任何花销。 （gas可是真金白银啊！）。</p>
<p>我们将在下一章讨论<code>for</code>循环，现在我们来看一下看如何如何在内存中声明数组。</p>
<p><strong>在内存中声明数组</strong></p>
<p>在数组后面加上 <code>memory</code>关键字， 表明这个数组是仅仅在内存中创建，不需要写入外部存储，并且在函数调用结束时它就解散了。与在程序结束时把数据保存进 <code>storage</code> 的做法相比，内存运算可以大大节省gas开销 – 把这数组放在<code>view</code>里用，完全不用花钱。</p>
<p>以下是申明一个内存数组的例子：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function getArray() external pure returns(uint[]) {</span><br><span class="line">  // 初始化一个长度为3的内存数组</span><br><span class="line">  uint[] memory values = new uint[](3);</span><br><span class="line">  // 赋值</span><br><span class="line">  values.push(1);</span><br><span class="line">  values.push(2);</span><br><span class="line">  values.push(3);</span><br><span class="line">  // 返回数组</span><br><span class="line">  return values;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个小例子展示了一些语法规则，下一章中，我们将通过一个实际用例，展示它和 <code>for</code> 循环结合的做法。</p>
<blockquote>
<p>注意：内存数组 <strong>必须</strong> 用长度参数（在本例中为<code>3</code>）创建。目前不支持 <code>array.push()</code>之类的方法调整数组大小，在未来的版本可能会支持长度修改。</p>
</blockquote>
<p><strong>实战演习</strong></p>
<p>我们要要创建一个名为 <code>getZombiesByOwner</code> 的函数，它以<code>uint []</code>数组的形式返回某一用户所拥有的所有僵尸。</p>
<ol>
<li>声明一个名为<code>result</code>的<code>uint [] memory'</code> （内存变量数组）</li>
<li>将其设置为一个新的 <code>uint</code> 类型数组。数组的长度为该 <code>_owner</code> 所拥有的僵尸数量，这可通过调用 <code>ownerZombieCount [_ owner]</code> 来获取。</li>
<li>函数结束，返回 <code>result</code> 。目前它只是个空数列，我们到下一章去实现它。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function getZombiesByOwner(address _owner) external view returns(uint[]) {</span><br><span class="line">    // 在这里开始</span><br><span class="line">    uint[] memory result = new uint[](ownerZombieCount[_owner]);</span><br><span class="line">    return result;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第12章-For-循环"><a href="#第12章-For-循环" class="headerlink" title="第12章: For 循环"></a>第12章: For 循环</h3><p>在之前的章节中，我们提到过，函数中使用的数组是运行时在内存中通过 <code>for</code> 循环实时构建，而不是预先建立在存储中的。</p>
<p>为什么要这样做呢？</p>
<p>为了实现 <code>getZombiesByOwner</code> 函数，一种“无脑式”的解决方案是在 <code>ZombieFactory</code> 中存入”主人“和”僵尸军团“的映射。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapping (address =&gt; uint[]) public ownerToZombies</span><br></pre></td></tr></tbody></table></figure>

<p>然后我们每次创建新僵尸时，执行 <code>ownerToZombies [owner] .push（zombieId）</code> 将其添加到主人的僵尸数组中。而 <code>getZombiesByOwner</code> 函数也非常简单：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function getZombiesByOwner(address _owner) external view returns (uint[]) {</span><br><span class="line">  return ownerToZombies[_owner];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>这个做法有问题</strong></p>
<p>做法倒是简单。可是如果我们需要一个函数来把一头僵尸转移到另一个主人名下（我们一定会在后面的课程中实现的），又会发生什么？</p>
<p>这个“换主”函数要做到：</p>
<p>1.将僵尸push到新主人的 <code>ownerToZombies</code> 数组中， 2.从旧主的 <code>ownerToZombies</code> 数组中移除僵尸， 3.将旧主僵尸数组中“换主僵尸”之后的的每头僵尸都往前挪一位，把挪走“换主僵尸”后留下的“空槽”填上， 4.将数组长度减1。</p>
<p>但是第三步实在是太贵了！因为每挪动一头僵尸，我们都要执行一次写操作。如果一个主人有20头僵尸，而第一头被挪走了，那为了保持数组的顺序，我们得做19个写操作。</p>
<p>由于写入存储是 Solidity 中最费 gas 的操作之一，使得换主函数的每次调用都非常昂贵。更糟糕的是，每次调用的时候花费的 gas 都不同！具体还取决于用户在原主军团中的僵尸头数，以及移走的僵尸所在的位置。以至于用户都不知道应该支付多少 gas。</p>
<blockquote>
<p>注意：当然，我们也可以把数组中最后一个僵尸往前挪来填补空槽，并将数组长度减少一。但这样每做一笔交易，都会改变僵尸军团的秩序。</p>
</blockquote>
<p>由于从外部调用一个 <code>view</code> 函数是免费的，我们也可以在 <code>getZombiesByOwner</code> 函数中用一个for循环遍历整个僵尸数组，把属于某个主人的僵尸挑出来构建出僵尸数组。那么我们的 <code>transfer</code> 函数将会便宜得多，因为我们不需要挪动存储里的僵尸数组重新排序，总体上这个方法会更便宜，虽然有点反直觉。</p>
<p><strong>使用 <code>for</code> 循环</strong></p>
<p><code>for</code>循环的语法在 Solidity 和 JavaScript 中类似。</p>
<p>来看一个创建偶数数组的例子：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function getEvens() pure external returns(uint[]) {</span><br><span class="line">  uint[] memory evens = new uint[](5);</span><br><span class="line">  // 在新数组中记录序列号</span><br><span class="line">  uint counter = 0;</span><br><span class="line">  // 在循环从1迭代到10：</span><br><span class="line">  for (uint i = 1; i &lt;= 10; i++) {</span><br><span class="line">    // 如果 `i` 是偶数...</span><br><span class="line">    if (i % 2 == 0) {</span><br><span class="line">      // 把它加入偶数数组</span><br><span class="line">      evens[counter] = i;</span><br><span class="line">      //索引加一， 指向下一个空的‘even’</span><br><span class="line">      counter++;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  return evens;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个函数将返回一个形为 <code>[2,4,6,8,10]</code> 的数组。</p>
<p><strong>实战演习</strong></p>
<p>我们回到 <code>getZombiesByOwner</code> 函数， 通过一条 <code>for</code> 循环来遍历 DApp 中所有的僵尸， 将给定的‘用户id’与每头僵尸的‘主人’进行比较，并在函数返回之前将它们推送到我们的<code>result</code> 数组中。</p>
<p>1.声明一个变量 <code>counter</code>，属性为 <code>uint</code>，设其值为 <code>0</code> 。我们用这个变量作为 <code>result</code> 数组的索引。</p>
<p>2.声明一个 <code>for</code> 循环， 从 <code>uint i = 0</code> 到 <code>i &lt;zombies.length</code>。它将遍历数组中的每一头僵尸。</p>
<p>3.在每一轮 <code>for</code> 循环中，用一个 <code>if</code> 语句来检查 <code>zombieToOwner [i]</code> 是否等于 <code>_owner</code>。这会比较两个地址是否匹配。</p>
<p>4.在 <code>if</code> 语句中：</p>
<ol>
<li>通过将 <code>result [counter]</code> 设置为 <code>i</code>，将僵尸ID添加到 <code>result</code> 数组中。</li>
<li>将counter加1（参见上面的for循环示例）。</li>
</ol>
<p>就是这样 - 这个函数能返回 <code>_owner</code> 所拥有的僵尸数组，不花一分钱 gas。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function getZombiesByOwner(address _owner) external view returns(uint[]) {</span><br><span class="line">    uint[] memory result = new uint[](ownerZombieCount[_owner]);</span><br><span class="line">    // 在这里开始</span><br><span class="line">    uint counter = 0;</span><br><span class="line">    for(uint i = 0; i &lt;zombies.length; i++){</span><br><span class="line">      if(zombieToOwner[i] == _owner){</span><br><span class="line">        result[counter] = i;</span><br><span class="line">        counter++;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    return result;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第13章-放在一起"><a href="#第13章-放在一起" class="headerlink" title="第13章: 放在一起"></a>第13章: 放在一起</h3><p>恭喜您啊，居然把第三课也学完了！</p>
<p><strong>让我们回顾一下：</strong></p>
<ul>
<li>添加了一种新方法来修改CryptoKitties合约</li>
<li>学会使用 <code>onlyOwner</code> 进行调用权限限制</li>
<li>了解了 gas 和 gas 的优化</li>
<li>为僵尸添加了 “级别” 和 “冷却周期”属性</li>
<li>当僵尸达到一定级别时，允许修改僵尸的名字和 DNA</li>
<li>最后，定义了一个函数，用以返回某个玩家的僵尸军团</li>
</ul>
<p><strong>领奖时间</strong></p>
<p>作为完成第三课的奖励，您的两个僵尸都已经升级了！</p>
<p>现在 NoName（你在第2课创建的小猫僵尸）已经升级到第2级，你可以调用 <code>changeName</code> 给它取个名字。 终于不再是无名之辈了！</p>
<p>去给您的 NoName 取个名字吧，等你做完下一章，本课程就结束了。</p>
<h2 id="lesson4-僵尸作战系统"><a href="#lesson4-僵尸作战系统" class="headerlink" title="lesson4 僵尸作战系统"></a>lesson4 僵尸作战系统</h2><h3 id="第1章-可支付"><a href="#第1章-可支付" class="headerlink" title="第1章: 可支付"></a>第1章: 可支付</h3><p>截至目前，我们只接触到很少的 <strong>函数修饰符</strong>。 要记住所有的东西很难，所以我们来个概览：</p>
<ol>
<li>我们有决定函数何时和被谁调用的可见性修饰符: <code>private</code> 意味着它只能被合约内部调用； <code>internal</code> 就像 <code>private</code> 但是也能被继承的合约调用； <code>external</code> 只能从合约外部调用；最后 <code>public</code> 可以在任何地方调用，不管是内部还是外部。</li>
<li>我们也有状态修饰符， 告诉我们函数如何和区块链交互: <code>view</code> 告诉我们运行这个函数不会更改和保存任何数据； <code>pure</code> 告诉我们这个函数不但不会往区块链写数据，它甚至不从区块链读取数据。这两种在被从合约外部调用的时候都不花费任何gas（但是它们在被内部其他函数调用的时候将会耗费gas）。</li>
<li>然后我们有了自定义的 <code>modifiers</code>，例如在第三课学习的: <code>onlyOwner</code> 和 <code>aboveLevel</code>。 对于这些修饰符我们可以自定义其对函数的约束逻辑。</li>
</ol>
<p>这些修饰符可以同时作用于一个函数定义上：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function test() external view onlyOwner anotherModifier { /* ... */ }</span><br></pre></td></tr></tbody></table></figure>

<p>在这一章，我们来学习一个新的修饰符 <code>payable</code>.</p>
<p><strong><code>payable</code> 修饰符</strong></p>
<p><code>payable</code> 方法是让 Solidity 和以太坊变得如此酷的一部分 —— 它们是一种可以接收以太的特殊函数。</p>
<p>先放一下。当你在调用一个普通网站服务器上的API函数的时候，你无法用你的函数传送美元——你也不能传送比特币。</p>
<p>但是在以太坊中， 因为钱 (<em>以太</em>), 数据 (<em>事务负载</em>)， 以及合约代码本身都存在于以太坊。你可以在同时调用函数 <strong>并</strong>付钱给另外一个合约。</p>
<p>这就允许出现很多有趣的逻辑， 比如向一个合约要求支付一定的钱来运行一个函数。</p>
<p><strong>来看个例子</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">contract OnlineStore {</span><br><span class="line">  function buySomething() external payable {</span><br><span class="line">    // 检查以确定0.001以太发送出去来运行函数:</span><br><span class="line">    require(msg.value == 0.001 ether);</span><br><span class="line">    // 如果为真，一些用来向函数调用者发送数字内容的逻辑</span><br><span class="line">    transferThing(msg.sender);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在这里，<code>msg.value</code> 是一种可以查看向合约发送了多少以太的方法，另外 <code>ether</code> 是一个內建单元。</p>
<p>这里发生的事是，一些人会从 web3.js 调用这个函数 (从DApp的前端)， 像这样 :</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 假设 `OnlineStore` 在以太坊上指向你的合约:</span><br><span class="line">OnlineStore.buySomething().send(from: web3.eth.defaultAccount, value: web3.utils.toWei(0.001))</span><br></pre></td></tr></tbody></table></figure>

<p>注意这个 <code>value</code> 字段， JavaScript 调用来指定发送多少(0.001)<code>以太</code>。如果把事务想象成一个信封，你发送到函数的参数就是信的内容。 添加一个 <code>value</code> 很像在信封里面放钱 —— 信件内容和钱同时发送给了接收者。</p>
<blockquote>
<p>注意： 如果一个函数没标记为<code>payable</code>， 而你尝试利用上面的方法发送以太，函数将拒绝你的事务。</p>
</blockquote>
<p><strong>实战演习</strong></p>
<p>我们来在僵尸游戏里面创建一个<code>payable</code> 函数。</p>
<p>假定在我们的游戏中，玩家可以通过支付ETH来升级他们的僵尸。ETH将存储在你拥有的合约中 —— 一个简单明了的例子，向你展示你可以通过自己的游戏赚钱。</p>
<ol>
<li>定义一个 <code>uint</code> ，命名为 <code>levelUpFee</code>, 将值设定为 <code>0.001 ether</code>。</li>
<li>定义一个名为 <code>levelUp</code> 的函数。 它将接收一个 <code>uint</code> 参数 <code>_zombieId</code>。 函数应该修饰为 <code>external</code> 以及 <code>payable</code>。</li>
<li>这个函数首先应该 <code>require</code> 确保 <code>msg.value</code> 等于 <code>levelUpFee</code>。</li>
<li>然后它应该增加僵尸的 <code>level</code>: <code>zombies[_zombieId].level++</code>。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 1. 在这里定义 levelUpFee</span><br><span class="line">  uint levelUpFee = 0.001 ether;</span><br><span class="line"></span><br><span class="line">  modifier aboveLevel(uint _level, uint _zombieId) {</span><br><span class="line">    require(zombies[_zombieId].level &gt;= _level);</span><br><span class="line">    _;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  // 2. 在这里插入 levelUp 函数 </span><br><span class="line">  function levelUp(uint _zombieId) external payable {</span><br><span class="line">    require(msg.value == levelUpFee);</span><br><span class="line">    zombies[_zombieId].level++;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第2章-提现"><a href="#第2章-提现" class="headerlink" title="第2章: 提现"></a>第2章: 提现</h3><p>在上一章，我们学习了如何向合约发送以太，那么在发送之后会发生什么呢？</p>
<p>在你发送以太之后，它将被存储进以合约的以太坊账户中， 并冻结在哪里 —— 除非你添加一个函数来从合约中把以太提现。</p>
<p>你可以写一个函数来从合约中提现以太，类似这样：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">contract GetPaid is Ownable {</span><br><span class="line">  function withdraw() external onlyOwner {</span><br><span class="line">    owner.transfer(this.balance);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注意我们使用 <code>Ownable</code> 合约中的 <code>owner</code> 和 <code>onlyOwner</code>，假定它已经被引入了。</p>
<p>你可以通过 <code>transfer</code> 函数向一个地址发送以太， 然后 <code>this.balance</code> 将返回当前合约存储了多少以太。 所以如果100个用户每人向我们支付1以太， <code>this.balance</code> 将是100以太。</p>
<p>你可以通过 <code>transfer</code> 向任何以太坊地址付钱。 比如，你可以有一个函数在 <code>msg.sender</code> 超额付款的时候给他们退钱：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint itemFee = 0.001 ether;</span><br><span class="line">msg.sender.transfer(msg.value - itemFee);</span><br></pre></td></tr></tbody></table></figure>

<p>或者在一个有卖家和卖家的合约中， 你可以把卖家的地址存储起来， 当有人买了它的东西的时候，把买家支付的钱发送给它 <code>seller.transfer(msg.value)</code>。</p>
<p>有很多例子来展示什么让以太坊编程如此之酷 —— 你可以拥有一个不被任何人控制的去中心化市场。</p>
<p><strong>实战演习</strong></p>
<ol>
<li><p>在我们的合约里创建一个 <code>withdraw</code> 函数，它应该几乎和上面的<code>GetPaid</code>一样。</p>
</li>
<li><p>以太的价格在过去几年内翻了十几倍，在我们写这个教程的时候 0.01 以太相当于1美元，如果它再翻十倍 0.001 以太将是10美元，那我们的游戏就太贵了。</p>
<p> 所以我们应该再创建一个函数，允许我们以合约拥有者的身份来设置 <code>levelUpFee</code>。</p>
<p> a. 创建一个函数，名为 <code>setLevelUpFee</code>， 其接收一个参数 <code>uint _fee</code>，是 <code>external</code> 并使用修饰符 <code>onlyOwner</code>。</p>
<p> b. 这个函数应该设置 <code>levelUpFee</code> 等于 <code>_fee</code>。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 1. 在这里创建 withdraw 函数</span><br><span class="line">  function withdraw() external onlyOwner {</span><br><span class="line">    owner.transfer(this.balance);</span><br><span class="line">  }</span><br><span class="line">  // 2. 在这里创建 setLevelUpFee 函数 </span><br><span class="line">  function setLevelUpFee(uint _fee) external onlyOwner {</span><br><span class="line">    levelUpFee = _fee;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第3章-僵尸战斗"><a href="#第3章-僵尸战斗" class="headerlink" title="第3章: 僵尸战斗"></a>第3章: 僵尸战斗</h3><p>在我们学习了可支付函数和合约余额之后，是时候为僵尸战斗添加功能了。</p>
<p>遵循上一章的格式，我们新建一个攻击功能合约，并将代码放进新的文件中，引入上一个合约。</p>
<p><strong>实战演习</strong></p>
<p>再来新建一个合约吧。熟能生巧。</p>
<p>如果你不记得怎么做了, 查看一下 <code>zombiehelper.sol</code> — 不过最好先试着做一下，检查一下你掌握的情况。</p>
<ol>
<li>在文件开头定义 Solidity 的版本 <code>^0.4.19</code>.</li>
<li><code>import</code> 自 <code>zombiehelper.sol</code> .</li>
<li>声明一个新的 <code>contract</code>，命名为 <code>ZombieBattle</code>， 继承自<code>ZombieHelper</code>。函数体就先空着吧。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import "./zombiehelper.sol";</span><br><span class="line"></span><br><span class="line">contract ZombieBattle is ZombieHelper{</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第4章-随机数"><a href="#第4章-随机数" class="headerlink" title="第4章: 随机数"></a>第4章: 随机数</h3><p>你太棒了！接下来我们梳理一下战斗逻辑。</p>
<p>优秀的游戏都需要一些随机元素，那么我们在 Solidity 里如何生成随机数呢？</p>
<p>真正的答案是你不能，或者最起码，你无法安全地做到这一点。</p>
<p>我们来看看为什么</p>
<p><strong>用 <code>keccak256</code> 来制造随机数</strong></p>
<p>Solidity 中最好的随机数生成器是 <code>keccak256</code> 哈希函数.</p>
<p>我们可以这样来生成一些随机数</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 生成一个0到100的随机数:</span><br><span class="line">uint randNonce = 0;</span><br><span class="line">uint random = uint(keccak256(now, msg.sender, randNonce)) % 100;</span><br><span class="line">randNonce++;</span><br><span class="line">uint random2 = uint(keccak256(now, msg.sender, randNonce)) % 100;</span><br></pre></td></tr></tbody></table></figure>

<p>这个方法首先拿到 <code>now</code> 的时间戳、 <code>msg.sender</code>、 以及一个自增数 <code>nonce</code> （一个仅会被使用一次的数，这样我们就不会对相同的输入值调用一次以上哈希函数了）。</p>
<p>然后利用 <code>keccak</code> 把输入的值转变为一个哈希值, 再将哈希值转换为 <code>uint</code>, 然后利用 <code>% 100</code> 来取最后两位, 就生成了一个0到100之间随机数了。</p>
<p><strong>这个方法很容易被不诚实的节点攻击</strong></p>
<p>在以太坊上, 当你在和一个合约上调用函数的时候, 你会把它广播给一个节点或者在网络上的 *<strong>transaction*</strong> 节点们。 网络上的节点将收集很多事务, 试着成为第一个解决计算密集型数学问题的人，作为“工作证明”，然后将“工作证明”(Proof of Work, PoW)和事务一起作为一个 *<strong>block*</strong> 发布在网络上。</p>
<p>一旦一个节点解决了一个PoW, 其他节点就会停止尝试解决这个 PoW, 并验证其他节点的事务列表是有效的，然后接受这个节点转而尝试解决下一个节点。</p>
<p><strong>这就让我们的随机数函数变得可利用了</strong></p>
<p>我们假设我们有一个硬币翻转合约——正面你赢双倍钱，反面你输掉所有的钱。假如它使用上面的方法来决定是正面还是反面 (<code>random &gt;= 50</code> 算正面, <code>random &lt; 50</code> 算反面)。</p>
<p>如果我正运行一个节点，我可以 <strong>只对我自己的节点</strong> 发布一个事务，且不分享它。 我可以运行硬币翻转方法来偷窥我的输赢 — 如果我输了，我就不把这个事务包含进我要解决的下一个区块中去。我可以一直运行这个方法，直到我赢得了硬币翻转并解决了下一个区块，然后获利。</p>
<p><strong>所以我们该如何在以太坊上安全地生成随机数呢</strong></p>
<p>因为区块链的全部内容对所有参与者来说是透明的， 这就让这个问题变得很难，它的解决方法不在本课程讨论范围，你可以阅读 <a target="_blank" rel="noopener" href="https://ethereum.stackexchange.com/questions/191/how-can-i-securely-generate-a-random-number-in-my-smart-contract">这个 StackOverflow 上的讨论</a> 来获得一些主意。 一个方法是利用 *<strong>oracle*</strong> 来访问以太坊区块链之外的随机数函数。</p>
<p>当然， 因为网络上成千上万的以太坊节点都在竞争解决下一个区块，我能成功解决下一个区块的几率非常之低。 这将花费我们巨大的计算资源来开发这个获利方法 — 但是如果奖励异常地高(比如我可以在硬币翻转函数中赢得 1个亿)， 那就很值得去攻击了。</p>
<p>所以尽管这个方法在以太坊上不安全，在实际中，除非我们的随机函数有一大笔钱在上面，你游戏的用户一般是没有足够的资源去攻击的。</p>
<p>因为在这个教程中，我们只是在编写一个简单的游戏来做演示，也没有真正的钱在里面，所以我们决定接受这个不足之处，使用这个简单的随机数生成函数。但是要谨记它是不安全的。</p>
<p><strong>实战演习</strong></p>
<p>我们来实现一个随机数生成函数，好来计算战斗的结果。虽然这个函数一点儿也不安全。</p>
<ol>
<li>给我们合约一个名为 <code>randNonce</code> 的 <code>uint</code>，将其值设置为 <code>0</code>。</li>
<li>建立一个函数，命名为 <code>randMod</code> (random-modulus)。它将作为<code>internal</code> 函数，传入一个名为 <code>_modulus</code>的 <code>uint</code>，并 <code>returns</code> 一个 <code>uint</code>。</li>
<li>这个函数首先将为 <code>randNonce</code>加一， (使用 <code>randNonce++</code> 语句)。</li>
<li>最后，它应该 (在一行代码中) 计算 <code>now</code>, <code>msg.sender</code>, 以及 <code>randNonce</code> 的 <code>keccak256</code> 哈希值并转换为 <code>uint</code>—— 最后 <code>return</code> <code>% _modulus</code> 的值。 （天! 听起来太拗口了。如果你有点理解不过来，看一下我们上面计算随机数的例子，它们的逻辑非常相似）</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">contract ZombieBattle is ZombieHelper {</span><br><span class="line">  // 在这里开始</span><br><span class="line">  uint randNonce = 0;</span><br><span class="line"></span><br><span class="line">  function randMod(uint _modulus) internal returns(uint){</span><br><span class="line">    randNonce++;</span><br><span class="line">    return uint(keccak256(now, msg.sender, randNonce)) % _modulus;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第5章-僵尸对战"><a href="#第5章-僵尸对战" class="headerlink" title="第5章: 僵尸对战"></a>第5章: 僵尸对战</h3><p>我们的合约已经有了一些随机性的来源，可以用进我们的僵尸战斗中去计算结果。</p>
<p>我们的僵尸战斗看起来将是这个流程：</p>
<ul>
<li>你选择一个自己的僵尸，然后选择一个对手的僵尸去攻击。</li>
<li>如果你是攻击方，你将有70%的几率获胜，防守方将有30%的几率获胜。</li>
<li>所有的僵尸（攻守双方）都将有一个 <code>winCount</code> 和一个 <code>lossCount</code>，这两个值都将根据战斗结果增长。</li>
<li>若攻击方获胜，这个僵尸将升级并产生一个新僵尸。</li>
<li>如果攻击方失败，除了失败次数将加一外，什么都不会发生。</li>
<li>无论输赢，当前僵尸的冷却时间都将被激活。</li>
</ul>
<p>这有一大堆的逻辑需要处理，我们将把这些步骤分解到接下来的课程中去。</p>
<p><strong>实战演习</strong></p>
<ol>
<li>给我们合约一个 <code>uint</code> 类型的变量，命名为 <code>attackVictoryProbability</code>, 将其值设定为 <code>70</code>。</li>
<li>创建一个名为 <code>attack</code>的函数。它将传入两个参数: <code>_zombieId</code> (<code>uint</code> 类型) 以及 <code>_targetId</code> (也是 <code>uint</code>)。它将是一个 <code>external</code> 函数。</li>
</ol>
<p>函数体先留空吧。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 在这里创建 attackVictoryProbability</span><br><span class="line">  uint attackVictoryProbability = 70;</span><br><span class="line">  function attack(uint _zombieId, uint _targetId) external{</span><br><span class="line">    </span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第6章-重构通用逻辑"><a href="#第6章-重构通用逻辑" class="headerlink" title="第6章: 重构通用逻辑"></a>第6章: 重构通用逻辑</h3><p>不管谁调用我们的 <code>attack</code> 函数 —— 我们想确保用户的确拥有他们用来攻击的僵尸。如果你能用其他人的僵尸来攻击将是一个很大的安全问题。</p>
<p>你能想一下我们如何添加一个检查步骤来看看调用这个函数的人就是他们传入的 <code>_zombieId</code> 的拥有者么？</p>
<p>想一想，看看你能不能自己找到一些答案。</p>
<p>花点时间…… 参考我们前面课程的代码来获得灵感。</p>
<p>答案在下面，在你有一些想法之前不要继续阅读。</p>
<p><strong>答案</strong></p>
<p>我们在前面的课程里面已经做过很多次这样的检查了。 在 <code>changeName()</code>, <code>changeDna()</code>, 和 <code>feedAndMultiply()</code>里，我们做过这样的检查：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(msg.sender == zombieToOwner[_zombieId]);</span><br></pre></td></tr></tbody></table></figure>

<p>这和我们 <code>attack</code> 函数将要用到的检查逻辑是相同的。 正因我们要多次调用这个检查逻辑，让我们把它移到它自己的 <code>modifier</code> 中来清理代码并避免重复编码。</p>
<p><strong>实战演习</strong></p>
<p>我们回到了 <code>zombiefeeding.sol</code>， 因为这是我们第一次调用检查逻辑的地方。让我们把它重构进它自己的 <code>modifier</code>。</p>
<ol>
<li><p>创建一个 <code>modifier</code>， 命名为 <code>ownerOf</code>。它将传入一个参数， <code>_zombieId</code> (一个 <code>uint</code>)。</p>
<p> 它的函数体应该 <code>require</code> <code>msg.sender</code> 等于 <code>zombieToOwner[_zombieId]</code>， 然后继续这个函数剩下的内容。 如果你忘记了修饰符的写法，可以参考 <code>zombiehelper.sol</code>。</p>
</li>
<li><p>将这个函数的 <code>feedAndMultiply</code> 定义修改为其使用修饰符 <code>ownerOf</code>。</p>
</li>
<li><p>现在我们使用 <code>modifier</code>了，你可以删除这行了： <code>require(msg.sender == zombieToOwner[_zombieId]);</code></p>
</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 1. 在这里创建 modifier</span><br><span class="line">  modifier ownerOf(uint _zombieId){</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    _;</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  // 2. 在函数定义时增加 modifier :</span><br><span class="line">  function feedAndMultiply(uint _zombieId, uint _targetDna, string _species) internal ownerOf(_zombieId){</span><br><span class="line">    // 3. 移除这一行</span><br><span class="line">    //require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    require(_isReady(myZombie));</span><br><span class="line">    _targetDna = _targetDna % dnaModulus;</span><br><span class="line">    uint newDna = (myZombie.dna + _targetDna) / 2;</span><br><span class="line">    if (keccak256(_species) == keccak256("kitty")) {</span><br><span class="line">      newDna = newDna - newDna % 100 + 99;</span><br><span class="line">    }</span><br><span class="line">    _createZombie("NoName", newDna);</span><br><span class="line">    _triggerCooldown(myZombie);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第7章-更多重构"><a href="#第7章-更多重构" class="headerlink" title="第7章: 更多重构"></a>第7章: 更多重构</h3><p>在 <code>zombiehelper.sol</code>里有几处地方，需要我们实现我们新的 <code>modifier</code>—— <code>ownerOf</code>。</p>
<p><strong>实战演习</strong></p>
<ol>
<li>修改 <code>changeName()</code> 使其使用 <code>ownerOf</code></li>
<li>修改 <code>changeDna()</code> 使其使用 <code>ownerOf</code></li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 1. 使用 `ownerOf` 修改这个函数:</span><br><span class="line">  function changeName(uint _zombieId, string _newName) external aboveLevel(2, _zombieId) ownerOf(_zombieId){</span><br><span class="line">    //require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    zombies[_zombieId].name = _newName;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  // 2. 对这个函数做同样的事:</span><br><span class="line">  function changeDna(uint _zombieId, uint _newDna) external aboveLevel(20, _zombieId) ownerOf(_zombieId){</span><br><span class="line">    //require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    zombies[_zombieId].dna = _newDna;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第8章-回到攻击！"><a href="#第8章-回到攻击！" class="headerlink" title="第8章: 回到攻击！"></a>第8章: 回到攻击！</h3><p>重构完成了，回到 <code>zombieattack.sol</code>。</p>
<p>继续来完善我们的 <code>attack</code> 函数， 现在我们有了 <code>ownerOf</code> 修饰符来用了。</p>
<p><strong>实战演习</strong></p>
<ol>
<li><p>将 <code>ownerOf</code> 修饰符添加到 <code>attack</code> 来确保调用者拥有<code>_zombieId</code>.</p>
</li>
<li><p>我们的函数所需要做的第一件事就是获得一个双方僵尸的 <code>storage</code> 指针， 这样我们才能很方便和它们交互：</p>
<p> a. 定义一个 <code>Zombie storage</code> 命名为 <code>myZombie</code>，使其值等于 <code>zombies[_zombieId]</code>。</p>
<p> b. 定义一个 <code>Zombie storage</code> 命名为 <code>enemyZombie</code>， 使其值等于 <code>zombies[_targetId]</code>。</p>
</li>
<li><p>我们将用一个0到100的随机数来确定我们的战斗结果。 定义一个 <code>uint</code>，命名为 <code>rand</code>， 设定其值等于 <code>randMod</code> 函数的返回值，此函数传入 <code>100</code>作为参数。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 1. 在这里增加 modifier</span><br><span class="line">  function attack(uint _zombieId, uint _targetId) external ownerOf(_zombieId){</span><br><span class="line">    // 2. 在这里开始定义函数</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    Zombie storage enemyZombie = zombies[_targetId];</span><br><span class="line">    uint rand = randMod(100);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第9章-僵尸的输赢"><a href="#第9章-僵尸的输赢" class="headerlink" title="第9章: 僵尸的输赢"></a>第9章: 僵尸的输赢</h3><p>对我们的僵尸游戏来说，我们将要追踪我们的僵尸输赢了多少场。有了这个我们可以在游戏里维护一个 “僵尸排行榜”。</p>
<p>有多种方法在我们的DApp里面保存一个数值 — 作为一个单独的映射，作为一个“排行榜”结构体，或者保存在 <code>Zombie</code> 结构体内。</p>
<p>每个方法都有其优缺点，取决于我们打算如何和这些数据打交道。在这个教程中，简单起见我们将这个状态保存在 <code>Zombie</code> 结构体中，将其命名为 <code>winCount</code> 和 <code>lossCount</code>。</p>
<p>我们跳回 <code>zombiefactory.sol</code>, 将这些属性添加进 <code>Zombie</code> 结构体.</p>
<p><strong>实战演习</strong></p>
<ol>
<li><p>修改 <code>Zombie</code> 结构体，添加两个属性:</p>
<p> a. <code>winCount</code>, 一个 <code>uint16</code></p>
<p> b. <code>lossCount</code>, 也是一个 <code>uint16</code></p>
<blockquote>
<p>注意： 记住, 因为我们能在结构体中包装<code>uint</code>, 我们打算用适合我们的最小的 <code>uint</code>。 一个 <code>uint8</code> 太小了， 因为 2^8 = 256 —— 如果我们的僵尸每天都作战，不到一年就溢出了。但是 2^16 = 65536 （<code>uint16</code>）—— 除非一个僵尸连续179年每天作战，否则我们就是安全的。</p>
</blockquote>
</li>
<li><p>现在我们的 <code>Zombie</code> 结构体有了新的属性， 我们需要修改 <code>_createZombie()</code> 中的函数定义。</p>
<p> 修改僵尸生成定义，让每个新僵尸都有 <code>0</code> 赢和 <code>0</code> 输。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct Zombie {</span><br><span class="line">      string name;</span><br><span class="line">      uint dna;</span><br><span class="line">      uint32 level;</span><br><span class="line">      uint32 readyTime;</span><br><span class="line">      // 1. 在这里添加新的属性</span><br><span class="line">      uint16 winCount;</span><br><span class="line">      uint16 lossCount;</span><br><span class="line">    }</span><br><span class="line">function _createZombie(string _name, uint _dna) internal {</span><br><span class="line">        // 2. 在这里修改修改新僵尸的创建:</span><br><span class="line">        uint id = zombies.push(Zombie(_name, _dna, 1, uint32(now + cooldownTime),0,0)) - 1;</span><br><span class="line">        zombieToOwner[id] = msg.sender;</span><br><span class="line">        ownerZombieCount[msg.sender]++;</span><br><span class="line">        NewZombie(id, _name, _dna);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第10章-僵尸胜利了-😄"><a href="#第10章-僵尸胜利了-😄" class="headerlink" title="第10章: 僵尸胜利了 😄"></a>第10章: 僵尸胜利了 😄</h3><p>有了 <code>winCount</code> 和 <code>lossCount</code>，我们可以根据僵尸哪个僵尸赢了战斗来更新它们了。</p>
<p>在第六章我们计算出来一个0到100的随机数。现在让我们用那个数来决定那谁赢了战斗，并以此更新我们的状态。</p>
<p><strong>实战演习</strong></p>
<ol>
<li><p>创建一个 <code>if</code> 语句来检查 <code>rand</code> 是不是 *<strong>小于或者等于*</strong> <code>attackVictoryProbability</code>。</p>
</li>
<li><p>如果以上条件为 <code>true</code>， 我们的僵尸就赢了！所以：</p>
<p> a. 增加 <code>myZombie</code> 的 <code>winCount</code>。</p>
<p> b. 增加 <code>myZombie</code> 的 <code>level</code>。 (升级了啦!!!!!!!)</p>
<p> c. 增加 <code>enemyZombie</code> 的 <code>lossCount</code>. (输家!!!!!! 😫 😫 😫)</p>
<p> d. 运行 <code>feedAndMultiply</code> 函数。 在 <code>zombiefeeding.sol</code> 里查看调用它的语句。 对于第三个参数 (<code>_species</code>)，传入字符串 “zombie”. （现在它实际上什么都不做，不过在稍后， 如果我们愿意，可以添加额外的方法，用来制造僵尸变的僵尸）。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function attack(uint _zombieId, uint _targetId) external ownerOf(_zombieId) {</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    Zombie storage enemyZombie = zombies[_targetId];</span><br><span class="line">    uint rand = randMod(100);</span><br><span class="line">    // 在这里开始</span><br><span class="line">    if(rand &lt;= attackVictoryProbability){</span><br><span class="line">      myZombie.winCount++;</span><br><span class="line">      myZombie.level++;</span><br><span class="line">      enemyZombie.lossCount++;</span><br><span class="line">      feedAndMultiply(_zombieId, enemyZombie.dna, "zombie");</span><br><span class="line">    }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第11章-僵尸失败-😞"><a href="#第11章-僵尸失败-😞" class="headerlink" title="第11章: 僵尸失败 😞"></a>第11章: 僵尸失败 😞</h3><p>我们已经编写了你的僵尸赢了之后会发生什么， 该看看 <strong>输了</strong> 的时候要怎么做了。</p>
<p>在我们的游戏中，僵尸输了后并不会降级 —— 只是简单地给 <code>lossCount</code> 加一，并触发冷却，等待一天后才能再次参战。</p>
<p>要实现这个逻辑，我们需要一个 <code>else</code> 语句。</p>
<p><code>else</code> 语句和 JavaScript 以及很多其他语言的 else 语句一样。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (zombieCoins[msg.sender] &gt; 100000000) {</span><br><span class="line">  // 你好有钱!!!</span><br><span class="line">} else {</span><br><span class="line">  // 我们需要更多的僵尸币...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实战演习</strong></p>
<ol>
<li><p>添加一个 <code>else</code> 语句。 若我们的僵尸输了：</p>
<p> a. 增加 <code>myZombie</code> 的 <code>lossCount</code>。</p>
<p> b. 增加 <code>enemyZombie</code> 的 <code>winCount</code>。</p>
</li>
<li><p>在 <code>else</code> 最后， 对 <code>myZombie</code> 运行 <code>_triggerCooldown</code> 方法。这让每个僵尸每天只能参战一次。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function attack(uint _zombieId, uint _targetId) external ownerOf(_zombieId) {</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    Zombie storage enemyZombie = zombies[_targetId];</span><br><span class="line">    uint rand = randMod(100);</span><br><span class="line">    if (rand &lt;= attackVictoryProbability) {</span><br><span class="line">      myZombie.winCount++;</span><br><span class="line">      myZombie.level++;</span><br><span class="line">      enemyZombie.lossCount++;</span><br><span class="line">      feedAndMultiply(_zombieId, enemyZombie.dna, "zombie");</span><br><span class="line">    } // 在这里开始</span><br><span class="line">    else{</span><br><span class="line">      myZombie.lossCount++;</span><br><span class="line">      enemyZombie.winCount++;</span><br><span class="line">      _triggerCooldown(myZombie);</span><br><span class="line">    }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h2 id="lesson5-ERC721-标准和加密收藏品"><a href="#lesson5-ERC721-标准和加密收藏品" class="headerlink" title="lesson5 ERC721 标准和加密收藏品"></a>lesson5 ERC721 标准和加密收藏品</h2><h3 id="第1章-以太坊上的代币"><a href="#第1章-以太坊上的代币" class="headerlink" title="第1章: 以太坊上的代币"></a>第1章: 以太坊上的代币</h3><p>让我们来聊聊 <strong>代币</strong>.</p>
<p>如果你对以太坊的世界有一些了解，你很可能听过人们聊到代币——尤其是 *<strong>ERC20 代币*</strong>.</p>
<p>一个 <strong><em>代币</em></strong> 在以太坊基本上就是一个遵循一些共同规则的智能合约——即它实现了所有其他代币合约共享的一组标准函数，例如 <code>transfer(address _to, uint256 _value)</code> 和 <code>balanceOf(address _owner)</code>.</p>
<p>在智能合约内部，通常有一个映射， <code>mapping(address =&gt; uint256) balances</code>，用于追踪每个地址还有多少余额。</p>
<p>所以基本上一个代币只是一个追踪谁拥有多少该代币的合约，和一些可以让那些用户将他们的代币转移到其他地址的函数。</p>
<p><strong>它为什么重要呢？</strong></p>
<p>由于所有 ERC20 代币共享具有相同名称的同一组函数，它们都可以以相同的方式进行交互。</p>
<p>这意味着如果你构建的应用程序能够与一个 ERC20 代币进行交互，那么它就也能够与任何 ERC20 代币进行交互。 这样一来，将来你就可以轻松地将更多的代币添加到你的应用中，而无需进行自定义编码。 你可以简单地插入新的代币合约地址，然后哗啦，你的应用程序有另一个它可以使用的代币了。</p>
<p>其中一个例子就是交易所。 当交易所添加一个新的 ERC20 代币时，实际上它只需要添加与之对话的另一个智能合约。 用户可以让那个合约将代币发送到交易所的钱包地址，然后交易所可以让合约在用户要求取款时将代币发送回给他们。</p>
<p>交易所只需要实现这种转移逻辑一次，然后当它想要添加一个新的 ERC20 代币时，只需将新的合约地址添加到它的数据库即可。</p>
<p><strong>其他代币标准</strong></p>
<p>对于像货币一样的代币来说，ERC20 代币非常酷。 但是要在我们僵尸游戏中代表僵尸就并不是特别有用。</p>
<p>首先，僵尸不像货币可以分割 —— 我可以发给你 0.237 以太，但是转移给你 0.237 的僵尸听起来就有些搞笑。</p>
<p>其次，并不是所有僵尸都是平等的。 你的2级僵尸”<strong>Steve</strong>“完全不能等同于我732级的僵尸”<strong>H4XF13LD MORRIS 💯💯😎💯💯</strong>“。（你差得远呢，<em>Steve</em>）。</p>
<p>有另一个代币标准更适合如 CryptoZombies 这样的加密收藏品——它们被称为*<strong>ERC721 代币.*</strong></p>
<p>*<strong>ERC721 代币*<strong>是</strong>不</strong>能互换的，因为每个代币都被认为是唯一且不可分割的。 你只能以整个单位交易它们，并且每个单位都有唯一的 ID。 这些特性正好让我们的僵尸可以用来交易。</p>
<blockquote>
<p>请注意，使用像 ERC721 这样的标准的优势就是，我们不必在我们的合约中实现拍卖或托管逻辑，这决定了玩家能够如何交易／出售我们的僵尸。 如果我们符合规范，其他人可以为加密可交易的 ERC721 资产搭建一个交易所平台，我们的 ERC721 僵尸将可以在该平台上使用。 所以使用代币标准相较于使用你自己的交易逻辑有明显的好处。</p>
</blockquote>
<p><strong>实战演习</strong></p>
<p>我们将在下一章深入讨论ERC721的实现。 但首先，让我们为本课设置我们的文件结构。</p>
<p>我们将把所有ERC721逻辑存储在一个叫<code>ZombieOwnership</code>的合约中。</p>
<ol>
<li>在文件顶部声明我们<code>pragma</code>的版本（格式参考之前的课程）。</li>
<li>将 <code>zombieattack.sol</code> <code>import</code> 进来。</li>
<li>声明一个继承 <code>ZombieAttack</code> 的新合约， 命名为<code>ZombieOwnership</code>。合约的其他部分先留空。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 从这里开始</span><br><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import "./zombieattack.sol";</span><br><span class="line"></span><br><span class="line">contract ZombieOwnership is ZombieAttack{</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第2章-ERC721-标准-多重继承"><a href="#第2章-ERC721-标准-多重继承" class="headerlink" title="第2章: ERC721 标准, 多重继承"></a>第2章: ERC721 标准, 多重继承</h3><p>让我们来看一看 ERC721 标准：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">contract ERC721 {</span><br><span class="line">  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);</span><br><span class="line">  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _owner) public view returns (uint256 _balance);</span><br><span class="line">  function ownerOf(uint256 _tokenId) public view returns (address _owner);</span><br><span class="line">  function transfer(address _to, uint256 _tokenId) public;</span><br><span class="line">  function approve(address _to, uint256 _tokenId) public;</span><br><span class="line">  function takeOwnership(uint256 _tokenId) public;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这是我们需要实现的方法列表，我们将在接下来的章节中逐个学习。</p>
<p>虽然看起来很多，但不要被吓到了！我们在这里就是准备带着你一步一步了解它们的。</p>
<blockquote>
<p>注意： ERC721目前是一个 <em>草稿</em>，还没有正式商定的实现。在本教程中，我们使用的是 OpenZeppelin 库中的当前版本，但在未来正式发布之前它可能会有更改。 所以把这 <strong>一个</strong> 可能的实现当作考虑，但不要把它作为 ERC721 代币的官方标准。</p>
</blockquote>
<p><strong>实现一个代币合约</strong></p>
<p>在实现一个代币合约的时候，我们首先要做的是将接口复制到它自己的 Solidity 文件并导入它，<code>import "./erc721.sol";</code>。 接着，让我们的合约继承它，然后我们用一个函数定义来重写每个方法。</p>
<p>但等一下—— <code>ZombieOwnership</code>已经继承自 <code>ZombieAttack</code>了 —— 它如何能够也继承于 <code>ERC721</code>呢？</p>
<p>幸运的是在Solidity，你的合约可以继承自多个合约，参考如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract SatoshiNakamoto is NickSzabo, HalFinney {</span><br><span class="line">  // 啧啧啧，宇宙的奥秘泄露了</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>正如你所见，当使用多重继承的时候，你只需要用逗号 <code>,</code> 来隔开几个你想要继承的合约。在上面的例子中，我们的合约继承自 <code>NickSzabo</code> 和 <code>HalFinney</code>。</p>
<p>来试试吧。</p>
<p><strong>实战演习</strong></p>
<p>我们已经在上面为你创建了带着接口的 <code>erc721.sol</code> 。</p>
<ol>
<li>将 <code>erc721.sol</code> 导入到 <code>zombieownership.sol</code></li>
<li>声明 <code>ZombieOwnership</code> 继承自 <code>ZombieAttack</code> 和 <code>ERC721</code></li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import "./zombieattack.sol";</span><br><span class="line">// 在这里引入文件</span><br><span class="line">import "./erc721.sol";</span><br><span class="line">// 在这里声明 ERC721 的继承</span><br><span class="line">contract ZombieOwnership is ZombieAttack, ERC721 {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第3章-balanceOf-和-ownerOf"><a href="#第3章-balanceOf-和-ownerOf" class="headerlink" title="第3章: balanceOf 和 ownerOf"></a>第3章: balanceOf 和 ownerOf</h3><p>太棒了，我们来深入讨论一下 ERC721 的实现。</p>
<p>我们已经把所有你需要在本课中实现的函数的空壳复制好了。</p>
<p>在本章节，我们将实现头两个方法： <code>balanceOf</code> 和 <code>ownerOf</code>。</p>
<p><strong><code>balanceOf</code></strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function balanceOf(address _owner) public view returns (uint256 _balance);</span><br></pre></td></tr></tbody></table></figure>

<p>这个函数只需要一个传入 <code>address</code> 参数，然后返回这个 <code>address</code> 拥有多少代币。</p>
<p>在我们的例子中，我们的“代币”是僵尸。你还记得在我们 DApp 的哪里存储了一个主人拥有多少只僵尸吗？</p>
<p> <strong><code>ownerOf</code></strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function ownerOf(uint256 _tokenId) public view returns (address _owner);</span><br></pre></td></tr></tbody></table></figure>

<p>这个函数需要传入一个代币 ID 作为参数 (我们的情况就是一个僵尸 ID)，然后返回该代币拥有者的 <code>address</code>。</p>
<p>同样的，因为在我们的 DApp 里已经有一个 <code>mapping</code> (映射) 存储了这个信息，所以对我们来说这个实现非常直接清晰。我们可以只用一行 <code>return</code> 语句来实现这个函数。</p>
<blockquote>
<p>注意：要记得， <code>uint256</code> 等同于<code>uint</code>。我们从课程的开始一直在代码中使用 <code>uint</code>，但从现在开始我们将在这里用 <code>uint256</code>，因为我们直接从规范中复制粘贴。</p>
</blockquote>
<p><strong>实战演习</strong></p>
<p>我将让你来决定如何实现这两个函数。</p>
<p>每个函数的代码都应该只有1行 <code>return</code> 语句。看看我们在之前课程中写的代码，想想我们都把这个数据存储在哪。如果你觉得有困难，你可以点“我要看答案”的按钮来获得帮助。</p>
<ol>
<li>实现 <code>balanceOf</code> 来返回 <code>_owner</code> 拥有的僵尸数量。</li>
<li>实现 <code>ownerOf</code> 来返回拥有 ID 为 <code>_tokenId</code> 僵尸的所有者的地址。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function balanceOf(address _owner) public view returns (uint256 _balance) {</span><br><span class="line">    // 1. 在这里返回 `_owner` 拥有的僵尸数</span><br><span class="line">    return ownerZombieCount[_owner];</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  function ownerOf(uint256 _tokenId) public view returns (address _owner) {</span><br><span class="line">    // 2. 在这里返回 `_tokenId` 的所有者</span><br><span class="line">    return zombieToOwner[_tokenId];</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第4章-重构"><a href="#第4章-重构" class="headerlink" title="第4章: 重构"></a>第4章: 重构</h3><p>嘿嘿！我们刚刚的代码中其实有个错误，以至于其根本无法通过编译，你发现了没？</p>
<p>在前一个章节我们定义了一个叫 <code>ownerOf</code> 的函数。但如果你还记得第4课的内容，我们同样在<code>zombiefeeding.sol</code> 里以 <code>ownerOf</code> 命名创建了一个 <code>modifier</code>（修饰符）。</p>
<p>如果你尝试编译这段代码，编译器会给你一个错误说你不能有相同名称的修饰符和函数。</p>
<p>所以我们应该把在 <code>ZombieOwnership</code> 里的函数名称改成别的吗？</p>
<p>不，我们不能那样做！！！要记得，我们正在用 ERC721 代币标准，意味着其他合约将期望我们的合约以这些确切的名称来定义函数。这就是这些标准实用的原因——如果另一个合约知道我们的合约符合 ERC721 标准，它可以直接与我们交互，而无需了解任何关于我们内部如何实现的细节。</p>
<p>所以，那意味着我们将必须重构我们第4课中的代码，将 <code>modifier</code> 的名称换成别的。</p>
<p><strong>实战演习</strong></p>
<p>我们回到了 <code>zombiefeeding.sol</code> 。我们将把 <code>modifier</code> 的名称从 <code>ownerOf</code> 改成 <code>onlyOwnerOf</code>。</p>
<ol>
<li>把修饰符定义中的名称改成 <code>onlyOwnerOf</code></li>
<li>往下滑到使用此修饰符的函数 <code>feedAndMultiply</code> 。我们也需要改这里的名称。</li>
</ol>
<blockquote>
<p>注意：我们在 <code>zombiehelper.sol</code> 和 <code>zombieattack.sol</code> 里也使用了这个修饰符，但为了不在这节课的重构里花太多时间，我们已经将那些文件里的修饰符名称为你改好了。</p>
</blockquote>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 1. 把修饰符名称改成 `onlyOwnerOf`</span><br><span class="line">  modifier onlyOwnerOf(uint _zombieId) {</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    _;</span><br><span class="line">  }</span><br><span class="line">// 2. 这里也要修改修饰符的名称</span><br><span class="line">  function feedAndMultiply(uint _zombieId, uint _targetDna, string _species) internal onlyOwnerOf(_zombieId) {</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    require(_isReady(myZombie));</span><br><span class="line">    _targetDna = _targetDna % dnaModulus;</span><br><span class="line">    uint newDna = (myZombie.dna + _targetDna) / 2;</span><br><span class="line">    if (keccak256(_species) == keccak256("kitty")) {</span><br><span class="line">      newDna = newDna - newDna % 100 + 99;</span><br><span class="line">    }</span><br><span class="line">    _createZombie("NoName", newDna);</span><br><span class="line">    _triggerCooldown(myZombie);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第5章-ERC721-转移标准"><a href="#第5章-ERC721-转移标准" class="headerlink" title="第5章: ERC721: 转移标准"></a>第5章: ERC721: 转移标准</h3><p>好了，我们将冲突修复了！</p>
<p>现在我们将通过学习把所有权从一个人转移给另一个人来继续我们的 ERC721 规范的实现。</p>
<p>注意 ERC721 规范有两种不同的方法来转移代币：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function transfer(address _to, uint256 _tokenId) public;</span><br><span class="line"></span><br><span class="line">function approve(address _to, uint256 _tokenId) public;</span><br><span class="line">function takeOwnership(uint256 _tokenId) public;</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>第一种方法是代币的拥有者调用<code>transfer</code> 方法，传入他想转移到的 <code>address</code> 和他想转移的代币的 <code>_tokenId</code>。</li>
<li>第二种方法是代币拥有者首先调用 <code>approve</code>，然后传入与以上相同的参数。接着，该合约会存储谁被允许提取代币，通常存储到一个 <code>mapping (uint256 =&gt; address)</code> 里。然后，当有人调用 <code>takeOwnership</code> 时，合约会检查 <code>msg.sender</code> 是否得到拥有者的批准来提取代币，如果是，则将代币转移给他。</li>
</ol>
<p>你注意到了吗，<code>transfer</code> 和 <code>takeOwnership</code> 都将包含相同的转移逻辑，只是以相反的顺序。 （一种情况是代币的发送者调用函数；另一种情况是代币的接收者调用它）。</p>
<p>所以我们把这个逻辑抽象成它自己的私有函数 <code>_transfer</code>，然后由这两个函数来调用它。 这样我们就不用写重复的代码了。</p>
<p><strong>实战演习</strong></p>
<p>让我们来定义 <code>_transfer</code> 的逻辑。</p>
<ol>
<li><p>定义一个名为 <code>_transfer</code>的函数。它会需要3个参数：<code>address _from</code>、<code>address _to</code>和<code>uint256 _tokenId</code>。它应该是一个 <code>私有</code> 函数。</p>
</li>
<li><p>我们有2个映射会在所有权改变的时候改变： <code>ownerZombieCount</code> （记录一个所有者有多少只僵尸）和 <code>zombieToOwner</code> （记录什么人拥有什么）。</p>
<p> 我们的函数需要做的第一件事是为 <strong>接收</strong> 僵尸的人（<code>address _to</code>）增 加<code>ownerZombieCount</code>。使用 <code>++</code> 来增加。</p>
</li>
<li><p>接下来，我们将需要为 <strong>发送</strong> 僵尸的人（<code>address _from</code>）<strong>减少</strong><code>ownerZombieCount</code>。使用 <code>--</code> 来扣减。</p>
</li>
<li><p>最后，我们将改变这个 <code>_tokenId</code> 的 <code>zombieToOwner</code> 映射，这样它现在就会指向 <code>_to</code>。</p>
</li>
<li><p>骗你的，那不是最后一步。我们还需要再做一件事情。</p>
<p> ERC721规范包含了一个 <code>Transfer</code> 事件。这个函数的最后一行应该用正确的参数触发<code>Transfer</code> ——查看 <code>erc721.sol</code> 看它期望传入的参数并在这里实现。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 在这里定义 _transfer()</span><br><span class="line">    function _transfer(address _from, address _to, uint256 _tokenId) private{</span><br><span class="line">        ownerZombieCount[_to]++;</span><br><span class="line">        ownerZombieCount[_from]--;</span><br><span class="line">        zombieToOwner[_tokenId] = _to;</span><br><span class="line">        Transfer(_from, _to, _tokenId);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第6章-ERC721-转移-续"><a href="#第6章-ERC721-转移-续" class="headerlink" title="第6章: ERC721: 转移-续"></a>第6章: ERC721: 转移-续</h3><p>太好了！刚才那是最难的部分——现在实现公共的 <code>transfer</code> 函数应该十分容易，因为我们的 <code>_transfer</code> 函数几乎已经把所有的重活都干完了。</p>
<p><strong>实战演习</strong></p>
<ol>
<li><p>我们想确保只有代币或僵尸的所有者可以转移它。还记得我们如何限制只有所有者才能访问某个功能吗？</p>
<p> 没错，我们已经有一个修饰符能够完成这个任务了。所以将修饰符 <code>onlyOwnerOf</code> 添加到这个函数中。</p>
</li>
<li><p>现在该函数的正文只需要一行代码。它只需要调用 <code>_transfer</code>。</p>
<p> 记得把 <code>msg.sender</code> 作为参数传递进 <code>address _from</code>。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 1. 在这里添加修饰符</span><br><span class="line">  function transfer(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId){</span><br><span class="line">    // 2. 在这里定义方法</span><br><span class="line">    _transfer(msg.sender, _to, _tokenId);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第7章-ERC721-批准"><a href="#第7章-ERC721-批准" class="headerlink" title="第7章: ERC721: 批准"></a>第7章: ERC721: 批准</h3><p>现在，让我们来实现 <code>approve</code>。</p>
<p>记住，使用 <code>approve</code> 或者 <code>takeOwnership</code> 的时候，转移有2个步骤：</p>
<ol>
<li>你，作为所有者，用新主人的 <code>address</code> 和你希望他获取的 <code>_tokenId</code> 来调用 <code>approve</code></li>
<li>新主人用 <code>_tokenId</code> 来调用 <code>takeOwnership</code>，合约会检查确保他获得了批准，然后把代币转移给他。</li>
</ol>
<p>因为这发生在2个函数的调用中，所以在函数调用之间，我们需要一个数据结构来存储什么人被批准获取什么。</p>
<p><strong>实战演习</strong></p>
<ol>
<li><p>首先，让我们来定义一个映射 <code>zombieApprovals</code>。它应该将一个 <code>uint</code> 映射到一个 <code>address</code>。</p>
<p> 这样一来，当有人用一个 <code>_tokenId</code> 调用 <code>takeOwnership</code> 时，我们可以用这个映射来快速查找谁被批准获取那个代币。</p>
</li>
<li><p>在函数 <code>approve</code> 上， 我们想要确保只有代币所有者可以批准某人来获取代币。所以我们需要添加修饰符 <code>onlyOwnerOf</code> 到 <code>approve</code>。</p>
</li>
<li><p>函数的正文部分，将 <code>_tokenId</code> 的 <code>zombieApprovals</code> 设置为和 <code>_to</code> 相等。</p>
</li>
<li><p>最后，在 ERC721 规范里有一个 <code>Approval</code> 事件。所以我们应该在这个函数的最后触发这个事件。（参考 <code>erc721.sol</code> 来确认传入的参数，并确保 <code>_owner</code> 是 <code>msg.sender</code>）</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 1. 在这里定义映射</span><br><span class="line">  mapping(uint =&gt; address) zombieApprovals;</span><br><span class="line">// 2. 在这里添加方法修饰符</span><br><span class="line">  function approve(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId){</span><br><span class="line">    // 3. 在这里定义方法</span><br><span class="line">    zombieApprovals[_tokenId] = _to;</span><br><span class="line">    Approval(msg.sender, _to, _tokenId);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第8章-ERC721-takeOwnership"><a href="#第8章-ERC721-takeOwnership" class="headerlink" title="第8章: ERC721: takeOwnership"></a>第8章: ERC721: takeOwnership</h3><p>太棒了，现在让我们完成最后一个函数来结束 ERC721 的实现。（别担心，这后面我们还会讲更多内容😉）</p>
<p>最后一个函数 <code>takeOwnership</code>， 应该只是简单地检查以确保 <code>msg.sender</code> 已经被批准来提取这个代币或者僵尸。若确认，就调用 <code>_transfer</code>；</p>
<p><strong>实战演习</strong></p>
<ol>
<li><p>首先，我们要用一个 <code>require</code> 句式来检查 <code>_tokenId</code> 的 <code>zombieApprovals</code> 和 <code>msg.sender</code> 相等。</p>
<p> 这样如果 <code>msg.sender</code> 未被授权来提取这个代币，将抛出一个错误。</p>
</li>
<li><p>为了调用 <code>_transfer</code>，我们需要知道代币所有者的地址（它需要一个 <code>_from</code> 来作为参数）。幸运的是我们可以在我们的 <code>ownerOf</code> 函数中来找到这个参数。</p>
<p> 所以，定义一个名为 <code>owner</code> 的 <code>address</code> 变量，并使其等于 <code>ownerOf(_tokenId)</code>。</p>
</li>
<li><p>最后，调用 <code>_transfer</code>, 并传入所有必须的参数。（在这里你可以用 <code>msg.sender</code> 作为 <code>_to</code>， 因为代币正是要发送给调用这个函数的人）。</p>
<blockquote>
<p>注意： 我们完全可以用一行代码来实现第2、3两步。但是分开写会让代码更易读。一点个人建议 :)</p>
</blockquote>
</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function takeOwnership(uint256 _tokenId) public {</span><br><span class="line">    // 从这里开始</span><br><span class="line">    require(msg.sender == zombieApprovals[_tokenId]);</span><br><span class="line">    address owner = ownerOf(_tokenId);</span><br><span class="line">    _transfer(owner, msg.sender, _tokenId);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第9章-预防溢出"><a href="#第9章-预防溢出" class="headerlink" title="第9章: 预防溢出"></a>第9章: 预防溢出</h3><p>恭喜你，我们完成了 ERC721 的实现。</p>
<p>并不是很复杂，对吧？很多类似的以太坊概念，当你只听人们谈论它们的时候，会觉得很复杂。所以最简单的理解方式就是你自己来实现它。</p>
<p>不过要记住那只是最简单的实现。还有很多的特性我们也许想加入到我们的实现中来，比如一些额外的检查，来确保用户不会不小心把他们的僵尸转移给<code>0</code> 地址（这被称作 “烧币”, 基本上就是把代币转移到一个谁也没有私钥的地址，让这个代币永远也无法恢复）。 或者在 DApp 中加入一些基本的拍卖逻辑。（你能想出一些实现的方法么？）</p>
<p>但是为了让我们的课程不至于离题太远，所以我们只专注于一些基础实现。如果你想学习一些更深层次的实现，可以在这个教程结束后，去看看 OpenZeppelin 的 ERC721 合约。</p>
<p><strong>合约安全增强: 溢出和下溢</strong></p>
<p>我们将来学习你在编写智能合约的时候需要注意的一个主要的安全特性：防止溢出和下溢。</p>
<p>什么是 <strong><em>溢出</em></strong> (*<strong>overflow*</strong>)?</p>
<p>假设我们有一个 <code>uint8</code>, 只能存储8 bit数据。这意味着我们能存储的最大数字就是二进制 <code>11111111</code> (或者说十进制的 2^8 - 1 = 255).</p>
<p>来看看下面的代码。最后 <code>number</code> 将会是什么值？</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint8 number = 255;</span><br><span class="line">number++;</span><br></pre></td></tr></tbody></table></figure>

<p>在这个例子中，我们导致了溢出 — 虽然我们加了1， 但是 <code>number</code> 出乎意料地等于 <code>0</code>了。 (如果你给二进制 <code>11111111</code> 加1, 它将被重置为 <code>00000000</code>，就像钟表从 <code>23:59</code> 走向 <code>00:00</code>)。</p>
<p>下溢(<code>underflow</code>)也类似，如果你从一个等于 <code>0</code> 的 <code>uint8</code> 减去 <code>1</code>, 它将变成 <code>255</code> (因为 <code>uint</code> 是无符号的，其不能等于负数)。</p>
<p>虽然我们在这里不使用 <code>uint8</code>，而且每次给一个 <code>uint256</code> 加 <code>1</code> 也不太可能溢出 (2^256 真的是一个很大的数了)，在我们的合约中添加一些保护机制依然是非常有必要的，以防我们的 DApp 以后出现什么异常情况。</p>
<p><strong>使用 SafeMath</strong></p>
<p>为了防止这些情况，OpenZeppelin 建立了一个叫做 SafeMath 的 <strong><em>库</em></strong>(*<strong>library*</strong>)，默认情况下可以防止这些问题。</p>
<p>不过在我们使用之前…… 什么叫做库?</p>
<p>一个**<em>库</em>** 是 Solidity 中一种特殊的合约。其中一个有用的功能是给原始数据类型增加一些方法。</p>
<p>比如，使用 SafeMath 库的时候，我们将使用 <code>using SafeMath for uint256</code> 这样的语法。 SafeMath 库有四个方法 — <code>add</code>， <code>sub</code>， <code>mul</code>， 以及 <code>div</code>。现在我们可以这样来让 <code>uint256</code> 调用这些方法：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">using SafeMath for uint256;</span><br><span class="line"></span><br><span class="line">uint256 a = 5;</span><br><span class="line">uint256 b = a.add(3); // 5 + 3 = 8</span><br><span class="line">uint256 c = a.mul(2); // 5 * 2 = 10</span><br></pre></td></tr></tbody></table></figure>

<p>我们将在下一章来学习这些方法，不过现在我们先将 SafeMath 库添加进我们的合约。</p>
<p><strong>实战演习</strong></p>
<p>我们已经帮你把 OpenZeppelin 的 <code>SafeMath</code> 库包含进 <code>safemath.sol</code>了，如果你想看一下代码的话，现在可以看看，不过我们下一章将深入进去。</p>
<p>首先我们来告诉我们的合约要使用 SafeMath。我们将在我们的 <code>ZombieFactory</code> 里调用，这是我们的基础合约 — 这样其他所有继承出去的子合约都可以使用这个库了。</p>
<ol>
<li>将 <code>safemath.sol</code> 引入到 <code>zombiefactory.sol</code>.</li>
<li>添加定义： <code>using SafeMath for uint256;</code>.</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 1. 在这里引入</span><br><span class="line">import "./safemath.sol";</span><br><span class="line"></span><br><span class="line">contract ZombieFactory is Ownable {</span><br><span class="line"></span><br><span class="line">  // 2. 在这里定义 using safemath </span><br><span class="line">    using SafeMath for uint256;</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第10章-SafeMath-第二部分"><a href="#第10章-SafeMath-第二部分" class="headerlink" title="第10章: SafeMath 第二部分"></a>第10章: SafeMath 第二部分</h3><p>来看看 SafeMath 的部分代码:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">library SafeMath {</span><br><span class="line"></span><br><span class="line">  function mul(uint256 a, uint256 b) internal pure returns (uint256) {</span><br><span class="line">    if (a == 0) {</span><br><span class="line">      return 0;</span><br><span class="line">    }</span><br><span class="line">    uint256 c = a * b;</span><br><span class="line">    assert(c / a == b);</span><br><span class="line">    return c;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  function div(uint256 a, uint256 b) internal pure returns (uint256) {</span><br><span class="line">    // assert(b &gt; 0); // Solidity automatically throws when dividing by 0</span><br><span class="line">    uint256 c = a / b;</span><br><span class="line">    // assert(a == b * c + a % b); // There is no case in which this doesn't hold</span><br><span class="line">    return c;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  function sub(uint256 a, uint256 b) internal pure returns (uint256) {</span><br><span class="line">    assert(b &lt;= a);</span><br><span class="line">    return a - b;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  function add(uint256 a, uint256 b) internal pure returns (uint256) {</span><br><span class="line">    uint256 c = a + b;</span><br><span class="line">    assert(c &gt;= a);</span><br><span class="line">    return c;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>首先我们有了 <code>library</code> 关键字 — 库和 <code>合约</code>很相似，但是又有一些不同。 就我们的目的而言，库允许我们使用 <code>using</code> 关键字，它可以自动把库的所有方法添加给一个数据类型：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">using SafeMath for uint;</span><br><span class="line">// 这下我们可以为任何 uint 调用这些方法了</span><br><span class="line">uint test = 2;</span><br><span class="line">test = test.mul(3); // test 等于 6 了</span><br><span class="line">test = test.add(5); // test 等于 11 了</span><br></pre></td></tr></tbody></table></figure>

<p>注意 <code>mul</code> 和 <code>add</code> 其实都需要两个参数。 在我们声明了 <code>using SafeMath for uint</code> 后，我们用来调用这些方法的 <code>uint</code> 就自动被作为第一个参数传递进去了(在此例中就是 <code>test</code>)</p>
<p>我们来看看 <code>add</code> 的源代码看 SafeMath 做了什么:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function add(uint256 a, uint256 b) internal pure returns (uint256) {</span><br><span class="line">  uint256 c = a + b;</span><br><span class="line">  assert(c &gt;= a);</span><br><span class="line">  return c;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>基本上 <code>add</code> 只是像 <code>+</code> 一样对两个 <code>uint</code> 相加， 但是<u><strong>它用一个 <code>assert</code> 语句来确保结果大于 <code>a</code>。这样就防止了溢出。</strong></u></p>
<p><code>assert</code> 和 <code>require</code> 相似，若结果为否它就会抛出错误。 <code>assert</code> 和 <code>require</code> 区别在于，<u><strong><code>require</code> 若失败则会返还给用户剩下的 gas， <code>assert</code> 则不会</strong></u>。所以大部分情况下，你写代码的时候会比较喜欢 <code>require</code>，<code>assert</code> 只在代码可能出现严重错误的时候使用，比如 <code>uint</code> 溢出。</p>
<p>所以简而言之， SafeMath 的 <code>add</code>， <code>sub</code>， <code>mul</code>， 和 <code>div</code> 方法只做简单的四则运算，然后在发生溢出或下溢的时候抛出错误。</p>
<p><strong>在我们的代码里使用 SafeMath</strong></p>
<p>为了防止溢出和下溢，我们可以在我们的代码里找 <code>+</code>， <code>-</code>， <code>*</code>， 或 <code>/</code>，然后替换为 <code>add</code>, <code>sub</code>, <code>mul</code>, <code>div</code>.</p>
<p>比如，与其这样做:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myUint++;</span><br></pre></td></tr></tbody></table></figure>

<p>我们这样做：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myUint = myUint.add(1);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实战演习</strong></p>
<p>在 <code>ZombieOwnership</code> 中有两个地方用到了数学运算，来替换成 SafeMath 方法把。</p>
<ol>
<li>将 <code>++</code> 替换成 SafeMath 方法。</li>
<li>将 <code>--</code> 替换成 SafeMath 方法。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function _transfer(address _from, address _to, uint256 _tokenId) private {</span><br><span class="line">    // 1. 替换成 SafeMath 的 `add`</span><br><span class="line">    //ownerZombieCount[_to]++;</span><br><span class="line">    ownerZombieCount[_to] = ownerZombieCount[_to].add(1);</span><br><span class="line">    // 2. 替换成 SafeMath 的 `sub`</span><br><span class="line">    //ownerZombieCount[_from]--;</span><br><span class="line">    ownerZombieCount[_from] = ownerZombieCount[_from].sub(1);</span><br><span class="line">    zombieToOwner[_tokenId] = _to;</span><br><span class="line">    Transfer(_from, _to, _tokenId);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第11章-SafeMath-第三部分"><a href="#第11章-SafeMath-第三部分" class="headerlink" title="第11章: SafeMath 第三部分"></a>第11章: SafeMath 第三部分</h3><p>太好了，这下我们的 ERC721 实现不会有溢出或者下溢了。</p>
<p>回头看看我们在之前课程写的代码，还有其他几个地方也有可能导致溢出或下溢。</p>
<p>比如， 在 ZombieAttack 里面我们有：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myZombie.winCount++;</span><br><span class="line">myZombie.level++;</span><br><span class="line">enemyZombie.lossCount++;</span><br></pre></td></tr></tbody></table></figure>

<p>我们同样应该在这些地方防止溢出。（通常情况下，总是使用 SafeMath 而不是普通数学运算是个好主意，也许在以后 Solidity 的新版本里这点会被默认实现，但是现在我们得自己在代码里实现这些额外的安全措施）。</p>
<p>不过我们遇到个小问题 — <code>winCount</code> 和 <code>lossCount</code> 是 <code>uint16</code>， 而 <code>level</code> 是 <code>uint32</code>。 所以如果我们用这些作为参数传入 SafeMath 的 <code>add</code> 方法。 它实际上并不会防止溢出，因为它会把这些变量都转换成 <code>uint256</code>:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function add(uint256 a, uint256 b) internal pure returns (uint256) {</span><br><span class="line">  uint256 c = a + b;</span><br><span class="line">  assert(c &gt;= a);</span><br><span class="line">  return c;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 如果我们在`uint8` 上调用 `.add`。它将会被转换成 `uint256`.</span><br><span class="line">// 所以它不会在 2^8 时溢出，因为 256 是一个有效的 `uint256`.</span><br></pre></td></tr></tbody></table></figure>

<p>这就意味着，我们需要再实现两个库来防止 <code>uint16</code> 和 <code>uint32</code> 溢出或下溢。我们可以将其命名为 <code>SafeMath16</code> 和 <code>SafeMath32</code>。</p>
<p>代码将和 SafeMath 完全相同，除了所有的 <code>uint256</code> 实例都将被替换成 <code>uint32</code> 或 <code>uint16</code>。</p>
<p>我们已经将这些代码帮你写好了，打开 <code>safemath.sol</code> 合约看看代码吧。</p>
<p>现在我们需要在 ZombieFactory 里使用它们。</p>
<p><strong>Putting it to the Test</strong></p>
<p>分配：</p>
<ol>
<li>声明我们将为 <code>uint32</code> 使用<code>SafeMath32</code>。</li>
<li>声明我们将为 <code>uint16</code> 使用<code>SafeMath16</code>。</li>
<li>在 ZombieFactory 里还有一处我们也应该使用 SafeMath 的方法， 我们已经在那里留了注释提醒你。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">contract ZombieFactory is Ownable {</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  // 1. 为 uint32 声明 使用 SafeMath32</span><br><span class="line">  // 2. 为 uint16 声明 使用 SafeMath16</span><br><span class="line">  using SafeMath32 for uint32;</span><br><span class="line">  using SafeMath16 for uint16;</span><br><span class="line">  ………………</span><br><span class="line">  function _createZombie(string _name, uint _dna) internal {</span><br><span class="line">    // 注意: 我们选择不处理2038年问题，所以不用担心 readyTime 的溢出</span><br><span class="line">    // 反正在2038年我们的APP早完蛋了</span><br><span class="line">    uint id = zombies.push(Zombie(_name, _dna, 1, uint32(now + cooldownTime), 0, 0)) - 1;</span><br><span class="line">    zombieToOwner[id] = msg.sender;</span><br><span class="line">    // 3. 在这里使用 SafeMath 的 `add` 方法:</span><br><span class="line">    //ownerZombieCount[msg.sender]++;</span><br><span class="line">    ownerZombieCount[msg.sender] = ownerZombieCount[msg.sender].add(1);</span><br><span class="line">    NewZombie(id, _name, _dna);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第12章-SafeMath-第4部分"><a href="#第12章-SafeMath-第4部分" class="headerlink" title="第12章: SafeMath 第4部分"></a>第12章: SafeMath 第4部分</h3><p>真棒，现在我们已经为我们的 DApp 里面用到的 <code>uint</code> 数据类型都实现了 SafeMath 了。</p>
<p>让我们把 <code>ZombieAttack</code> 里所有潜在的问题都修复了吧。 （其实在 <code>ZombieHelper</code> 里也有一处 <code>zombies[_zombieId].level++;</code> 需要修复，不过我们已经帮你做好了，这样我们就不用再来一章了 😉）。</p>
<p><strong>实战演习</strong></p>
<p>放心大胆去对 <code>ZombieAttack</code> 里所有的 <code>++</code> 操作都使用 SafeMath 方法吧。为了方便你找，我们已经在相应的地方留了注释给你。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import "./zombiehelper.sol";</span><br><span class="line"></span><br><span class="line">contract ZombieBattle is ZombieHelper {</span><br><span class="line">  uint randNonce = 0;</span><br><span class="line">  uint attackVictoryProbability = 70;</span><br><span class="line"></span><br><span class="line">  function randMod(uint _modulus) internal returns(uint) {</span><br><span class="line">    // 这儿有一个</span><br><span class="line">    //randNonce++;</span><br><span class="line">    randNonce = randNonce.add(1);</span><br><span class="line">    return uint(keccak256(now, msg.sender, randNonce)) % _modulus;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  function attack(uint _zombieId, uint _targetId) external onlyOwnerOf(_zombieId) {</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    Zombie storage enemyZombie = zombies[_targetId];</span><br><span class="line">    uint rand = randMod(100);</span><br><span class="line">    if (rand &lt;= attackVictoryProbability) {</span><br><span class="line">      // 这里有三个</span><br><span class="line">      //myZombie.winCount++;</span><br><span class="line">      myZombie.winCount = myZombie.winCount.add(1);</span><br><span class="line">      //myZombie.level++;</span><br><span class="line">      myZombie.level = myZombie.level.add(1);</span><br><span class="line">      //enemyZombie.lossCount++;</span><br><span class="line">      enemyZombie.lossCount = enemyZombie.lossCount.add(1);</span><br><span class="line">      feedAndMultiply(_zombieId, enemyZombie.dna, "zombie");</span><br><span class="line">    } else {</span><br><span class="line">      // 这儿还有俩哦</span><br><span class="line">      //myZombie.lossCount++;</span><br><span class="line">        myZombie.lossCount = myZombie.lossCount.add(1);</span><br><span class="line">      //enemyZombie.winCount++;</span><br><span class="line">        enemyZombie.winCount = enemyZombie.winCount.add(1);</span><br><span class="line">      _triggerCooldown(myZombie);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第13章-注释"><a href="#第13章-注释" class="headerlink" title="第13章: 注释"></a>第13章: 注释</h3><p>僵尸游戏的 Solidity 代码终于完成啦。</p>
<p>在以后的课程中，我们将学习如何将游戏部署到以太坊，以及如何和 Web3.js 交互。</p>
<p>不过在你离开第五课之前，我们来谈谈如何 <strong>给你的代码添加注释</strong>.</p>
<p><strong>注释语法</strong></p>
<p>Solidity 里的注释和 JavaScript 相同。在我们的课程中你已经看到了不少单行注释了：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 这是一个单行注释，可以理解为给自己或者别人看的笔记</span><br></pre></td></tr></tbody></table></figure>

<p>只要在任何地方添加一个 <code>//</code> 就意味着你在注释。如此简单所以你应该经常这么做。</p>
<p>不过我们也知道你的想法：有时候单行注释是不够的。毕竟你生来话痨。</p>
<p>所以我们有了多行注释：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">contract CryptoZombies {</span><br><span class="line">  /* 这是一个多行注释。我想对所有花时间来尝试这个编程课程的人说声谢谢。</span><br><span class="line">  它是免费的，并将永远免费。但是我们依然倾注了我们的心血来让它变得更好。</span><br><span class="line"></span><br><span class="line">   要知道这依然只是区块链开发的开始而已，虽然我们已经走了很远，</span><br><span class="line">   仍然有很多种方式来让我们的社区变得更好。</span><br><span class="line">   如果我们在哪个地方出了错，欢迎在我们的 github 提交 PR 或者 issue 来帮助我们改进：</span><br><span class="line">    https://github.com/loomnetwork/cryptozombie-lessons</span><br><span class="line"></span><br><span class="line">    或者，如果你有任何的想法、建议甚至仅仅想和我们打声招呼，欢迎来我们的电报群：</span><br><span class="line">     https://t.me/loomnetworkdev</span><br><span class="line">  */</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>特别是，最好为你合约中每个方法添加注释来解释它的预期行为。这样其他开发者（或者你自己，在6个月以后再回到这个项目中）可以很快地理解你的代码而不需要逐行阅读所有代码。</p>
<p>Solidity 社区所使用的一个标准是使用一种被称作 *<strong>natspec*</strong> 的格式，看起来像这样：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/// @title 一个简单的基础运算合约</span><br><span class="line">/// @author H4XF13LD MORRIS 💯💯😎💯💯</span><br><span class="line">/// @notice 现在，这个合约只添加一个乘法</span><br><span class="line">contract Math {</span><br><span class="line">  /// @notice 两个数相乘</span><br><span class="line">  /// @param x 第一个 uint</span><br><span class="line">  /// @param y  第二个 uint</span><br><span class="line">  /// @return z  (x * y) 的结果</span><br><span class="line">  /// @dev 现在这个方法不检查溢出</span><br><span class="line">  function multiply(uint x, uint y) returns (uint z) {</span><br><span class="line">    // 这只是个普通的注释，不会被 natspec 解释</span><br><span class="line">    z = x * y;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>@title</code>（标题） 和 <code>@author</code> （作者）很直接了.</p>
<p><code>@notice</code> （须知）向 <strong>用户</strong> 解释这个方法或者合约是做什么的。 <code>@dev</code> （开发者） 是向开发者解释更多的细节。</p>
<p><code>@param</code> （参数）和 <code>@return</code> （返回） 用来描述这个方法需要传入什么参数以及返回什么值。</p>
<p>注意你并不需要每次都用上所有的标签，它们都是可选的。不过最少，写下一个 <code>@dev</code> 注释来解释每个方法是做什么的。</p>
<p><strong>实战演习</strong></p>
<p>如果你还没注意到：CryptoZombies 的答案检查器在工作的时候将忽略所有的注释。所以这一章我们其实无法检查你的 natspec 注释了。全靠你自己咯。</p>
<p>话说回来，到现在你应该已经是一个 Solidity 小能手了。我们就假定你已经学会这些了。</p>
<p>大胆去做些尝试把，给 <code>ZombieOwnership</code> 加上一些 natspec 标签:</p>
<ol>
<li><code>@title</code> — 例如：一个管理转移僵尸所有权的合约</li>
<li><code>@author</code> — 你的名字</li>
<li><code>@dev</code> — 例如：符合 OpenZeppelin 对 ERC721 标准草案的实现</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import "./zombieattack.sol";</span><br><span class="line">import "./erc721.sol";</span><br><span class="line">import "./safemath.sol";</span><br><span class="line"></span><br><span class="line">/// TODO: 把这里变成 natspec 标准的注释把</span><br><span class="line">/// @title 一个管理转移僵尸所有权的合约</span><br><span class="line">/// @author 0xMx1@0</span><br><span class="line">/// @dev 符合 OpenZeppelin 对 ERC721 标准草案的实现</span><br></pre></td></tr></tbody></table></figure>

<h4 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h4><p>这节课里面我们学到了</p>
<ul>
<li>代币, ERC721 标准，以及可交易的物件/僵尸</li>
<li>库以及如何使用库</li>
<li>如何利用 SafeMath 来防止溢出和下溢</li>
<li>代码注释和 natspec 标准</li>
</ul>
<p>在接下来的两节课中，我们将学习如何将游戏部署到以太坊以及和 *<strong>web3.js*</strong> 交互 （这样你就能为你的 DApp 打造一个界面了 ）。</p>
<h2 id="lesson6-应用前端和-Web3-js"><a href="#lesson6-应用前端和-Web3-js" class="headerlink" title="lesson6 应用前端和 Web3.js"></a>lesson6 应用前端和 Web3.js</h2><h3 id="第1章-介绍-Web3-js"><a href="#第1章-介绍-Web3-js" class="headerlink" title="第1章: 介绍 Web3.js"></a>第1章: 介绍 Web3.js</h3><p>完成第五课以后，我们的僵尸 DApp 的 Solidity 合约部分就完成了。现在我们来做一个基本的网页好让你的用户能玩它。 要做到这一点，我们将使用以太坊基金发布的 JavaScript 库 —— *<strong>Web3.js*</strong>.</p>
<p><strong>什么是 Web3.js?</strong></p>
<p>还记得么？以太坊网络是由节点组成的，每一个节点都包含了区块链的一份拷贝。当你想要调用一份智能合约的一个方法，你需要从其中一个节点中查找并告诉它:</p>
<ol>
<li>智能合约的地址</li>
<li>你想调用的方法，以及</li>
<li>你想传入那个方法的参数</li>
</ol>
<p>以太坊节点只能识别一种叫做 <u>*<strong>JSON-RPC*</strong></u> 的语言。这种语言直接读起来并不好懂。当你你想调用一个合约的方法的时候，需要发送的查询语句将会是这样的：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哈……祝你写所有这样的函数调用的时候都一次通过</span></span><br><span class="line"><span class="comment">// 往右边拉…… ==&gt;</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"jsonrpc"</span><span class="punctuation">:</span><span class="string">"2.0"</span><span class="punctuation">,</span><span class="attr">"method"</span><span class="punctuation">:</span><span class="string">"eth_sendTransaction"</span><span class="punctuation">,</span><span class="attr">"params"</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">{</span><span class="attr">"from"</span><span class="punctuation">:</span><span class="string">"0xb60e8dd61c5d32be8058bb8eb970870f07233155"</span><span class="punctuation">,</span><span class="attr">"to"</span><span class="punctuation">:</span><span class="string">"0xd46e8dd67c5d32be8058bb8eb970870f07244567"</span><span class="punctuation">,</span><span class="attr">"gas"</span><span class="punctuation">:</span><span class="string">"0x76c0"</span><span class="punctuation">,</span><span class="attr">"gasPrice"</span><span class="punctuation">:</span><span class="string">"0x9184e72a000"</span><span class="punctuation">,</span><span class="attr">"value"</span><span class="punctuation">:</span><span class="string">"0x9184e72a"</span><span class="punctuation">,</span><span class="attr">"data"</span><span class="punctuation">:</span><span class="string">"0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675"</span><span class="punctuation">}</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">"id"</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>幸运的是 Web3.js 把这些令人讨厌的查询语句都隐藏起来了， 所以你只需要与方便易懂的 JavaScript 界面进行交互即可。</p>
<p>你不需要构建上面的查询语句，在你的代码中调用一个函数看起来将是这样：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CryptoZombies.methods.createRandomZombie("Vitalik Nakamoto 🤔")</span><br><span class="line">  .send({ from: "0xb60e8dd61c5d32be8058bb8eb970870f07233155", gas: "3000000" })</span><br></pre></td></tr></tbody></table></figure>

<p>我们将在接下来的几章详细解释这些语句，不过首先我们来把 Web3.js 环境搭建起来。</p>
<p><strong>准备好了么？</strong></p>
<p>取决于你的项目工作流程和你的爱好，你可以用一些常用工具把 Web3.js 添加进来：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 用 NPM</span><br><span class="line">npm install web3</span><br><span class="line"></span><br><span class="line">// 用 Yarn</span><br><span class="line">yarn add web3</span><br><span class="line"></span><br><span class="line">// 用 Bower</span><br><span class="line">bower install web3</span><br><span class="line"></span><br><span class="line">// ...或者其他。</span><br></pre></td></tr></tbody></table></figure>

<p>甚至，你可以从 <a target="_blank" rel="noopener" href="https://github.com/ethereum/web3.js/blob/1.0/dist/web3.min.js">github</a> 直接下载压缩后的 <code>.js</code> 文件 然后包含到你的项目文件中：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=<span class="string">"javascript"</span> type=<span class="string">"text/javascript"</span> src=<span class="string">"web3.min.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>因为我们不想让你花太多在项目环境搭建上，在本教程中我们将使用上面的 <code>script</code> 标签来将 Web3.js 引入。</p>
<p><strong>实战演习</strong></p>
<p>我们为你建立了一个HTML 项目空壳 —— <code>index.html</code>。假设在和 <code>index.html</code> 同个文件夹里有一份 <code>web3.min.js</code></p>
<ol>
<li>使用上面的 <code>script</code> 标签代码把 <code>web3.js</code> 添加进去以备接下来使用。</li>
</ol>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>CryptoZombies front-end<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">"javascript"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- Include web3.js here --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">"javascript"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"web3.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br></pre></td></tr></tbody></table></figure>



<h3 id="第2章-Web3-提供者"><a href="#第2章-Web3-提供者" class="headerlink" title="第2章: Web3 提供者"></a>第2章: Web3 提供者</h3><p>太棒了。现在我们的项目中有了Web3.js, 来初始化它然后和区块链对话吧。</p>
<p>首先我们需要 *<strong>Web3 Provider*</strong>.</p>
<p>要记住，以太坊是由共享同一份数据的相同拷贝的 <strong><em>节点</em></strong> 构成的。 在 Web3.js 里设置 Web3 的 <code>Provider</code>（提供者） 告诉我们的代码应该和 <strong>哪个节点</strong> 交互来处理我们的读写。这就好像在传统的 Web 应用程序中为你的 API 调用设置远程 Web 服务器的网址。</p>
<p>你可以运行你自己的以太坊节点来作为 Provider。 不过，有一个第三方的服务，可以让你的生活变得轻松点，让你不必为了给你的用户提供DApp而维护一个以太坊节点— *<strong>Infura*</strong>.</p>
<p><strong>Infura</strong></p>
<p><a target="_blank" rel="noopener" href="https://infura.io/">Infura</a> 是一个服务，它维护了很多以太坊节点并提供了一个缓存层来实现高速读取。你可以用他们的 API 来免费访问这个服务。 用 Infura 作为节点提供者，你可以不用自己运营节点就能很可靠地向以太坊发送、接收信息。</p>
<p>你可以通过这样把 Infura 作为你的 Web3 节点提供者：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var web3 = new Web3(new Web3.providers.WebsocketProvider("wss://mainnet.infura.io/ws"));</span><br></pre></td></tr></tbody></table></figure>

<p>不过，因为我们的 DApp 将被很多人使用，这些用户不单会从区块链读取信息，还会向区块链 <strong><em>写</em></strong> 入信息，我们需要用一个方法让用户可以用他们的私钥给事务签名。</p>
<blockquote>
<p>注意: 以太坊 (以及通常意义上的 blockchains )使用一个公钥/私钥对来对给事务做数字签名。把它想成一个数字签名的异常安全的密码。这样当我修改区块链上的数据的时候，我可以用我的公钥来 <strong>证明</strong> 我就是签名的那个。但是因为没人知道我的私钥，所以没人能伪造我的事务。</p>
</blockquote>
<p>加密学非常复杂，所以除非你是个专家并且的确知道自己在做什么，你最好不要在你应用的前端中管理你用户的私钥。</p>
<p>不过幸运的是，你并不需要，已经有可以帮你处理这件事的服务了： *<strong>Metamask*</strong>.</p>
<p><strong>Metamask</strong></p>
<p><a target="_blank" rel="noopener" href="https://metamask.io/">Metamask</a> 是 Chrome 和 Firefox 的浏览器扩展， 它能让用户安全地维护他们的以太坊账户和私钥， 并用他们的账户和使用 Web3.js 的网站互动（如果你还没用过它，你肯定会想去安装的——这样你的浏览器就能使用 Web3.js 了，然后你就可以和任何与以太坊区块链通信的网站交互了）</p>
<p>作为开发者，如果你想让用户从他们的浏览器里通过网站和你的DApp交互（就像我们在 CryptoZombies 游戏里一样），你肯定会想要兼容 Metamask 的。</p>
<blockquote>
<p><strong>注意</strong>: Metamask 默认使用 Infura 的服务器做为 web3 提供者。 就像我们上面做的那样。不过它还为用户提供了选择他们自己 Web3 提供者的选项。所以使用 Metamask 的 web3 提供者，你就给了用户选择权，而自己无需操心这一块。</p>
</blockquote>
<p><strong>使用 Metamask 的 web3 提供者</strong></p>
<p>Metamask 把它的 web3 提供者注入到浏览器的全局 JavaScript对象<code>web3</code>中。所以你的应用可以检查 <code>web3</code> 是否存在。若存在就使用 <code>web3.currentProvider</code> 作为它的提供者。</p>
<p>这里是一些 Metamask 提供的示例代码，用来检查用户是否安装了MetaMask，如果没有安装就告诉用户需要安装MetaMask来使用我们的应用。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener('load', function() {</span><br><span class="line"></span><br><span class="line">  // 检查web3是否已经注入到(Mist/MetaMask)</span><br><span class="line">  if (typeof web3 !== 'undefined') {</span><br><span class="line">    // 使用 Mist/MetaMask 的提供者</span><br><span class="line">    web3js = new Web3(web3.currentProvider);</span><br><span class="line">  } else {</span><br><span class="line">    // 处理用户没安装的情况， 比如显示一个消息</span><br><span class="line">    // 告诉他们要安装 MetaMask 来使用我们的应用</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  // 现在你可以启动你的应用并自由访问 Web3.js:</span><br><span class="line">  startApp()</span><br><span class="line"></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>你可以在你所有的应用中使用这段样板代码，好检查用户是否安装以及告诉用户安装 MetaMask。</p>
<blockquote>
<p>注意: 除了MetaMask，你的用户也可能在使用其他他的私钥管理应用，比如 <strong>Mist</strong> 浏览器。不过，它们都实现了相同的模式来注入 <code>web3</code> 变量。所以我这里描述的方法对两者是通用的。</p>
</blockquote>
<p><strong>实战演习</strong></p>
<p>我们在HTML文件中的 <code>&lt;/body&gt;</code> 标签前面放置了一个空的 <code>script</code> 标签。可以把这节课的 JavaScript 代码写在里面。</p>
<ol>
<li>把上面用来检测 MetaMask 是否安装的模板代码粘贴进来。请粘贴到以 <code>window.addEventListener</code> 开头的代码块中。</li>
</ol>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>CryptoZombies front-end<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">"javascript"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">"javascript"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"web3.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">// Start here</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">'load'</span>, <span class="keyword">function</span>(<span class="params"></span>) {</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">// 检查web3是否已经注入到(Mist/MetaMask)</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">if</span> (<span class="keyword">typeof</span> web3 !== <span class="string">'undefined'</span>) {</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">// 使用 Mist/MetaMask 的提供者</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        web3js = <span class="keyword">new</span> <span class="title class_">Web3</span>(web3.<span class="property">currentProvider</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      } <span class="keyword">else</span> {</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">// 处理用户没安装的情况， 比如显示一个消息</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">// 告诉他们要安装 MetaMask 来使用我们的应用</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      }</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">// 现在你可以启动你的应用并自由访问 Web3.js:</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="title function_">startApp</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    })</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br></pre></td></tr></tbody></table></figure>



<h3 id="第3章-和合约对话"><a href="#第3章-和合约对话" class="headerlink" title="第3章: 和合约对话"></a>第3章: 和合约对话</h3><p>现在，我们已经用 MetaMask 的 Web3 提供者初始化了 Web3.js。接下来就让它和我们的智能合约对话吧。</p>
<p>Web3.js 需要两个东西来和你的合约对话: 它的 <strong><em>地址</em></strong> 和它的 ***ABI***。</p>
<p><strong>合约地址</strong></p>
<p>在你写完了你的智能合约后，你需要编译它并把它部署到以太坊。我们将在<strong>下一课</strong>中详述<strong>部署</strong>，因为它和写代码是截然不同的过程，所以我们决定打乱顺序，先来讲 Web3.js。</p>
<p>在你部署智能合约以后，它将获得一个以太坊上的永久地址。如果你还记得第二课，CryptoKitties 在以太坊上的地址是 <code>0x06012c8cf97BEaD5deAe237070F9587f8E7A266d</code>。</p>
<p>你需要在部署后复制这个地址以来和你的智能合约对话。</p>
<p><strong>合约 ABI</strong></p>
<p>另一个 Web3.js 为了要和你的智能合约对话而需要的东西是 ***ABI***。</p>
<p>ABI 意为应用二进制接口（Application Binary Interface）。 基本上，它是以 JSON 格式表示合约的方法，告诉 Web3.js 如何以合同理解的方式格式化函数调用。</p>
<p>当你编译你的合约向以太坊部署时(我们将在第七课详述)， Solidity 编译器会给你 ABI，所以除了合约地址，你还需要把这个也复制下来。</p>
<p>因为我们这一课不会讲述部署，所以现在我们已经帮你编译了 ABI 并放在了名为<code>cryptozombies_abi.js</code>，文件中，保存在一个名为 <code>cryptoZombiesABI</code> 的变量中。</p>
<p>如果我们将<code>cryptozombies_abi.js</code> 包含进我们的项目，我们就能通过那个变量访问 CryptoZombies ABI 。</p>
<p><strong>实例化 Web3.js</strong></p>
<p>一旦你有了合约的地址和 ABI，你可以像这样来实例化 Web3.js。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 实例化 myContract</span><br><span class="line">var myContract = new web3js.eth.Contract(myABI, myContractAddress);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实战演习</strong></p>
<ol>
<li>在文件的 <code>&lt;head&gt;</code> 标签块中，用 <code>script</code> 标签引入<code>cryptozombies_abi.js</code>，好把 ABI 的定义引入项目。</li>
<li>在 <code>&lt;body&gt;</code> 里的 <code>&lt;script&gt;</code> 开头 , 定义一个<code>var</code>，取名 <code>cryptoZombies</code>， 不过不要对其赋值，稍后我们将用这个这个变量来存储我们实例化合约。</li>
<li>接下来，创建一个名为 <code>startApp()</code> 的 <code>function</code>。 接下来两步来完成这个方法。</li>
<li><code>startApp()</code> 里应该做的第一件事是定义一个名为<code>cryptoZombiesAddress</code> 的变量并赋值为<code>"你的合约地址"</code> (这是你的合约在以太坊主网上的地址)。</li>
<li>最后，来实例化我们的合约。模仿我们上面的代码，将 <code>cryptoZombies</code> 赋值为 <code>new</code> <code>web3js.eth.Contract</code> (使用我们上面代码中通过 <code>script</code> 引入的 <code>cryptoZombiesABI</code> 和 <code>cryptoZombiesAddress</code>)。</li>
</ol>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>CryptoZombies front-end<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">"javascript"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">"javascript"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"web3.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 1. Include cryptozombies_abi.js here --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">"javascript"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"cryptozombies_abi.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">// 2. Start code here</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">var</span> cryptoZombies;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">function</span> <span class="title function_">startApp</span>(<span class="params"></span>){</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">var</span> cryptoZombiesAddress = <span class="string">"你的合约地址"</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        cryptoZombies = <span class="keyword">new</span> web3js.<span class="property">eth</span>.<span class="title class_">Contract</span>(cryptoZombiesABI, cryptoZombiesAddress);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      }</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">'load'</span>, <span class="keyword">function</span>(<span class="params"></span>) {</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">// Checking if Web3 has been injected by the browser (Mist/MetaMask)</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">if</span> (<span class="keyword">typeof</span> web3 !== <span class="string">'undefined'</span>) {</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="comment">// Use Mist/MetaMask's provider</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          web3js = <span class="keyword">new</span> <span class="title class_">Web3</span>(web3.<span class="property">currentProvider</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        } <span class="keyword">else</span> {</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="comment">// Handle the case where the user doesn't have Metamask installed</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="comment">// Probably show them a message prompting them to install Metamask</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        }</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">// Now you can start your app &amp; access web3 freely:</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">startApp</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      })</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br></pre></td></tr></tbody></table></figure>



<h3 id="第4章-调用和合约函数"><a href="#第4章-调用和合约函数" class="headerlink" title="第4章: 调用和合约函数"></a>第4章: 调用和合约函数</h3><p>我们的合约配置好了！现在来用 Web3.js 和它对话。</p>
<p>Web3.js 有两个方法来调用我们合约的函数: <code>call</code> and <code>send</code>.</p>
<p><strong>Call</strong></p>
<p><code>call</code> 用来调用 <code>view</code> 和 <code>pure</code> 函数。它只运行在本地节点，不会在区块链上创建事务。</p>
<blockquote>
<p><strong>复习:</strong> <code>view</code> 和 <code>pure</code> 函数是只读的并不会改变区块链的状态。它们也不会消耗任何gas。用户也不会被要求用MetaMask对事务签名。</p>
</blockquote>
<p>使用 Web3.js，你可以如下 <code>call</code> 一个名为<code>myMethod</code>的方法并传入一个 <code>123</code> 作为参数：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myContract.<span class="property">methods</span>.<span class="title function_">myMethod</span>(<span class="number">123</span>).<span class="title function_">call</span>()</span><br></pre></td></tr></tbody></table></figure>

<p><strong>Send</strong></p>
<p><code>send</code> 将创建一个事务并改变区块链上的数据。你需要用 <code>send</code> 来调用任何非 <code>view</code> 或者 <code>pure</code> 的函数。</p>
<blockquote>
<p><strong>注意:</strong> <code>send</code> 一个事务将要求用户支付gas，并会要求弹出对话框请求用户使用 Metamask 对事务签名。在我们使用 Metamask 作为我们的 web3 提供者的时候，所有这一切都会在我们调用 <code>send()</code> 的时候自动发生。而我们自己无需在代码中操心这一切，挺爽的吧。</p>
</blockquote>
<p>使用 Web3.js, 你可以像这样 <code>send</code> 一个事务调用<code>myMethod</code> 并传入 <code>123</code> 作为参数：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myContract.<span class="property">methods</span>.<span class="title function_">myMethod</span>(<span class="number">123</span>).<span class="title function_">send</span>()</span><br></pre></td></tr></tbody></table></figure>

<p>语法几乎 <code>call()</code>一模一样。</p>
<p><strong>获取僵尸数据</strong></p>
<p>来看一个使用 <code>call</code> 读取我们合约数据的真实例子</p>
<p>回忆一下，我们定义我们的僵尸数组为 <code>公开</code>(public):</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Zombie[] public zombies;</span><br></pre></td></tr></tbody></table></figure>

<p><u><strong>在 Solidity 里，当你定义一个 <code>public</code>变量的时候， 它将自动定义一个公开的 “getter” 同名方法</strong></u>， 所以如果你像要查看 id 为 <code>15</code> 的僵尸，你可以像一个函数一样调用它： <code>zombies(15)</code>.</p>
<p>这是如何在外面的前端界面中写一个 JavaScript 方法来传入一个僵尸 id，在我们的合同中查询那个僵尸并返回结果</p>
<blockquote>
<p>注意: 本课中所有的示例代码都使用 Web3.js 的 <strong>1.0 版</strong>，此版本使用的是 Promises 而不是回调函数。你在线上看到的其他教程可能还在使用老版的 Web3.js。在1.0版中，语法改变了不少。如果你从其他教程中复制代码，先确保你们使用的是相同版本的Web3.js。</p>
</blockquote>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getZombieDetails</span>(<span class="params">id</span>) {</span><br><span class="line">  <span class="keyword">return</span> cryptoZombies.<span class="property">methods</span>.<span class="title function_">zombies</span>(id).<span class="title function_">call</span>()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数并做一些其他事情</span></span><br><span class="line"><span class="title function_">getZombieDetails</span>(<span class="number">15</span>)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">result</span>) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"Zombie 15: "</span> + <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(result));</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>我们来看看这里都做了什么</p>
<p><code>cryptoZombies.methods.zombies(id).call()</code> 将和 Web3 提供者节点通信，告诉它返回从我们的合约中的 <code>Zombie[] public zombies</code>，<code>id</code>为传入参数的僵尸信息。</p>
<p>注意这是 <strong>异步的</strong>，就像从外部服务器中调用API。所以 Web3 在这里返回了一个 Promises. (如果你对 JavaScript的 Promises 不了解，最好先去学习一下这方面知识再继续)。</p>
<p>一旦那个 <code>promise</code> 被 <code>resolve</code>, (意味着我们从 Web3 提供者那里获得了响应)，我们的例子代码将执行 <code>then</code> 语句中的代码，在控制台打出 <code>result</code>。</p>
<p><code>result</code> 是一个像这样的 JavaScript 对象：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"H4XF13LD MORRIS'S COOLER OLDER BROTHER"</span>,</span><br><span class="line">  <span class="string">"dna"</span>: <span class="string">"1337133713371337"</span>,</span><br><span class="line">  <span class="string">"level"</span>: <span class="string">"9999"</span>,</span><br><span class="line">  <span class="string">"readyTime"</span>: <span class="string">"1522498671"</span>,</span><br><span class="line">  <span class="string">"winCount"</span>: <span class="string">"999999999"</span>,</span><br><span class="line">  <span class="string">"lossCount"</span>: <span class="string">"0"</span> <span class="comment">// Obviously.</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们可以用一些前端逻辑代码来解析这个对象并在前端界面友好展示。</p>
<p><strong>实战演习</strong></p>
<p>我们已经帮你把 <code>getZombieDetails</code> 复制进了代码。</p>
<ol>
<li><p>先为<code>zombieToOwner</code> 创建一个类似的函数。如果你还记得 <code>ZombieFactory.sol</code>，我们有一个长这样的映射：</p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapping (uint =&gt; address) public zombieToOwner;</span><br></pre></td></tr></tbody></table></figure>

<p> 定义一个 JavaScript 方法，起名为 <code>zombieToOwner</code>。和上面的 <code>getZombieDetails</code> 类似， 它将接收一个<code>id</code> 作为参数，并返回一个 Web3.js <code>call</code> 我们合约里的<code>zombieToOwner</code> 。</p>
</li>
<li><p>之后在下面，为 <code>getZombiesByOwner</code> 定义一个方法。如果你还能记起 <code>ZombieHelper.sol</code>，这个方法定义像这样：</p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function getZombiesByOwner(address _owner)</span><br></pre></td></tr></tbody></table></figure>

<p> 我们的 <code>getZombiesByOwner</code> 方法将接收 <code>owner</code> 作为参数，并返回一个对我们函数 <code>getZombiesByOwner</code>的 Web3.js <code>call</code></p>
</li>
</ol>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Define `zombieToOwner` here</span></span><br><span class="line">     <span class="keyword">function</span> <span class="title function_">zombieToOwner</span>(<span class="params">id</span>){</span><br><span class="line">       <span class="keyword">return</span> cryptoZombies.<span class="property">methods</span>.<span class="title function_">zombieToOwner</span>(id).<span class="title function_">call</span>()</span><br><span class="line">     }</span><br><span class="line">     <span class="comment">// 2. Define `getZombiesByOwner` here</span></span><br><span class="line">     <span class="keyword">function</span> <span class="title function_">getZombiesByOwner</span>(<span class="params">owner</span>){</span><br><span class="line">       <span class="keyword">return</span> cryptoZombies.<span class="property">methods</span>.<span class="title function_">getZombiesByOwner</span>(owner).<span class="title function_">call</span>()</span><br><span class="line">     }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第5章-MetaMask-和账户"><a href="#第5章-MetaMask-和账户" class="headerlink" title="第5章: MetaMask 和账户"></a>第5章: MetaMask 和账户</h3><p>太棒了！你成功地写了一些前端代码来和你的第一个智能合约交互。</p>
<p>接下来我们综合一下——比如我们想让我们应用的首页显示用户的整个僵尸大军。</p>
<p>毫无疑问我们首先需要用 <code>getZombiesByOwner(owner)</code> 来查询当前用户的所有僵尸ID。</p>
<p>但是我们的 Solidity 合约需要 <code>owner</code> 作为 Solidity <code>address</code>。我们如何能知道应用用户的地址呢？</p>
<p><strong>获得 MetaMask中的用户账户</strong></p>
<p>MetaMask 允许用户在扩展中管理多个账户。</p>
<p>我们可以通过这样来获取 <code>web3</code> 变量中激活的当前账户：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> userAccount = web3.<span class="property">eth</span>.<span class="property">accounts</span>[<span class="number">0</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>因为用户可以随时在 MetaMask 中切换账户，我们的应用需要监控这个变量，一旦改变就要相应更新界面。例如，若用户的首页展示它们的僵尸大军，当他们在 MetaMask 中切换了账号，我们就需要更新页面来展示新选择的账户的僵尸大军。</p>
<p>我们可以通过 <code>setInterval</code> 方法来做:</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> accountInterval = <span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="comment">// 检查账户是否切换</span></span><br><span class="line">  <span class="keyword">if</span> (web3.<span class="property">eth</span>.<span class="property">accounts</span>[<span class="number">0</span>] !== userAccount) {</span><br><span class="line">    userAccount = web3.<span class="property">eth</span>.<span class="property">accounts</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 调用一些方法来更新界面</span></span><br><span class="line">    <span class="title function_">updateInterface</span>();</span><br><span class="line">  }</span><br><span class="line">}, <span class="number">100</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>这段代码做的是，每100毫秒检查一次 <code>userAccount</code> 是否还等于 <code>web3.eth.accounts[0]</code> (比如：用户是否还激活了那个账户)。若不等，则将 当前激活用户赋值给 <code>userAccount</code>，然后调用一个函数来更新界面。</p>
<p><strong>实战演习</strong></p>
<p>我们来让应用在页面第一次加载的时候显示用户的僵尸大军，监控当前 MetaMask 中的激活账户，并在账户发生改变的时候刷新显示。</p>
<ol>
<li><p>定义一个名为<code>userAccount</code>的变量，不给任何初始值。</p>
</li>
<li><p>在 <code>startApp()</code>函数的最后，复制粘贴上面样板代码中的 <code>accountInterval</code> 方法进去。</p>
</li>
<li><p>将 <code>updateInterface();</code>替换成一个 <code>getZombiesByOwner</code> 的 <code>call</code> 函数，并传入 <code>userAccount</code>。</p>
</li>
<li><p>在 <code>getZombiesByOwner</code> 后面链式调用<code>then</code> 语句，并将返回的结果传入名为 <code>displayZombies</code> 的函数。 (语句像这样: <code>.then(displayZombies);</code>).</p>
<p> 我们还没有 <code>displayZombies</code> 函数，将于下一章实现。</p>
</li>
</ol>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. declare `userAccount` here</span></span><br><span class="line">      <span class="keyword">var</span> userAccount;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">function</span> <span class="title function_">startApp</span>(<span class="params"></span>) {</span><br><span class="line">        <span class="keyword">var</span> cryptoZombiesAddress = <span class="string">"YOUR_CONTRACT_ADDRESS"</span>;</span><br><span class="line">        cryptoZombies = <span class="keyword">new</span> web3js.<span class="property">eth</span>.<span class="title class_">Contract</span>(cryptoZombiesABI, cryptoZombiesAddress);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. Create `setInterval` code here</span></span><br><span class="line">        <span class="keyword">var</span> accountInterval = <span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line">        <span class="comment">// 检查账户是否切换</span></span><br><span class="line">        <span class="keyword">if</span> (web3.<span class="property">eth</span>.<span class="property">accounts</span>[<span class="number">0</span>] !== userAccount) {</span><br><span class="line">          userAccount = web3.<span class="property">eth</span>.<span class="property">accounts</span>[<span class="number">0</span>];</span><br><span class="line">          <span class="comment">// 调用一些方法来更新界面</span></span><br><span class="line">          <span class="title function_">getZombiesByOwner</span>(userAccount).<span class="title function_">then</span>(displayZombies);</span><br><span class="line">        }</span><br><span class="line">      }, <span class="number">100</span>);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>



















































<h2 id="openzeppelin攻防挑战"><a href="#openzeppelin攻防挑战" class="headerlink" title="openzeppelin攻防挑战"></a>openzeppelin攻防挑战</h2><h3 id="1-Hello-Ethernaut"><a href="#1-Hello-Ethernaut" class="headerlink" title="1 Hello Ethernaut"></a>1 Hello Ethernaut</h3><p>这道题，主要考察的是控制台执行函数调用，通过语句<code>contract.函数名</code>来进行函数的调用，从而查看函数的返回值，然后进入下一个内容，层层递进，最终完成合约交互，提交最终的实例。</p>
<p><strong>生成的实例是真实部署到测试网的合约</strong></p>
<p>执行流程</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">contract.info()</span><br><span class="line">contract.info1()</span><br><span class="line">contract.info2("hello")</span><br><span class="line">contract.infoNum()</span><br><span class="line">contract.info42()</span><br><span class="line">contract.theMethodName()</span><br><span class="line">contract.method7123949()</span><br><span class="line">contract.password()</span><br><span class="line">contract.authenticate("ethern0")</span><br></pre></td></tr></tbody></table></figure>

<p>合约源码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Instance {</span><br><span class="line">    string public password;</span><br><span class="line">    uint8 public infoNum = 42;</span><br><span class="line">    string public theMethodName = "The method name is method7123949.";</span><br><span class="line">    bool private cleared = false;</span><br><span class="line"></span><br><span class="line">    // constructor</span><br><span class="line">    constructor(string memory _password) {</span><br><span class="line">        password = _password;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function info() public pure returns (string memory) {</span><br><span class="line">        return "You will find what you need in info1().";</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function info1() public pure returns (string memory) {</span><br><span class="line">        return 'Try info2(), but with "hello" as a parameter.';</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function info2(string memory param) public pure returns (string memory) {</span><br><span class="line">        if (keccak256(abi.encodePacked(param)) == keccak256(abi.encodePacked("hello"))) {</span><br><span class="line">            return "The property infoNum holds the number of the next info method to call.";</span><br><span class="line">        }</span><br><span class="line">        return "Wrong parameter.";</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function info42() public pure returns (string memory) {</span><br><span class="line">        return "theMethodName is the name of the next method.";</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function method7123949() public pure returns (string memory) {</span><br><span class="line">        return "If you know the password, submit it to authenticate().";</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function authenticate(string memory passkey) public {</span><br><span class="line">        if (keccak256(abi.encodePacked(passkey)) == keccak256(abi.encodePacked(password))) {</span><br><span class="line">            cleared = true;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function getCleared() public view returns (bool) {</span><br><span class="line">        return cleared;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="2-Fallback"><a href="#2-Fallback" class="headerlink" title="2 Fallback"></a>2 Fallback</h3><blockquote>
<p>仔细看下面的合约代码.</p>
<p>通过这关你需要</p>
<ol>
<li>获得这个合约的所有权</li>
<li>把他的余额减到0</li>
</ol>
<p> 这可能有帮助</p>
<ul>
<li>如何通过与ABI互动发送ether</li>
<li>如何在ABI之外发送ether</li>
<li>转换 wei/ether 单位 (参见 <code>help()</code> 命令)</li>
<li>Fallback 方法</li>
</ul>
</blockquote>
<p>合约源码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Fallback {</span><br><span class="line">    mapping(address =&gt; uint256) public contributions;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    constructor() {			//构造函数，初始化操作</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        contributions[msg.sender] = 1000 * (1 ether);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    modifier onlyOwner() {		//函数修饰符，函数执行前先执行修饰符内的内容</span><br><span class="line">        require(msg.sender == owner, "caller is not the owner");	//验证调用者是否为主人</span><br><span class="line">        _;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function contribute() public payable {</span><br><span class="line">        require(msg.value &lt; 0.001 ether);</span><br><span class="line">        contributions[msg.sender] += msg.value;</span><br><span class="line">        if (contributions[msg.sender] &gt; contributions[owner]) {//如果贡献值大于主人，那么就成为主人</span><br><span class="line">            owner = msg.sender;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function getContribution() public view returns (uint256) {	//查询贡献值</span><br><span class="line">        return contributions[msg.sender];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function withdraw() public onlyOwner {		//提出所有余额</span><br><span class="line">        payable(owner).transfer(address(this).balance);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    receive() external payable {</span><br><span class="line">        require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>漏洞点</strong>：</p>
<ul>
<li><code>receive()</code> 函数在接收 ETH 时，若调用者有贡献记录（<code>contributions[msg.sender] &gt; 0</code>），会将其设为 <code>owner</code>。</li>
</ul>
<p><strong>攻击步骤：</strong></p>
<ol>
<li>调用 <code>contribute()</code> 存入少量 ETH</li>
</ol>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.<span class="title function_">contribute</span>({<span class="attr">value</span>: web3.<span class="property">utils</span>.<span class="title function_">toWei</span>(<span class="string">'0.0001'</span>)});</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>作用</strong>：满足 <code>contributions[msg.sender] &gt; 0</code> 的条件。</li>
<li><strong>关键限制</strong>：必须发送 <code>&lt; 0.001 ETH</code>（因 <code>contribute()</code> 中有数值检查）。</li>
</ul>
<ol start="2">
<li>直接发送 ETH 触发 <code>receive()</code></li>
</ol>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.<span class="title function_">sendTransaction</span>({<span class="attr">value</span>: web3.<span class="property">utils</span>.<span class="title function_">toWei</span>(<span class="string">'0.0001'</span>)});</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>原理</strong>：<ul>
<li>直接向合约地址转账（无 calldata）会触发 <code>receive()</code>。</li>
<li>由于攻击者已通过 <code>contribute()</code> 存入过 ETH，满足 <code>contributions[msg.sender] &gt; 0</code>，此时 <code>owner</code> 被修改为攻击者地址。</li>
</ul>
</li>
</ul>
<ol start="3">
<li>调用 <code>withdraw()</code> 提取所有 ETH</li>
</ol>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.<span class="title function_">withdraw</span>();</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>前提</strong>：攻击者已成为 <code>owner</code>（通过 <code>receive()</code> 篡改成功）。</li>
<li><strong>结果</strong>：合约余额被全部转移到攻击者地址。</li>
</ul>
<p><strong>修复建议</strong></p>
<ol>
<li><p><strong>分离 ETH 接收和权限管理</strong>：</p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">receive() external payable {</span><br><span class="line">    contributions[msg.sender] += msg.value; // 仅更新贡献值</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>使用明确的权限转移函数</strong>：</p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function transferOwnership(address newOwner) public onlyOwner {</span><br><span class="line">    owner = newOwner;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>添加事件日志</strong>：</p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event OwnershipTransferred(address oldOwner, address newOwner);</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h3 id="3-Fallout"><a href="#3-Fallout" class="headerlink" title="3 Fallout"></a>3 Fallout</h3><blockquote>
<p>获得以下合约的所有权来完成这一关.</p>
<p> 这可能有帮助</p>
<ul>
<li>Solidity Remix IDE</li>
</ul>
</blockquote>
<p>合约源码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import "openzeppelin-contracts-06/math/SafeMath.sol";</span><br><span class="line"></span><br><span class="line">contract Fallout {</span><br><span class="line">    using SafeMath for uint256;</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; uint256) allocations;</span><br><span class="line">    address payable public owner;</span><br><span class="line"></span><br><span class="line">    //constructor</span><br><span class="line">    function Fal1out() public payable {</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        allocations[owner] = msg.value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    modifier onlyOwner() {</span><br><span class="line">        require(msg.sender == owner, "caller is not the owner");</span><br><span class="line">        _;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function allocate() public payable {</span><br><span class="line">        allocations[msg.sender] = allocations[msg.sender].add(msg.value);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function sendAllocation(address payable allocator) public {</span><br><span class="line">        require(allocations[allocator] &gt; 0);</span><br><span class="line">        allocator.transfer(allocations[allocator]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function collectAllocations() public onlyOwner {</span><br><span class="line">        msg.sender.transfer(address(this).balance);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function allocatorBalance(address allocator) public view returns (uint256) {</span><br><span class="line">        return allocations[allocator];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>







<h1 id="8月13日"><a href="#8月13日" class="headerlink" title="8月13日"></a>8月13日</h1><table>
<thead>
<tr>
<th>今日学习内容</th>
</tr>
</thead>
<tbody><tr>
<td>智能合约开发</td>
</tr>
<tr>
<td>Chainlink预言机的solidity进阶课程</td>
</tr>
<tr>
<td>Hardhat开发框架-初学</td>
</tr>
</tbody></table>
<h2 id="智能合约开发-1"><a href="#智能合约开发-1" class="headerlink" title="智能合约开发"></a>智能合约开发</h2><h3 id="Dapp-架构和开发流程-1"><a href="#Dapp-架构和开发流程-1" class="headerlink" title="Dapp 架构和开发流程"></a>Dapp 架构和开发流程</h3><p>Dapp：去中心化应用，运行在区块链或分布式网络上，应用的逻辑和数据是由多个参与者共同维护。</p>
<h4 id="Dapp-架构-1"><a href="#Dapp-架构-1" class="headerlink" title="Dapp 架构"></a>Dapp 架构</h4><p>三个核心部分：</p>
<ol>
<li><strong>前端（User Interface）</strong>：</li>
</ol>
<ul>
<li>前端是 Dapp 与用户交互的界面，通常由 HTML、CSS 和 JavaScript（如 React、Vue 等框架）构建。与传统 Web 应用不同，Dapp 前端会连接区块链来调用智能合约，呈现数据和执行交易。</li>
<li>前端还需要集成区块链钱包（如 MetaMask）来进行身份验证和签署交易，确保用户的隐私和安全。</li>
</ul>
<ol start="2">
<li><strong>智能合约（Smart Contracts）</strong>：</li>
</ol>
<ul>
<li>智能合约是 Dapp 的核心，它定义了应用的业务逻辑，并部署在区块链上。智能合约通过执行自动化的规则来确保交易和操作的透明性与不可篡改性。</li>
<li>在以太坊平台上，智能合约通常使用 <strong>Solidity</strong> 编程语言编写，并通过 <strong>Ethereum Virtual Machine (EVM)</strong> 执行。</li>
</ul>
<ol start="3">
<li><strong>数据检索器（Indexer）</strong>：</li>
</ol>
<ul>
<li>智能合约通常以 <code>Event</code> 形式释放日志事件，比如释放代表 NFT 转移的 <code>Transfer</code> 事件，数据检索器会检索这些数据并将其写入到 PostgreSQL 等传统数据库中</li>
<li>Dapp 在前端进行数据展示时需要检索器内的数据。一个简单的示例是某 NFT 项目需要展示用户持有的所有 NFT，但是 NFT 合约并不会提供通过输入地址参数返回该地址下的所有 NFT 的函数，此时我们可以运行数据检索器将 <code>Transfer</code> 事件读取后写入传统数据库内，前端可以在传统数据库内检索用户持有的 NFT 数据</li>
</ul>
<ol start="4">
<li><strong>区块链和去中心化存储（Blockchain &amp; Decentralized Storage）</strong>：</li>
</ol>
<ul>
<li>区块链用于存储智能合约的状态数据及交易记录。去中心化存储如 <strong>IPFS</strong>（InterPlanetary File System）或 <strong>Arweave</strong>，用于存储大规模的非结构化数据（如图片、文档等），确保数据不易丢失和篡改。</li>
<li>通过使用去中心化存储，Dapp 确保所有数据在多个节点上备份，保证数据的持久性和去中心化特性。</li>
</ul>
<h4 id="Dapp-开发流程-1"><a href="#Dapp-开发流程-1" class="headerlink" title="Dapp 开发流程"></a>Dapp 开发流程</h4><ol>
<li><p><strong>需求分析与规划</strong></p>
<p> 在开发 Dapp 之前，首先需要进行需求分析和规划，明确应用的目标和功能。此阶段包括：</p>
<ul>
<li><strong>确定功能需求</strong>：需要定义用户可以进行的操作，比如转账、查询余额、创建投票等。</li>
<li><strong>选择区块链平台</strong>：决定在哪个平台上构建 Dapp（如以太坊、Solana、Polygon 等），这通常取决于目标用户群、交易成本、可扩展性等因素。</li>
<li><strong>设计用户体验（UX）</strong>：定义 Dapp 的界面设计和交互流程，确保用户能够轻松使用应用并与区块链交互。</li>
</ul>
</li>
<li><p><strong>智能合约开发</strong></p>
<p> 智能合约是 Dapp 的核心，负责执行去中心化的业务逻辑和存储重要的数据。在这一阶段，开发者需要：</p>
<ul>
<li><strong>编写智能合约</strong>：使用 <strong>Solidity</strong> 或其他智能合约语言编写合约，确保合约的功能满足需求分析中定义的要求。</li>
<li><strong>编写测试用例</strong>：为智能合约编写单元测试，确保合约逻辑正确、无漏洞。</li>
<li><strong>审计和优化</strong>：对合约进行安全审计，确保合约的安全性，避免常见漏洞（如重入攻击、整数溢出等）。</li>
</ul>
</li>
<li><p><strong>检索器开发</strong></p>
<p> 检索器是<u><strong>获取链上数据的核心</strong></u>，<u><strong>负责捕获智能合约释放的事件并以合理的方式将其存入数据库</strong></u>的不同的表内部。在这一阶段，开发者需要:</p>
<ul>
<li><strong>确定功能需要的数据内容</strong>: 前端使用的数据大部份都直接来自检索器，所以开发者需要确定前端工程师所需要的数据</li>
<li><strong>编写检索器程序</strong>: 目前主流的检索器框架，如 ponder 和 subgraph 都是用了 TypeScript 语言作为检索器的程序编写语言，开发者主要编写事件数据清理以及事件数据写入数据库的代码</li>
<li><strong>部署和运维</strong>: 编写程序完成后，一般使用 Docker 部署到云服务器中，当然目前很多检索器框架也提供 SaaS 服务，同时检索器作为一个常规的数据库应用需要运维</li>
</ul>
</li>
<li><p><strong>前端开发</strong></p>
<p> 前端是用户与 Dapp 交互的主要界面，因此开发前端时需要：</p>
<ul>
<li><strong>选择前端框架</strong>：可以使用现代前端框架（如 <strong>React</strong>、<strong>Vue</strong>）来构建 UI。前端将通过 JavaScript 与智能合约进行交互。</li>
<li><strong>连接钱包</strong>：通过集成 <strong>MetaMask</strong> 等 Web3 钱包，用户可以连接到 Dapp，并授权其与智能合约交互。</li>
<li><strong>显示区块链数据</strong>：前端需要从区块链和检索器内获取数据（如账户余额、交易记录），并通过用户界面展示。</li>
<li><strong>处理交易签名与确认</strong>：当用户发起交易时，前端需要与钱包进行交互，获取用户的签名并将交易发送到区块链。</li>
</ul>
</li>
<li><p><strong>与区块链交互</strong></p>
<p> 前端和智能合约通过 <strong>Viem</strong>（推荐）、<strong>Ethers.js</strong> 或 <strong>Wagmi</strong> 等现代化库进行交互。这些库提供更好的 TypeScript 支持和性能优化：</p>
<ul>
<li><strong>读取数据</strong>：前端通过智能合约的公共函数读取区块链上的状态数据（如余额、合约信息）。</li>
<li><strong>发送交易</strong>：当用户发起交易时，前端需要通过钱包签署交易并发送到区块链，执行合约中的某个功能（如转账）。</li>
</ul>
</li>
<li><p><strong>部署与上线</strong></p>
<p> 一旦开发完成，Dapp 进入部署阶段。具体步骤包括：</p>
<ul>
<li><strong>部署智能合约</strong>：推荐使用 <strong>Hardhat</strong> 或 <strong>Foundry</strong>（现代化开发工具）将智能合约部署到测试网（如 <strong>Sepolia</strong>、<strong>Holesky</strong>）或主网。</li>
<li><strong>前端部署</strong>：将前端应用部署到去中心化平台（如 <strong>IPFS</strong>）或传统的 Web 服务（Vercel）。</li>
<li><strong>发布和维护</strong>：将 Dapp 上线，进行用户反馈收集，定期更新合约和前端，修复潜在问题。</li>
</ul>
</li>
</ol>
<h3 id="Solidity-智能合约编程"><a href="#Solidity-智能合约编程" class="headerlink" title="Solidity 智能合约编程"></a>Solidity 智能合约编程</h3><h4 id="基础语法与开发范式"><a href="#基础语法与开发范式" class="headerlink" title="基础语法与开发范式"></a>基础语法与开发范式</h4><ol>
<li><p><strong>版本声明</strong></p>
<p> 每个 Solidity 文件必须以版本声明开始：</p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>数据类型</strong></p>
<p> 基本数据类型</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">描述</th>
<th align="center">示例</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">bool</td>
<td align="center">布尔值</td>
<td align="center">true / false</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">uint8</td>
<td align="center">8 位无符号整数</td>
<td align="center">0 ~ 255</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">uint16</td>
<td align="center">16 位无符号整数</td>
<td align="center">0 ~ 65535</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">uint256 / uint</td>
<td align="center">256 位无符号整数</td>
<td align="center">0 ~ (2^256 - 1)</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">int8</td>
<td align="center">8 位有符号整数</td>
<td align="center">-128 - 127</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">int256 / int</td>
<td align="center">256 位有符号整数</td>
<td align="center">-2^255 ~ (2^255 - 1)</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">address</td>
<td align="center">以太坊地址</td>
<td align="center">0x….</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">bytes1 ~ bytes32</td>
<td align="center">固定长度字节数组</td>
<td align="center">bytes32 data = “Hello”</td>
<td align="center">0x00</td>
</tr>
<tr>
<td align="center">bytes</td>
<td align="center">动态字节数组</td>
<td align="center">bytes memory data = “Hello World”</td>
<td align="center">“”</td>
</tr>
<tr>
<td align="center">string</td>
<td align="center">UTF-8 编码字符串</td>
<td align="center">string name = “Alice”</td>
<td align="center">“”</td>
</tr>
</tbody></table>
<p> 复合数据类型</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">语法</th>
<th align="center">描述</th>
<th align="center">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">静态数组</td>
<td align="center">T[k]</td>
<td align="center">固定长度数组</td>
<td align="center">uint[5] numbers</td>
</tr>
<tr>
<td align="center">动态数组</td>
<td align="center">T[]</td>
<td align="center">可变长度数组</td>
<td align="center">uint[] memory list</td>
</tr>
<tr>
<td align="center">映射</td>
<td align="center">mapping(K =&gt; V)</td>
<td align="center">键值对存储</td>
<td align="center">mapping(address =&gt; uint256) balances</td>
</tr>
<tr>
<td align="center">结构体</td>
<td align="center">struct</td>
<td align="center">自定义数据结构</td>
<td align="center"><code>struct Person { string name; uint age; }</code></td>
</tr>
<tr>
<td align="center">枚举</td>
<td align="center">enum</td>
<td align="center">枚举类型</td>
<td align="center"><code>enum Status { Pending, Active, Inactive }</code></td>
</tr>
</tbody></table>
</li>
<li><p><strong>函数修饰符</strong></p>
<p> 可见性修饰符表</p>
<table>
<thead>
<tr>
<th align="center">修饰符</th>
<th align="center">可见范围</th>
<th align="center">描述</th>
<th align="center">使用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public</td>
<td align="center">内部 + 外部</td>
<td align="center">任何地方都可以调用</td>
<td align="center">对外提供的公共接口</td>
</tr>
<tr>
<td align="center">external</td>
<td align="center">仅外部</td>
<td align="center">只能从合约外部调用</td>
<td align="center">外部用户接口，gas 效率更高</td>
</tr>
<tr>
<td align="center">internal</td>
<td align="center">内部 + 继承</td>
<td align="center">当前合约和子合约可调用</td>
<td align="center">内部逻辑函数，需要被继承</td>
</tr>
<tr>
<td align="center">private</td>
<td align="center">仅内部</td>
<td align="center">只有当前合约可调用</td>
<td align="center">私有实现细节</td>
</tr>
</tbody></table>
<p> 状态修饰符表</p>
<table>
<thead>
<tr>
<th align="center">修饰符</th>
<th align="center">状态读取</th>
<th align="center">状态修改</th>
<th align="center">Gas 消耗</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">pure</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">低</td>
<td align="center">不读取也不修改状态的函数</td>
</tr>
<tr>
<td align="center">view</td>
<td align="center">✅</td>
<td align="center">❌</td>
<td align="center">低</td>
<td align="center">只读取状态，不修改状态</td>
</tr>
<tr>
<td align="center">payable</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">正常</td>
<td align="center">可以接收以太币的函数</td>
</tr>
<tr>
<td align="center">无修饰符</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">正常</td>
<td align="center">可以读取和修改状态</td>
</tr>
</tbody></table>
</li>
<li><p><strong>开发范式</strong></p>
<ul>
<li><p><strong>状态机模式</strong></p>
<p>  智能合约本质上是一个状态机，通过交易改变合约状态。</p>
</li>
<li><p><strong>事件驱动编程</strong></p>
<p>  使用事件（Events）记录重要的状态变化，便于前端监听和日志记录。</p>
</li>
<li><p><strong>模块化设计</strong></p>
<p>  通过继承和库（Library）实现代码复用和模块化。</p>
</li>
</ul>
</li>
</ol>
<h4 id="合约结构详解"><a href="#合约结构详解" class="headerlink" title="合约结构详解"></a>合约结构详解</h4><ol>
<li><p><strong>基本结构</strong></p>
<ol>
<li><code>//</code> 是 Solidity 中的单行注释符号，例如：<code>// SPDX-License-Identifier: MIT</code> 用于指定源代码的许可证类型。</li>
<li><code>pragma</code> 关键字用于声明 Solidity 源代码所需的编译器版本，确保合约在兼容的编译器环境中正确编译。</li>
<li><code>contract</code> 关键字用于定义一个智能合约，其语法格式为：<code>contract 合约名 { ... }</code>。</li>
<li>一个智能合约的基本结构通常由以下三部分组成：状态变量、构造函数和普通函数。</li>
</ol>
 <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract MyContract {</span><br><span class="line">    // 状态变量</span><br><span class="line">    uint256 public myNumber;</span><br><span class="line"></span><br><span class="line">    // 构造函数</span><br><span class="line">    constructor() {</span><br><span class="line">        myNumber = 100;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 函数</span><br><span class="line">    function setNumber(uint256 _number) public {</span><br><span class="line">        myNumber = _number;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>状态变量（State Variables）</strong></p>
<p> 状态变量是指在合约中定义的、其值永久存储在区块链上的变量。它们用于记录合约的持久化数据，构成了合约的整体状态。当合约被部署后，这些变量将被写入区块链，并在合约的整个生命周期中保持可访问性和可追踪性。</p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">contract MyContract {</span><br><span class="line">    /*</span><br><span class="line">    * 可以通过内部与外部函数更改变量</span><br><span class="line">    * public可以通过前端代码访问</span><br><span class="line">    */</span><br><span class="line">    uint256 public totalSupply;</span><br><span class="line">    mapping(address =&gt; uint256) private balances;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    // 常量</span><br><span class="line">    uint256 public constant MAX_SUPPLY = 1000000;</span><br><span class="line"></span><br><span class="line">    // 不可变量（构造函数中设置一次）</span><br><span class="line">    uint256 public immutable deploymentTime;</span><br><span class="line"></span><br><span class="line">    constructor() {</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        deploymentTime = block.timestamp;</span><br><span class="line">        totalSupply = 0;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>函数（Functions）</strong></p>
<p> 函数是 Solidity 智能合约中执行具体逻辑操作的核心组成部分。通过函数，可以实现对状态变量的读取、修改，或执行特定业务逻辑。</p>
<p> <strong>函数声明格式</strong></p>
<p> Solidity 中函数的标准声明格式如下所示：</p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function &lt;函数名&gt;(&lt;参数列表&gt;)</span><br><span class="line">    &lt;可见性&gt;</span><br><span class="line">    &lt;状态可变性&gt;</span><br><span class="line">    &lt;修饰符列表&gt;</span><br><span class="line">    &lt;虚拟/重写关键字&gt;</span><br><span class="line">    returns (&lt;返回值列表&gt;)</span><br><span class="line">{</span><br><span class="line">    // 函数体</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p> 各部分含义如下：</p>
<ul>
<li><code>&lt;函数名&gt;</code>：函数的名称；</li>
<li><code>&lt;参数列表&gt;</code>：传入函数的参数；</li>
<li><code>&lt;可见性修饰符&gt;</code>：如 <code>public</code>、<code>private</code>、<code>internal</code>、<code>external</code>；</li>
<li><code>&lt;状态可变性修饰符&gt;</code>：如 <code>view</code>、<code>pure</code>、<code>payable</code>；</li>
<li><code>&lt;函数修饰符&gt;</code>：如 <code>onlyOwner</code> 等自定义逻辑控制；</li>
<li><code>virtual/override</code>：用于支持继承与函数重写；</li>
<li><code>returns</code>：定义返回值及其类型。</li>
</ul>
<p> <strong>函数可见性（Function Visibility）</strong></p>
<p> 函数可见性决定了函数在何种上下文中可以被调用</p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">contract VisibilityExample {</span><br><span class="line">    // 仅当前合约可访问</span><br><span class="line">    function privateFunc() private pure returns(uint256) { return 1; }</span><br><span class="line">    // 当前合约和继承合约可访问</span><br><span class="line">    function internalFunc() internal pure returns(uint256) { return 2; }</span><br><span class="line">    // 所有人可访问</span><br><span class="line">    function publicFunc() public pure returns(uint256) { return 3; }</span><br><span class="line">    // 仅外部调用</span><br><span class="line">    function externalFunc() external pure returns(uint256) { return 4; }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p> <strong>函数状态修饰符</strong>（State Mutability Modifiers）</p>
<p> 用于指明函数是否修改或读取合约状态：</p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">contract StateModifiers {</span><br><span class="line">    uint256 public count = 0;</span><br><span class="line"></span><br><span class="line">    // view: 只读函数，不修改状态</span><br><span class="line">    function getCount() public view returns(uint256) {</span><br><span class="line">        return count;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // pure: 纯函数，不读取也不修改状态</span><br><span class="line">    function add(uint256 a, uint256 b) public pure returns(uint256) {</span><br><span class="line">        return a + b;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // payable: 可接收以太币</span><br><span class="line">    function deposit() public payable {</span><br><span class="line">        // msg.value 是发送的以太币数量</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 默认：可修改状态</span><br><span class="line">    function increment() public {</span><br><span class="line">        count++;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p> <strong>函数参数和返回值</strong></p>
<p> Solidity 支持多参数与多返回值，以及命名返回值：</p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 多个返回值</span><br><span class="line">function getPersonInfo() public pure returns(string memory name, uint256 age) {</span><br><span class="line">    name = "Alice";</span><br><span class="line">    age = 25;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 命名返回值</span><br><span class="line">function calculate(uint256 a, uint256 b) public pure returns(uint256 sum, uint256 product) {</span><br><span class="line">    sum = a + b;</span><br><span class="line">    product = a * b;</span><br><span class="line">    // 自动返回命名变量</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 调用带多返回值的函数</span><br><span class="line">function callExample() public pure {</span><br><span class="line">    (string memory name, uint256 age) = getPersonInfo();</span><br><span class="line">    // 或者忽略某些返回值</span><br><span class="line">    (, uint256 productOnly) = calculate(5, 3);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p> <strong>修饰符（Function Modifiers）</strong></p>
<p> 修饰符允许在函数执行前插入额外逻辑，常用于权限控制与前置检查：</p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">contract ModifierExample {</span><br><span class="line">    address public owner;</span><br><span class="line">    bool public paused = false;</span><br><span class="line"></span><br><span class="line">    constructor() {</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 自定义修饰符</span><br><span class="line">    modifier onlyOwner() {</span><br><span class="line">        require(msg.sender == owner, "Not the owner");</span><br><span class="line">        _;  // 继续执行被修饰的函数</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    modifier whenNotPaused() {</span><br><span class="line">        require(!paused, "Contract is paused");</span><br><span class="line">        _;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function togglePause() public onlyOwner {</span><br><span class="line">        paused = !paused;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 使用多个修饰符</span><br><span class="line">    function criticalFunction() public onlyOwner whenNotPaused {</span><br><span class="line">        // 函数逻辑</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p> <strong>继承与函数重写（Inheritance and Override）</strong></p>
<p> Solidity 支持单继承与多继承，子合约可重写父合约中的函数：</p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 基础合约</span><br><span class="line">contract Animal {</span><br><span class="line">    string public name;</span><br><span class="line"></span><br><span class="line">    constructor(string memory _name) {</span><br><span class="line">        name = _name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function speak() public virtual returns(string memory) {</span><br><span class="line">        return "Some sound";</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 继承合约</span><br><span class="line">contract Dog is Animal {</span><br><span class="line">    constructor(string memory _name) Animal(_name) {}</span><br><span class="line"></span><br><span class="line">    // 重写父类函数</span><br><span class="line">    function speak() public pure override returns(string memory) {</span><br><span class="line">        return "Woof!";</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 多重继承</span><br><span class="line">contract Pet is Animal {</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    constructor(string memory _name, address _owner) Animal(_name) {</span><br><span class="line">        owner = _owner;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">contract Labrador is Dog, Pet {</span><br><span class="line">    constructor(string memory _name, address _owner)</span><br><span class="line">        Dog(_name)</span><br><span class="line">        Pet(_name, _owner) {}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p> <strong>接口与抽象合约（Interfaces &amp; Abstract Contracts）</strong></p>
<p> 接口与抽象合约用于定义规范与继承框架：</p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 接口定义</span><br><span class="line">interface IERC20 {</span><br><span class="line">    function transfer(address to, uint256 amount) external returns (bool);</span><br><span class="line">    function balanceOf(address account) external view returns (uint256);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 抽象合约</span><br><span class="line">abstract contract AbstractToken {</span><br><span class="line">    string public name;</span><br><span class="line"></span><br><span class="line">    // 没有函数体的抽象函数，必须被子类使用 override 关键词重载实现</span><br><span class="line">    function totalSupply() public virtual returns (uint256);</span><br><span class="line"></span><br><span class="line">    // 有函数体实现的抽象函数，子类可以不使用 override 关键词重载直接继承已有的实现，也可以选择使用 override 关键词重载实现</span><br><span class="line">    function decimals() public view virtual returns (uint8) {</span><br><span class="line">        return 18;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p> <strong>事件机制（Events）</strong></p>
<p> 事件用于在链上记录重要状态变化，并可由外部监听器（如检索器或前端应用）捕捉：</p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">contract EventExample {</span><br><span class="line">    // 定义事件</span><br><span class="line">    event Transfer(address indexed from, address indexed to, uint256 amount);</span><br><span class="line">    event Approval(address indexed owner, address indexed spender, uint256 amount);</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    function transfer(address to, uint256 amount) public {</span><br><span class="line">        require(balances[msg.sender] &gt;= amount, "Insufficient balance");</span><br><span class="line"></span><br><span class="line">        balances[msg.sender] -= amount;</span><br><span class="line">        balances[to] += amount;</span><br><span class="line"></span><br><span class="line">        // 触发事件</span><br><span class="line">        // 可以在区块链浏览器查找到当前事件记录</span><br><span class="line">        emit Transfer(msg.sender, to, amount);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h3 id="以太坊技术基础"><a href="#以太坊技术基础" class="headerlink" title="以太坊技术基础"></a>以太坊技术基础</h3><h4 id="帐户模型"><a href="#帐户模型" class="headerlink" title="帐户模型"></a>帐户模型</h4><table>
<thead>
<tr>
<th align="left">对比维度</th>
<th align="left">外部拥有账户 <strong>EOA</strong></th>
<th align="left">合约账户 <strong>Contract Account</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">地址来源</td>
<td align="left"><code>keccak256(pubKey)[12:]</code>  (公钥 → 地址)</td>
<td align="left">创建时由 <code>CREATE/CREATE2</code> 计算</td>
</tr>
<tr>
<td align="left">控制方式</td>
<td align="left"><strong>私钥签名</strong>（用户、钱包）</td>
<td align="left"><strong>合约代码</strong>（EVM 字节码）</td>
</tr>
<tr>
<td align="left">状态字段</td>
<td align="left"><code>nonce</code>、<code>balance</code></td>
<td align="left"><code>nonce</code>、<code>balance</code>、<code>codeHash</code>、<code>storageRoot</code></td>
</tr>
<tr>
<td align="left">能否发起交易</td>
<td align="left">✅  必须用私钥签名</td>
<td align="left">❌  只能由 EOA 触发或合约内部调用</td>
</tr>
<tr>
<td align="left">Gas 费用支付</td>
<td align="left">由账户本身 ETH 余额承担</td>
<td align="left">由调用者支付</td>
</tr>
<tr>
<td align="left">典型场景</td>
<td align="left">钱包地址、热冷账户</td>
<td align="left">ERC-20/721 Token、DeFi 协议、DAO</td>
</tr>
</tbody></table>
<h4 id="Gas-机制"><a href="#Gas-机制" class="headerlink" title="Gas 机制"></a>Gas 机制</h4><table>
<thead>
<tr>
<th align="left">术语</th>
<th align="left">含义</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Gas</strong></td>
<td align="left">执行 1 条 EVM 指令的抽象工作量单位</td>
<td align="left">汇编级别价格表见 <a target="_blank" rel="noopener" href="https://www.evm.codes/">evm.codes</a></td>
</tr>
<tr>
<td align="left"><strong>Gas Limit (Tx)</strong></td>
<td align="left">发送者愿为本笔交易消耗的 Gas 上限</td>
<td align="left">防止死循环耗尽余额</td>
</tr>
<tr>
<td align="left"><strong>Gas Used</strong></td>
<td align="left">实际执行指令花费的 Gas 总和</td>
<td align="left">多退少不补</td>
</tr>
<tr>
<td align="left"><strong>Base Fee</strong></td>
<td align="left">随区块动态调整的基础费用（EIP-1559）</td>
<td align="left">全网销毁，抑制拍卖狂飙</td>
</tr>
<tr>
<td align="left"><strong>Priority Fee / Tip</strong></td>
<td align="left">发送者给出以激励打包者的附加费</td>
<td align="left">给矿工 / 验证者</td>
</tr>
<tr>
<td align="left"><strong>Max Fee Per Gas</strong></td>
<td align="left"><code>maxFee = baseFee + priorityFee</code> 上限</td>
<td align="left">钱包通常自动估算</td>
</tr>
</tbody></table>
<h4 id="交易生命周期"><a href="#交易生命周期" class="headerlink" title="交易生命周期"></a>交易生命周期</h4><ul>
<li>签名构造<ul>
<li>钱包收集字段：<code>nonce, to, value, data, gasLimit, maxFeePerGas, priorityFeePerGas, chainId</code></li>
<li>使用私钥生成 <code>v, r, s</code> 签名 → <strong>序列化 RLP</strong></li>
</ul>
</li>
<li>广播到 P2P 网络<ul>
<li>交易进入本地 &amp; 邻居节点的 <strong>mempool</strong></li>
<li>节点根据 <code>maxFeePerGas</code>、<code>gasLimit</code>、<code>nonce</code> 做基本筛查</li>
</ul>
</li>
<li>打包 / 提议区块<ul>
<li>验证者（PoS）或矿工（PoW 时代）挑选利润最高、合法顺序的交易</li>
<li>执行 EVM → 产生 <strong>交易收据</strong>（<code>status, gasUsed, logsBloom, logs[]</code>）</li>
</ul>
</li>
<li>区块传播与共识<ul>
<li>区块头包含新 <strong>stateRoot</strong>、<strong>receiptsRoot</strong></li>
<li>超 2⁄3 质押者签名后在共识层定案（PoS Finality ≈ 2 Epoch ≈ 64 slot ≈ ~12 min）</li>
</ul>
</li>
<li>确认数 &amp; Finality<ul>
<li>客户端/前端常以 <code>n ≥ 12</code> 作”概率足够低”确认</li>
<li>完全终结在 PoS 下由 <strong>Finality Gadget</strong>（Casper FFG）给出</li>
</ul>
</li>
</ul>
<h2 id="Chainlink预言机的solidity进阶课程-1"><a href="#Chainlink预言机的solidity进阶课程-1" class="headerlink" title="Chainlink预言机的solidity进阶课程"></a>Chainlink预言机的solidity进阶课程</h2><h3 id="虚函数："><a href="#虚函数：" class="headerlink" title="虚函数："></a>虚函数：</h3><p>允许函数在继承合约中被<strong>重写（Override）</strong></p>
<p>在父合约中声明为 <code>virtual</code> 的函数，表示允许子合约重写该函数。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 父合约</span><br><span class="line">abstract contract Parent {</span><br><span class="line">    function foo() public virtual;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 子合约</span><br><span class="line">contract Child is Parent {</span><br><span class="line">    function foo() public override {</span><br><span class="line">        return "Child"; // 重写父合约函数</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注意：</p>
<ul>
<li><p><strong>存在虚函数的合约必须为抽象合约，也就是再合约开头添加abstract</strong></p>
</li>
<li><p><strong>如果虚函数没有函数体，那么继承了抽象父合约的子合约需要重写虚函数，或者使用抽象子合约</strong></p>
</li>
</ul>
<h3 id="部署一个Token合约"><a href="#部署一个Token合约" class="headerlink" title="部署一个Token合约"></a>部署一个Token合约</h3><p>基础版本</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.20;</span><br><span class="line"></span><br><span class="line">contract FundToken{</span><br><span class="line">    //1.通证的名字</span><br><span class="line">    //2.通证的简称</span><br><span class="line">    //3.通证的发行数量</span><br><span class="line">    //4.合约的owner</span><br><span class="line">    //5.balance address =&gt; uint256</span><br><span class="line">    string public tokenName;</span><br><span class="line">    string public tokenSymbol;</span><br><span class="line">    uint256 public totalSupply;</span><br><span class="line">    address public owner;</span><br><span class="line">    mapping (address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    constructor(string memory _tokenName, string memory _tokenSymbol){</span><br><span class="line">        tokenName = _tokenName;</span><br><span class="line">        tokenSymbol = _tokenSymbol;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //mint：获取通证</span><br><span class="line">    function mint(uint256 amountToMint) public {</span><br><span class="line">        balances[msg.sender] += amountToMint;</span><br><span class="line">        totalSupply += amountToMint;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //transfer: transfer通证</span><br><span class="line">    function transfer(address payee, uint256 amount) public {</span><br><span class="line">        require(balances[msg.sender] &gt;= amount, "You do not have enough balance to transfer");</span><br><span class="line">        balances[msg.sender] -= amount;</span><br><span class="line">        balances[payee] += amount;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //balance0f: 查看某个地址的通证数量</span><br><span class="line">    function balanceOf(address addr) public view returns(uint256){</span><br><span class="line">        return balances[addr];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>ERC-20继承版本</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.20;</span><br><span class="line">//FundMe</span><br><span class="line">//1.让FundMe的参与者，基于 mapping来领取相应数量的通证</span><br><span class="line">//2.让FundMe的参与者 transfer通证</span><br><span class="line">//3.在使用完成之后，需要 burn 验证</span><br><span class="line"></span><br><span class="line">import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";</span><br><span class="line">import {FundMe} from "../Fund/FundMe.sol";</span><br><span class="line"></span><br><span class="line">contract FundTokenERC20 is ERC20{</span><br><span class="line">    FundMe fundMe;</span><br><span class="line">    constructor(address fundMeAddr) ERC20("FundTokenERC20","FT"){</span><br><span class="line">        fundMe = FundMe(fundMeAddr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function mint(uint256 amountToMint) public {</span><br><span class="line">        require(fundMe.fundersToAmount(msg.sender) &gt;= amountToMint, "You cannot mint this many tokens");</span><br><span class="line">        require(fundMe.getFundSuccess(), "The fundme is not completed yet");    //保证在时间窗口</span><br><span class="line">        _mint(msg.sender, amountToMint);</span><br><span class="line">        fundMe.setFunderToAmount(msg.sender, fundMe.fundersToAmount(msg.sender) - amountToMint);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function claim(uint256 amountToClaim) public {</span><br><span class="line">        //完成兑换</span><br><span class="line">        require(balanceOf(msg.sender) &gt;= amountToClaim, "You do not have enough REC20 tokens");</span><br><span class="line">        require(fundMe.getFundSuccess(), "The fundme is not completed yet");    //保证在时间窗口     </span><br><span class="line">        //burn amountToClaim Tokens</span><br><span class="line">        _burn(msg.sender, amountToClaim);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<h1 id="8月14日"><a href="#8月14日" class="headerlink" title="8月14日"></a>8月14日</h1><table>
<thead>
<tr>
<th>今日学习内容</th>
</tr>
</thead>
<tbody><tr>
<td>Hardhat开发框架</td>
</tr>
</tbody></table>
<p>今天主要实操会比较多，大部分时间在研究数据包为什么导入失败，为什么部署失败，主要是在解决一些疑难杂症</p>
<h2 id="Hardhat开发框架"><a href="#Hardhat开发框架" class="headerlink" title="Hardhat开发框架"></a>Hardhat开发框架</h2><p>主流开发框架</p>
<table>
<thead>
<tr>
<th align="center">框架</th>
<th align="center">语言</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Hardhat</td>
<td align="center">Javascript</td>
</tr>
<tr>
<td align="center">Truffle</td>
<td align="center">Javascript</td>
</tr>
<tr>
<td align="center">Foundry</td>
<td align="center">Rust</td>
</tr>
<tr>
<td align="center">Brownie</td>
<td align="center">Python</td>
</tr>
</tbody></table>
<p>需要安装的环境：node.js、vscode、git</p>
<h3 id="合约部署"><a href="#合约部署" class="headerlink" title="合约部署"></a>合约部署</h3><ol>
<li>创建Hardhat项目需要先创建npm项目，首先初始化npm项目，初始化中可以设置该项目的相关信息，初始化成功后，会生成package.json文件</li>
</ol>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>安装Hardhat包</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hardhat --save-dev</span><br></pre></td></tr></tbody></table></figure>

<p>–save-dev：只在开发环境中使用</p>
<ol start="3">
<li>创建Hardhat项目</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx hardhat</span><br></pre></td></tr></tbody></table></figure>

<ol start="4">
<li>下载我们需要的合约</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @chainlink/contracts --save-dev</span><br></pre></td></tr></tbody></table></figure>

<ol start="5">
<li>编译contract文件夹下的合约</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx hardhat compile</span><br></pre></td></tr></tbody></table></figure>

<ol start="6">
<li>部署合约</li>
</ol>
<p>使用插件部署</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx hardhat deploy</span><br></pre></td></tr></tbody></table></figure>

<p>使用脚本部署，创建一个js文件</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import ethers</span></span><br><span class="line"><span class="comment">// create main function</span></span><br><span class="line"><span class="comment">// execute main function</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> { ethers } = <span class="built_in">require</span>(<span class="string">"hardhat"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) {    <span class="comment">//异步函数</span></span><br><span class="line">  <span class="comment">// create factory</span></span><br><span class="line">  <span class="keyword">const</span> fundMeFactory = <span class="keyword">await</span> ethers.<span class="title function_">getContractFactory</span>(<span class="string">"FundMe"</span>)   <span class="comment">//await等待执行完成再往下执行</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"contract deploying"</span>)</span><br><span class="line">  <span class="comment">//deploy contract from factory</span></span><br><span class="line">  <span class="keyword">const</span> fundMe = <span class="keyword">await</span> fundMeFactory.<span class="title function_">deploy</span>()</span><br><span class="line">  <span class="keyword">await</span> fundMe.<span class="title function_">waitForDeployment</span>()      <span class="comment">//等待入块</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"contract has been deployed successfully, contract address is "</span> + fundMe.<span class="property">target</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="title function_">main</span>().<span class="title function_">then</span>().<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(error)</span><br><span class="line">  process.<span class="title function_">exit</span>(<span class="number">1</span>)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx hardhat run scripts/deployFundMe.js --network sepolia</span><br></pre></td></tr></tbody></table></figure>



<h3 id="网络-私钥配置"><a href="#网络-私钥配置" class="headerlink" title="网络&amp;私钥配置"></a>网络&amp;私钥配置</h3><p>想要发送到指定测试网，需要配置</p>
<ol>
<li>打开hardhat.config.js，添加network字段，填入测试网的url以及私钥</li>
</ol>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">"@nomicfoundation/hardhat-toolbox"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@type</span> import('hardhat/config').HardhatUserConfig */</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = {</span><br><span class="line">  <span class="attr">networks</span>: {</span><br><span class="line">    <span class="attr">sepolia</span>: {</span><br><span class="line">      <span class="attr">url</span>: <span class="string">"https://eth-sepolia.g.alchemy.com/v2/Vf-WXrhQ2Fv_u9XbSC9Mc"</span>,</span><br><span class="line">      <span class="attr">accounts</span>: [<span class="string">"xxxxx187b8aafb1c9f8af1b47ee14xxxxxcbe734b0a1ea01c91a5c30xxxxx"</span>]</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">  <span class="attr">solidity</span>: <span class="string">"0.8.28"</span>,</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p><strong>注意：私钥很重要，此处一定要创建一个测试账户来进行，因为你的代码一旦部署到github上，此配置文件是可见的，那么私钥就是暴露的。不过还有一个方法，此处可以将将私钥写入创建的env文件，然后通过调用的方式来使用，因为env是不会被上传到github的</strong></p>
<h4 id="env"><a href="#env" class="headerlink" title=".env"></a>.env</h4><p>引入一个dotenv包，将url和私钥写入.env文件</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev dotenv</span><br></pre></td></tr></tbody></table></figure>

<p>更改后配置</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">"@nomicfoundation/hardhat-toolbox"</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">"dotenv"</span>).<span class="title function_">config</span>()	</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">SEPOLIA_URL</span> = process.<span class="property">env</span>.<span class="property">SEPOLIA_URL</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PRIVATE_KEY</span> = process.<span class="property">env</span>.<span class="property">PRIVATE_KEY</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@type</span> import('hardhat/config').HardhatUserConfig */</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = {</span><br><span class="line">  <span class="attr">networks</span>: {</span><br><span class="line">    <span class="attr">sepolia</span>: {</span><br><span class="line">      <span class="attr">url</span>: <span class="variable constant_">SEPOLIA_URL</span>,</span><br><span class="line">      <span class="attr">accounts</span>: [<span class="variable constant_">PRIVATE_KEY</span>]</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">  <span class="attr">solidity</span>: <span class="string">"0.8.28"</span>,</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>.env</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SEPOLIA_URL = https://eth-sepolia.g.alchemy.com/v2/Vf-WXrhQ2Fv_u9XbSC9Mc</span><br><span class="line">PRIVATE_KEY = 55555187b8aafb1c9f8af1b47ee14e9134b9acbe734b0a1ea01c91a5c3055555</span><br></pre></td></tr></tbody></table></figure>

<p>然后运行部署脚本，显示部署成功</p>
<p><img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-14%20152454.png"></p>
<h4 id="env-enc"><a href="#env-enc" class="headerlink" title="env-enc"></a>env-enc</h4><p>当然，这样的方式仍然存在安全问题，一旦别人拿到这个配置文件，就还是有可能得到私钥，那么其实可以考虑加密该文件内容。</p>
<p>导入env-enc包</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @chainlink/env-enc</span><br></pre></td></tr></tbody></table></figure>

<p>使用env-enc设置密码</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx env-enc set-pw</span><br></pre></td></tr></tbody></table></figure>

<p>将配置文件通过加密的方式进行写入</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx env-enc set</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-14%20153536.png"></p>
<p>设置完成后，可以在.env.enc看到内容</p>
<p><img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-14%20153629.png"></p>
<p>再将hardhat.config.js文件中的require(“dotenv”)内容更改</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require("@chainlink/env-enc").config()	</span><br></pre></td></tr></tbody></table></figure>

<p>在.gitignore文件中增加.env.enc，来防止上传到github</p>
<h3 id="Hardhat-Verify"><a href="#Hardhat-Verify" class="headerlink" title="Hardhat Verify"></a>Hardhat Verify</h3><p> 借助于<a target="_blank" rel="noopener" href="https://hardhat.org/plugins/nomicfoundation-hardhat-verify">hardhat-verify</a>，Verify之后可以在etherscan上看到合约的代码以及可以查看和运行合约代码</p>
<p>安装插件</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @nomicfoundation/hardhat-verify</span><br></pre></td></tr></tbody></table></figure>

<p>导入包</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import hardhatVerify from "@nomicfoundation/hardhat-verify";</span><br></pre></td></tr></tbody></table></figure>

<p>因为hardhat这个插件默认运行在主网，所以此处需要获取etherscan的aipkey</p>
<p><code>hardhat.config.ts</code>您需要在文件中添加以下 Etherscan 配置</p>
<figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">  <span class="attr">verify</span>: {</span><br><span class="line">    <span class="attr">etherscan</span>: {</span><br><span class="line">      <span class="comment">// Your API key for Etherscan</span></span><br><span class="line">      <span class="comment">// Obtain one at https://etherscan.io/</span></span><br><span class="line">      <span class="attr">apiKey</span>: <span class="string">"&lt;ETHERSCAN_API_KEY&gt;"</span>,</span><br><span class="line">    },</span><br><span class="line">  },</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>运行<code>verify</code>任务，传递部署网络、合约地址以及用于部署它的构造函数参数</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx hardhat verify --network sepolia 合约地址 "10"</span><br></pre></td></tr></tbody></table></figure>

<p>这里还是建议使用导入，而不是直接显示apikey</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">ETHERSCAN_API_KEY</span> = process.<span class="property">env</span>.<span class="property">ETHERSCAN_API_KEY</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@type</span> import('hardhat/config').HardhatUserConfig */</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = {</span><br><span class="line">  <span class="attr">networks</span>: {</span><br><span class="line">    <span class="attr">sepolia</span>: {</span><br><span class="line">      <span class="attr">url</span>: <span class="variable constant_">SEPOLIA_URL</span>,</span><br><span class="line">      <span class="attr">accounts</span>: [<span class="variable constant_">PRIVATE_KEY</span>]</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">  <span class="attr">etherscan</span>: {</span><br><span class="line">    <span class="attr">apiKey</span>: {</span><br><span class="line">      <span class="attr">sepolia</span>: <span class="variable constant_">ETHERSCAN_API_KEY</span></span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">  <span class="attr">solidity</span>: <span class="string">"0.8.28"</span>,</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>在js脚本中加入内容，使用<code>verifyContract</code>插件中的函数以编程方式验证合约</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="title function_">verifyContract</span>(</span><br><span class="line">    {</span><br><span class="line">      <span class="attr">address</span>: fundMe.<span class="property">target</span>,</span><br><span class="line">      <span class="attr">constructorArgs</span>: [<span class="number">10</span>],</span><br><span class="line">      <span class="attr">provider</span>: <span class="string">"etherscan"</span>, <span class="comment">// or "blockscout" for Blockscout-compatible explorers</span></span><br><span class="line">    },</span><br><span class="line">    hre,</span><br><span class="line">  );</span><br></pre></td></tr></tbody></table></figure>

<p>然后运行</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx hardhat run scripts/deployFundMe.js --network sepolia</span><br></pre></td></tr></tbody></table></figure>



<h1 id="8月15日"><a href="#8月15日" class="headerlink" title="8月15日"></a>8月15日</h1><table>
<thead>
<tr>
<th>今日学习内容</th>
</tr>
</thead>
<tbody><tr>
<td>Web.js</td>
</tr>
</tbody></table>
<h2 id="Web-js"><a href="#Web-js" class="headerlink" title="Web.js"></a>Web.js</h2><h3 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h3><p>安装vue-cli</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br></pre></td></tr></tbody></table></figure>

<p>创建一个vue项目</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx @vue/cli create web3-wallet</span><br></pre></td></tr></tbody></table></figure>

<p>此处我使用了Vue3</p>
<p>到项目路径下启动项目</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run serve</span><br></pre></td></tr></tbody></table></figure>



<h3 id="配置安装vant-ui组件库"><a href="#配置安装vant-ui组件库" class="headerlink" title="配置安装vant-ui组件库"></a>配置安装vant-ui组件库</h3><p>安装</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install vant</span><br><span class="line">npm install unplugin-vue-components -D</span><br></pre></td></tr></tbody></table></figure>

<p>-D：只在dev开发环境中安装</p>
<p>在vue.config.js文件中配置插件</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> { defineConfig } = <span class="built_in">require</span>(<span class="string">'@vue/cli-service'</span>)</span><br><span class="line"><span class="keyword">const</span> { <span class="title class_">VantResolver</span> } = <span class="built_in">require</span>(<span class="string">'unplugin-vue-components/resolvers'</span>)		<span class="comment">//添加</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ComponentsPlugin</span> = <span class="built_in">require</span>(<span class="string">'unplugin-vue-components/webpack'</span>)			<span class="comment">//添加</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">defineConfig</span>({</span><br><span class="line">  <span class="attr">transpileDependencies</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">configureWebpack</span>: {														<span class="comment">//添加</span></span><br><span class="line">    <span class="attr">plugins</span>: [<span class="title class_">ComponentsPlugin</span>({ <span class="attr">resolvers</span>: [<span class="title class_">VantResolver</span>()] })],			<span class="comment">//添加</span></span><br><span class="line">  }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Web3连接到以太坊网络"><a href="#Web3连接到以太坊网络" class="headerlink" title="Web3连接到以太坊网络"></a>Web3连接到以太坊网络</h3><ol>
<li>web3是以太坊官方开提供的一个连接以太坊区块链的模块，允许使用HTTP或IPC与本地或远程以太坊节点进行交互，它包含以太坊生态系统的几乎所有功能。web3模块主要连接以太坊暴露出来的RPC层。开发者利用web3连接RPC层，可以连接任何暴露了RPC接口的节点，从而与区块链交互。web3是一个集合库，支持多种开发语言使用wbe3，其中的 JavaScript API 叫做web3.js、另外还有web3.py、web3j，web3.js将是我们钱包开发项目的重点</li>
</ol>
<table>
<thead>
<tr>
<th align="center">包</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">web3.eth</td>
<td align="center">用于与以太坊区块链和智能合约之间的交互</td>
</tr>
<tr>
<td align="center">web3.utils</td>
<td align="center">包含一些辅助方法</td>
</tr>
<tr>
<td align="center">web3.shh</td>
<td align="center">用于协议进行通信的P2P和广播</td>
</tr>
<tr>
<td align="center">web3.bzz</td>
<td align="center">用于与群网络交互的Bzz模块</td>
</tr>
</tbody></table>
<ol start="2">
<li>实例化web3对象</li>
</ol>
<p>安装web3</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install web3</span><br></pre></td></tr></tbody></table></figure>

<p>web3要与以坊节点进行交互，需要创建一个web3对象</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Web3</span> = <span class="built_in">require</span>(<span class="string">'web3'</span>);</span><br><span class="line"><span class="comment">// "web3.providers.givenProvider" will be set if in an Ethereum supported browser.</span></span><br><span class="line"><span class="keyword">var</span> web3= <span class="keyword">new</span> <span class="title class_">Web3</span>(web3.<span class="property">givenProvider</span> || <span class="string">'ws://some.local-or-remote.node:8546'</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>根据APl可知需要指定节点地址，我们将ws://some.local-or-remote.node:8546换成其它连接到以太坊网络的节点的地址，以此来确定连接的以太坊的网络。那么连接到以太坊网络的节点的地址是多少呢？这里我们需要使用到<br>alchemy</p>
<ol start="3">
<li>获取连接到以太坊网络的节点地址</li>
</ol>
<p>alchemy提供公开的Ethereum主网和测试网络节点，到alchemy.com网站注册后即可获取各个网络的地址。请按照如下步骤获取地址。<br>第一步：打开alchemy网站地址：<a target="_blank" rel="noopener" href="https://dashboard.alchemy.com/%EF%BC%8C%E4%BD%BF%E7%94%A8%E9%82%AE%E7%AE%B1%E6%B3%A8%E5%86%8C%E5%90%8E%E7%99%BB%E9%99%86">https://dashboard.alchemy.com/，使用邮箱注册后登陆</a></p>
<p>第二步：点击上图标记的“create new project”按钮创建一个新项目。然后弹出如下弹框，在输入框输入项目名，<br>如”MyEtherWallet“，然后点击“create project”按钮创建。</p>
<p>第三步：找到Ethereum下的sepolia测试网下的websockets接口</p>
<img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-15%20183046.png" style="zoom:50%;">

<ol start="4">
<li>连接到以太坊测试网络</li>
</ol>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Web3</span> = <span class="built_in">require</span>(<span class="string">"web3"</span>)</span><br><span class="line"><span class="keyword">var</span> web3=<span class="keyword">new</span> <span class="title class_">Web3</span>(web3.<span class="property">givenProvider</span> || <span class="string">'wss://eth-sepolia.g.alchemy.com/v2/cb7e63cf28244e4499b4b6fb6162e746'</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"web3:"</span>, web3)</span><br></pre></td></tr></tbody></table></figure>

<p>连接到以太坊主网与sepolia测试网络一样的，只需复制主网节点的地址去实例化web3即可。由于在主网上交易需要花费gas，因此我们基于sepolia测试网络进行开发，后续开发完成后可再切换到主网</p>
<h3 id="Web3-js高频API"><a href="#Web3-js高频API" class="headerlink" title="Web3.js高频API"></a>Web3.js高频API</h3><h4 id="账号创建"><a href="#账号创建" class="headerlink" title="账号创建"></a>账号创建</h4><p>API</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.accounts.create([entropy]);</span><br></pre></td></tr></tbody></table></figure>

<p>参数:</p>
<p>entropy-String（可选)：它是一个可选项，是一个随机字符串，将作为解锁账号的密码。如果没有传递字符串，则使用random生成随机字符串</p>
<p>返回值：</p>
<p>Object：包含以下字段的一个帐户对象：<br>address- string：帐户地址<br>privateKey-string：帐户私钥。前端永远不应该在localstorage中以未加密的方式共享或存储！<br>signTransaction(tx[, callback]) - Function：签名交易的方法。<br>sign(data)-Function：签名二进制交易的方法。</p>
<p>例子：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">web3.<span class="property">eth</span>.<span class="property">accounts</span>.<span class="title function_">create</span>(<span class="string">'2435a#@#@±±±</span></span><br><span class="line"><span class="string">+!!!!678543213456764321534567543213456785432134567'</span>);</span><br><span class="line">{</span><br><span class="line"><span class="attr">address</span>: <span class="string">"0×F2CD2AA0c7926743B1D4310b2BC984a0a453c3d4"</span>,</span><br><span class="line"><span class="attr">privateKey</span>: <span class="string">"0xd7325de5c2c1cf0009fac77d3d04a9c004b038883446b065871bc3e831dcd098"</span>,</span><br><span class="line"><span class="attr">signTransaction</span>: <span class="keyword">function</span>(<span class="params">tx</span>){...},</span><br><span class="line"><span class="attr">sign</span>: <span class="keyword">function</span>(<span class="params">data</span>){...},</span><br><span class="line"><span class="attr">encrypt</span>: <span class="keyword">function</span>(<span class="params">password</span>){...}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h4 id="余额获取"><a href="#余额获取" class="headerlink" title="余额获取"></a>余额获取</h4><p>根据地址获取以wei为单位余额</p>
<p>API</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">web3.<span class="property">eth</span>.<span class="title function_">getBalance</span>(address).<span class="title function_">then</span>((res）→{</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>例子：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取余额</span></span><br><span class="line">  <span class="keyword">const</span> mount = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line">  web3.<span class="property">eth</span>.<span class="title function_">getBalance</span>(address.<span class="property">value</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> {</span><br><span class="line">    mount.<span class="property">value</span> = res</span><br><span class="line">  })</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>在 Vue 3 的 Composition API 中，<code>ref</code> 是一个函数，用于创建一个<strong>响应式引用（reactive reference）</strong>，通常用于包装基本类型（如字符串、数字等），使其具有响应式能力。</p>
<p><code>ref</code> 的作用：</p>
<ol>
<li><strong>创建响应式数据</strong>：<code>ref</code> 会将传入的值包装在一个响应式对象中</li>
<li><strong>自动追踪依赖</strong>：当在模板或计算属性中使用时，Vue 会自动追踪它的变化</li>
<li><strong>触发视图更新</strong>：当 <code>ref</code> 的值改变时，Vue 会自动更新相关的 DOM</li>
</ol>
<p>代码解析：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> address = <span class="title function_">ref</span>(<span class="string">'0x6191a878F0CB11E707271bce5C5e6d20dbF7xxxx'</span>)</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>创建了一个响应式变量 <code>address</code>，初始值是 <code>'0x6191a878F0CB11E707271bce5C5e6d20dbF7xxxx'</code></li>
<li><code>address</code> 实际上是一个 <code>Ref</code> 对象，不是直接的字符串</li>
</ul>
<p>如何使用 <code>ref</code>：</p>
<ol>
<li><p><strong>读取值</strong>：需要通过 <code>.value</code> 访问实际值</p>
 <figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(address.<span class="property">value</span>) <span class="comment">// 输出: '0x6191a878F0CB11E707271bce5C5e6d20dbF7f6f5'</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>修改值</strong>：也必须通过 <code>.value</code> 修改</p>
 <figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">address.<span class="property">value</span> = <span class="string">'0xNewAddress...'</span> <span class="comment">// 修改后会触发响应式更新</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>在模板中使用</strong>：模板中会自动解包，不需要写 <code>.value</code></p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;{{ address }}&lt;/div&gt; &lt;!-- 自动显示 address.value --&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
</blockquote>
<h4 id="单位转换"><a href="#单位转换" class="headerlink" title="单位转换"></a>单位转换</h4><ol>
<li>Eth 转为 wei</li>
</ol>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#<span class="title class_">Web3</span>或者实例后的web3对象都可以</span><br><span class="line"><span class="keyword">const</span> num1 = <span class="title class_">Web3</span>.<span class="property">utils</span>.<span class="title function_">toWei</span>(<span class="string">'0.3'</span>,<span class="string">'ether'</span>)	<span class="comment">//大写W</span></span><br><span class="line"><span class="keyword">const</span> num1 = web3.<span class="property">utils</span>.<span class="title function_">toWei</span>(<span class="string">'0.3'</span>,<span class="string">'ether'</span>)	<span class="comment">//小写w，实例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num1)</span><br><span class="line"><span class="comment">// 300000000000000000</span></span><br></pre></td></tr></tbody></table></figure>



<ol start="2">
<li>wei转为Eth</li>
</ol>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#<span class="title class_">Web3</span>或者实例后的web3对象都可以</span><br><span class="line"><span class="keyword">const</span> num1 =<span class="title class_">Web3</span>.<span class="property">utils</span>.<span class="title function_">fromWei</span>(<span class="string">'3000000'</span>,<span class="string">"ether"</span>);</span><br><span class="line"><span class="keyword">const</span> num1 =web3.<span class="property">utils</span>.<span class="title function_">fromWei</span>(<span class="string">'3000000'</span>,<span class="string">"ether"</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num1)</span><br><span class="line"><span class="comment">//0.000000000003</span></span><br></pre></td></tr></tbody></table></figure>



<h4 id="Eth转账"><a href="#Eth转账" class="headerlink" title="Eth转账"></a>Eth转账</h4><p>API</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web3.<span class="property">eth</span>.<span class="title function_">sendSignedTransaction</span>(signedTransactionData[,callback]参数</span><br></pre></td></tr></tbody></table></figure>

<p>参数</p>
<ul>
<li><p><code>signedTransactionData-String</code>：以HEX格式签名的交易数据。</p>
<p>  交易数据对象可以包含如下字段：</p>
<ul>
<li><p><code>from </code>- （String|Number）：发送帐户的地址。如果未指定，则使用web3.eth.defaultAccount属性。或web3.eth.accounts.wallet中本地钱包的地址。</p>
</li>
<li><p><code>to</code>-（String）：（可选）消息的目标地址，若未定义则为合同发送消息。</p>
</li>
<li><p><code>value</code> - （Number|String|BN|BigNumber）：(可选）为wei中的交易转移的数量，如果是合约发送消息，则<br>  是捐赠给合约地址。</p>
</li>
<li><p><code>gas</code>-（Number）：(可选，默认：待定）用于交易的gas(未使用的gas会退还）。</p>
</li>
<li><p><code>gasPrice</code>-（Number|String|BN|BigNumber）：(可选）此交易的gas价格，以wei为单位，默认为web3.eth.gasPrice</p>
</li>
<li><p><code>data</code>-（String）：（可选）包含合同上函数调用数据的ABl字节字符串。</p>
</li>
<li><p><code>nonce</code>-（Number）：（可选）随机数的整数。</p>
</li>
</ul>
</li>
<li><p><code>callback</code>-（Function）：（可选）可选回调，将错误对象作为第一个参数返回，结果作为第二个参数返回。</p>
</li>
</ul>
<p>返回</p>
<p><code>PromiEvent</code>：promise组合的事件，将在交易完成时调用。包含以下事件</p>
<ul>
<li><code>"transactionHash"</code>返回<code>String</code>：在发送事务并且事务哈希可用之后立即触发。</li>
<li><code>"receipt"</code>返回<code>Object</code>：在交易确认时触发。</li>
<li><code>“confirmation"</code>返回<code>Number</code>，<code>Object</code>：每次确认都会被调用，直到第12次确认。接收确认编号作为第一个参数，将数据作为第二个参数。</li>
<li><code>"error”</code>返回<code>Error</code>：如果在发送过程中发生错误，则会触发。</li>
</ul>
<p>1．构建转账参数</p>
<p>区块链转账和支付宝转账类似，需要<code>发送方</code>、<code>接收方</code>、<code>金额</code>、<code>密码</code></p>
<p>另外需要添加部分区块链参数：<code>矿工费gas</code>、<code>地址转账交易次数</code></p>
<p><strong>await需要在async函数中才能使用</strong></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取账户交易次数</span></span><br><span class="line"><span class="keyword">let</span> nonce = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getTransactionCount</span>(fromaddress);</span><br><span class="line"><span class="comment">//获取预计转账gas费</span></span><br><span class="line"><span class="keyword">let</span> gasPrice = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getGasPrice</span>();</span><br><span class="line"><span class="comment">//转账金额以wei为单位</span></span><br><span class="line"><span class="keyword">let</span> balance = <span class="keyword">await</span> web3.<span class="property">utils</span>.<span class="title function_">towei</span>(number);</span><br><span class="line"><span class="keyword">var</span> rawTx ={</span><br><span class="line">	<span class="attr">from</span>: fromaddress,</span><br><span class="line">	<span class="attr">nonce</span>: nonce,</span><br><span class="line">	<span class="attr">gasPrice</span>: gasPrice,</span><br><span class="line">	<span class="attr">to</span>: toaddress,</span><br><span class="line">	<span class="attr">value</span>: balance,</span><br><span class="line">	data：<span class="string">"0×00"</span>，<span class="comment">//转Token代币会用到的一个字段</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>


<p>通过转账参数计算最终gas费用，并将通过私钥将转账参数进行编码加密</p>
<blockquote>
<p>ethereumjs-tx 第三方库请选择1.3.7版本</p>
</blockquote>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Tx</span> <span class="keyword">from</span> <span class="string">"ethereumjs-tx"</span>;</span><br><span class="line"><span class="comment">//将私钥去除“0x”后进行hex转化</span></span><br><span class="line">	<span class="keyword">var</span> privateKey = <span class="keyword">new</span> <span class="title class_">Buffer</span>(privatekey.<span class="title function_">slice</span>(<span class="number">2</span>), <span class="string">"hex"</span>);</span><br><span class="line">	<span class="comment">//需要将交易的数据进行预估 gas 计算，然后将 gas 值设置到数据参数中</span></span><br><span class="line">	<span class="keyword">let</span> gas = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">estimateGas</span>(rawTx);</span><br><span class="line">	rawTx.<span class="property">gas</span> = gas;</span><br><span class="line">	<span class="comment">//通过ethereumjs-tx实现私钥加密i</span></span><br><span class="line">	<span class="keyword">var</span> tx = <span class="keyword">new</span> <span class="title class_">Tx</span>(rawTx)；</span><br><span class="line">	tx.<span class="title function_">sign</span>(privateKey);</span><br><span class="line">	<span class="keyword">var</span> serializedTx = tx.<span class="title function_">serialize</span>();</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>这段代码是使用 <strong><code>ethereumjs-tx</code><strong>（一个 Ethereum 交易签名的 JavaScript 库）来</strong>离线构建、签名并序列化以太坊交易</strong>的过程。它通常用于在浏览器或 Node.js 环境下，通过私钥对交易进行签名，而无需依赖 MetaMask 或其他 Web3 钱包。</p>
<hr>
<p><strong>代码逐行解析</strong></p>
<p><strong>1. 导入 <code>ethereumjs-tx</code></strong></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Tx</span> <span class="keyword">from</span> <span class="string">"ethereumjs-tx"</span>;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><code>ethereumjs-tx</code> 是一个用于处理以太坊交易的库，可以：<ul>
<li>构建原始交易数据</li>
<li>用私钥签名交易</li>
<li>生成符合以太坊协议要求的 RLP 编码交易数据</li>
</ul>
</li>
</ul>
<hr>
<p><strong>2. 处理私钥</strong></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> privateKey = <span class="keyword">new</span> <span class="title class_">Buffer</span>(privatekey.<span class="title function_">slice</span>(<span class="number">2</span>), <span class="string">"hex"</span>);</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>**<code>privatekey.slice(2)</code>**：<br>  以太坊私钥通常以 <code>0x</code> 开头（如 <code>0xabc123...</code>），<code>slice(2)</code> 去掉 <code>0x</code>，只保留 hex 部分。</li>
<li>**<code>new Buffer(..., "hex")</code>**：<br>  将私钥的 16 进制字符串转换成 <code>Buffer</code>（二进制数据），因为 <code>ethereumjs-tx</code> 要求私钥必须是 <code>Buffer</code> 类型。</li>
</ul>
<hr>
<p><strong>3. 预估 Gas 费用</strong></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> gas = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">estimateGas</span>(rawTx);</span><br><span class="line">rawTx.<span class="property">gas</span> = gas;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>**<code>web3.eth.estimateGas(rawTx)</code>**：<br>  调用 Web3 的 <code>estimateGas</code> 方法，估算该交易需要消耗的 Gas（燃料费）。</li>
<li>**<code>rawTx.gas = gas</code>**：<br>  将估算的 Gas 值赋给交易的 <code>gas</code> 字段，避免 Gas 不足导致交易失败。</li>
</ul>
<hr>
<p><strong>4. 创建交易对象并签名</strong></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tx = <span class="keyword">new</span> <span class="title class_">Tx</span>(rawTx);</span><br><span class="line">tx.<span class="title function_">sign</span>(privateKey);</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>**<code>new Tx(rawTx)</code>**：<br>  用 <code>rawTx</code>（原始交易数据）初始化一个 <code>ethereumjs-tx</code> 交易对象。</li>
<li><strong><code>tx.sign(privateKey)</code><strong>：<br>  用 <code>privateKey</code>（Buffer 格式的私钥）对交易进行</strong>数字签名</strong>，确保只有私钥持有者能发起这笔交易。</li>
</ul>
<p> <strong><code>rawTx</code> 的典型结构</strong></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rawTx = {</span><br><span class="line">  <span class="attr">nonce</span>: <span class="string">"0x00"</span>,         <span class="comment">// 交易序号（防止重放攻击）</span></span><br><span class="line">  <span class="attr">gasPrice</span>: <span class="string">"0x09184e72a000"</span>, <span class="comment">// Gas 单价（wei）</span></span><br><span class="line">  <span class="attr">gasLimit</span>: <span class="string">"0x2710"</span>,    <span class="comment">// Gas 上限</span></span><br><span class="line">  <span class="attr">to</span>: <span class="string">"0xRecipientAddress"</span>,  <span class="comment">// 接收方地址</span></span><br><span class="line">  <span class="attr">value</span>: <span class="string">"0x00"</span>,         <span class="comment">// 转账金额（wei）</span></span><br><span class="line">  <span class="attr">data</span>: <span class="string">"0x7f7465737432000000000000000000000000000000000000000000000000000000600057"</span>, <span class="comment">// 合约调用数据（可选）</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<p><strong>5. 序列化交易</strong></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> serializedTx = tx.<span class="title function_">serialize</span>();</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong><code>tx.serialize()</code><strong>：<br>  将签名后的交易数据</strong>编码成 RLP（Recursive Length Prefix）格式</strong>，这是以太坊网络要求的二进制格式。</li>
<li><strong><code>serializedTx</code></strong> 的结果是 <code>Buffer</code> 类型，可以用于：<ul>
<li>通过 <code>web3.eth.sendSignedTransaction()</code> 广播到以太坊网络</li>
<li>存储或传输签名后的交易数据</li>
</ul>
</li>
</ul>
<p><strong>完整流程总结</strong></p>
<ol>
<li><strong>准备私钥</strong> → 去掉 <code>0x</code>，转成 <code>Buffer</code>。</li>
<li><strong>估算 Gas</strong> → 确保交易有足够的燃料费。</li>
<li><strong>创建交易对象</strong> → 设置 <code>nonce</code>、<code>gasPrice</code>、<code>to</code>、<code>value</code> 等字段。</li>
<li><strong>签名交易</strong> → 用私钥对交易进行 ECDSA 签名。</li>
<li><strong>序列化交易</strong> → 生成 RLP 编码的二进制数据，用于广播。</li>
</ol>
</blockquote>
<p>这里使用buffer，需要引入一个包</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i node-polyfill-webpack-plugin</span><br></pre></td></tr></tbody></table></figure>

<p>在vue.config.js中导入配置</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> { defineConfig } = <span class="built_in">require</span>(<span class="string">'@vue/cli-service'</span>)</span><br><span class="line"><span class="keyword">const</span> { <span class="title class_">VantResolver</span> } = <span class="built_in">require</span>(<span class="string">'unplugin-vue-components/resolvers'</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ComponentsPlugin</span> = <span class="built_in">require</span>(<span class="string">'unplugin-vue-components/webpack'</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">NodePolyfillWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">'node-polyfill-webpack-plugin'</span>)		<span class="comment">//++</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">defineConfig</span>({</span><br><span class="line">  <span class="attr">transpileDependencies</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">configureWebpack</span>: {</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">NodePolyfillWebpackPlugin</span>(),							<span class="comment">//++</span></span><br><span class="line">      <span class="title class_">ComponentsPlugin</span>({ <span class="attr">resolvers</span>: [<span class="title class_">VantResolver</span>()] })</span><br><span class="line">    ],</span><br><span class="line">  }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p><code>NodePolyfillWebpackPlugin</code> 是一个 <strong>Webpack 插件</strong>，主要用于在浏览器环境中<strong>模拟 Node.js 核心模块</strong>（如 <code>crypto</code>、<code>buffer</code>、<code>stream</code> 等），解决前端项目依赖 Node.js 原生模块时的兼容性问题。</p>
<hr>
<p><strong>为什么需要这个插件？</strong></p>
<ol>
<li><p><strong>浏览器无法直接使用 Node.js 模块</strong></p>
<ul>
<li>像 <code>crypto</code>、<code>path</code>、<code>stream</code>、<code>buffer</code> 等模块是 Node.js 内置的，浏览器默认不支持。</li>
<li>但某些库（如 <code>web3.js</code>、<code>ethers.js</code>、<code>ipfs</code>）可能间接依赖这些模块。</li>
</ul>
</li>
<li><p><strong>Web3/区块链开发常见问题</strong></p>
<ul>
<li><p>例如，<code>web3.js</code> 可能依赖 <code>crypto</code> 进行哈希计算，或 <code>buffer</code> 处理二进制数据。</p>
</li>
<li><p>直接运行会报错：</p>
<p>  text</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Module not found: Error: Can't resolve 'crypto'</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ol>
<hr>
<p><strong>NodePolyfillWebpackPlugin 的作用</strong></p>
<p>✅ <strong>自动注入 Node.js 核心模块的浏览器兼容实现</strong></p>
<ul>
<li>将 <code>crypto</code>、<code>buffer</code>、<code>stream</code> 等模块替换为浏览器可用的 polyfill（如 <code>crypto-browserify</code>）。</li>
<li>无需手动配置每个模块。</li>
</ul>
</blockquote>
<p>通过<code>sendsignedTransaction</code> api发送转账交易，并且获取交易id</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">web3.<span class="property">eth</span>.<span class="title function_">sendSignedTransaction</span>(<span class="string">"0x"</span> + serializedTx.<span class="title function_">toString</span>(<span class="string">"hex"</span>)).<span class="title function_">on</span>(<span class="string">"transactionHash"</span>,<span class="function">(<span class="params">txid</span>) =&gt;</span> {</span><br><span class="line">	<span class="variable language_">console</span>.<span class="property">log</span>（<span class="string">"交易成功，请在区块链浏览器查看"</span>）;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"交易id"</span>，txid);</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(*<span class="attr">https</span>:<span class="comment">//goerli.etherscan.io/tx/${txid}');</span></span><br><span class="line">	<span class="comment">// .on('receipt',(ret)→{console.log('receipt')})</span></span><br><span class="line">	<span class="comment">//.on('confirmation',(ret)→(console.log('confirmation')))</span></span><br><span class="line">	.<span class="title function_">on</span>(<span class="string">"error"</span>,(err)→{</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"error:"</span> + err);</span><br><span class="line">    });</span><br></pre></td></tr></tbody></table></figure>



<h1 id="8月16日"><a href="#8月16日" class="headerlink" title="8月16日"></a>8月16日</h1><p>留点时间就回顾一下行业赛道</p>
<p>今天产生了问题，为什么会有稳定币，既然稳定币是和法币一比一对等的，为什么需要稳定币？</p>
<p>ai给我的解答</p>
<blockquote>
<p> <strong>1. 解决加密货币的波动性问题</strong></p>
<ul>
<li><strong>问题</strong>：比特币、以太坊等主流加密货币价格波动剧烈，不适合作为：<ul>
<li><strong>日常支付工具</strong>（商家不愿接受一天内可能贬值10%的货币）。</li>
<li><strong>价值存储媒介</strong>（用户担心资产缩水）。</li>
</ul>
</li>
<li><strong>稳定币的解决方案</strong>：<br>  通过锚定法币（如USDT、USDC）或算法调控（如DAI），提供价格稳定的加密资产，同时保留区块链的便捷性。</li>
</ul>
<hr>
<p> <strong>2. 加密货币市场的“避风港”</strong></p>
<ul>
<li><strong>交易媒介</strong>：<br>  在交易所中，稳定币是<strong>主要的交易对</strong>（如BTC/USDT）。用户可以在市场暴跌时将资产转换为稳定币避险，避免换成法币的复杂流程（提现、手续费、监管限制）。</li>
<li><strong>套利和做市</strong>：<br>  交易者利用稳定币快速切换仓位，无需依赖传统银行系统。</li>
</ul>
<hr>
<p><strong>3. 跨境支付与金融包容性</strong></p>
<ul>
<li><strong>传统跨境支付的问题</strong>：<br>  银行转账慢（1-3天）、手续费高（尤其是小额汇款）、依赖SWIFT系统。</li>
<li><strong>稳定币的优势</strong>：<ul>
<li>几分钟内完成跨境转账，手续费极低。</li>
<li>为无银行账户的人群提供金融服务（如通过USDT进行国际汇款）。</li>
</ul>
</li>
</ul>
</blockquote>
<p>总结一下就是</p>
<ol>
<li><strong>稳定性</strong>：在波动剧烈的加密市场中提供“安全资产”</li>
<li><strong>效率</strong>：实现快速、低成本的全球支付</li>
<li><strong>兼容性</strong>：成为连接传统金融与加密世界的桥梁</li>
</ol>
<h2 id="DeFi"><a href="#DeFi" class="headerlink" title="DeFi"></a>DeFi</h2><p>去中心化金融，提供不依赖传统银行或金融中介的服务</p>
<p>DEX：中心化交易所</p>
<h3 id="Uniswap"><a href="#Uniswap" class="headerlink" title="Uniswap"></a>Uniswap</h3><p>去中心化交易所（DEX）的代表，核心创新在于引入“自动做市商”（AMM）模式，通过“<strong>恒定乘积公式</strong>” 实现代币定价。用户通过存入流动性池（如 ETH 和 DAI）成为流动性提供者（LP），赚取交易手续费。</p>
<blockquote>
<p><strong>恒定乘积公式：x * y = k</strong></p>
<p>这个公式听起来复杂，但它的核心思想其实很简单。我们可以把它想象成 Uniswap 是一个非常聪明的自动交易员，它通过一个简单的数学公式来决定价格，而不依赖人工设置或市场波动。</p>
<ul>
<li><p><strong>x</strong> 和 <strong>y</strong> 代表流动性池中的两种加密货币，比如 ETH 和 USDC。</p>
</li>
<li><p>比如一个流动性池里，假设有 10 个 ETH 和 5000 个 USDC。那么：</p>
<p>  x = 10（ETH） y = 5000（USDC）</p>
<p>  公式如何工作？</p>
</li>
<li><p>恒定乘积公式就是 <strong>x * y = k</strong>，其中 <strong>k</strong> 是一个常数。</p>
<p>  10 * 5000 = 50,000（这就是 k 的值）</p>
<p>  当你在这个池子里进行交易时，这个公式始终要保持成立。也就是说，交易后，ETH 和 USDC 的数量会发生变化，但它们相乘的结果 <strong>k</strong> 必须始终是 50,000（忽略手续费的情况下）。</p>
</li>
</ul>
<p>举个例子：</p>
<ul>
<li><p>如果你想用 1 个 ETH 兑换 USDC，流动性池中的 ETH 数量就会增多，而 USDC 的数量就会减少。</p>
</li>
<li><p>假设交易后，池中的 ETH 变成了 11 个，那么为了保持公式成立，USDC 数量需要调整到 4545.45 个（50,000 / 11 = 4545.45）。</p>
</li>
<li><p>具体兑换价格计算</p>
<p>  ：</p>
<ul>
<li>交易前：10 ETH，5000 USDC</li>
<li>交易后：11 ETH，4545.45 USDC</li>
<li>你用 1 ETH 兑换到了 5000 − 4545.45 = 454.55 USDC（不考虑手续费的情况）</li>
<li><strong>兑换价格 = 454.55 USDC / 1 ETH = 454.55 USDC per ETH</strong>（低于交易前现货价 500，体现了价格冲击）</li>
</ul>
</li>
<li><p>这样，Uniswap 就能自动算出兑换的价格，而且随着池子中资产比例的变化，价格也会自动调整。</p>
</li>
</ul>
</blockquote>
<p><strong>那流动性提供者（LP）是如何赚钱的</strong></p>
<p>当你把资金存入流动性池时，你成为了流动性提供者（LP）。每当别人进行交易时，你提供的资金就会被用来进行兑换。LP 在每次交易中都会收取一定的 <strong>交易手续费</strong>（我们以 0.3% 为例）。这些手续费会根据你在流动性池中提供的资金比例进行分配。</p>
<h3 id="去中心化交易所-vs-中心化交易所"><a href="#去中心化交易所-vs-中心化交易所" class="headerlink" title="去中心化交易所 vs 中心化交易所"></a>去中心化交易所 vs 中心化交易所</h3><table>
<thead>
<tr>
<th align="center">特点</th>
<th align="center">去中心化交易所</th>
<th align="center">中心化交易所</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>交易不需要中介，快速方便</strong></td>
<td align="center">你直接用自己的钱包进行交易，不需要像中心化交易所那样注册账户、上传身份证等繁琐步骤。</td>
<td align="center">需要通过一个平台来进行配对和交易，往往存在人工审核、系统延迟等问题，交易可能比较慢。</td>
</tr>
<tr>
<td align="center"><strong>24/7 全天候交易</strong></td>
<td align="center">无论你身在何处，任何时候都能进行交易。没有交易时间的限制。</td>
<td align="center">通常会受到全球市场交易时间、服务器维护等因素的影响。尤其是某些交易所还可能进行系统升级或停机。</td>
</tr>
<tr>
<td align="center"><strong>大额交易更便捷</strong></td>
<td align="center">你不需要等待层层审批，特别是对于一些大额资金的交易，完全依赖智能合约和流动性池来完成。所有交易都直接在链上进行，快速而高效。</td>
<td align="center">大额资金的交易通常需要通过银行、金融机构等审批环节，可能还要经过反洗钱审查等复杂的程序，时间较长。</td>
</tr>
</tbody></table>
<h3 id="Compound：去中心化借贷协议"><a href="#Compound：去中心化借贷协议" class="headerlink" title="Compound：去中心化借贷协议"></a>Compound：去中心化借贷协议</h3><p>Compound 是一个去中心化的借贷平台，允许用户借入或借出加密资产。用户在平台上存入资产并获得相应的 <strong>cToken</strong>，这是一种代表用户在协议中存入资金的代币。用户可以通过这个代币赚取利息，同时也可以借入其他资产，但需要提供超额担保。</p>
<h3 id="MakerDAO（现已更名为-Sky）：稳定币系统"><a href="#MakerDAO（现已更名为-Sky）：稳定币系统" class="headerlink" title="MakerDAO（现已更名为 Sky）：稳定币系统"></a>MakerDAO（现已更名为 Sky）：稳定币系统</h3><p>MakerDAO 是一个去中心化的借贷协议，它允许用户通过超额抵押资产来生成 <strong>DAI</strong>，一种与美元挂钩的稳定币</p>
<h2 id="NFT"><a href="#NFT" class="headerlink" title="NFT"></a>NFT</h2><p>基本理解 所以不需要复习</p>
<h2 id="DAO：去中心化自治组织"><a href="#DAO：去中心化自治组织" class="headerlink" title="DAO：去中心化自治组织"></a>DAO：去中心化自治组织</h2><p>不依赖传统的公司架构，而是通过智能合约和社区投票来做决策</p>
<h3 id="Nouns-DAO：社区驱动的-NFT-艺术-DAO"><a href="#Nouns-DAO：社区驱动的-NFT-艺术-DAO" class="headerlink" title="Nouns DAO：社区驱动的 NFT 艺术 DAO"></a>Nouns DAO：社区驱动的 NFT 艺术 DAO</h3><p>Nouns DAO 就像是艺术和区块链的结合体，每天都会生成一个独一无二的 NFT —— 一个卡通小人头像。</p>
<h3 id="LXDAO：支持-Web3-公共物品的建设者"><a href="#LXDAO：支持-Web3-公共物品的建设者" class="headerlink" title="LXDAO：支持 Web3 公共物品的建设者"></a>LXDAO：支持 Web3 公共物品的建设者</h3><p>LXDAO 是一个特别专注于 Web3 公共物品的项目。Web3 是一种更自由、更去中心化的互联网形态。LXDAO 通过支持开源项目、资助创新项目，推动这一理念的实际落地。</p>
<p>它的运作方式有点像是一个“工会”加“奖励平台”。</p>
<h3 id="ConstitutionDAO：一场疯狂的拍卖"><a href="#ConstitutionDAO：一场疯狂的拍卖" class="headerlink" title="ConstitutionDAO：一场疯狂的拍卖"></a>ConstitutionDAO：一场疯狂的拍卖</h3><p>拍卖</p>
<h1 id="8月19日"><a href="#8月19日" class="headerlink" title="8月19日"></a>8月19日</h1><p>转账web3js功能</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"> <span class="keyword">import</span> { ref } <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"> <span class="keyword">import</span> <span class="title class_">Web3</span> <span class="keyword">from</span> <span class="string">'web3'</span></span><br><span class="line"> <span class="keyword">import</span> <span class="title class_">Tx</span> <span class="keyword">from</span> <span class="string">'ethereumjs-tx'</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//实例化web3</span></span><br><span class="line">  <span class="keyword">var</span> web3 = <span class="keyword">new</span> <span class="title class_">Web3</span>(</span><br><span class="line">    <span class="title class_">Web3</span>.<span class="property">givenProvider</span> || </span><br><span class="line">    <span class="string">"wss://eth-sepolia.g.alchemy.com/v2/Vf-WXrhQ2Fv_u9XbSC9Mc"</span></span><br><span class="line">  );</span><br><span class="line">  <span class="comment">//创建账户</span></span><br><span class="line">  <span class="comment">//只要执行一次 就会创建一个新的</span></span><br><span class="line">  <span class="keyword">const</span> account = web3.<span class="property">eth</span>.<span class="property">accounts</span>.<span class="title function_">create</span>(<span class="string">'123'</span>)</span><br><span class="line">  <span class="comment">// console.log(account.address)</span></span><br><span class="line">  <span class="comment">// console.log(account.privateKey)</span></span><br><span class="line">  <span class="keyword">const</span> address = <span class="title function_">ref</span>(<span class="string">'0x6191a878F0CB11E707271bce5C5e6d20dbF7f6f5'</span>)</span><br><span class="line">  <span class="keyword">const</span> privateKey = <span class="title function_">ref</span>(<span class="string">'0x5b73f024533766c257ddc575580fac09d69bb73197f7b0cdd8938ad244c4360b'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取余额</span></span><br><span class="line">  <span class="keyword">const</span> mount = <span class="title function_">ref</span>(-<span class="number">1</span>)</span><br><span class="line">  web3.<span class="property">eth</span>.<span class="title function_">getBalance</span>(address.<span class="property">value</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> {</span><br><span class="line">    mount.<span class="property">value</span> = <span class="title class_">Web3</span>.<span class="property">utils</span>.<span class="title function_">fromWei</span>(res,<span class="string">"ether"</span>)</span><br><span class="line">  })</span><br><span class="line"></span><br><span class="line">  <span class="comment">//单位转换</span></span><br><span class="line">  <span class="keyword">const</span> num1 = web3.<span class="property">utils</span>.<span class="title function_">toWei</span>(<span class="string">'0.3'</span>,<span class="string">'ether'</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(num1)</span><br><span class="line">  <span class="keyword">const</span> num2 =<span class="title class_">Web3</span>.<span class="property">utils</span>.<span class="title function_">fromWei</span>(<span class="string">'3000000'</span>,<span class="string">"ether"</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(num2)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//转账操作</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">send</span> = <span class="keyword">async</span>(<span class="params"></span>) =&gt; {</span><br><span class="line">    <span class="comment">//1.构建转账参数</span></span><br><span class="line">    <span class="comment">//获取账户交易次数</span></span><br><span class="line">    <span class="keyword">const</span> nonce = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getTransactionCount</span>(address.<span class="property">value</span>)</span><br><span class="line">    <span class="comment">//获预计转账的gas费用</span></span><br><span class="line">    <span class="comment">// const gasPrice = await web3.eth.getGasPrice()</span></span><br><span class="line">    <span class="keyword">const</span> gasPrice = web3.<span class="property">utils</span>.<span class="title function_">toWei</span>(<span class="string">'10'</span>, <span class="string">'gwei'</span>); </span><br><span class="line">    <span class="keyword">const</span> gasLimit = <span class="number">21000</span></span><br><span class="line">    <span class="comment">// console.log(gasPrice)     //以wei为单位</span></span><br><span class="line">    <span class="comment">//转账金额 以wei作为单位</span></span><br><span class="line">    <span class="keyword">const</span> value = web3.<span class="property">utils</span>.<span class="title function_">toWei</span>(<span class="string">'0.0005'</span>,<span class="string">'ether'</span>)</span><br><span class="line">    <span class="keyword">const</span> rawTx = {</span><br><span class="line">      <span class="attr">from</span>: address.<span class="property">value</span>,</span><br><span class="line">      <span class="attr">nonce</span>: web3.<span class="property">utils</span>.<span class="title function_">toHex</span>(nonce),</span><br><span class="line">      <span class="attr">gasPrice</span>: web3.<span class="property">utils</span>.<span class="title function_">toHex</span>(gasPrice),</span><br><span class="line">      <span class="attr">gasLimit</span>: web3.<span class="property">utils</span>.<span class="title function_">toHex</span>(gasLimit),</span><br><span class="line">      <span class="attr">to</span>: <span class="string">'0xE1e55b0dc88EA14be89e218F403734bE0cADd27f'</span>,</span><br><span class="line">      <span class="attr">value</span>: web3.<span class="property">utils</span>.<span class="title function_">toHex</span>(value),</span><br><span class="line">      <span class="attr">data</span>: <span class="string">"0x"</span>,</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.生成serializedTx</span></span><br><span class="line">    <span class="comment">//转换私钥</span></span><br><span class="line">    <span class="keyword">const</span> pKey = <span class="title class_">Buffer</span>(privateKey.<span class="property">value</span>.<span class="title function_">slice</span>(<span class="number">2</span>), <span class="string">"hex"</span>)</span><br><span class="line">    <span class="comment">//gas 估算</span></span><br><span class="line">    <span class="keyword">const</span> gas = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">estimateGas</span>(rawTx)</span><br><span class="line">    rawTx.<span class="property">gas</span> = gas;</span><br><span class="line">    <span class="comment">//ethereumjs-tx 实现私钥加密</span></span><br><span class="line">    <span class="keyword">const</span> tx = <span class="keyword">new</span> <span class="title class_">Tx</span>(rawTx)</span><br><span class="line">    tx.<span class="title function_">sign</span>(pKey)</span><br><span class="line">    <span class="comment">//生成serializedTx</span></span><br><span class="line">    <span class="keyword">const</span> serializedTx = <span class="string">'0x'</span> + tx.<span class="title function_">serializedTx</span>().<span class="title function_">toString</span>(<span class="string">"hex"</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(serializedTx)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.开始转账</span></span><br><span class="line">    <span class="keyword">const</span> trans = web3.<span class="property">eth</span>.<span class="title function_">sendSignedTransaction</span>(serializedTx)</span><br><span class="line">    trans.<span class="title function_">on</span>(<span class="string">'transactionHash'</span>, <span class="function">(<span class="params">txid</span>) =&gt;</span> {</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'交易ID：'</span>,txid )</span><br><span class="line">    })</span><br><span class="line"></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;<span class="name">h1</span>&gt;</span>账户信息:<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;<span class="name">van-divider</span> <span class="attr">hairline</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>地址：{{ address }}<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>私钥：{{ privateKey }}<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>余额： {{ mount }}<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;<span class="name">van-divider</span> <span class="attr">hairline</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;<span class="name">h1</span>&gt;</span>转账操作：<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;<span class="name">van-button</span> <span class="attr">type</span>=<span class="string">"primary"</span> @<span class="attr">click</span>=<span class="string">"send"</span>&gt;</span>开始转账<span class="tag">&lt;/<span class="name">van-button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"scss"</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="selector-tag">body</span>{</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  }</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<h1 id="8月20日"><a href="#8月20日" class="headerlink" title="8月20日"></a>8月20日</h1><h2 id="账户系统"><a href="#账户系统" class="headerlink" title="账户系统"></a>账户系统</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>密码</strong></p>
<p>密码的使用场景：</p>
<ol>
<li>作为转账的支付密码</li>
<li>用keystore导入钱包的时候需要输入</li>
</ol>
<p><strong>私钥</strong></p>
<p>私钥由64位长度的十六进制的字符组成，比<br>如：0×A4356E49C88C8B7AB370AF7D5C0C54F0261AAA006F6BDE09CD4745CF54E0115A，一个账户只有一个私钥且不能修改。</p>
<p>通常一个钱包中私钥和公钥是成对出现的，有了私钥，我们就可以通过一定的算法生成公钥，再通过公钥经过一定<br>的算法生成地址，这一过程都是不可逆的。私钥一定要妥善保管，若被泄漏别人可以通过私钥解锁账号转出你的该<br>账号的数字货币。</p>
<p><strong>公钥</strong></p>
<p>公钥（PublicKey）是和私钥成对出现的，和私钥一起组成一个密钥对，保存在钱包中。公钥由私钥生成，但是无法通过公钥倒推得到私钥。公钥能够通过一系列算法运算得到钱包的地址，因此可以作为拥有这个钱包地址的凭证。</p>
<p><strong>Keystore</strong></p>
<p>Keystore常见于以太坊钱包，它是将私钥以加密的方式保存为一份JSON文件，这份JSON文件就是keystore，所<br>以它就是加密后的私钥。Keystore必须配合钱包密码才能导入并使用该账号。当黑客盗取Keystore后，在没有密码情况下，有可能通过暴力破解Keystore密码解开Keystore，所以建议使用者在设置密码时稍微复杂些，比如带上特殊字符，至少8位以上，并安全存储。</p>
<p><strong>助记词 Mnemonic</strong></p>
<p>私钥是64位长度的十六进制的字符，不利于记录且容易记错，所以用算法将一串随机数转化为了一串12~24个容易记住的单词，方便保存记录。注意：</p>
<ol>
<li>助记词是私钥的另一种表现形式</li>
<li>助记词=私钥，这是不正确的说法，通过助记词可以获取相关联的多个私钥，但是通过其中一个私钥是不能获<br> 取助记词的，因此助记词私钥。</li>
</ol>
<p><strong>BIP</strong></p>
<p>要弄清楚助记词与私钥的关系，得清楚BlP协议，是 Bitcoin Improvement Proposals的缩 写，意思是Bitcoin<br>的改进建议，用于提出Bitcoin的新功能或改进措施。BIP协议衍生了很多的版本，主要有BIP32、BIP39、BIP44。</p>
<p><strong>BIP32</strong></p>
<p>BIP32是HD钱包的核心提案，通过种子来生成主私钥，然后派生海量的子私钥和地址，种子是一串很长的随机数。</p>
<p><strong>BIP39</strong></p>
<p>由于种子是一串很长的随机数，不利于记录，所以我们用算法将种子转化为一串12~24个的单词，方便保存记录，<br>这就是BIP39，它扩展了HD钱包种子的生成算法。</p>
<p><strong>BIP44</strong></p>
<p>BIP44是在BIP32和BIP43的基础上增加多币种，提出的层次结构非常全面，它允许处理多个币种，多个帐户，每<br>个帐户有数百万个地址</p>
<p>在BIP32路径中定义以下5个级别：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m/purpse'/coin_type'/account'/change/address_index</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>purpose：在BIP43之后建议将常数设置为44’。表示根据BIP44规范使用该节点的子树</li>
<li>Coin_type：币种，代表一个主节点（种子）可用于无限数量的独立加密币，如比特币，Litecoin或Namecoin。此级别为每个加密币创建一个单独的子树，避免重用已经在其它链上存在的地址。开发人员可以为他们的项目注册未使用的号码</li>
<li>Account：账户，此级别为了设置独立的用户身份可以将所有币种放在一个的帐户中，从0开始按顺序递增</li>
<li>Change：常量0用于外部链，常量1用于内部链，外部链用于钱包在外部用于接收和付款。内部链用于在钱包<br>  外部不可见的地址，如返回交易变更</li>
<li>Address_index：地址索引，按顺序递增的方式从索引o开始编号</li>
</ul>
<p>BIP44的规则使得HD钱包非常强大，用户只需要保存一个种子，就能控制所有币种，所有账户的钱包，因此由BIP39生成的助记词非常重要，所以一定安全妥善保管，那么会不会被破解呢？如果一个HD钱包助记词是12个单词，一共有2048个单词可能性，那么随机的生成的助记词所有可能性大概是5e+39，因此几乎不可能被破解</p>
<p><strong>HD钱包</strong></p>
<p>通过BIP协议生成账号的钱包叫做HD钱包。这个HD钱包，并不是HardwareWallet硬件钱包，这里的HD是HierarchicalDeterministic的缩写，意思是分层确定性，所以HD钱包的全称为比特币分成确定性钱包。</p>
<h2 id="密码、私钥、keystore与助记词的关系"><a href="#密码、私钥、keystore与助记词的关系" class="headerlink" title="密码、私钥、keystore与助记词的关系"></a>密码、私钥、keystore与助记词的关系</h2><img src="https://cdn.jsdelivr.net/gh/xmhhmx/PicGoCDN//img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-19%20224746.png" style="zoom:67%;">

<p><strong>钱包的核心：私钥</strong></p>
<p>基于以上的分析，我们对以太坊钱包的账号系统有了一个很好的认识，那么我们在使用钱包的过程中，该如何保管<br>自己的钱包呢？主要包含以下几种方式：</p>
<ul>
<li>私钥(Private Key)</li>
<li>keystore+密码(Keystore+Password)</li>
<li>助记词(Mnemonic code)</li>
</ul>
<p>通过以上三种中的一种方式都可以解锁账号，然后掌控它，所以对于每种方式中的数据都必须妥善包括，如有泄漏，请尽快转移数字资产。</p>
<p>我们可以得到以下总结：</p>
<ul>
<li>通过私钥+密码可以生成keystore，即加密私钥；</li>
<li>通过keystore+密码可以获取私钥，即解密keystore。</li>
<li>通过助记词根据不同的路径获取不同的私钥，即使用HD钱包将助记词转化成种子来生成主私钥，然后派生海<br>  量的子私钥和地址。</li>
</ul>
<p>可以看出这几种方式的核心其实都是为了获得私钥，然后去解锁账号，因此钱包的核心功能是私钥的创建、存储和<br>使用。</p>
<h2 id="创建账户"><a href="#创建账户" class="headerlink" title="创建账户"></a>创建账户</h2><h3 id="web3直接创建账户"><a href="#web3直接创建账户" class="headerlink" title="web3直接创建账户"></a>web3直接创建账户</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.accounts.create('2435@#@#@±++t!!678543213456764321534567543213456785432134567);</span><br></pre></td></tr></tbody></table></figure>

<h3 id="助记词创建账户"><a href="#助记词创建账户" class="headerlink" title="助记词创建账户"></a>助记词创建账户</h3><p>需要使用 <code>BIP39</code> 协议将助记词转换成种子，再通过 <code>ethereumjs-wallet</code> 库生成hd钱包，根据路径的不同从hd钱包中获取不同的keypair，keypair中就包含有公钥、私钥，再通过 <code>ethereumjs-util</code> 库将公钥生成地址，从而根据助记词获取所有关联的账号，能获取到公钥、私钥、地址等数据信息。</p>
<blockquote>
<p><strong>HD钱包</strong> 的全称是 <strong>分层确定性钱包</strong>。它是一种利用特定算法，从一个<strong>单一的种子</strong>（Seed）生成几乎无限个密钥对（私钥和公钥）的系统。</p>
<p>你可以把它想象成一棵“密钥树”：</p>
<ul>
<li><strong>根种子</strong>：就像大树的根。这是最核心的机密，通常由12或24个英文单词（助记词）表示。<strong>谁拥有这个种子，谁就完全控制整棵树上的所有资产。</strong></li>
<li><strong>主私钥</strong>：由根种子生成的第一个、也是最重要的私钥，相当于树干。</li>
<li><strong>子密钥</strong>：从主私钥派生出的无数个私钥和地址，相当于树枝和树叶。这些地址就是你用来接收不同加密货币（如ETH、BTC）的地址。</li>
</ul>
</blockquote>
<ol>
<li>依赖库</li>
</ol>
<p>需要用到三个库：bip39、ethereumjs-wallet/hdkey、ethereumjs-util。先安装依赖库，cd到项目跟路径运行命令<code>npm i bip39 ethereumjs-wallet ethereumjs-util</code></p>
<ul>
<li>bip39：随机产生新的 mnemonic code，并可以将其转成 binary 的seed。</li>
<li>ethereumjs-wallet：生成和管理公私钥，下面使用其中hdkey子套件来创建HD钱包。</li>
<li>ethereumjs-util：Ethereum的一个工具库。</li>
<li><a target="_blank" rel="noopener" href="https://iancoleman.io/bip39/">https://iancoleman.io/bip39/</a></li>
</ul>
<ol start="2">
<li>通过助记词创建账号</li>
</ol>
<ul>
<li>创建助记词</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入bip39模块</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> bip39 <span class="keyword">from</span> <span class="string">"bip39"</span>;</span><br><span class="line"><span class="comment">//创建助记词</span></span><br><span class="line"><span class="keyword">let</span> mnenonic = bip39.<span class="title function_">generateMnemonic</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mnemonic);</span><br><span class="line"><span class="comment">//结果 12位助记词</span></span><br><span class="line"><span class="comment">// vote select solar shy embrace immense lizard stamp scrub vague negative forward</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>根据助记词生成密钥对keypair</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入分层钱包模块</span></span><br><span class="line"><span class="keyword">import</span> { hdkey } <span class="keyword">from</span> <span class="string">"ethereumjs-wallet"</span>;</span><br><span class="line"><span class="comment">//1.将助记词转成seed</span></span><br><span class="line"><span class="keyword">let</span> seed = <span class="keyword">await</span> bip39.<span class="title function_">mnemonicToSeed</span>(<span class="string">"12位助记词"</span>);</span><br><span class="line"><span class="comment">//3.通过hdkey将seed生成HDWallet</span></span><br><span class="line"><span class="keyword">let</span> hdwallet = hdkey.<span class="title function_">fromMasterSeed</span>(seed);</span><br><span class="line"><span class="comment">//4.生成钱包中在m/44'/60`/0`/0/i路径的keypair</span></span><br><span class="line"><span class="keyword">let</span> keypair = hdWallet.<span class="title function_">derivePath</span>(<span class="string">"m/44'/6o'/0'/0/0"</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(keypair);</span><br></pre></td></tr></tbody></table></figure>







<h1 id="8月21日"><a href="#8月21日" class="headerlink" title="8月21日"></a>8月21日</h1><h2 id="Uniswap-1"><a href="#Uniswap-1" class="headerlink" title="Uniswap"></a>Uniswap</h2><p>Uniswp是一个去中心化交易所，所谓去中心化，可以从以下两个方面理解：</p>
<ul>
<li>交易全部是由开源的代码来控制，没有任何人为的因素</li>
<li>交易所无实际的掌控机构，规则不能够被随便修改</li>
</ul>
<p>Uniswap的核心是一个数学公式</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x * y = k</span><br></pre></td></tr></tbody></table></figure>

<p>Uniswap允许任何人做市和交换代币。第个版本一一Uniswap V1，于2018年发布，作为概念验证。第2版是2020年发布的生产版本。</p>
<p>Uniswap V2允许交易者直接从一个ERC-20代币交换到另一个ERC-20代币。交易者之间不直接进行交易。相反，他们使用一个保留两个代币的代币池进行交易。这个代币池被称为“流动性池’。</p>
<h3 id="Uniswap-V2"><a href="#Uniswap-V2" class="headerlink" title="Uniswap V2"></a>Uniswap V2</h3><p>Uniswap V2 是一个<strong>革命性的、完全去中心化的链上交易所协议</strong>，构建在以太坊区块链上。它于 2020 年 5 月发布，是 Uniswap V1 的重大升级，解决了 V1 的一些关键限制，并成为了整个 DeFi（去中心化金融）生态系统的基石。</p>
<p>你可以把它理解为一个<strong>无人管理的、由代码和数学公式运行的自动做市商（AMM）</strong>。</p>
<hr>
<p>一、核心机制与工作原理</p>
<ol>
<li>自动做市商 (AMM) 与恒定乘积公式</li>
</ol>
<p>Uniswap V2 的核心是一个简单的数学公式：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X * Y = K</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>X</strong>：流动性池中第一种资产的数量（例如 ETH）。</li>
<li><strong>Y</strong>：流动性池中第二种资产的数量（例如 DAI）。</li>
<li><strong>K</strong>：一个恒定不变的常数。</li>
</ul>
<p>这个公式决定了交易的价格和滑点：</p>
<ul>
<li><strong>定价</strong>：资产的价格完全由池中两种资产的比例决定。例如，ETH 的价格 = (DAI 的数量) / (ETH 的数量)。</li>
<li><strong>交易执行</strong>：当用户用 A 资产购买 B 资产时，他们向池子投入 A，取出 B。由于 K 必须保持不变，取出 B 会导致 Y 减少，因此 X 必须增加来补偿。这种变化自动决定了用户能拿到多少 B，即执行了交易。</li>
<li><strong>滑点</strong>：交易量越大，对池子比例的改变就越大，价格滑点也越大。</li>
</ul>
<ol start="2">
<li>流动性提供者 (LPs) 与手续费</li>
</ol>
<ul>
<li><strong>任何人都可以成为流动性提供者</strong>：用户可以将等值的两种资产（如 ETH 和 USDC）存入交易池中，为市场提供流动性。</li>
<li><strong>获得奖励</strong>：作为回报，LPs 会获得该交易对的**流动性代币 (LP Tokens)**。LP Tokens 代表了他们在资金池中的份额。</li>
<li><strong>赚取手续费</strong>：所有交易都会收取 <strong>0.3%</strong> 的费用。这笔费用会直接添加到流动性池中，使得 <code>K值</code> 缓慢增大。当 LPs 销毁他们的 LP Tokens 取出本金时，他们可以按份额获得这部分积累的手续费，从而实现被动收益。</li>
</ul>
<ol start="3">
<li>价格预言机</li>
</ol>
<p>这是 V2 相对于 V1 的一个重大创新。</p>
<ul>
<li>Uniswap V2 通过记录每个区块第一笔交易的资产价格（即资产累积价格），提供了一个<strong>防篡改的链上价格数据源</strong>。</li>
<li>其他 DeFi 协议（如 Compound, Aave）可以引用这个时间加权平均价格（TWAP）来获取资产价格，极大地增强了整个生态的安全性和可靠性。</li>
</ul>
<hr>
<p>二、相比 V1 的重大改进</p>
<ol>
<li><strong>支持任意ERC20交易对</strong>：<ul>
<li>V1 只能与 ETH 组成交易对（如 DAI/ETH, MKR/ETH）。如果你想用 DAI 换 MKR，需要经过 ETH 中转，效率低且手续费高。</li>
<li>V2 允许<strong>任何两种 ERC-20 代币直接组成交易对</strong>（如 DAI/MKR），大大提高了资本效率和交易体验。</li>
</ul>
</li>
<li><strong>价格预言机</strong>：<ul>
<li>如上所述，V2 引入了原生的价格预言机功能，而 V1 没有。</li>
</ul>
</li>
<li><strong>闪电贷</strong>：<ul>
<li>V2 原生支持<strong>闪电贷</strong>功能。允许用户无需抵押即可借出大量资产，但<strong>必须在同一笔以太坊交易内归还本金和0.09%的费用</strong>。这为套利、清算和复杂的链上策略提供了强大的金融工具。</li>
</ul>
</li>
<li><strong>协议费用（可开关）</strong>：<ul>
<li>V2 在代码中预留了一个向 LP 收取的0.05%费用作为协议收入的功能，但这个功能在发布时是关闭的，需要通过治理来开启（事实上从未开启过）。</li>
</ul>
</li>
</ol>
<hr>
<p>三、核心功能</p>
<ol>
<li>**代币兑换 (Swap)**：用户可以在任意两个 ERC-20 代币之间进行兑换。</li>
<li>**提供流动性 (Add Liquidity)**：注入资产以赚取手续费。</li>
<li>**移除流动性 (Remove Liquidity)**：销毁 LP Tokens，取回本金和赚取的手续费。</li>
<li>**闪电贷 (Flash Swaps)**：无需抵押的即时贷款。</li>
</ol>
<hr>
<p>四、优缺点分析</p>
<p>优点：</p>
<ul>
<li><strong>完全去中心化与无需许可</strong>：任何人都可以上线新代币的交易对，无需审核。</li>
<li><strong>高度抗审查</strong>：协议在链上运行，无法被关闭。</li>
<li><strong>资本效率（对于长尾资产）</strong>：为不热门的小币种提供了前所未有的流动性。</li>
<li><strong>可组合性</strong>：是 DeFi 乐高的基石，可以与其他协议无缝组合。</li>
</ul>
<p>缺点（或称“无常损失”）：</p>
<ul>
<li>**无常损失 (Impermanent Loss)**：<ul>
<li>这是提供流动性最大的风险。当池中两种资产的价格比率发生剧烈变化时（如一个暴涨），相比于单纯持有这些资产，LP 可能会遭受损失。</li>
<li>简单理解：AMM 机制会自动“高卖低买”，导致你持有的暴涨资产数量变少，暴跌资产数量变多。只有当价格比率回归到存入时的水平，损失才会消失（因此称为“无常”）。</li>
</ul>
</li>
<li>** gas 费高昂**：所有操作都在链上进行，在以太坊网络拥堵时成本很高。</li>
<li><strong>滑点</strong>：对于流动性差的池子，大额交易会有很高的滑点。</li>
</ul>
<hr>
<p>五、总结与影响</p>
<p>Uniswap V2 不仅仅是一个交易所，它更是一个<strong>金融基础设施</strong>。它通过极其简洁优雅的数学模型，实现了完全去中心化的交易、借贷（闪电贷）和价格发现功能，为 2020 年的 “DeFi Summer” 提供了核心动力。</p>
<p>尽管后来出现了更高效的 V3 版本，但 V2 因其简单性和可靠性，至今仍在许多链和场景中被广泛使用，是理解 AMM 和 DeFi 世界不可或缺的一课。</p>
<h3 id="Uniswap-V3"><a href="#Uniswap-V3" class="headerlink" title="Uniswap V3"></a>Uniswap V3</h3><p>Uniswap V3 是 Uniswap 协议的第三个主要版本，于 2021 年 5 月上线。它最革命性的改进是引入了<strong>集中流动性</strong>，彻底改变了流动性提供者（LP）的资金效率。</p>
<hr>
<p><strong>V3 与 V2 的核心区别</strong></p>
<table>
<thead>
<tr>
<th align="center">特性</th>
<th align="center">Uniswap V2</th>
<th align="center">Uniswap V3</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>流动性配置</strong></td>
<td align="center"><strong>被动 &amp; 分散</strong> 流动性均匀分布在整个（0, ∞）价格区间</td>
<td align="center"><strong>主动 &amp; 集中</strong> LP 可以自定义价格区间来提供流动性</td>
</tr>
<tr>
<td align="center"><strong>资金效率</strong></td>
<td align="center">低</td>
<td align="center"><strong>极高</strong>（最高可达 V2 的 4000 倍）</td>
</tr>
<tr>
<td align="center"><strong>做市策略</strong></td>
<td align="center">单一</td>
<td align="center"><strong>多样化</strong>（如稳定币对窄区间，波动性大的币对宽区间）</td>
</tr>
<tr>
<td align="center"><strong>费用等级</strong></td>
<td align="center">单一（0.3%）</td>
<td align="center"><strong>多层级</strong>（0.05%， 0.3%， 1%）</td>
</tr>
<tr>
<td align="center"><strong>LP Token</strong></td>
<td align="center">可互换的 ERC-20 代表池子的份额</td>
<td align="center"><strong>不可互换的 NFT (ERC-721)</strong> 代表一个特定的头寸</td>
</tr>
<tr>
<td align="center"><strong>价格预言机</strong></td>
<td align="center">时间加权平均价格</td>
<td align="center"><strong>更高效、更便宜的预言机</strong></td>
</tr>
</tbody></table>
<hr>
<p><strong>V3 的核心创新：集中流动性</strong></p>
<p>这是理解 V3 的钥匙。</p>
<p><strong>传统 V2 的问题</strong></p>
<p>在 V2 中，LP 的资本沿着 <code>x * y = k</code> 曲线均匀分布。这意味着只有一小部分资金在当前价格附近实际参与交易，大部分资金是闲置的，效率低下。</p>
<p><strong>V3 的解决方案</strong></p>
<p>V3 允许 LP 将资金<strong>集中</strong>在一个自定义的价格区间内（例如，USDC/DAI 集中在 $0.99 - $1.01）。</p>
<ul>
<li><strong>在区间内</strong>：LP 提供 100% 的流动性，赚取所有交易费用，资本效率极高。</li>
<li><strong>在区间外</strong>：LP 的资金会 100% 转换成两种资产中价值较低的一种，停止赚取费用，直到价格重新进入区间。</li>
</ul>
<p><strong>举例</strong>：<br>一个 LP 认为 ETH 将在 $1,800 到 $2,200 之间交易。他们可以创建一个只在这个区间提供流动性的头寸。他们的资金效率将远高于一个在整个价格范围提供流动性的 V2 LP。</p>
<hr>
<p><strong>其他关键特性</strong></p>
<ol>
<li>多级费率</li>
</ol>
<p>为了适应不同波动性的交易对，V3 引入了三个独立的费用等级：</p>
<ul>
<li>**0.05%**：针对极度稳定的资产对（如 USDC/DAI）</li>
<li>**0.30%**：针对标准波动性资产对（如 ETH/USDC）（与 V2 相同）</li>
<li>**1.00%**：针对高度波动性或长尾资产对</li>
</ul>
<p>这允许 LP 根据其承担的风险获得相应的补偿。</p>
<ol start="2">
<li>活跃的流动性管理</li>
</ol>
<p>由于价格会波动，LP 的头寸可能会移出活跃区间。这要求 LP 更积极地管理他们的头寸（手动调整或使用专门的“再平衡”服务），以最大化费用收益并避免无常损失。</p>
<ol start="3">
<li>高级预言机</li>
</ol>
<p>V3 引入了一种更 gas 高效的方式，让开发者能够存储任何时间间隔的价格历史数据，降低了集成链上价格数据的成本。</p>
<hr>
<p><strong>对参与者的影响</strong></p>
<ol>
<li>对于流动性提供者 (LPs)</li>
</ol>
<ul>
<li><strong>优点</strong>：潜在收益大幅增加（更高的资本效率）。</li>
<li><strong>挑战</strong>：需要更多的主动管理和市场判断（选择价格区间）。<strong>“懒惰的”LP 策略不再有效</strong>。</li>
<li><strong>风险</strong>：如果价格超出设定的范围，将停止赚取费用并 100% 暴露于一种资产中。</li>
</ul>
<ol start="2">
<li>对于交易者</li>
</ol>
<ul>
<li><strong>体验</strong>：与 V2 几乎无差别。</li>
<li><strong>优势</strong>：由于集中流动性，<strong>滑点通常更低</strong>，特别是对于主流交易对。</li>
</ul>
<ol start="3">
<li>对于开发者</li>
</ol>
<ul>
<li><strong>可组合性</strong>：V3 的核心合约甚至比 V2 更具可组合性，催生了一个全新的创新生态系统（如 DeFi 机枪池、结构化产品等）。</li>
<li><strong>基础设施</strong>：需要与新的非标准（NFT）LP 令牌进行交互。</li>
</ul>
<hr>
<p><strong>V3 生态与工具</strong></p>
<p>由于 V3 的复杂性，一个庞大的工具生态系统已经出现：</p>
<ul>
<li><strong>流动性管理平台</strong>：如 <a target="_blank" rel="noopener" href="https://www.gamma.xyz/">Gamma</a>, <a target="_blank" rel="noopener" href="https://www.arrakis.finance/">Arrakis Finance</a> 等，帮助 LP 自动管理他们的 V3 头寸。</li>
<li><strong>分析平台</strong>：如 <a target="_blank" rel="noopener" href="https://info.uniswap.org/">Uniswap V3 Analytics</a>, <a target="_blank" rel="noopener" href="https://dex.guru/">DexGuru</a> 等，提供高级的头寸和池子分析。</li>
<li><strong>DeFi 集成</strong>：许多协议将 V3 LP 头寸作为抵押品或其他用途。</li>
</ul>
<p><strong>总结</strong></p>
<p><strong>Uniswap V3 将从被动、通用的自动化做市商转变为一个主动、专业的资本效率市场。</strong></p>
<p>它不再是“一劳永逸”的协议，而是为高级用户和机构级参与者提供了一个功能更强大、但也更复杂的工具。它牺牲了一些简单性，但换来了无与伦比的资本控制力和效率，巩固了 Uniswap 作为 DeFi 基础设施核心的地位。</p>
<p>对于新手来说，从 V2 开始理解更容易，但要深入了解现代 DeFi 的运作方式，掌握 V3 的概念是必不可少的。</p>

      
    </div>
    <footer class="article-footer">
      
      
      
      
      
      
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item" data-aos="zoom-in"><a class="article-tag-list-link" href="/tags/Web3/" rel="tag">Web3</a></li><li class="article-tag-list-item" data-aos="zoom-in"><a class="article-tag-list-link" href="/tags/%E5%AE%9E%E4%B9%A0%E8%AE%A1%E5%88%92/" rel="tag">实习计划</a></li></ul>


    </footer>
  </div>
  
  <nav id="article-nav" data-aos="fade-up">
    
      
      <div class="article-nav-link-wrap article-nav-link-left">
        
          
          
            <img data-src="/covers/18.jpg" data-sizes="auto" alt="磐石行动CTFWP" class="lazyload">
          
        
        <a href="/2025/08/06/pan-shi-xing-dong-ctfwp/"></a>
        <div class="article-nav-caption">Prev</div>
        <h3 class="article-nav-title">
          
            磐石行动CTFWP
          
        </h3>
      </div>
    
    
    
    <div class="article-nav-link-wrap article-nav-link-right">
      
        
        
          <img data-src="/covers/3.jpg" data-sizes="auto" alt="以太坊学习" class="lazyload">
        
      
      <a href="/2025/08/01/yi-tai-fang-xue-xi/"></a>
      <div class="article-nav-caption">Next</div>
      <h3 class="article-nav-title">
        
          以太坊学习
        
      </h3>
    </div>
    
  </nav>


</article>










</section>
        </div>
        <footer id="footer">
  <div style="width: 100%; overflow: hidden">
    <div class="footer-line"></div>
  </div>
  <div id="footer-info">
    
    <div>
      <span class="icon-copyright"></span>
      
      
      
        2024-2025
      
      <span class="footer-info-sep "></span>
      mX1@0
    </div>
    
      <div>
        Powered by&nbsp;<a href="https://hexo.io/" rel="noopener external nofollow noreferrer" target="_blank">Hexo</a>&nbsp;
        Theme.<a href="https://github.com/D-Sketon/hexo-theme-reimu" rel="noopener external nofollow noreferrer" target="_blank">Reimu</a>
      </div>
    
    
      <div>
        <span class="icon-brush"></span>
        286.1k
        &nbsp;|&nbsp;
        <span class="icon-coffee"></span>
        17:51
      </div>
    
    
    
    
    
      <div>
        <span class="icon-eye"></span>
        <span id="busuanzi_container_site_pv">Number of visits&nbsp;<span id="busuanzi_value_site_pv"></span></span>
        &nbsp;|&nbsp;
        <span class="icon-user"></span>
        <span id="busuanzi_container_site_uv">Number of visitors&nbsp;<span id="busuanzi_value_site_uv"></span></span>
      </div>
    
  </div>
</footer>

        
          <div class="sidebar-top">
            <div class="sidebar-top-taichi rotate"></div>
            <div class="arrow-up"></div>
          </div>
        
        <div id="mask" class="hide"></div>
      </div>
      <nav id="mobile-nav">
  <div class="sidebar-wrap">
    
      
        <div class="sidebar-toc-sidebar"><div class="sidebar-toc">
  <h3 class="toc-title">Contents</h3>
  <div class="sidebar-toc-wrapper toc-div-class" >
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Web3-%E5%AE%9E%E4%B9%A0%E8%AE%A1%E5%88%92-2025-%E5%A4%8F%E5%AD%A3"><span class="toc-text">Web3 实习计划 - 2025 夏季</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E6%9C%884%E6%97%A5"><span class="toc-text">8月4日</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-text">区块链基础概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E4%BB%8B%E7%BB%8D"><span class="toc-text">区块链介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E7%89%B9%E6%80%A7"><span class="toc-text">区块链特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-text">区块链的核心组成部分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E7%9A%84%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8C%BA%E5%9D%97%E9%93%BE"><span class="toc-text">去中心化的网络和区块链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%B4%E6%8C%81%E7%BD%91%E7%BB%9C%E8%BF%90%E8%A1%8C%E7%9A%84%E4%BB%A3%E5%B8%81%E6%BF%80%E5%8A%B1"><span class="toc-text">维持网络运行的代币激励</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E9%93%BE-%E7%A7%81%E9%93%BE-%E8%81%94%E7%9B%9F%E9%93%BE"><span class="toc-text">公链 私链 联盟链</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AC%E9%93%BE%EF%BC%88Public-Blockchain%EF%BC%89"><span class="toc-text">公链（Public Blockchain）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%81%E9%93%BE%EF%BC%88Private-Blockchain%EF%BC%89"><span class="toc-text">私链（Private Blockchain）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%94%E7%9B%9F%E9%93%BE%EF%BC%88Consortium-Blockchain%EF%BC%89"><span class="toc-text">联盟链（Consortium Blockchain）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93"><span class="toc-text">对比总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E4%BE%9D%E6%8D%AE"><span class="toc-text">选择依据</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E6%9C%885%E6%97%A5"><span class="toc-text">8月5日</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%A6%82%E8%A7%88"><span class="toc-text">以太坊概览</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%BB%8B%E7%BB%8D"><span class="toc-text">以太坊介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ethereum-%E4%B8%8E-Bitcoin-%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-text">Ethereum 与 Bitcoin 的差异</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%9A%84%E5%AE%9A%E4%BD%8D%E4%B8%8E%E6%BC%94%E8%BF%9B"><span class="toc-text">以太坊的定位与演进</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E5%9D%8A1-0%EF%BC%88PoW%E9%98%B6%E6%AE%B5%EF%BC%89"><span class="toc-text">以太坊1.0（PoW阶段）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E5%9D%8A2-0%E4%B8%8EThe-Merge%EF%BC%9A%E4%BB%8E%E5%8F%8C%E9%93%BE%E5%B9%B6%E8%A1%8C%E5%88%B0%E5%AE%8C%E7%BE%8E%E5%90%88%E5%B9%B6"><span class="toc-text">以太坊2.0与The Merge：从双链并行到完美合并</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AA%E6%9D%A5%E5%8D%87%E7%BA%A7%E8%B7%AF%E7%BA%BF"><span class="toc-text">未来升级路线</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%94%9F%E6%80%81%E6%A6%82%E8%A7%88%EF%BC%9AL1%E3%80%81L2%E3%80%81Sidechains-%E7%AD%89"><span class="toc-text">以太坊生态概览：L1、L2、Sidechains 等</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%96%87%E5%8C%96%E4%B8%8E%E4%BB%B7%E5%80%BC%E8%A7%82"><span class="toc-text">以太坊文化与价值观</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%EF%BC%9A%E4%BB%8E%E8%B4%A6%E6%88%B7%E5%88%B0%E6%89%A7%E8%A1%8C%E7%9A%84%E5%AE%8C%E6%95%B4%E9%93%BE%E8%B7%AF"><span class="toc-text">以太坊核心机制：从账户到执行的完整链路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unphishable%E9%92%93%E9%B1%BC%E6%94%BB%E9%98%B2%E6%8C%91%E6%88%98"><span class="toc-text">Unphishable钓鱼攻防挑战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E7%BA%A7"><span class="toc-text">初级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#No-0x0001-Web3-%E9%92%B1%E5%8C%85%E8%AE%BE%E7%BD%AE%E6%8C%87%E5%8D%97"><span class="toc-text">No.0x0001 Web3 钱包设置指南</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#No-0x0002-%E9%92%B1%E5%8C%85%E6%81%A2%E5%A4%8D%E5%8A%A9%E6%89%8B"><span class="toc-text">No.0x0002 钱包恢复助手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#No-0x0003-USDC-Permit-%E9%92%93%E9%B1%BC%E6%A8%A1%E6%8B%9F"><span class="toc-text">No.0x0003 USDC Permit 钓鱼模拟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#No-0x0004-%E4%B8%93%E5%B1%9E%E4%BB%A3%E5%B8%81%E7%A9%BA%E6%8A%95"><span class="toc-text">No.0x0004 专属代币空投</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#No-0x0005-USDT-%E6%8E%88%E6%9D%83%E9%92%93%E9%B1%BC%E6%A8%A1%E6%8B%9F"><span class="toc-text">No.0x0005 USDT 授权钓鱼模拟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#No-0x0006-%E5%81%87%E5%86%92%E4%BB%A3%E5%B8%81%E7%A9%BA%E6%8A%95%E9%92%93%E9%B1%BC%E6%94%BB%E5%87%BB"><span class="toc-text">No.0x0006 假冒代币空投钓鱼攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#No-0x0007-%E8%B6%85%E9%AB%98%E6%94%B6%E7%9B%8A%E8%B4%A8%E6%8A%BC%E5%B9%B3%E5%8F%B0"><span class="toc-text">No.0x0007 超高收益质押平台</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#No-0x0008-Telegram-%E4%BB%A3%E5%B8%81%E9%92%93%E9%B1%BC%E6%8C%91%E6%88%98"><span class="toc-text">No.0x0008 Telegram 代币钓鱼挑战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#No-0x0009-Punycode-%E9%92%93%E9%B1%BC%E6%94%BB%E5%87%BB"><span class="toc-text">No.0x0009 Punycode 钓鱼攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Punycode%EF%BC%9F"><span class="toc-text">什么是 Punycode？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#No-0x0010-%E5%89%AA%E8%B4%B4%E6%9D%BF%E9%92%93%E9%B1%BC%E6%8C%91%E6%88%98"><span class="toc-text">No.0x0010 剪贴板钓鱼挑战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#No-0x0011-Google-%E6%90%9C%E7%B4%A2%E5%B9%BF%E5%91%8A%E9%92%93%E9%B1%BC%E6%94%BB%E5%87%BB"><span class="toc-text">No.0x0011 Google 搜索广告钓鱼攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#No-0x0012-Microsoft-Teams-%E9%92%93%E9%B1%BC%E6%94%BB%E5%87%BB"><span class="toc-text">No.0x0012 Microsoft Teams 钓鱼攻击</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Microsoft-Teams-%E9%92%93%E9%B1%BC%E6%94%BB%E5%87%BB%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">Microsoft Teams 钓鱼攻击的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#No-0x0037-%E8%99%9A%E5%81%87%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F%E9%92%93%E9%B1%BC"><span class="toc-text">No.0x0037 虚假扩展程序钓鱼</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E7%BA%A7"><span class="toc-text">中级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#No-0x0013-TransferFrom-%E9%9B%B6%E5%80%BC%E8%BD%AC%E8%B4%A6%E9%92%93%E9%B1%BC%E6%8C%91%E6%88%98"><span class="toc-text">No.0x0013 TransferFrom 零值转账钓鱼挑战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%88%E9%AA%97%E8%80%85%E5%88%A9%E7%94%A8%E2%80%9C%E9%9B%B6%E5%80%BC%E8%BD%AC%E8%B4%A6%E2%80%9D%E4%BC%AA%E9%80%A0%E4%BA%A4%E6%98%93%E5%8E%86%E5%8F%B2%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E9%98%B2%E8%8C%83%E6%8E%AA%E6%96%BD"><span class="toc-text">诈骗者利用“零值转账”伪造交易历史的原理及防范措施</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86"><span class="toc-text">1. 攻击原理</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E6%9C%886%E6%97%A5"><span class="toc-text">8月6日</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MyFirstLayer2"><span class="toc-text">MyFirstLayer2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%85%AC%E9%93%BE%E7%93%B6%E9%A2%88"><span class="toc-text">1 公链瓶颈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1%E6%94%B9%E8%BF%9B%E5%B0%9D%E8%AF%95"><span class="toc-text">1.1改进尝试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%89%E9%9A%BE%E5%9B%B0%E5%A2%83"><span class="toc-text">1.2 区块链三难困境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-Layer-2"><span class="toc-text">1.3 Layer 2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Layer-2%E5%8F%91%E5%B1%95%E5%8F%B2"><span class="toc-text">2 Layer 2发展史</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E7%8A%B6%E6%80%81%E9%80%9A%E9%81%93%EF%BC%88State-channel%EF%BC%89"><span class="toc-text">2.1 状态通道（State channel）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E4%BE%A7%E9%93%BE%EF%BC%88Sidechain%EF%BC%89"><span class="toc-text">2.2 侧链（Sidechain）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-Plasma"><span class="toc-text">2.3 Plasma</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-Rollup"><span class="toc-text">2.4 Rollup</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E%EF%BC%88Zero-Knowledge-Proof-ZKP%EF%BC%89%E8%AF%A6%E8%A7%A3"><span class="toc-text">零知识证明（Zero-Knowledge Proof, ZKP）详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E%E7%9A%84%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="toc-text">1. 零知识证明的三大核心特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BB%8F%E5%85%B8%E7%B1%BB%E6%AF%94%EF%BC%9A%E6%B4%9E%E7%A9%B4%E5%AF%93%E8%A8%80"><span class="toc-text">2. 经典类比：洞穴寓言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E%E7%9A%84%E4%B8%A4%E7%A7%8D%E4%B8%BB%E8%A6%81%E7%B1%BB%E5%9E%8B"><span class="toc-text">3. 零知识证明的两种主要类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84-ZKP-%E6%8A%80%E6%9C%AF"><span class="toc-text">4. 区块链中的 ZKP 技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E%E7%9A%84%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8"><span class="toc-text">5. 零知识证明的区块链应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">6. 零知识证明的优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-Layer-2-%E5%AF%B9%E6%AF%94"><span class="toc-text">2.5 Layer 2 对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Rollup%E8%AF%A6%E6%83%85"><span class="toc-text">3 Rollup详情</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E5%A6%82%E4%BD%95%E5%8E%8B%E7%BC%A9"><span class="toc-text">3.1 如何压缩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%8E%8B%E7%BC%A9"><span class="toc-text">3.2 进一步压缩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-Optimistic-Rollup"><span class="toc-text">3.3 Optimistic Rollup</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-Zero-Knowledge-Proof"><span class="toc-text">3.4 Zero-Knowledge Proof</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-ZK-%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86-STARK-vs-SNARK"><span class="toc-text">3.5 ZK 技术原理 STARK vs SNARK</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#SNARK"><span class="toc-text">SNARK</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#STARK"><span class="toc-text">STARK</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-ZK-%E5%8F%91%E5%B1%95%E8%B7%AF%E7%BA%BF-ZK-VM-vs-ZK-EVM"><span class="toc-text">3.6 ZK 发展路线 ZK-VM vs ZK-EVM</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ZK-VM%EF%BC%9A%E4%BB%8E%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E%E7%9A%84%E8%A7%92%E5%BA%A6%E5%87%BA%E5%8F%91"><span class="toc-text">ZK-VM：从零知识证明的角度出发</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ZK-EVM%EF%BC%9A%E4%BB%8E-EVM-%E5%85%BC%E5%AE%B9%E6%80%A7%E7%9A%84%E8%A7%92%E5%BA%A6%E5%87%BA%E5%8F%91"><span class="toc-text">ZK-EVM：从 EVM 兼容性的角度出发</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%9C%AA%E6%9D%A5%E5%B1%95%E6%9C%9B"><span class="toc-text">4 未来展望</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E5%85%B6%E5%AE%83%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9AValidium-%E5%92%8C-Volition"><span class="toc-text">4.1 其它解决方案：Validium 和 Volition</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Validium"><span class="toc-text">Validium</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Volition"><span class="toc-text">Volition</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-Deneb-%E6%9B%B4%E6%96%B0%E4%B8%8E-Layer-2"><span class="toc-text">4.2 Deneb 更新与 Layer 2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E8%B4%A6%E6%88%B7%E6%8A%BD%E8%B1%A1%E4%B8%8E%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%BA%94%E7%94%A8"><span class="toc-text">4.3 账户抽象与大规模应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E5%B2%97%E4%BD%8D%E5%85%A8%E6%99%AF%E5%9B%BE"><span class="toc-text">区块链岗位全景图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%8A%80%E6%9C%AF%E5%B2%97"><span class="toc-text">一、技术岗</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88"><span class="toc-text">1. 前端工程师</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%90%8E%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88"><span class="toc-text">2. 后端工程师</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%B7%A5%E7%A8%8B%E5%B8%88"><span class="toc-text">3. 智能合约工程师</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E9%9D%9E%E6%8A%80%E6%9C%AF%E5%B2%97"><span class="toc-text">二、非技术岗</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BA%A7%E5%93%81%E4%B8%8E%E8%BF%90%E8%90%A5"><span class="toc-text">1. 产品与运营</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%A4%BE%E5%8C%BA%E7%AE%A1%E7%90%86"><span class="toc-text">2. 社区管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%A0%94%E7%A9%B6%E5%88%86%E6%9E%90"><span class="toc-text">3. 研究分析</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E6%9C%887%E6%97%A5"><span class="toc-text">8月7日</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%8C%E4%B8%9A%E8%B5%9B%E9%81%93%E5%85%A8%E8%A7%88"><span class="toc-text">行业赛道全览</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E6%9C%888%E6%97%A5"><span class="toc-text">8月8日</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CryptoZombiesx%E7%9A%84solidity%E5%AD%A6%E4%B9%A0"><span class="toc-text">CryptoZombiesx的solidity学习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Solidity-Beginner-to-Intermediate-Smart-Contracts"><span class="toc-text">Solidity: Beginner to Intermediate Smart Contracts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lesson1-%E6%90%AD%E5%BB%BA%E5%83%B5%E5%B0%B8%E5%B7%A5%E5%8E%82"><span class="toc-text">lesson1 搭建僵尸工厂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E5%90%88%E7%BA%A6"><span class="toc-text">第2章: 合约</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B4%E6%95%B0"><span class="toc-text">第3章: 状态变量和整数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97"><span class="toc-text">第4章: 数学运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">第5章: 结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E6%95%B0%E7%BB%84"><span class="toc-text">第6章: 数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><span class="toc-text">第7章: 定义函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-text">第8章: 使用结构体和数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-%E7%A7%81%E6%9C%89-%E5%85%AC%E5%85%B1%E5%87%BD%E6%95%B0"><span class="toc-text">第9章: 私有 &#x2F; 公共函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-%E5%87%BD%E6%95%B0%E7%9A%84%E6%9B%B4%E5%A4%9A%E5%B1%9E%E6%80%A7"><span class="toc-text">第10章: 函数的更多属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-Keccak256-%E5%92%8C-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">第11章: Keccak256 和 类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-%E6%94%BE%E5%9C%A8%E4%B8%80%E8%B5%B7"><span class="toc-text">第12章: 放在一起</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-%E4%BA%8B%E4%BB%B6"><span class="toc-text">第13章: 事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-Web3-js"><span class="toc-text">第14章: Web3.js</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E6%9C%889%E6%97%A5"><span class="toc-text">8月9日</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Chainlink%E9%A2%84%E8%A8%80%E6%9C%BA%E7%9A%84solidity%E8%AF%BE%E7%A8%8B"><span class="toc-text">Chainlink预言机的solidity课程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#solidity%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E5%87%BD%E6%95%B0%E3%80%81%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">solidity数据类型、函数、存储模式、数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#solidity%E7%9A%84%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-text">solidity的工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D"><span class="toc-text">工厂模式介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E5%90%88%E7%BA%A6%E6%96%B9%E5%BC%8F"><span class="toc-text">引入合约方式</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E6%9C%8810%E6%97%A5"><span class="toc-text">8月10日</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CryptoZombiesx%E7%9A%84solidity%E5%AD%A6%E4%B9%A0-1"><span class="toc-text">CryptoZombiesx的solidity学习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Solidity-Beginner-to-Intermediate-Smart-Contracts-1"><span class="toc-text">Solidity: Beginner to Intermediate Smart Contracts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lesson2-%E5%83%B5%E5%B0%B8%E6%94%BB%E5%87%BB%E4%BA%BA%E7%B1%BB"><span class="toc-text">lesson2 僵尸攻击人类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E6%98%A0%E5%B0%84%EF%BC%88Mapping%EF%BC%89%E5%92%8C%E5%9C%B0%E5%9D%80%EF%BC%88Address%EF%BC%89"><span class="toc-text">第2章: 映射（Mapping）和地址（Address）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-Msg-sender"><span class="toc-text">第3章: Msg.sender</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-Require"><span class="toc-text">第4章: Require</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E7%BB%A7%E6%89%BF%EF%BC%88Inheritance%EF%BC%89"><span class="toc-text">第5章: 继承（Inheritance）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E5%BC%95%E5%85%A5%EF%BC%88Import%EF%BC%89"><span class="toc-text">第6章: 引入（Import）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-Storage%E4%B8%8EMemory"><span class="toc-text">第7章: Storage与Memory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E5%83%B5%E5%B0%B8%E7%9A%84DNA"><span class="toc-text">第8章: 僵尸的DNA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-%E6%9B%B4%E5%A4%9A%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-text">第9章: 更多关于函数可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-%E5%83%B5%E5%B0%B8%E5%90%83%E4%BB%80%E4%B9%88"><span class="toc-text">第10章: 僵尸吃什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3"><span class="toc-text">第11章: 使用接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-%E5%A4%84%E7%90%86%E5%A4%9A%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">第12章: 处理多返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-%E5%A5%96%E5%8A%B1-Kitty-%E5%9F%BA%E5%9B%A0"><span class="toc-text">第13章: 奖励: Kitty 基因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-%E6%94%BE%E5%9C%A8%E4%B8%80%E8%B5%B7"><span class="toc-text">第14章: 放在一起</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E6%9C%8811%E6%97%A5"><span class="toc-text">8月11日</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Chainlink%E9%A2%84%E8%A8%80%E6%9C%BA%E7%9A%84solidity%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B"><span class="toc-text">Chainlink预言机的solidity进阶课程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E8%A8%80%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88Chainlink%EF%BC%89"><span class="toc-text">预言机网络（Chainlink）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%96%82%E4%BB%B7%EF%BC%88Data-Feed%EF%BC%89"><span class="toc-text">喂价（Data Feed）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Data-Feed-%E6%9E%B6%E6%9E%84"><span class="toc-text">Data Feed 架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Data-Feed-%E7%BB%93%E6%9E%84"><span class="toc-text">Data Feed 结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2%E4%B8%80%E4%B8%AAFundMe%E7%9A%84%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6"><span class="toc-text">部署一个FundMe的智能合约</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E8%B4%A6%E7%9A%84%E4%B8%89%E7%A7%8D%E7%B1%BB%E5%9E%8B"><span class="toc-text">转账的三种类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E6%AC%BE"><span class="toc-text">提款</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E9%94%81"><span class="toc-text">时间锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#modifier%E4%BF%AE%E6%94%B9%E5%99%A8"><span class="toc-text">modifier修改器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91"><span class="toc-text">智能合约开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Dapp-%E6%9E%B6%E6%9E%84%E5%92%8C%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B"><span class="toc-text">Dapp 架构和开发流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Dapp-%E6%9E%B6%E6%9E%84"><span class="toc-text">Dapp 架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dapp-%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B"><span class="toc-text">Dapp 开发流程</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E6%9C%8812%E6%97%A5"><span class="toc-text">8月12日</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CryptoZombiesx%E7%9A%84solidity%E5%AD%A6%E4%B9%A0-2"><span class="toc-text">CryptoZombiesx的solidity学习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Solidity-Beginner-to-Intermediate-Smart-Contracts-2"><span class="toc-text">Solidity: Beginner to Intermediate Smart Contracts</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lesson3-%E9%AB%98%E7%BA%A7-Solidity-%E7%90%86%E8%AE%BA"><span class="toc-text">lesson3 高级 Solidity 理论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-%E6%99%BA%E8%83%BD%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%B0%B8%E5%9B%BA%E6%80%A7"><span class="toc-text">第1章: 智能协议的永固性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-Ownable-Contracts"><span class="toc-text">第2章: Ownable Contracts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-onlyOwner-%E5%87%BD%E6%95%B0%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">第3章: onlyOwner 函数修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-Gas"><span class="toc-text">第4章: Gas</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E6%97%B6%E9%97%B4%E5%8D%95%E4%BD%8D"><span class="toc-text">第5章: 时间单位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E5%83%B5%E5%B0%B8%E5%86%B7%E5%8D%B4"><span class="toc-text">第6章: 僵尸冷却</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-%E5%85%AC%E6%9C%89%E5%87%BD%E6%95%B0%E5%92%8C%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-text">第7章: 公有函数和安全性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%87%BD%E6%95%B0%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">第8章: 进一步了解函数修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-%E5%83%B5%E5%B0%B8%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">第9章: 僵尸修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-%E5%88%A9%E7%94%A8-%E2%80%98View%E2%80%99-%E5%87%BD%E6%95%B0%E8%8A%82%E7%9C%81-Gas"><span class="toc-text">第10章: 利用 ‘View’ 函数节省 Gas</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-%E5%AD%98%E5%82%A8%E9%9D%9E%E5%B8%B8%E6%98%82%E8%B4%B5"><span class="toc-text">第11章: 存储非常昂贵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-For-%E5%BE%AA%E7%8E%AF"><span class="toc-text">第12章: For 循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-%E6%94%BE%E5%9C%A8%E4%B8%80%E8%B5%B7"><span class="toc-text">第13章: 放在一起</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lesson4-%E5%83%B5%E5%B0%B8%E4%BD%9C%E6%88%98%E7%B3%BB%E7%BB%9F"><span class="toc-text">lesson4 僵尸作战系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-%E5%8F%AF%E6%94%AF%E4%BB%98"><span class="toc-text">第1章: 可支付</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E6%8F%90%E7%8E%B0"><span class="toc-text">第2章: 提现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-%E5%83%B5%E5%B0%B8%E6%88%98%E6%96%97"><span class="toc-text">第3章: 僵尸战斗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="toc-text">第4章: 随机数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E5%83%B5%E5%B0%B8%E5%AF%B9%E6%88%98"><span class="toc-text">第5章: 僵尸对战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E9%87%8D%E6%9E%84%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91"><span class="toc-text">第6章: 重构通用逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-%E6%9B%B4%E5%A4%9A%E9%87%8D%E6%9E%84"><span class="toc-text">第7章: 更多重构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E5%9B%9E%E5%88%B0%E6%94%BB%E5%87%BB%EF%BC%81"><span class="toc-text">第8章: 回到攻击！</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-%E5%83%B5%E5%B0%B8%E7%9A%84%E8%BE%93%E8%B5%A2"><span class="toc-text">第9章: 僵尸的输赢</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-%E5%83%B5%E5%B0%B8%E8%83%9C%E5%88%A9%E4%BA%86-%F0%9F%98%84"><span class="toc-text">第10章: 僵尸胜利了 😄</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-%E5%83%B5%E5%B0%B8%E5%A4%B1%E8%B4%A5-%F0%9F%98%9E"><span class="toc-text">第11章: 僵尸失败 😞</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lesson5-ERC721-%E6%A0%87%E5%87%86%E5%92%8C%E5%8A%A0%E5%AF%86%E6%94%B6%E8%97%8F%E5%93%81"><span class="toc-text">lesson5 ERC721 标准和加密收藏品</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%B8%8A%E7%9A%84%E4%BB%A3%E5%B8%81"><span class="toc-text">第1章: 以太坊上的代币</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-ERC721-%E6%A0%87%E5%87%86-%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-text">第2章: ERC721 标准, 多重继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-balanceOf-%E5%92%8C-ownerOf"><span class="toc-text">第3章: balanceOf 和 ownerOf</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E9%87%8D%E6%9E%84"><span class="toc-text">第4章: 重构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-ERC721-%E8%BD%AC%E7%A7%BB%E6%A0%87%E5%87%86"><span class="toc-text">第5章: ERC721: 转移标准</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-ERC721-%E8%BD%AC%E7%A7%BB-%E7%BB%AD"><span class="toc-text">第6章: ERC721: 转移-续</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-ERC721-%E6%89%B9%E5%87%86"><span class="toc-text">第7章: ERC721: 批准</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-ERC721-takeOwnership"><span class="toc-text">第8章: ERC721: takeOwnership</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-%E9%A2%84%E9%98%B2%E6%BA%A2%E5%87%BA"><span class="toc-text">第9章: 预防溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-SafeMath-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86"><span class="toc-text">第10章: SafeMath 第二部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-SafeMath-%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86"><span class="toc-text">第11章: SafeMath 第三部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-SafeMath-%E7%AC%AC4%E9%83%A8%E5%88%86"><span class="toc-text">第12章: SafeMath 第4部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-%E6%B3%A8%E9%87%8A"><span class="toc-text">第13章: 注释</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B"><span class="toc-text">总结一下</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lesson6-%E5%BA%94%E7%94%A8%E5%89%8D%E7%AB%AF%E5%92%8C-Web3-js"><span class="toc-text">lesson6 应用前端和 Web3.js</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-%E4%BB%8B%E7%BB%8D-Web3-js"><span class="toc-text">第1章: 介绍 Web3.js</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-Web3-%E6%8F%90%E4%BE%9B%E8%80%85"><span class="toc-text">第2章: Web3 提供者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-%E5%92%8C%E5%90%88%E7%BA%A6%E5%AF%B9%E8%AF%9D"><span class="toc-text">第3章: 和合约对话</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E8%B0%83%E7%94%A8%E5%92%8C%E5%90%88%E7%BA%A6%E5%87%BD%E6%95%B0"><span class="toc-text">第4章: 调用和合约函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-MetaMask-%E5%92%8C%E8%B4%A6%E6%88%B7"><span class="toc-text">第5章: MetaMask 和账户</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#openzeppelin%E6%94%BB%E9%98%B2%E6%8C%91%E6%88%98"><span class="toc-text">openzeppelin攻防挑战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Hello-Ethernaut"><span class="toc-text">1 Hello Ethernaut</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Fallback"><span class="toc-text">2 Fallback</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Fallout"><span class="toc-text">3 Fallout</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E6%9C%8813%E6%97%A5"><span class="toc-text">8月13日</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91-1"><span class="toc-text">智能合约开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Dapp-%E6%9E%B6%E6%9E%84%E5%92%8C%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B-1"><span class="toc-text">Dapp 架构和开发流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Dapp-%E6%9E%B6%E6%9E%84-1"><span class="toc-text">Dapp 架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dapp-%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B-1"><span class="toc-text">Dapp 开发流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Solidity-%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E7%BC%96%E7%A8%8B"><span class="toc-text">Solidity 智能合约编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%B8%8E%E5%BC%80%E5%8F%91%E8%8C%83%E5%BC%8F"><span class="toc-text">基础语法与开发范式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3"><span class="toc-text">合约结构详解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80"><span class="toc-text">以太坊技术基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%90%E6%88%B7%E6%A8%A1%E5%9E%8B"><span class="toc-text">帐户模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Gas-%E6%9C%BA%E5%88%B6"><span class="toc-text">Gas 机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%98%93%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">交易生命周期</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chainlink%E9%A2%84%E8%A8%80%E6%9C%BA%E7%9A%84solidity%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B-1"><span class="toc-text">Chainlink预言机的solidity进阶课程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-text">虚函数：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2%E4%B8%80%E4%B8%AAToken%E5%90%88%E7%BA%A6"><span class="toc-text">部署一个Token合约</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E6%9C%8814%E6%97%A5"><span class="toc-text">8月14日</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Hardhat%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6"><span class="toc-text">Hardhat开发框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E9%83%A8%E7%BD%B2"><span class="toc-text">合约部署</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C-%E7%A7%81%E9%92%A5%E9%85%8D%E7%BD%AE"><span class="toc-text">网络&amp;私钥配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#env"><span class="toc-text">.env</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#env-enc"><span class="toc-text">env-enc</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hardhat-Verify"><span class="toc-text">Hardhat Verify</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E6%9C%8815%E6%97%A5"><span class="toc-text">8月15日</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Web-js"><span class="toc-text">Web.js</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA"><span class="toc-text">项目创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85vant-ui%E7%BB%84%E4%BB%B6%E5%BA%93"><span class="toc-text">配置安装vant-ui组件库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Web3%E8%BF%9E%E6%8E%A5%E5%88%B0%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%BD%91%E7%BB%9C"><span class="toc-text">Web3连接到以太坊网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Web3-js%E9%AB%98%E9%A2%91API"><span class="toc-text">Web3.js高频API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%A6%E5%8F%B7%E5%88%9B%E5%BB%BA"><span class="toc-text">账号创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%99%E9%A2%9D%E8%8E%B7%E5%8F%96"><span class="toc-text">余额获取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%BD%8D%E8%BD%AC%E6%8D%A2"><span class="toc-text">单位转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Eth%E8%BD%AC%E8%B4%A6"><span class="toc-text">Eth转账</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E6%9C%8816%E6%97%A5"><span class="toc-text">8月16日</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#DeFi"><span class="toc-text">DeFi</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Uniswap"><span class="toc-text">Uniswap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E4%BA%A4%E6%98%93%E6%89%80-vs-%E4%B8%AD%E5%BF%83%E5%8C%96%E4%BA%A4%E6%98%93%E6%89%80"><span class="toc-text">去中心化交易所 vs 中心化交易所</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Compound%EF%BC%9A%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E5%80%9F%E8%B4%B7%E5%8D%8F%E8%AE%AE"><span class="toc-text">Compound：去中心化借贷协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MakerDAO%EF%BC%88%E7%8E%B0%E5%B7%B2%E6%9B%B4%E5%90%8D%E4%B8%BA-Sky%EF%BC%89%EF%BC%9A%E7%A8%B3%E5%AE%9A%E5%B8%81%E7%B3%BB%E7%BB%9F"><span class="toc-text">MakerDAO（现已更名为 Sky）：稳定币系统</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NFT"><span class="toc-text">NFT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DAO%EF%BC%9A%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E8%87%AA%E6%B2%BB%E7%BB%84%E7%BB%87"><span class="toc-text">DAO：去中心化自治组织</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Nouns-DAO%EF%BC%9A%E7%A4%BE%E5%8C%BA%E9%A9%B1%E5%8A%A8%E7%9A%84-NFT-%E8%89%BA%E6%9C%AF-DAO"><span class="toc-text">Nouns DAO：社区驱动的 NFT 艺术 DAO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LXDAO%EF%BC%9A%E6%94%AF%E6%8C%81-Web3-%E5%85%AC%E5%85%B1%E7%89%A9%E5%93%81%E7%9A%84%E5%BB%BA%E8%AE%BE%E8%80%85"><span class="toc-text">LXDAO：支持 Web3 公共物品的建设者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConstitutionDAO%EF%BC%9A%E4%B8%80%E5%9C%BA%E7%96%AF%E7%8B%82%E7%9A%84%E6%8B%8D%E5%8D%96"><span class="toc-text">ConstitutionDAO：一场疯狂的拍卖</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E6%9C%8819%E6%97%A5"><span class="toc-text">8月19日</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E6%9C%8820%E6%97%A5"><span class="toc-text">8月20日</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%A6%E6%88%B7%E7%B3%BB%E7%BB%9F"><span class="toc-text">账户系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-text">简介</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%86%E7%A0%81%E3%80%81%E7%A7%81%E9%92%A5%E3%80%81keystore%E4%B8%8E%E5%8A%A9%E8%AE%B0%E8%AF%8D%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">密码、私钥、keystore与助记词的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%B4%A6%E6%88%B7"><span class="toc-text">创建账户</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#web3%E7%9B%B4%E6%8E%A5%E5%88%9B%E5%BB%BA%E8%B4%A6%E6%88%B7"><span class="toc-text">web3直接创建账户</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A9%E8%AE%B0%E8%AF%8D%E5%88%9B%E5%BB%BA%E8%B4%A6%E6%88%B7"><span class="toc-text">助记词创建账户</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E6%9C%8821%E6%97%A5"><span class="toc-text">8月21日</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Uniswap-1"><span class="toc-text">Uniswap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Uniswap-V2"><span class="toc-text">Uniswap V2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Uniswap-V3"><span class="toc-text">Uniswap V3</span></a></li></ol></li></ol></li></ol>
      
  </div>
</div>
</div>
        <div class="sidebar-common-sidebar hidden"><div class="sidebar-author">
  <img data-src="/avatar/avatar.webp" data-sizes="auto" alt="mX1@0" class="lazyload">
  <div class="sidebar-author-name">mX1@0</div>
  <div class="sidebar-description"></div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>Post</div>
    <div class="sidebar-state-number">54</div>
  </div>
  <div class="sidebar-state-category">
    <div>Category</div>
    <div class="sidebar-state-number">25</div>
  </div>
  <div class="sidebar-state-tag">
    <div>Tag</div>
    <div class="sidebar-state-number">65</div>
  </div>
</div>
<div class="sidebar-social">
  
    <div class="icon-twitter sidebar-social-icon">
      <a href=https://x.com/0xMx1a0 itemprop="url" target="_blank" aria-label="twitter" rel="noopener external nofollow noreferrer"></a>
    </div>
  
</div>
<div class="sidebar-menu">
  
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/" aria-label="首页"></a>
        <div class="sidebar-menu-icon icon rotate">
          
            &#xe62b;
          
        </div>
        <div class="sidebar-menu-link">首页</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/archives" aria-label="归类"></a>
        <div class="sidebar-menu-icon icon rotate">
          
            &#xe62b;
          
        </div>
        <div class="sidebar-menu-link">归类</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/about" aria-label="关于"></a>
        <div class="sidebar-menu-icon icon rotate">
          
            &#xe62b;
          
        </div>
        <div class="sidebar-menu-link">关于</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/friend" aria-label="友链"></a>
        <div class="sidebar-menu-icon icon rotate">
          
            &#xe62b;
          
        </div>
        <div class="sidebar-menu-link">友链</div>
      </div>
    
  
</div>
</div>
      
    
  </div>
  
    
      <div class="sidebar-btn-wrapper">
        <div class="sidebar-toc-btn current"></div>
        <div class="sidebar-common-btn"></div>
      </div>
    
  
</nav>

    </div>
    
    
    
    
<script src="https://npm.webcache.cn/lazysizes@5.3.2/lazysizes.min.js" integrity="sha384-3gT&#x2F;vsepWkfz&#x2F;ff7PpWNUeMzeWoH3cDhm&#x2F;A8jM7ouoAK0&#x2F;fP&#x2F;9bcHHR5kHq2nf+e" crossorigin="anonymous"></script>


<script src="https://npm.webcache.cn/clipboard@2.0.11/dist/clipboard.min.js" integrity="sha384-J08i8An&#x2F;QeARD9ExYpvphB8BsyOj3Gh2TSh1aLINKO3L0cMSH2dN3E22zFoXEi0Q" crossorigin="anonymous"></script>





<script src="/js/script.js"></script>



  
<script src="/js/aos.js"></script>

  <script>
    var aosInit = () => {
      AOS.init({
        duration: 1000,
        easing: "ease",
        once: true,
        offset: 50,
      });
    };
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', aosInit);
    } else {
      aosInit();
    }
  </script>



<script src="/js/pjax_script.js" data-pjax></script>







  
<script src="https://npm.webcache.cn/mouse-firework@0.1.1/dist/index.umd.js" integrity="sha384-8LyaidD9GPxQQgLJO&#x2F;WRw&#x2F;O2h3BoNq&#x2F;ApI&#x2F;ecpvM6RsrCz2qP2ppBXUKihP4V&#x2F;2d" crossorigin="anonymous"></script>

  <script>
    window.firework && window.firework(JSON.parse('{"excludeElements":["a","button"],"particles":[{"shape":"circle","move":["emit"],"easing":"easeOutExpo","colors":["var(--red-1)","var(--red-2)","var(--red-3)","var(--red-4)"],"number":20,"duration":[1200,1800],"shapeOptions":{"radius":[16,32],"alpha":[0.3,0.5]}},{"shape":"circle","move":["diffuse"],"easing":"easeOutExpo","colors":["var(--red-0)"],"number":1,"duration":[1200,1800],"shapeOptions":{"radius":20,"alpha":[0.2,0.5],"lineWidth":6}}]}'))
  </script>










<div id="lazy-script">
  <div>
    
      
      
      <script data-pjax>
        window.REIMU_POST = {
          author: "mX1@0",
          title: "Web3 实习计划 - 2025 夏季",
          url: "http://example.com/2025/08/04/web3-shi-xi-ji-hua-2025-xia-ji/",
          excerpt: "",
          description: "",
          stripContent: "Web3 实习计划 - 2025 夏季在这个Web3实习计划之前，其实我学过一些区块链的内容，但是也仅仅是知道一些概念性的东西，例如，PoW、PoS、defi等一些概念，所以参加这个实习计划也是为了更深入的学习Web3的内容，接下来是我的每日学习笔记 8月4日区块链基础概念区块链介绍区块链是一种去中心化的分布式账本技术，用于在网络节点之间安全、透明且不可篡改地记录事务数据  去中心化：区块链网络通常分布在全球，每个节点都将会存储一份相同的区块链数据。没有人能够控制全部的节点，因此这份区块链数据将",
          date: "Mon Aug 04 2025 20:34:47 GMT+0800",
          updated: "Wed Aug 20 2025 23:42:23 GMT+0800",
          cover: "/images/%E7%8E%9B%E8%8E%8E%E6%8B%89%E8%92%82.jpg",
        };
      </script>
       
    
    
      
        
<script src="/js/insert_highlight.js" data-pjax></script>

        
      
    
    
      <script type="module" data-pjax>
        const PhotoSwipeLightbox = (await safeImport("https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe-lightbox.esm.min.js", "sha384-DiL6M/gG+wmTxmCRZyD1zee6lIhawn5TGvED0FOh7fXcN9B0aZ9dexSF/N6lrZi/")).default;
        
        const pswp = () => {
          if (_$$('.article-entry a.article-gallery-item').length > 0) {
            new PhotoSwipeLightbox({
              gallery: '.article-entry',
              children: 'a.article-gallery-item',
              pswpModule: () => safeImport("https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8+oTJ7m3DfYEWX1fu1scuS4+s")
            }).init();
          }
          if(_$$('.article-gallery a.article-gallery-item').length > 0) {
            new PhotoSwipeLightbox({
              gallery: '.article-gallery',
              children: 'a.article-gallery-item',
              pswpModule: () => safeImport("https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8+oTJ7m3DfYEWX1fu1scuS4+s")
            }).init();
          }
          window.lightboxStatus = 'done';
          window.removeEventListener('lightbox:ready', pswp);
        }
        if(window.lightboxStatus === 'ready') {
          pswp()
        } else {
          window.addEventListener('lightbox:ready', pswp);
        }
      </script>
      
        








      
    
  </div>
</div>


  <script>
    console.log(String.raw`%c 
 ______     ______     __     __    __     __  __    
/\  == \   /\  ___\   /\ \   /\ "-./  \   /\ \/\ \   
\ \  __<   \ \  __\   \ \ \  \ \ \-./\ \  \ \ \_\ \  
 \ \_\ \_\  \ \_____\  \ \_\  \ \_\ \ \_\  \ \_____\ 
  \/_/ /_/   \/_____/   \/_/   \/_/  \/_/   \/_____/ 
                                                  
`,'color: #ff5252;')
    console.log('%c Theme.Reimu v' + '1.9.0' + ' %c https://github.com/D-Sketon/hexo-theme-reimu ', 'color: white; background: #ff5252; padding:5px 0;', 'padding:4px;border:1px solid #ff5252;')
  </script>
  



  
<script src="https://npm.webcache.cn/busuanzi@2.3.0/bsz.pure.mini.js" integrity="sha384-0M75wtSkhjIInv4coYlaJU83+OypaRCIq2SukQVQX04eGTCBXJDuWAbJet56id+S" crossorigin="anonymous" async></script>




<script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.getRegistrations().then((registrations) => {
      for (let registration of registrations) {
        registration.unregister();
      }
    });
  }
</script>









    
  </body>
  </html>

