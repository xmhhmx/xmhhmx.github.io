
  <!DOCTYPE html>
  <html lang="en"  
    
      data-theme-mode="auto"
    
  >
  <head>
  
  <meta charset="utf-8">
  

  

  

  <script>window.REIMU_CONFIG = {};window.REIMU_CONFIG.icon_font = '4552607_0khxww3tj3q9';window.REIMU_CONFIG.clipboard_tips = {"success":{"zh-CN":"复制成功","en":"复制成功","zh-TW":"複製成功 (*^▽^*)","ja":"コピー成功 (*^▽^*)"},"fail":{"zh-CN":"复制失败","en":"复制失败","zh-TW":"複製失敗 (ﾟ⊿ﾟ)ﾂ","ja":"コピー失敗 (ﾟ⊿ﾟ)ﾂ"},"copyright":{"enable":false,"count":50,"license_type":"by-nc-sa"}};window.REIMU_CONFIG.clipboard_tips.copyright.content = 'All articles on this blog are licensed under the BY-NC-SA license agreement unless otherwise stated. Please indicate the source when reprinting!';window.REIMU_CONFIG.code_block = {"expand":true};window.REIMU_CONFIG.base = 'http://example.com';</script>
  
  <title>
    CryptoZombiesx的solidity学习 |
    
    mX1@0_blog
  </title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
  
    <link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin><link rel="preload" as="style" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic&display=swap"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic&display=swap" media="print" onload="this.media&#x3D;&#39;all&#39;">
  
  
    <link rel="preload" href="//at.alicdn.com/t/c/font_4552607_0khxww3tj3q9.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  
  
    
<link rel="stylesheet" href="/css/loader.css">

  
  
    <meta name="description" content="CryptoZombiesx的solidity学习Solidity: Beginner to Intermediate Smart Contractslesson1 搭建僵尸工厂第2章: 合约从最基本的开始入手: Solidity 的代码都包裹在合约里面. 一份合约就是以太应币应用的基本模块， 所有的变量和函数都属于一份合约, 它是你所有应用的起点. 一份名为 HelloWorld 的空合约如下:">
<meta property="og:type" content="article">
<meta property="og:title" content="CryptoZombiesx的solidity学习">
<meta property="og:url" content="http://example.com/2025/08/10/cryptozombiesx-de-solidity-xue-xi/index.html">
<meta property="og:site_name" content="mX1@0_blog">
<meta property="og:description" content="CryptoZombiesx的solidity学习Solidity: Beginner to Intermediate Smart Contractslesson1 搭建僵尸工厂第2章: 合约从最基本的开始入手: Solidity 的代码都包裹在合约里面. 一份合约就是以太应币应用的基本模块， 所有的变量和函数都属于一份合约, 它是你所有应用的起点. 一份名为 HelloWorld 的空合约如下:">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-08-10T15:38:00.671Z">
<meta property="article:modified_time" content="2025-08-11T17:12:23.904Z">
<meta property="article:author" content="mX1@0">
<meta name="twitter:card" content="summary">
  
  
  
    <link rel="shortcut icon" href="/images/%E5%9B%BE1.jpg">
  
  
<link rel="stylesheet" href="/css/style.css">

  <link rel="preload" as="style" onload="this.onload&#x3D;null;this.rel&#x3D;&#39;stylesheet&#39;" href="https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.css" integrity="sha384-IfxC36XL&#x2F;toUyJ939C73PcgMuRzAZuIzZxE38drsmO5p6jD7ei+Zx&#x2F;1oA&#x2F;0l8ysE" crossorigin="anonymous">
  
  
  
  
    
<script src="https://npm.webcache.cn/pace-js@1.2.4/pace.min.js" integrity="sha384-k6YtvFUEIuEFBdrLKJ3YAUbBki333tj1CSUisai5Cswsg9wcLNaPzsTHDswp4Az8" crossorigin="anonymous"></script>

  
  
    
<link rel="stylesheet" href="https://npm.webcache.cn/@reimujs/aos@0.1.0/dist/aos.css" integrity="sha384-4NN3fZ5AokFyHuoihl7A9qWaCt+HsAtOaUsXwJGRb4&#x2F;SMBtFr2vcNSHR5E8dg0Wk" crossorigin="anonymous">

  
  
  
<meta name="generator" content="Hexo 7.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>

  <body>
    
    
  <div id='loader'>
    <div class="loading-left-bg loading-bg"></div>
    <div class="loading-right-bg loading-bg"></div>
    <div class="spinner-box">
      <div class="loading-taichi rotate">
        
          <svg width="150" height="150" viewBox="0 0 1024 1024" class="icon" version="1.1" xmlns="https://www.w3.org/2000/svg" shape-rendering="geometricPrecision">
            <path d="M303.5 432A80 80 0 0 1 291.5 592A80 80 0 0 1 303.5 432z" fill="var(--red-1, #ff5252)" />
            <path d="M512 65A447 447 0 0 1 512 959L512 929A417 417 0 0 0 512 95A417 417 0 0 0 512 929L512 959A447 447 0 0 1 512 65z 
           M512 95A417 417 0 0 1 929 512A208.5 208.5 0 0 1 720.5 720.5L720.5 592A80 80 0 0 0 720.5 432A80 80 0 0 0 720.5 592L720.5 720.5A208.5 208.5 0 0 1 512 512A208.5 208.5 0 0 0 303.5 303.5A208.5 208.5 0 0 0 95 512A417 417 0 0 1 512 95z" fill="var(--red-1, #ff5252)" />
          </svg>
        
      </div>
      
      
        
      
      <div class="loading-word">加载中...</div>
    </div>
  </div>
  </div>
  <script>
    var time = null;
    var startLoading = () => {
      time = Date.now();
      document.getElementById('loader').classList.remove("loading");
    }
    var endLoading = () => {
      if (!time) {
        document.body.style.overflow = 'auto';
        document.getElementById('loader').classList.add("loading");
      } else {
        if (Date.now() - time > 500) {
          time = null;
          document.body.style.overflow = 'auto';
          document.getElementById('loader').classList.add("loading");
        } else {
          setTimeout(endLoading, 500 - (Date.now() - time));
          time = null;
        }
      }
    }
    window.addEventListener('DOMContentLoaded', endLoading);
    document.getElementById('loader').addEventListener('click', endLoading);
  </script>

<div id="copy-tooltip" style="pointer-events: none; opacity: 0; transition: all 0.2s ease; position: fixed;top: 50%;left: 50%;z-index: 999;transform: translate(-50%, -50%);color: white;background: rgba(0, 0, 0, 0.5);padding: 10px 15px;border-radius: 10px;">
</div>
<div id="heatmap-tooltip"></div>


    <div id="container">
      <div id="wrap">
        <div id="header-nav">
  <nav id="main-nav">
    
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
             
              &#xe62b;
             
          </div>
          <a class="main-nav-link" href="/">首页</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
             
              &#xe62b;
             
          </div>
          <a class="main-nav-link" href="/archives">归类</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
             
              &#xe62b;
             
          </div>
          <a class="main-nav-link" href="/about">关于</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
             
              &#xe62b;
             
          </div>
          <a class="main-nav-link" href="/friend">友链</a>
        </span>
      
    
    <a id="main-nav-toggle" class="nav-icon"></a>
  </nav>
  <nav id="sub-nav">
    
    
    
  </nav>
  
</div>
<header id="header">
  
    
      
        <picture>
          
        </picture>
        
          <img  fetchpriority="high" src="/images/%E7%8E%9B%E8%8E%8E%E6%8B%89%E8%92%82.jpg" alt="CryptoZombiesx的solidity学习">
        
      
    
  
  <div id="header-outer">
    <div id="header-title">
      
        
        
          <a href="/" id="logo">
            <h1 data-aos="slide-up">CryptoZombiesx的solidity学习</h1>
          </a>
        
      
      
        
        <h2 id="subtitle-wrap" data-aos="slide-down">
          
        </h2>
      
    </div>
  </div>
</header>

        <div id="content" class="sidebar-left"  >
          <aside id="sidebar">
  
  
  
  <div class="sidebar-wrapper wrap-sticky">
    <div class="sidebar-wrap" data-aos="fade-up">
      
        
          <div class="sidebar-toc-sidebar"><div class="sidebar-toc">
  <h3 class="toc-title">Contents</h3>
  <div class="sidebar-toc-wrapper toc-div-class" >
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#CryptoZombiesx%E7%9A%84solidity%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.</span> <span class="toc-text">CryptoZombiesx的solidity学习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Solidity-Beginner-to-Intermediate-Smart-Contracts"><span class="toc-number">1.1.</span> <span class="toc-text">Solidity: Beginner to Intermediate Smart Contracts</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lesson1-%E6%90%AD%E5%BB%BA%E5%83%B5%E5%B0%B8%E5%B7%A5%E5%8E%82"><span class="toc-number">1.2.</span> <span class="toc-text">lesson1 搭建僵尸工厂</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E5%90%88%E7%BA%A6"><span class="toc-number">1.2.1.</span> <span class="toc-text">第2章: 合约</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B4%E6%95%B0"><span class="toc-number">1.2.2.</span> <span class="toc-text">第3章: 状态变量和整数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97"><span class="toc-number">1.2.3.</span> <span class="toc-text">第4章: 数学运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.2.4.</span> <span class="toc-text">第5章: 结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E6%95%B0%E7%BB%84"><span class="toc-number">1.2.5.</span> <span class="toc-text">第6章: 数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.6.</span> <span class="toc-text">第7章: 定义函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-number">1.2.7.</span> <span class="toc-text">第8章: 使用结构体和数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-%E7%A7%81%E6%9C%89-%E5%85%AC%E5%85%B1%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.8.</span> <span class="toc-text">第9章: 私有 &#x2F; 公共函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-%E5%87%BD%E6%95%B0%E7%9A%84%E6%9B%B4%E5%A4%9A%E5%B1%9E%E6%80%A7"><span class="toc-number">1.2.9.</span> <span class="toc-text">第10章: 函数的更多属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-Keccak256-%E5%92%8C-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.2.10.</span> <span class="toc-text">第11章: Keccak256 和 类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-%E6%94%BE%E5%9C%A8%E4%B8%80%E8%B5%B7"><span class="toc-number">1.2.11.</span> <span class="toc-text">第12章: 放在一起</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.2.12.</span> <span class="toc-text">第13章: 事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-Web3-js"><span class="toc-number">1.2.13.</span> <span class="toc-text">第14章: Web3.js</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lesson2-%E5%83%B5%E5%B0%B8%E6%94%BB%E5%87%BB%E4%BA%BA%E7%B1%BB"><span class="toc-number">1.3.</span> <span class="toc-text">lesson2 僵尸攻击人类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E6%98%A0%E5%B0%84%EF%BC%88Mapping%EF%BC%89%E5%92%8C%E5%9C%B0%E5%9D%80%EF%BC%88Address%EF%BC%89"><span class="toc-number">1.3.1.</span> <span class="toc-text">第2章: 映射（Mapping）和地址（Address）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-Msg-sender"><span class="toc-number">1.3.2.</span> <span class="toc-text">第3章: Msg.sender</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-Require"><span class="toc-number">1.3.3.</span> <span class="toc-text">第4章: Require</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E7%BB%A7%E6%89%BF%EF%BC%88Inheritance%EF%BC%89"><span class="toc-number">1.3.4.</span> <span class="toc-text">第5章: 继承（Inheritance）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E5%BC%95%E5%85%A5%EF%BC%88Import%EF%BC%89"><span class="toc-number">1.3.5.</span> <span class="toc-text">第6章: 引入（Import）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-Storage%E4%B8%8EMemory"><span class="toc-number">1.3.6.</span> <span class="toc-text">第7章: Storage与Memory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E5%83%B5%E5%B0%B8%E7%9A%84DNA"><span class="toc-number">1.3.7.</span> <span class="toc-text">第8章: 僵尸的DNA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-%E6%9B%B4%E5%A4%9A%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">1.3.8.</span> <span class="toc-text">第9章: 更多关于函数可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-%E5%83%B5%E5%B0%B8%E5%90%83%E4%BB%80%E4%B9%88"><span class="toc-number">1.3.9.</span> <span class="toc-text">第10章: 僵尸吃什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.3.10.</span> <span class="toc-text">第11章: 使用接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-%E5%A4%84%E7%90%86%E5%A4%9A%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.3.11.</span> <span class="toc-text">第12章: 处理多返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-%E5%A5%96%E5%8A%B1-Kitty-%E5%9F%BA%E5%9B%A0"><span class="toc-number">1.3.12.</span> <span class="toc-text">第13章: 奖励: Kitty 基因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-%E6%94%BE%E5%9C%A8%E4%B8%80%E8%B5%B7"><span class="toc-number">1.3.13.</span> <span class="toc-text">第14章: 放在一起</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lesson3-%E9%AB%98%E7%BA%A7-Solidity-%E7%90%86%E8%AE%BA"><span class="toc-number">1.4.</span> <span class="toc-text">lesson3 高级 Solidity 理论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-%E6%99%BA%E8%83%BD%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%B0%B8%E5%9B%BA%E6%80%A7"><span class="toc-number">1.4.1.</span> <span class="toc-text">第1章: 智能协议的永固性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-Ownable-Contracts"><span class="toc-number">1.4.2.</span> <span class="toc-text">第2章: Ownable Contracts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-onlyOwner-%E5%87%BD%E6%95%B0%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">1.4.3.</span> <span class="toc-text">第3章: onlyOwner 函数修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-Gas"><span class="toc-number">1.4.4.</span> <span class="toc-text">第4章: Gas</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E6%97%B6%E9%97%B4%E5%8D%95%E4%BD%8D"><span class="toc-number">1.4.5.</span> <span class="toc-text">第5章: 时间单位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E5%83%B5%E5%B0%B8%E5%86%B7%E5%8D%B4"><span class="toc-number">1.4.6.</span> <span class="toc-text">第6章: 僵尸冷却</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-%E5%85%AC%E6%9C%89%E5%87%BD%E6%95%B0%E5%92%8C%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">1.4.7.</span> <span class="toc-text">第7章: 公有函数和安全性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%87%BD%E6%95%B0%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">1.4.8.</span> <span class="toc-text">第8章: 进一步了解函数修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-%E5%83%B5%E5%B0%B8%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">1.4.9.</span> <span class="toc-text">第9章: 僵尸修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-%E5%88%A9%E7%94%A8-%E2%80%98View%E2%80%99-%E5%87%BD%E6%95%B0%E8%8A%82%E7%9C%81-Gas"><span class="toc-number">1.4.10.</span> <span class="toc-text">第10章: 利用 ‘View’ 函数节省 Gas</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-%E5%AD%98%E5%82%A8%E9%9D%9E%E5%B8%B8%E6%98%82%E8%B4%B5"><span class="toc-number">1.4.11.</span> <span class="toc-text">第11章: 存储非常昂贵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-For-%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.4.12.</span> <span class="toc-text">第12章: For 循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-%E6%94%BE%E5%9C%A8%E4%B8%80%E8%B5%B7"><span class="toc-number">1.4.13.</span> <span class="toc-text">第13章: 放在一起</span></a></li></ol></li></ol></li></ol>
      
  </div>
</div>
</div>
          <div class="sidebar-common-sidebar hidden"><div class="sidebar-author">
  <img data-src="/avatar/avatar.webp" data-sizes="auto" alt="mX1@0" class="lazyload">
  <div class="sidebar-author-name">mX1@0</div>
  <div class="sidebar-description"></div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>Post</div>
    <div class="sidebar-state-number">63</div>
  </div>
  <div class="sidebar-state-category">
    <div>Category</div>
    <div class="sidebar-state-number">18</div>
  </div>
  <div class="sidebar-state-tag">
    <div>Tag</div>
    <div class="sidebar-state-number">24</div>
  </div>
</div>
<div class="sidebar-social">
  
    <div class="icon-twitter sidebar-social-icon">
      <a href=https://x.com/0xMx1a0 itemprop="url" target="_blank" aria-label="twitter" rel="noopener external nofollow noreferrer"></a>
    </div>
  
</div>
<div class="sidebar-menu">
  
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/" aria-label="首页"></a>
        <div class="sidebar-menu-icon icon rotate">
          
            &#xe62b;
          
        </div>
        <div class="sidebar-menu-link">首页</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/archives" aria-label="归类"></a>
        <div class="sidebar-menu-icon icon rotate">
          
            &#xe62b;
          
        </div>
        <div class="sidebar-menu-link">归类</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/about" aria-label="关于"></a>
        <div class="sidebar-menu-icon icon rotate">
          
            &#xe62b;
          
        </div>
        <div class="sidebar-menu-link">关于</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/friend" aria-label="友链"></a>
        <div class="sidebar-menu-icon icon rotate">
          
            &#xe62b;
          
        </div>
        <div class="sidebar-menu-link">友链</div>
      </div>
    
  
</div>
</div>
        
      
      
        
          <div class="sidebar-btn-wrapper" style="position:static">
            <div class="sidebar-toc-btn current"></div>
            <div class="sidebar-common-btn"></div>
          </div>
        
      
    </div>
  </div>

  <div class="sidebar-widget">
  
  </div>
  
</aside>

          <section id="main"><article id="post-CryptoZombiesx的solidity学习" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner" data-aos="fade-up">
    <div class="article-meta">
      <div class="article-date">
  <span class="article-date-link" data-aos="zoom-in">
    <time datetime="2025-08-10T15:38:00.671Z" itemprop="datePublished">2025-08-10</time>
    <time style="display: none;" id="post-update-time">2025-08-12</time>
  </span>
</div>

      

    </div>
    <div class="hr-line"></div>
    

    <div class="e-content article-entry" itemprop="articleBody">
      
      
        <h1 id="CryptoZombiesx的solidity学习"><a href="#CryptoZombiesx的solidity学习" class="headerlink" title="CryptoZombiesx的solidity学习"></a>CryptoZombiesx的solidity学习</h1><h2 id="Solidity-Beginner-to-Intermediate-Smart-Contracts"><a href="#Solidity-Beginner-to-Intermediate-Smart-Contracts" class="headerlink" title="Solidity: Beginner to Intermediate Smart Contracts"></a>Solidity: Beginner to Intermediate Smart Contracts</h2><h2 id="lesson1-搭建僵尸工厂"><a href="#lesson1-搭建僵尸工厂" class="headerlink" title="lesson1 搭建僵尸工厂"></a>lesson1 搭建僵尸工厂</h2><h3 id="第2章-合约"><a href="#第2章-合约" class="headerlink" title="第2章: 合约"></a>第2章: 合约</h3><p>从最基本的开始入手:</p>
<p>Solidity 的代码都包裹在<strong>合约</strong>里面. 一份<code>合约</code>就是以太应币应用的基本模块， 所有的变量和函数都属于一份合约, 它是你所有应用的起点.</p>
<p>一份名为 <code>HelloWorld</code> 的空合约如下:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract HelloWorld {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>版本指令</strong></p>
<p>所有的 Solidity 源码都必须冠以 “version pragma” — 标明 Solidity 编译器的版本. 以避免将来新的编译器可能破坏你的代码。</p>
<p>例如: <code>pragma solidity ^0.4.19;</code> (当前 Solidity 的最新版本是 0.4.19).</p>
<p>综上所述， 下面就是一个最基本的合约 — 每次建立一个新的项目时的第一段代码:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract HelloWorld {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实战演习</strong></p>
<p>为了建立我们的僵尸部队， 让我们先建立一个基础合约，称为 <code>ZombieFactory</code>。</p>
<ol>
<li>在右边的输入框里输入 <code>0.4.19</code>，我们的合约基于这个版本的编译器。</li>
<li>建立一个空合约 <code>ZombieFactory</code>。</li>
</ol>
<p>一切完毕，点击下面 “答案” . 如果没效果，点击 “提示”。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第3章-状态变量和整数"><a href="#第3章-状态变量和整数" class="headerlink" title="第3章: 状态变量和整数"></a>第3章: 状态变量和整数</h3><p>真棒！我们已经为我们的合约做了一个外壳， 下面学习 Solidity 中如何使用变量。</p>
<p><strong>状态变量</strong>是被永久地保存在合约中。也就是说它们被写入以太币区块链中. 想象成写入一个数据库。</p>
<p>例子:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">contract Example {</span><br><span class="line">  // 这个无符号整数将会永久的被保存在区块链中</span><br><span class="line">  uint myUnsignedInteger = 100;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在上面的例子中，定义 <code>myUnsignedInteger</code> 为 <code>uint</code> 类型，并赋值100。</p>
<p><strong>无符号整数: <code>uint</code></strong></p>
<p><code>uint</code> 无符号数据类型， 指<strong>其值不能是负数</strong>，对于有符号的整数存在名为 <code>int</code> 的数据类型。</p>
<blockquote>
<p>注: Solidity中， <code>uint</code> 实际上是 <code>uint256</code>代名词， 一个256位的无符号整数。你也可以定义位数少的uints — <code>uint8</code>， <code>uint16</code>， <code>uint32</code>， 等…… 但一般来讲你愿意使用简单的 <code>uint</code>， 除非在某些特殊情况下，这我们后面会讲。</p>
</blockquote>
<p><strong>实战演习</strong></p>
<p>我们的僵尸DNA将由一个十六位数字组成。</p>
<p>定义 <code>dnaDigits</code> 为 <code>uint</code> 数据类型, 并赋值 <code>16</code>。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第4章-数学运算"><a href="#第4章-数学运算" class="headerlink" title="第4章: 数学运算"></a>第4章: 数学运算</h3><p>在 Solidity 中，数学运算很直观明了，与其它程序设计语言相同:</p>
<ul>
<li>加法: <code>x + y</code></li>
<li>减法: <code>x - y</code>,</li>
<li>乘法: <code>x * y</code></li>
<li>除法: <code>x / y</code></li>
<li>取模 / 求余: <code>x % y</code> <em>(例如, <code>13 % 5</code> 余 <code>3</code>, 因为13除以5，余3)</em></li>
</ul>
<p>Solidity 还支持 *<strong>乘方操作*</strong> (如：x 的 y次方） // 例如： 5 ** 2 = 25</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint x = 5 ** 2; // equal to 5^2 = 25</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实战演习</strong></p>
<p>为了保证我们的僵尸的DNA只含有16个字符，我们先造一个<code>uint</code>数据，让它等于10^16。这样一来以后我们可以用模运算符 <code>%</code> 把一个整数变成16位。</p>
<ol>
<li>建立一个<code>uint</code>类型的变量，名字叫<code>dnaModulus</code>, 令其等于 <strong>10 的 <code>dnaDigits</code> 次方</strong>.</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第5章-结构体"><a href="#第5章-结构体" class="headerlink" title="第5章: 结构体"></a>第5章: 结构体</h3><p>有时你需要更复杂的数据类型，Solidity 提供了 <strong>结构体</strong>:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct Person {</span><br><span class="line">  uint age;</span><br><span class="line">  string name;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>结构体允许你生成一个更复杂的数据类型，它有多个属性。</p>
<blockquote>
<p>注：我们刚刚引进了一个新类型, <code>string</code>。 字符串用于保存任意长度的 UTF-8 编码数据。 如： <code>string greeting = "Hello world!"</code>。</p>
</blockquote>
<p><strong>实战演习</strong></p>
<p>在我们的程序中，我们将创建一些僵尸！每个僵尸将拥有多个属性，所以这是一个展示结构体的完美例子。</p>
<ol>
<li>建立一个<code>struct</code> 命名为 <code>Zombie</code>.</li>
<li>我们的 <code>Zombie</code> 结构体有两个属性： <code>name</code> (类型为 <code>string</code>), 和 <code>dna</code> (类型为 <code>uint</code>)。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第6章-数组"><a href="#第6章-数组" class="headerlink" title="第6章: 数组"></a>第6章: 数组</h3><p>如果你想建立一个集合，可以用 <strong>数组</strong>这样的数据类型. Solidity 支持两种数组: <strong>静态</strong>数组和<strong>动态</strong>数组:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 固定长度为2的静态数组:</span><br><span class="line">uint[2] fixedArray;</span><br><span class="line">// 固定长度为5的string类型的静态数组:</span><br><span class="line">string[5] stringArray;</span><br><span class="line">// 动态数组，长度不固定，可以动态添加元素:</span><br><span class="line">uint[] dynamicArray;</span><br></pre></td></tr></tbody></table></figure>

<p>你也可以建立一个 <strong>结构体</strong>类型的数组 例如，上一章提到的 <code>Person</code>:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person[] people; // 这是动态数组，我们可以不断添加元素</span><br></pre></td></tr></tbody></table></figure>

<p>记住：状态变量被永久保存在区块链中。所以在你的合约中创建动态数组来保存成结构的数据是非常有意义的。</p>
<p><strong>公共数组</strong></p>
<p>你可以定义 <code>public</code> 数组, Solidity 会自动创建 <strong>getter</strong> 方法. 语法如下:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person[] public people;</span><br></pre></td></tr></tbody></table></figure>

<p>其它的合约可以从这个数组读取数据（但不能写入数据），所以这在合约中是一个有用的保存公共数据的模式。</p>
<p><strong>实战演习</strong></p>
<p>为了把一个僵尸部队保存在我们的APP里，并且能够让其它APP看到这些僵尸，我们需要一个公共数组。</p>
<ol>
<li>创建一个数据类型为 <code>Zombie</code> 的结构体数组，用 <code>public</code> 修饰，命名为：<code>zombies</code>.</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第7章-定义函数"><a href="#第7章-定义函数" class="headerlink" title="第7章: 定义函数"></a>第7章: 定义函数</h3><p>在 Solidity 中函数定义的句法如下:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function eatHamburgers(string _name, uint _amount) {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这是一个名为 <code>eatHamburgers</code> 的函数，它接受两个参数：一个 <code>string</code>类型的 和 一个 <code>uint</code>类型的。现在函数内部还是空的。</p>
<blockquote>
<p>注：: 习惯上函数里的变量都是以(<code>_</code>)开头 (但不是硬性规定) 以区别全局变量。我们整个教程都会沿用这个习惯。</p>
</blockquote>
<p>我们的函数定义如下:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eatHamburgers("vitalik", 100);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实战演习</strong></p>
<p>在我们的应用里，我们要能创建一些僵尸，让我们写一个函数做这件事吧！</p>
<ol>
<li>建立一个函数 <code>createZombie</code>。 它有两个参数: <strong>_name</strong> (类型为<code>string</code>), 和 <strong>_dna</strong> (类型为<code>uint</code>)。</li>
</ol>
<p>暂时让函数空着——我们在后面会增加内容。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    function createZombie(string _name, uint _dna) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第8章-使用结构体和数组"><a href="#第8章-使用结构体和数组" class="headerlink" title="第8章: 使用结构体和数组"></a>第8章: 使用结构体和数组</h3><p><strong>创建新的结构体</strong></p>
<p>还记得上个例子中的 <code>Person</code> 结构吗？</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Person {</span><br><span class="line">  uint age;</span><br><span class="line">  string name;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Person[] public people;</span><br></pre></td></tr></tbody></table></figure>

<p>现在我们学习创建新的 <code>Person</code> 结构，然后把它加入到名为 <code>people</code> 的数组中.</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个新的Person:</span><br><span class="line">Person satoshi = Person(172, "Satoshi");</span><br><span class="line"></span><br><span class="line">// 将新创建的satoshi添加进people数组:</span><br><span class="line">people.push(satoshi);</span><br></pre></td></tr></tbody></table></figure>

<p>你也可以两步并一步，用一行代码更简洁:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">people.push(Person(16, "Vitalik"));</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注：<code>array.push()</code> 在数组的 <strong>尾部</strong> 加入新元素 ，所以元素在数组中的顺序就是我们添加的顺序， 如:</p>
</blockquote>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uint[] numbers;</span><br><span class="line">numbers.push(5);</span><br><span class="line">numbers.push(10);</span><br><span class="line">numbers.push(15);</span><br><span class="line">// The `numbers` array is now equal to [5, 10, 15]</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实战演习</strong></p>
<p>让我们创建名为createZombie的函数来做点儿什么吧。</p>
<ol>
<li>在函数体里新创建一个 <code>Zombie</code>， 然后把它加入 <code>zombies</code> 数组中。 新创建的僵尸的 <code>name</code> 和 <code>dna</code>，来自于函数的参数。</li>
<li>让我们用一行代码简洁地完成它。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    function createZombie(string _name, uint _dna) {</span><br><span class="line">        zombies.push(Zombie(_name, _dna));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第9章-私有-公共函数"><a href="#第9章-私有-公共函数" class="headerlink" title="第9章: 私有 / 公共函数"></a>第9章: 私有 / 公共函数</h3><p>Solidity 定义的函数的属性默认为<code>公共</code>。 这就意味着任何一方 (或其它合约) 都可以调用你合约里的函数。</p>
<p>显然，不是什么时候都需要这样，而且这样的合约易于受到攻击。 所以将自己的函数定义为<code>私有</code>是一个好的编程习惯，只有当你需要外部世界调用它时才将它设置为<code>公共</code>。</p>
<p>如何定义一个私有的函数呢？</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uint[] numbers;</span><br><span class="line"></span><br><span class="line">function _addToArray(uint _number) private {</span><br><span class="line">  numbers.push(_number);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这意味着只有我们合约中的其它函数才能够调用这个函数，给 <code>numbers</code> 数组添加新成员。</p>
<p>可以看到，在**<u>函数名字后面使用关键字 <code>private</code> 即可</u><strong>。</strong><u>和函数的参数类似，私有函数的名字用(<code>_</code>)起始。</u>**</p>
<p><strong>实战演习</strong></p>
<p>我们合约的函数 <code>createZombie</code> 的默认属性是公共的，这意味着任何一方都可以调用它去创建一个僵尸。 咱们来把它变成私有吧！</p>
<ol>
<li>变 <code>createZombie</code> 为私有函数，不要忘记遵守命名的规矩哦！</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    function _createZombie(string _name, uint _dna) private {</span><br><span class="line">        zombies.push(Zombie(_name, _dna));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第10章-函数的更多属性"><a href="#第10章-函数的更多属性" class="headerlink" title="第10章: 函数的更多属性"></a>第10章: 函数的更多属性</h3><p>本章中我们将学习函数的返回值和修饰符。</p>
<p><strong>返回值</strong></p>
<p>要想函数返回一个数值，按如下定义：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string greeting = "What's up dog";</span><br><span class="line"></span><br><span class="line">function sayHello() public returns (string) {</span><br><span class="line">  return greeting;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Solidity 里，函数的定义里可包含返回值的数据类型(如本例中 <code>string</code>)。</p>
<p><strong>函数的修饰符</strong></p>
<p>上面的函数实际上没有改变 Solidity 里的状态，即，它没有改变任何值或者写任何东西。</p>
<p>这种情况下我们可以把函数定义为 <strong>view</strong>, 意味着它只能读取数据不能更改数据:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function sayHello() public view returns (string) {</span><br></pre></td></tr></tbody></table></figure>

<p>Solidity 还支持 <strong>pure</strong> 函数, 表明这个函数甚至都不访问应用里的数据，例如：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function _multiply(uint a, uint b) private pure returns (uint) {</span><br><span class="line">  return a * b;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><u><strong>这个函数甚至都不读取应用里的状态 — 它的返回值完全取决于它的输入参数，在这种情况下我们把函数定义为 pure.</strong></u></p>
<blockquote>
<p>注：可能很难记住何时把函数标记为 pure/view。 幸运的是， Solidity 编辑器会给出提示，提醒你使用这些修饰符。</p>
</blockquote>
<p><strong>实战演习</strong></p>
<p>我们想建立一个帮助函数，它根据一个字符串随机生成一个DNA数据。</p>
<ol>
<li>创建一个 <code>private</code> 函数，命名为 <code>_generateRandomDna</code>。它只接收一个输入变量 <code>_str</code> (类型 <code>string</code>), 返回一个 <code>uint</code> 类型的数值。</li>
<li>此函数只读取我们合约中的一些变量，所以标记为<code>view</code>。</li>
<li>函数内部暂时留空，以后我们再添加代码。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    function _createZombie(string _name, uint _dna) private {</span><br><span class="line">        zombies.push(Zombie(_name, _dna));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function _generateRandomDna(string _str) private view returns (uint) {</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第11章-Keccak256-和-类型转换"><a href="#第11章-Keccak256-和-类型转换" class="headerlink" title="第11章: Keccak256 和 类型转换"></a>第11章: Keccak256 和 类型转换</h3><p>如何让 <code>_generateRandomDna</code> 函数返回一个全(半) 随机的 <code>uint</code>?</p>
<p>Ethereum 内部有一个散列函数<code>keccak256</code>，它用了SHA3版本。一个散列函数基本上就是把一个字符串转换为一个256位的16进制数字。字符串的一个微小变化会引起散列数据极大变化。</p>
<p>这在 Ethereum 中有很多应用，但是现在我们只是用它造一个伪随机数。</p>
<p>例子:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//6e91ec6b618bb462a4a6ee5aa2cb0e9cf30f7a052bb467b0ba58b8748c00d2e5</span><br><span class="line">keccak256("aaaab");</span><br><span class="line">//b1f078126895a1424524de5321b339ab00408010b7cf0e6ed451514981e58aa9</span><br><span class="line">keccak256("aaaac");</span><br></pre></td></tr></tbody></table></figure>

<p>显而易见，输入字符串只改变了一个字母，输出就已经天壤之别了。</p>
<blockquote>
<p>注: 在区块链中<strong>安全地</strong>产生一个随机数是一个很难的问题， 本例的方法不安全，但是在我们的Zombie DNA算法里不是那么重要，已经很好地满足我们的需要了。</p>
</blockquote>
<p><strong>类型转换</strong></p>
<p>有时你需要变换数据类型。例如:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">uint8 a = 5;</span><br><span class="line">uint b = 6;</span><br><span class="line">// 将会抛出错误，因为 a * b 返回 uint, 而不是 uint8:</span><br><span class="line">uint8 c = a * b;</span><br><span class="line">// 我们需要将 b 转换为 uint8:</span><br><span class="line">uint8 c = a * uint8(b);</span><br></pre></td></tr></tbody></table></figure>

<p>上面, <code>a * b</code> 返回类型是 <code>uint</code>, 但是当我们尝试用 <code>uint8</code> 类型接收时, 就会造成潜在的错误。如果把它的数据类型转换为 <code>uint8</code>, 就可以了，编译器也不会出错。</p>
<p><strong>实战演习</strong></p>
<p>给 <code>_generateRandomDna</code> 函数添加代码! 它应该完成如下功能:</p>
<ol>
<li>第一行代码取 <code>_str</code> 的 <code>keccak256</code> 散列值生成一个伪随机十六进制数，类型转换为 <code>uint</code>, 最后保存在类型为 <code>uint</code> 名为 <code>rand</code> 的变量中。</li>
<li>我们只想让我们的DNA的长度为16位 (还记得 <code>dnaModulus</code>?)。所以第二行代码应该 <code>return</code> 上面计算的数值对 <code>dnaModulus</code> 求余数(<code>%</code>)。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    function _createZombie(string _name, uint _dna) private {</span><br><span class="line">        zombies.push(Zombie(_name, _dna));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function _generateRandomDna(string _str) private view returns (uint) {</span><br><span class="line">        uint rand = uint(keccak256(_str));</span><br><span class="line">        return rand % dnaModulus;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第12章-放在一起"><a href="#第12章-放在一起" class="headerlink" title="第12章: 放在一起"></a>第12章: 放在一起</h3><p>我们就快完成我们的随机僵尸制造器了，来写一个公共的函数把所有的部件连接起来。</p>
<p>写一个公共函数，它有一个参数，用来接收僵尸的名字，之后用它生成僵尸的DNA。</p>
<p><strong>实战演习</strong></p>
<ol>
<li>创建一个 <code>public</code> 函数，命名为 <code>createRandomZombie</code>. 它将被传入一个变量 <code>_name</code> (数据类型是 <code>string</code>)。 *(注: 定义公共函数 <code>public</code> 和定义一个私有 <code>private</code> 函数的做法一样)*。</li>
<li>函数的第一行应该调用 <code>_generateRandomDna</code> 函数，传入 <code>_name</code> 参数, 结果保存在一个类型为 <code>uint</code> 的变量里，命名为 <code>randDna</code>。</li>
<li>第二行调用 <code>_createZombie</code> 函数， 传入参数： <code>_name</code> 和 <code>randDna</code>。</li>
<li>整个函数应该是4行代码 (包括函数的结束符号 <code>}</code> )。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line"></span><br><span class="line">    // 这里建立事件</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    function _createZombie(string _name, uint _dna) private {</span><br><span class="line">        zombies.push(Zombie(_name, _dna));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function _generateRandomDna(string _str) private view returns (uint) {</span><br><span class="line">        uint rand = uint(keccak256(_str));</span><br><span class="line">        return rand % dnaModulus;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function createRandomZombie(string _name) public {</span><br><span class="line">        uint randDna = _generateRandomDna(_name);</span><br><span class="line">        _createZombie(_name, randDna);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第13章-事件"><a href="#第13章-事件" class="headerlink" title="第13章: 事件"></a>第13章: 事件</h3><p>我们的合约几乎就要完成了！让我们加上一个<strong>事件</strong>.</p>
<p><strong>事件</strong> 是合约和区块链通讯的一种机制。你的前端应用“监听”某些事件，并做出反应。</p>
<p>例子:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 这里建立事件</span><br><span class="line">event IntegersAdded(uint x, uint y, uint result);</span><br><span class="line"></span><br><span class="line">function add(uint _x, uint _y) public {</span><br><span class="line">  uint result = _x + _y;</span><br><span class="line">  //触发事件，通知app</span><br><span class="line">  IntegersAdded(_x, _y, result);</span><br><span class="line">  return result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>你的 app 前端可以监听这个事件。JavaScript 实现如下:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YourContract.IntegersAdded(function(error, result) {</span><br><span class="line">  // 干些事</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实战演习</strong></p>
<p>我们想每当一个僵尸创造出来时，我们的前端都能监听到这个事件，并将它显示出来。</p>
<p>1。 定义一个 <code>事件</code> 叫做 <code>NewZombie</code>。 它有3个参数: <code>zombieId</code> (<code>uint</code>)， <code>name</code> (<code>string</code>)， 和 <code>dna</code> (<code>uint</code>)。</p>
<p>2。 修改 <code>_createZombie</code> 函数使得当新僵尸造出来并加入 <code>zombies</code>数组后，生成事件<code>NewZombie</code>。</p>
<p>3。 需要定义僵尸<code>id</code>。 <code>array.push()</code> 返回数组的长度类型是<code>uint</code> - 因为数组的第一个元素的索引是 0， <code>array.push() - 1</code> 将是我们加入的僵尸的索引。 <code>zombies.push() - 1</code> 就是 <code>id</code>，数据类型是 <code>uint</code>。在下一行中你可以把它用到 <code>NewZombie</code> 事件中。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line">	</span><br><span class="line">	// 这里建立事件</span><br><span class="line">    event NewZombie(uint zombieId, string name, uint dna);</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    function _createZombie(string _name, uint _dna) private {</span><br><span class="line">        uint id = zombies.push(Zombie(_name, _dna)) - 1;</span><br><span class="line">        //// 这里触发事件</span><br><span class="line">        NewZombie(id, _name, _dna);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function _generateRandomDna(string _str) private view returns (uint) {</span><br><span class="line">        uint rand = uint(keccak256(_str));</span><br><span class="line">        return rand % dnaModulus;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function createRandomZombie(string _name) public {</span><br><span class="line">        uint randDna = _generateRandomDna(_name);</span><br><span class="line">        _createZombie(_name, randDna);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第14章-Web3-js"><a href="#第14章-Web3-js" class="headerlink" title="第14章: Web3.js"></a>第14章: Web3.js</h3><p>我们的 Solidity 合约完工了！ 现在我们要写一段 JavaScript 前端代码来调用这个合约。</p>
<p>以太坊有一个 JavaScript 库，名为<strong>Web3.js</strong>。</p>
<p>在后面的课程里，我们会进一步地教你如何安装一个合约，如何设置Web3.js。 但是现在我们通过一段代码来了解 Web3.js 是如何和我们发布的合约交互的吧。</p>
<p>如果下面的代码你不能全都理解，不用担心。</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面是调用合约的方式:</span></span><br><span class="line"><span class="keyword">var</span> abi = <span class="comment">/* abi是由编译器生成的 */</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">ZombieFactoryContract</span> = web3.<span class="property">eth</span>.<span class="title function_">contract</span>(abi)</span><br><span class="line"><span class="keyword">var</span> contractAddress = <span class="comment">/* 发布之后在以太坊上生成的合约地址 */</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">ZombieFactory</span> = <span class="title class_">ZombieFactoryContract</span>.<span class="title function_">at</span>(contractAddress)</span><br><span class="line"><span class="comment">// `ZombieFactory` 能访问公共的函数以及事件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 某个监听文本输入的监听器:</span></span><br><span class="line">$(<span class="string">"#ourButton"</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params">e</span>) {</span><br><span class="line">  <span class="keyword">var</span> name = $(<span class="string">"#nameInput"</span>).<span class="title function_">val</span>()</span><br><span class="line">  <span class="comment">//调用合约的 `createRandomZombie` 函数:</span></span><br><span class="line">  <span class="title class_">ZombieFactory</span>.<span class="title function_">createRandomZombie</span>(name)</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听 `NewZombie` 事件, 并且更新UI</span></span><br><span class="line"><span class="keyword">var</span> event = <span class="title class_">ZombieFactory</span>.<span class="title class_">NewZombie</span>(<span class="keyword">function</span>(<span class="params">error, result</span>) {</span><br><span class="line">  <span class="keyword">if</span> (error) <span class="keyword">return</span></span><br><span class="line">  <span class="title function_">generateZombie</span>(result.<span class="property">zombieId</span>, result.<span class="property">name</span>, result.<span class="property">dna</span>)</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 Zombie 的 dna, 更新图像</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">generateZombie</span>(<span class="params">id, name, dna</span>) {</span><br><span class="line">  <span class="keyword">let</span> dnaStr = <span class="title class_">String</span>(dna)</span><br><span class="line">  <span class="comment">// 如果dna少于16位,在它前面用0补上</span></span><br><span class="line">  <span class="keyword">while</span> (dnaStr.<span class="property">length</span> &lt; <span class="number">16</span>)</span><br><span class="line">    dnaStr = <span class="string">"0"</span> + dnaStr</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> zombieDetails = {</span><br><span class="line">    <span class="comment">// 前两位数构成头部.我们可能有7种头部, 所以 % 7</span></span><br><span class="line">    <span class="comment">// 得到的数在0-6,再加上1,数的范围变成1-7</span></span><br><span class="line">    <span class="comment">// 通过这样计算：</span></span><br><span class="line">    <span class="attr">headChoice</span>: dnaStr.<span class="title function_">substring</span>(<span class="number">0</span>, <span class="number">2</span>) % <span class="number">7</span> + <span class="number">1</span>，</span><br><span class="line">    <span class="comment">// 我们得到的图片名称从head1.png 到 head7.png</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来的两位数构成眼睛, 眼睛变化就对11取模:</span></span><br><span class="line">    <span class="attr">eyeChoice</span>: dnaStr.<span class="title function_">substring</span>(<span class="number">2</span>, <span class="number">4</span>) % <span class="number">11</span> + <span class="number">1</span>,</span><br><span class="line">    <span class="comment">// 再接下来的两位数构成衣服，衣服变化就对6取模:</span></span><br><span class="line">    <span class="attr">shirtChoice</span>: dnaStr.<span class="title function_">substring</span>(<span class="number">4</span>, <span class="number">6</span>) % <span class="number">6</span> + <span class="number">1</span>,</span><br><span class="line">    <span class="comment">//最后6位控制颜色. 用css选择器: hue-rotate来更新</span></span><br><span class="line">    <span class="comment">// 360度:</span></span><br><span class="line">    <span class="attr">skinColorChoice</span>: <span class="built_in">parseInt</span>(dnaStr.<span class="title function_">substring</span>(<span class="number">6</span>, <span class="number">8</span>) / <span class="number">100</span> * <span class="number">360</span>),</span><br><span class="line">    <span class="attr">eyeColorChoice</span>: <span class="built_in">parseInt</span>(dnaStr.<span class="title function_">substring</span>(<span class="number">8</span>, <span class="number">10</span>) / <span class="number">100</span> * <span class="number">360</span>),</span><br><span class="line">    <span class="attr">clothesColorChoice</span>: <span class="built_in">parseInt</span>(dnaStr.<span class="title function_">substring</span>(<span class="number">10</span>, <span class="number">12</span>) / <span class="number">100</span> * <span class="number">360</span>),</span><br><span class="line">    <span class="attr">zombieName</span>: name,</span><br><span class="line">    <span class="attr">zombieDescription</span>: <span class="string">"A Level 1 CryptoZombie"</span>,</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> zombieDetails</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们的 JavaScript 所做的就是获取由<code>zombieDetails</code> 产生的数据, 并且利用浏览器里的 JavaScript 神奇功能 (我们用 Vue.js)，置换出图像以及使用CSS过滤器。在后面的课程中，你可以看到全部的代码。</p>
<h2 id="lesson2-僵尸攻击人类"><a href="#lesson2-僵尸攻击人类" class="headerlink" title="lesson2 僵尸攻击人类"></a>lesson2 僵尸攻击人类</h2><h3 id="第2章-映射（Mapping）和地址（Address）"><a href="#第2章-映射（Mapping）和地址（Address）" class="headerlink" title="第2章: 映射（Mapping）和地址（Address）"></a>第2章: 映射（Mapping）和地址（Address）</h3><p>我们通过给数据库中的僵尸指定“主人”， 来支持“多玩家”模式。</p>
<p>如此一来，我们需要引入2个新的数据类型：<code>mapping</code>（映射） 和 <code>address</code>（地址）。</p>
<p><strong>Addresses （地址）</strong></p>
<p>以太坊区块链由 <strong>_ account _</strong> (账户)组成，你可以把它想象成银行账户。一个帐户的余额是 <strong><em>以太</em></strong> （在以太坊区块链上使用的币种），你可以和其他帐户之间支付和接受以太币，就像你的银行帐户可以电汇资金到其他银行帐户一样。</p>
<p>每个帐户都有一个“地址”，你可以把它想象成银行账号。这是账户唯一的标识符，它看起来长这样：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0cE446255506E92DF41614C46F1d6df9Cc969183</span><br></pre></td></tr></tbody></table></figure>

<p>（这是 CryptoZombies 团队的地址，如果你喜欢 CryptoZombies 的话，请打赏我们一些以太币！😉）</p>
<p>我们将在后面的课程中介绍地址的细节，现在你只需要了解<strong>地址属于特定用户（或智能合约）的</strong>。</p>
<p>所以我们可以指定“地址”作为僵尸主人的 ID。当用户通过与我们的应用程序交互来创建新的僵尸时，新僵尸的所有权被设置到调用者的以太坊地址下。</p>
<p><strong>Mapping（映射）</strong></p>
<p>在第1课中，我们看到了 <strong>结构体</strong> 和 <strong>数组</strong> 。 <strong>映射</strong> 是另一种在 Solidity 中存储有组织数据的方法。</p>
<p>映射是这样定义的：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//对于金融应用程序，将用户的余额保存在一个 uint类型的变量中：</span><br><span class="line">mapping (address =&gt; uint) public accountBalance;</span><br><span class="line">//或者可以用来通过userId 存储/查找的用户名</span><br><span class="line">mapping (uint =&gt; string) userIdToName;</span><br></pre></td></tr></tbody></table></figure>

<p>映射本质上是存储和查找数据所用的<strong>键-值对</strong>。在第一个例子中，键是一个 <code>address</code>，值是一个 <code>uint</code>，在第二个例子中，键是一个<code>uint</code>，值是一个 <code>string</code>。</p>
<p><strong>实战演习</strong></p>
<p>为了存储僵尸的所有权，我们会使用到两个映射：一个记录僵尸拥有者的地址，另一个记录某地址所拥有僵尸的数量。</p>
<p>1.创建一个叫做 <code>zombieToOwner</code> 的映射。其键是一个<code>uint</code>（我们将根据它的 id 存储和查找僵尸），值为 <code>address</code>。映射属性为<code>public</code>。</p>
<p>2.创建一个名为 <code>ownerZombieCount</code> 的映射，其中键是 <code>address</code>，值是 <code>uint</code>。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 在这里定义映射</span><br><span class="line">mapping (uint =&gt; address ) public zombieToOwner;</span><br><span class="line">mapping ( address =&gt; uint) ownerZombieCount;</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第3章-Msg-sender"><a href="#第3章-Msg-sender" class="headerlink" title="第3章: Msg.sender"></a>第3章: Msg.sender</h3><p>现在有了一套映射来记录僵尸的所有权了，我们可以修改 <code>_createZombie</code> 方法来运用它们。</p>
<p>为了做到这一点，我们要用到 <code>msg.sender</code>。</p>
<p><strong>msg.sender</strong></p>
<p>在 Solidity 中，有一些全局变量可以被所有函数调用。 其中一个就是 <code>msg.sender</code>，它指的是当前调用者（或智能合约）的 <code>address</code>。</p>
<blockquote>
<p>注意：在 Solidity 中，功能执行始终需要从外部调用者开始。 一个合约只会在区块链上什么也不做，除非有人调用其中的函数。所以 <code>msg.sender</code>总是存在的。</p>
</blockquote>
<p>以下是使用 <code>msg.sender</code> 来更新 <code>mapping</code> 的例子：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mapping (address =&gt; uint) favoriteNumber;</span><br><span class="line"></span><br><span class="line">function setMyNumber(uint _myNumber) public {</span><br><span class="line">  // 更新我们的 `favoriteNumber` 映射来将 `_myNumber`存储在 `msg.sender`名下</span><br><span class="line">  favoriteNumber[msg.sender] = _myNumber;</span><br><span class="line">  // 存储数据至映射的方法和将数据存储在数组相似</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function whatIsMyNumber() public view returns (uint) {</span><br><span class="line">  // 拿到存储在调用者地址名下的值</span><br><span class="line">  // 若调用者还没调用 setMyNumber， 则值为 `0`</span><br><span class="line">  return favoriteNumber[msg.sender];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在这个小小的例子中，任何人都可以调用 <code>setMyNumber</code> 在我们的合约中存下一个 <code>uint</code> 并且与他们的地址相绑定。 然后，他们调用 <code>whatIsMyNumber</code> 就会返回他们存储的 <code>uint</code>。</p>
<p>使用 <code>msg.sender</code> 很安全，因为它具有以太坊区块链的安全保障 —— 除非窃取与以太坊地址相关联的私钥，否则是没有办法修改其他人的数据的。</p>
<p><strong>实战演习</strong></p>
<p>我们来修改第1课的 <code>_createZombie</code> 方法，将僵尸分配给函数调用者吧。</p>
<ol>
<li>首先，在得到新的僵尸 <code>id</code> 后，更新 <code>zombieToOwner</code> 映射，在 <code>id</code> 下面存入 <code>msg.sender</code>。</li>
<li>然后，我们为这个 <code>msg.sender</code> 名下的 <code>ownerZombieCount</code> 加 1。</li>
</ol>
<p>跟在 JavaScript 中一样， 在 Solidity 中你也可以用 <code>++</code> 使 <code>uint</code> 递增。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uint number = 0;</span><br><span class="line">number++;</span><br><span class="line">// `number` 现在是 `1`了</span><br></pre></td></tr></tbody></table></figure>

<p>修改两行代码即可。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function _createZombie(string _name, uint _dna) private {</span><br><span class="line">        uint id = zombies.push(Zombie(_name, _dna)) - 1;</span><br><span class="line">        // 从这里开始</span><br><span class="line">        zombieToOwner[id] = msg.sender;</span><br><span class="line">        ownerZombieCount[msg.sender]++;</span><br><span class="line">        NewZombie(id, _name, _dna);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第4章-Require"><a href="#第4章-Require" class="headerlink" title="第4章: Require"></a>第4章: Require</h3><p>在第一课中，我们成功让用户通过调用 <code>createRandomZombie</code>函数 并输入一个名字来创建新的僵尸。 但是，如果用户能持续调用这个函数来创建出无限多个僵尸加入他们的军团，这游戏就太没意思了！</p>
<p>于是，我们作出限定：每个玩家只能调用一次这个函数。 这样一来，新玩家可以在刚开始玩游戏时通过调用它，为其军团创建初始僵尸。</p>
<p>我们怎样才能限定每个玩家只调用一次这个函数呢？</p>
<p>答案是使用<code>require</code>。 <code>require</code>使得函数在执行过程中，当不满足某些条件时抛出错误，并停止执行：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function sayHiToVitalik(string _name) public returns (string) {</span><br><span class="line">  // 比较 _name 是否等于 "Vitalik". 如果不成立，抛出异常并终止程序</span><br><span class="line">  // (敲黑板: Solidity 并不支持原生的字符串比较, 我们只能通过比较</span><br><span class="line">  // 两字符串的 keccak256 哈希值来进行判断)</span><br><span class="line">  require(keccak256(_name) == keccak256("Vitalik"));</span><br><span class="line">  // 如果返回 true, 运行如下语句</span><br><span class="line">  return "Hi!";</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果你这样调用函数 <code>sayHiToVitalik（“Vitalik”）</code> ,它会返回“Hi！”。而如果调用的时候使用了其他参数，它则会抛出错误并停止执行。</p>
<p>因此，在调用一个函数之前，用 <code>require</code> 验证前置条件是非常有必要的。</p>
<p><strong>实战演习</strong></p>
<p>在我们的僵尸游戏中，我们不希望用户通过反复调用 <code>createRandomZombie</code> 来給他们的军队创建无限多个僵尸 —— 这将使得游戏非常无聊。</p>
<p>我们使用了 <code>require</code> 来确保这个函数只有在每个用户第一次调用它的时候执行，用以创建初始僵尸。</p>
<ol>
<li>在 <code>createRandomZombie</code> 的前面放置 <code>require</code> 语句。 使得函数先检查 <code>ownerZombieCount [msg.sender]</code> 的值为 <code>0</code> ，不然就抛出一个错误。</li>
</ol>
<blockquote>
<p>注意：在 Solidity 中，关键词放置的顺序并不重要</p>
<ul>
<li>虽然参数的两个位置是等效的。 但是，由于我们的答案检查器比较呆板，它只能认定其中一个为正确答案</li>
<li>于是在这里，我们就约定把<code>ownerZombieCount [msg.sender]</code>放前面吧</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function createRandomZombie(string _name) public {</span><br><span class="line">        // start here</span><br><span class="line">        require(ownerZombieCount[msg.sender] == 0);</span><br><span class="line">        uint randDna = _generateRandomDna(_name);</span><br><span class="line">        _createZombie(_name, randDna);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第5章-继承（Inheritance）"><a href="#第5章-继承（Inheritance）" class="headerlink" title="第5章: 继承（Inheritance）"></a>第5章: 继承（Inheritance）</h3><p>我们的游戏代码越来越长。 当代码过于冗长的时候，最好将代码和逻辑分拆到多个不同的合约中，以便于管理。</p>
<p>有个让 Solidity 的代码易于管理的功能，就是合约 *<strong>inheritance*</strong> (继承)：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract Doge {</span><br><span class="line">  function catchphrase() public returns (string) {</span><br><span class="line">    return "So Wow CryptoDoge";</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">contract BabyDoge is Doge {</span><br><span class="line">  function anotherCatchphrase() public returns (string) {</span><br><span class="line">    return "Such Moon BabyDoge";</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>由于 <code>BabyDoge</code> 是从 <code>Doge</code> 那里 *<strong>inherits*</strong> （继承)过来的。 这意味着当你编译和部署了 <code>BabyDoge</code>，它将可以访问 <code>catchphrase()</code> 和 <code>anotherCatchphrase()</code>和其他我们在 <code>Doge</code> 中定义的其他公共函数。</p>
<p>这可以用于逻辑继承（比如表达子类的时候，<code>Cat</code> 是一种 <code>Animal</code>）。 但也可以简单地将类似的逻辑组合到不同的合约中以组织代码。</p>
<p><strong>实战演习</strong></p>
<p>在接下来的章节中，我们将要为僵尸实现各种功能，让它可以“猎食”和“繁殖”。 通过将这些运算放到父类 <code>ZombieFactory</code> 中，使得所有 <code>ZombieFactory</code> 的继承者合约都可以使用这些方法。</p>
<ol>
<li>在 <code>ZombieFactory</code> 下创建一个叫 <code>ZombieFeeding</code> 的合约，它是继承自 `ZombieFactory 合约的。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Start here</span><br><span class="line">contract ZombieFeeding is ZombieFactory {</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第6章-引入（Import）"><a href="#第6章-引入（Import）" class="headerlink" title="第6章: 引入（Import）"></a>第6章: 引入（Import）</h3><p>哇！你有没有注意到，我们只是清理了下右边的代码，现在你的编辑器的顶部就多了个选项卡。 尝试点击它的标签，看看会发生什么吧！</p>
<p>代码已经够长了，我们把它分成多个文件以便于管理。 通常情况下，当 Solidity 项目中的代码太长的时候我们就是这么做的。</p>
<p>在 Solidity 中，当你有多个文件并且想把一个文件导入另一个文件时，可以使用 <code>import</code> 语句：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import "./someothercontract.sol";</span><br><span class="line"></span><br><span class="line">contract newContract is SomeOtherContract {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这样当我们在合约（contract）目录下有一个名为 <code>someothercontract.sol</code> 的文件（ <code>./</code> 就是同一目录的意思），它就会被编译器导入。</p>
<p><strong>实战演习</strong></p>
<p>现在我们已经建立了一个多文件架构，并用 <code>import</code> 来读取来自另一个文件中合约的内容：</p>
<p>1.将 <code>zombiefactory.sol</code> 导入到我们的新文件 <code>zombiefeeding.sol</code> 中。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// put import statement here</span><br><span class="line">import "./zombiefactory.sol";</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第7章-Storage与Memory"><a href="#第7章-Storage与Memory" class="headerlink" title="第7章: Storage与Memory"></a>第7章: Storage与Memory</h3><p>在 Solidity 中，有两个地方可以存储变量 —— <code>storage</code> 或 <code>memory</code>。</p>
<p><strong>Storage</strong> 变量是指**<u>永久存储</u><strong>在区块链中的变量。 <strong>Memory</strong> 变量则是</strong><u>临时的</u>**，当外部函数对某合约调用完成时，内存型变量即被移除。 你可以把它想象成存储在你电脑的硬盘或是RAM中数据的关系。</p>
<p>大多数时候你都用不到这些关键字，默认情况下 Solidity 会自动处理它们。 状态变量（在函数之外声明的变量）默认为“存储”形式，并永久写入区块链；而在函数内部声明的变量是“内存”型的，它们函数调用结束后消失。</p>
<p>然而也有一些情况下，你需要手动声明存储类型，主要用于处理函数内的 <strong>结构体</strong> 和 <strong>数组</strong> 时：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">contract SandwichFactory {</span><br><span class="line">  struct Sandwich {</span><br><span class="line">    string name;</span><br><span class="line">    string status;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  Sandwich[] sandwiches;</span><br><span class="line"></span><br><span class="line">  function eatSandwich(uint _index) public {</span><br><span class="line">    // Sandwich mySandwich = sandwiches[_index];</span><br><span class="line"></span><br><span class="line">    // ^ 看上去很直接，不过 Solidity 将会给出警告</span><br><span class="line">    // 告诉你应该明确在这里定义 `storage` 或者 `memory`。</span><br><span class="line"></span><br><span class="line">    // 所以你应该明确定义 `storage`:</span><br><span class="line">    Sandwich storage mySandwich = sandwiches[_index];</span><br><span class="line">    // ...这样 `mySandwich` 是指向 `sandwiches[_index]`的指针</span><br><span class="line">    // 在存储里，另外...</span><br><span class="line">    mySandwich.status = "Eaten!";</span><br><span class="line">    // ...这将永久把 `sandwiches[_index]` 变为区块链上的存储</span><br><span class="line"></span><br><span class="line">    // 如果你只想要一个副本，可以使用`memory`:</span><br><span class="line">    Sandwich memory anotherSandwich = sandwiches[_index + 1];</span><br><span class="line">    // ...这样 `anotherSandwich` 就仅仅是一个内存里的副本了</span><br><span class="line">    // 另外</span><br><span class="line">    anotherSandwich.status = "Eaten!";</span><br><span class="line">    // ...将仅仅修改临时变量，对 `sandwiches[_index + 1]` 没有任何影响</span><br><span class="line">    // 不过你可以这样做:</span><br><span class="line">    sandwiches[_index + 1] = anotherSandwich;</span><br><span class="line">    // ...如果你想把副本的改动保存回区块链存储</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果你还没有完全理解究竟应该使用哪一个，也不用担心 —— 在本教程中，我们将告诉你何时使用 <code>storage</code> 或是 <code>memory</code>，并且当你不得不使用到这些关键字的时候，Solidity 编译器也发警示提醒你的。</p>
<p>现在，只要知道在某些场合下也需要你显式地声明 <code>storage</code> 或 <code>memory</code>就够了！</p>
<p><strong>实战演习</strong></p>
<p>是时候给我们的僵尸增加“猎食”和“繁殖”功能了！</p>
<p>当一个僵尸猎食其他生物体时，它自身的DNA将与猎物生物的DNA结合在一起，形成一个新的僵尸DNA。</p>
<ol>
<li>创建一个名为 <code>feedAndMultiply</code> 的函数。 使用两个参数：<code>_zombieId</code>（ <code>uint</code>类型 ）和<code>_targetDna</code> （也是 <code>uint</code> 类型）。 设置属性为 <code>public</code> 的。</li>
<li>我们不希望别人用我们的僵尸去捕猎。 首先，我们确保对自己僵尸的所有权。 通过添加一个<code>require</code> 语句来确保 <code>msg.sender</code> 只能是这个僵尸的主人（类似于我们在 <code>createRandomZombie</code> 函数中做过的那样）。</li>
</ol>
<blockquote>
<p>注意：同样，因为我们的答案检查器比较呆萌，只认识把 <code>msg.sender</code> 放在前面的答案，如果你切换了参数的顺序，它就不认得了。 但你正常编码时，如何安排参数顺序都是正确的。</p>
</blockquote>
<ol>
<li>为了获取这个僵尸的DNA，我们的函数需要声明一个名为 <code>myZombie</code> 数据类型为<code>Zombie</code>的本地变量（这是一个 <code>storage</code> 型的指针）。 将其值设定为在 <code>zombies</code> 数组中索引为<code>_zombieId</code>所指向的值。</li>
</ol>
<p>到目前为止，包括函数结束符 <code>}</code> 的那一行， 总共4行代码。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Start here</span><br><span class="line">    function feedAndMultiply(uint _zombieId, uint _targetDna) public{</span><br><span class="line">        require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">        Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第8章-僵尸的DNA"><a href="#第8章-僵尸的DNA" class="headerlink" title="第8章: 僵尸的DNA"></a>第8章: 僵尸的DNA</h3><p>我们来把 <code>feedAndMultiply</code> 函数写完吧。</p>
<p>获取新的僵尸DNA的公式很简单：计算猎食僵尸DNA和被猎僵尸DNA之间的平均值。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function testDnaSplicing() public {</span><br><span class="line">  uint zombieDna = 2222222222222222;</span><br><span class="line">  uint targetDna = 4444444444444444;</span><br><span class="line">  uint newZombieDna = (zombieDna + targetDna) / 2;</span><br><span class="line">  // newZombieDna 将等于 3333333333333333</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以后，我们也可以让函数变得更复杂些，比方给新的僵尸的 DNA 增加一些随机性之类的。但现在先从最简单的开始 —— 以后还可以回来完善它嘛。</p>
<p><strong>实战演习</strong></p>
<ol>
<li>首先我们确保 <code>_targetDna</code> 不长于16位。要做到这一点，我们可以设置 <code>_targetDna</code> 为 <code>_targetDna ％ dnaModulus</code> ，并且只取其最后16位数字。</li>
<li>接下来为我们的函数声明一个名叫 <code>newDna</code> 的 <code>uint</code>类型的变量，并将其值设置为 <code>myZombie</code>的 DNA 和 <code>_targetDna</code> 的平均值（如上例所示）。</li>
</ol>
<blockquote>
<p>注意：您可以用 <code>myZombie.name</code> 或 <code>myZombie.dna</code> 访问 <code>myZombie</code> 的属性。</p>
</blockquote>
<ol>
<li>一旦我们计算出新的DNA，再调用 <code>_createZombie</code> 就可以生成新的僵尸了。如果你忘了调用这个函数所需要的参数，可以查看 <code>zombiefactory.sol</code> 选项卡。请注意，需要先给它命名，所以现在我们把新的僵尸的名字设为<code>NoName</code> - 我们回头可以编写一个函数来更改僵尸的名字。</li>
</ol>
<blockquote>
<p>注意：对于 Solidity 高手，你可能会注意到我们的代码存在一个问题。别担心，下一章会解决这个问题的 ;）</p>
</blockquote>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function feedAndMultiply(uint _zombieId, uint _targetDna) public {</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    // start here</span><br><span class="line">    _targetDna = _targetDna % dnaModulus;</span><br><span class="line">    uint newDna = (myZombie.dna + _targetDna) / 2;</span><br><span class="line">    _createZombie("NoName", newDna);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第9章-更多关于函数可见性"><a href="#第9章-更多关于函数可见性" class="headerlink" title="第9章: 更多关于函数可见性"></a>第9章: 更多关于函数可见性</h3><p><strong>我们上一课的代码有问题！</strong></p>
<p>编译的时候编译器就会报错。</p>
<p>错误在于，我们尝试从 <code>ZombieFeeding</code> 中调用 <code>_createZombie</code> 函数，但 <code>_createZombie</code> 却是 <code>ZombieFactory</code> 的 <code>private</code> （私有）函数。这意味着任何继承自 <code>ZombieFactory</code> 的子合约都不能访问它。</p>
<p><strong>internal 和 external</strong></p>
<p>除 <code>public</code> 和 <code>private</code> 属性之外，Solidity 还使用了另外两个描述函数可见性的修饰词：<code>internal</code>（内部） 和 <code>external</code>（外部）。</p>
<p><code>internal</code> 和 <code>private</code> 类似，不过， 如果某个合约继承自其父合约，这个合约即可以访问父合约中定义的“内部”函数。（嘿，这听起来正是我们想要的那样！）。</p>
<p><code>external</code> 与<code>public</code> 类似，只不过这些函数只能在合约之外调用 - 它们不能被合约内的其他函数调用。稍后我们将讨论什么时候使用 <code>external</code> 和 <code>public</code>。</p>
<p>声明函数 <code>internal</code> 或 <code>external</code> 类型的语法，与声明 <code>private</code> 和 <code>public</code>类 型相同：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">contract Sandwich {</span><br><span class="line">  uint private sandwichesEaten = 0;</span><br><span class="line"></span><br><span class="line">  function eat() internal {</span><br><span class="line">    sandwichesEaten++;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">contract BLT is Sandwich {</span><br><span class="line">  uint private baconSandwichesEaten = 0;</span><br><span class="line"></span><br><span class="line">  function eatWithBacon() public returns (string) {</span><br><span class="line">    baconSandwichesEaten++;</span><br><span class="line">    // 因为eat() 是internal 的，所以我们能在这里调用</span><br><span class="line">    eat();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实战演习</strong></p>
<ol>
<li><p>将 <code>_createZombie()</code> 函数的属性从 <code>private</code> 改为 <code>internal</code> ， 使得其他的合约也能访问到它。</p>
<p> 我们已经成功把你的注意力集中在到<code>zombiefactory.sol</code>这个选项卡上啦。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 在这里修改函数的功能</span><br><span class="line">    function _createZombie(string _name, uint _dna) internal {</span><br><span class="line">        uint id = zombies.push(Zombie(_name, _dna)) - 1;</span><br><span class="line">        zombieToOwner[id] = msg.sender;</span><br><span class="line">        ownerZombieCount[msg.sender]++;</span><br><span class="line">        NewZombie(id, _name, _dna);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第10章-僵尸吃什么"><a href="#第10章-僵尸吃什么" class="headerlink" title="第10章: 僵尸吃什么?"></a>第10章: 僵尸吃什么?</h3><p>是时候让我们的僵尸去捕猎！ 那僵尸最喜欢的食物是什么呢？</p>
<p>Crypto 僵尸喜欢吃的是…</p>
<p><strong>CryptoKitties！</strong> 😱😱😱</p>
<p>（正经点，我可不是开玩笑😆）</p>
<p>为了做到这一点，我们要读出 CryptoKitties 智能合约中的 kittyDna。这些数据是公开存储在区块链上的。区块链是不是很酷？</p>
<p>别担心 —— 我们的游戏并不会伤害到任何真正的CryptoKitty。 我们只 <em>读取</em> CryptoKitties 数据，但却无法在物理上删除它。</p>
<p><strong>与其他合约的交互</strong></p>
<p>如果我们的合约需要和区块链上的其他的合约会话，则需先定义一个 <strong>interface</strong> (接口)。</p>
<p>先举一个简单的栗子。 假设在区块链上有这么一个合约：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract LuckyNumber {</span><br><span class="line">  mapping(address =&gt; uint) numbers;</span><br><span class="line"></span><br><span class="line">  function setNum(uint _num) public {</span><br><span class="line">    numbers[msg.sender] = _num;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  function getNum(address _myAddress) public view returns (uint) {</span><br><span class="line">    return numbers[_myAddress];</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这是个很简单的合约，您可以用它存储自己的幸运号码，并将其与您的以太坊地址关联。 这样其他人就可以通过您的地址查找您的幸运号码了。</p>
<p>现在假设我们有一个外部合约，使用 <code>getNum</code> 函数可读取其中的数据。</p>
<p>首先，我们定义 <code>LuckyNumber</code> 合约的 <strong>interface</strong> ：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract NumberInterface {</span><br><span class="line">  function getNum(address _myAddress) public view returns (uint);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>请注意，这个过程虽然看起来像在定义一个合约，但其实内里不同：</p>
<p>首先，我们只声明了要与之交互的函数 —— 在本例中为 <code>getNum</code> —— 在其中我们没有使用到任何其他的函数或状态变量。</p>
<p>其次，我们并没有使用大括号（<code>{</code> 和 <code>}</code>）定义函数体，我们单单用分号（<code>;</code>）结束了函数声明。这使它看起来像一个合约框架。</p>
<p>编译器就是靠这些特征认出它是一个接口的。</p>
<p>在我们的 app 代码中使用这个接口，合约就知道其他合约的函数是怎样的，应该如何调用，以及可期待什么类型的返回值。</p>
<p>在下一课中，我们将真正调用其他合约的函数。目前我们只要声明一个接口，用于调用 CryptoKitties 合约就行了。</p>
<p><strong>实战演习</strong></p>
<p>我们已经为你查看过了 CryptoKitties 的源代码，并且找到了一个名为 <code>getKitty</code>的函数，它返回所有的加密猫的数据，包括它的“基因”（我们的僵尸游戏要用它生成新的僵尸）。</p>
<p>该函数如下所示：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function getKitty(uint256 _id) external view returns (</span><br><span class="line">    bool isGestating,</span><br><span class="line">    bool isReady,</span><br><span class="line">    uint256 cooldownIndex,</span><br><span class="line">    uint256 nextActionAt,</span><br><span class="line">    uint256 siringWithId,</span><br><span class="line">    uint256 birthTime,</span><br><span class="line">    uint256 matronId,</span><br><span class="line">    uint256 sireId,</span><br><span class="line">    uint256 generation,</span><br><span class="line">    uint256 genes</span><br><span class="line">) {</span><br><span class="line">    Kitty storage kit = kitties[_id];</span><br><span class="line"></span><br><span class="line">    // if this variable is 0 then it's not gestating</span><br><span class="line">    isGestating = (kit.siringWithId != 0);</span><br><span class="line">    isReady = (kit.cooldownEndBlock &lt;= block.number);</span><br><span class="line">    cooldownIndex = uint256(kit.cooldownIndex);</span><br><span class="line">    nextActionAt = uint256(kit.cooldownEndBlock);</span><br><span class="line">    siringWithId = uint256(kit.siringWithId);</span><br><span class="line">    birthTime = uint256(kit.birthTime);</span><br><span class="line">    matronId = uint256(kit.matronId);</span><br><span class="line">    sireId = uint256(kit.sireId);</span><br><span class="line">    generation = uint256(kit.generation);</span><br><span class="line">    genes = kit.genes;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个函数看起来跟我们习惯的函数不太一样。 它竟然返回了…一堆不同的值！ 如果您用过 JavaScript 之类的编程语言，一定会感到奇怪 —— 在 Solidity中，您可以让一个函数返回多个值。</p>
<p>现在我们知道这个函数长什么样的了，就可以用它来创建一个接口：</p>
<p>1.定义一个名为 <code>KittyInterface</code> 的接口。 请注意，因为我们使用了 <code>contract</code> 关键字， 这过程看起来就像创建一个新的合约一样。</p>
<p>2.在interface里定义了 <code>getKitty</code> 函数（不过是复制/粘贴上面的函数，但在 <code>returns</code> 语句之后用分号，而不是大括号内的所有内容。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Create KittyInterface here</span><br><span class="line">contract KittyInterface {</span><br><span class="line">    function getKitty(uint256 _id) external view returns (</span><br><span class="line">    bool isGestating,</span><br><span class="line">    bool isReady,</span><br><span class="line">    uint256 cooldownIndex,</span><br><span class="line">    uint256 nextActionAt,</span><br><span class="line">    uint256 siringWithId,</span><br><span class="line">    uint256 birthTime,</span><br><span class="line">    uint256 matronId,</span><br><span class="line">    uint256 sireId,</span><br><span class="line">    uint256 generation,</span><br><span class="line">    uint256 genes</span><br><span class="line">    );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第11章-使用接口"><a href="#第11章-使用接口" class="headerlink" title="第11章: 使用接口"></a>第11章: 使用接口</h3><p>继续前面 <code>NumberInterface</code> 的例子，我们既然将接口定义为：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract NumberInterface {</span><br><span class="line">  function getNum(address _myAddress) public view returns (uint);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们可以在合约中这样使用：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">contract MyContract {</span><br><span class="line">  address NumberInterfaceAddress = 0xab38...;</span><br><span class="line">  // ^ 这是FavoriteNumber合约在以太坊上的地址</span><br><span class="line">  NumberInterface numberContract = NumberInterface(NumberInterfaceAddress);</span><br><span class="line">  // 现在变量 `numberContract` 指向另一个合约对象</span><br><span class="line"></span><br><span class="line">  function someFunction() public {</span><br><span class="line">    // 现在我们可以调用在那个合约中声明的 `getNum`函数:</span><br><span class="line">    uint num = numberContract.getNum(msg.sender);</span><br><span class="line">    // ...在这儿使用 `num`变量做些什么</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过这种方式，只要将您合约的可见性设置为<code>public</code>(公共)或<code>external</code>(外部)，它们就可以与以太坊区块链上的任何其他合约进行交互。</p>
<p><strong>实战演习</strong></p>
<p>我们来建个自己的合约去读取另一个智能合约– CryptoKitties 的内容吧！</p>
<ol>
<li>我已经将代码中 CryptoKitties 合约的地址保存在一个名为 <code>ckAddress</code> 的变量中。在下一行中，请创建一个名为 <code>kittyContract</code> 的 KittyInterface，并用 <code>ckAddress</code> 为它初始化 —— 就像我们为 <code>numberContract</code>所做的一样。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">contract ZombieFeeding is ZombieFactory {</span><br><span class="line"></span><br><span class="line">  address ckAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;</span><br><span class="line">  // Initialize kittyContract here using `ckAddress` from above</span><br><span class="line">    KittyInterface kittyContract = KittyInterface(ckAddress);</span><br><span class="line"></span><br><span class="line">  function feedAndMultiply(uint _zombieId, uint _targetDna) public {</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    _targetDna = _targetDna % dnaModulus;</span><br><span class="line">    uint newDna = (myZombie.dna + _targetDna) / 2;</span><br><span class="line">    _createZombie("NoName", newDna);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第12章-处理多返回值"><a href="#第12章-处理多返回值" class="headerlink" title="第12章: 处理多返回值"></a>第12章: 处理多返回值</h3><p><code>getKitty</code> 是我们所看到的第一个返回多个值的函数。我们来看看是如何处理的：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function multipleReturns() internal returns(uint a, uint b, uint c) {</span><br><span class="line">  return (1, 2, 3);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function processMultipleReturns() external {</span><br><span class="line">  uint a;</span><br><span class="line">  uint b;</span><br><span class="line">  uint c;</span><br><span class="line">  // 这样来做批量赋值:</span><br><span class="line">  (a, b, c) = multipleReturns();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 或者如果我们只想返回其中一个变量:</span><br><span class="line">function getLastReturnValue() external {</span><br><span class="line">  uint c;</span><br><span class="line">  // 可以对其他字段留空:</span><br><span class="line">  (,,c) = multipleReturns();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实战演习</strong></p>
<p>是时候与 CryptoKitties 合约交互起来了！</p>
<p>我们来定义一个函数，从 kitty 合约中获取它的基因：</p>
<ol>
<li><p>创建一个名为 <code>feedOnKitty</code> 的函数。它需要2个 <code>uint</code> 类型的参数，<code>_zombieId</code> 和<code>_kittyId</code> ，这是一个 <code>public</code> 类型的函数。</p>
</li>
<li><p>函数首先要声明一个名为 <code>kittyDna</code> 的 <code>uint</code>。</p>
<blockquote>
<p>注意：在我们的 <code>KittyInterface</code> 中，<code>genes</code> 是一个 <code>uint256</code> 类型的变量，但是如果你记得，我们在第一课中提到过，<code>uint</code> 是 <code>uint256</code> 的别名，也就是说它们是一回事。</p>
</blockquote>
</li>
<li><p>这个函数接下来调用 <code>kittyContract.getKitty</code>函数, 传入 <code>_kittyId</code> ，将返回的 <code>genes</code> 存储在 <code>kittyDna</code> 中。记住 —— <code>getKitty</code> 会返回一大堆变量。 （确切地说10个 - 我已经为你数过了，不错吧！）。但是我们只关心最后一个– <code>genes</code>。数逗号的时候小心点哦！</p>
</li>
<li><p>最后，函数调用了 <code>feedAndMultiply</code> ，并传入了 <code>_zombieId</code> 和 <code>kittyDna</code> 两个参数。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// define function here</span><br><span class="line">    function feedOnKitty(uint _zombieId, uint _kittyId) public{</span><br><span class="line">        uint kittyDna;</span><br><span class="line">        (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId);</span><br><span class="line">        feedAndMultiply(_zombieId,kittyDna);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第13章-奖励-Kitty-基因"><a href="#第13章-奖励-Kitty-基因" class="headerlink" title="第13章: 奖励: Kitty 基因"></a>第13章: 奖励: Kitty 基因</h3><p>我们的功能逻辑主体已经完成了…现在让我们来添一个奖励功能吧。</p>
<p>这样吧，给从小猫制造出的僵尸添加些特征，以显示他们是猫僵尸。</p>
<p>要做到这一点，咱们在新僵尸的DNA中添加一些特殊的小猫代码。</p>
<p>还记得吗，第一课中我们提到，我们目前只使用16位DNA的前12位数来指定僵尸的外观。所以现在我们可以使用最后2个数字来处理“特殊”的特征。</p>
<p>这样吧，把猫僵尸DNA的最后两个数字设定为<code>99</code>（因为猫有9条命）。所以在我们这么来写代码：<code>如果</code>这个僵尸是一只猫变来的，就将它DNA的最后两位数字设置为<code>99</code>。</p>
<p><strong>if 语句</strong></p>
<p>if语句的语法在 Solidity 中，与在 JavaScript 中差不多：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function eatBLT(string sandwich) public {</span><br><span class="line">  // 看清楚了，当我们比较字符串的时候，需要比较他们的 keccak256 哈希码</span><br><span class="line">  if (keccak256(sandwich) == keccak256("BLT")) {</span><br><span class="line">    eat();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实战演习</strong></p>
<p>让我们在我们的僵尸代码中实现小猫的基因。</p>
<ol>
<li><p>首先，我们修改下 <code>feedAndMultiply</code> 函数的定义，给它传入第三个参数：一条名为 <code>_species</code> 的字符串。</p>
</li>
<li><p>接下来，在我们计算出新的僵尸的DNA之后，添加一个 <code>if</code> 语句来比较 <code>_species</code> 和字符串 <code>"kitty"</code> 的 <code>keccak256</code> 哈希值。</p>
</li>
<li><p>在 <code>if</code> 语句中，我们用 <code>99</code> 替换了新僵尸DNA的最后两位数字。可以这么做：<code>newDna = newDna - newDna % 100 + 99;</code>。</p>
<blockquote>
<p>解释：假设 <code>newDna</code> 是 <code>334455</code>。那么 <code>newDna % 100</code> 是 <code>55</code>，所以 <code>newDna - newDna % 100</code> 得到 <code>334400</code>。最后加上 <code>99</code> 可得到 <code>334499</code>。</p>
</blockquote>
</li>
<li><p>最后，我们修改了 <code>feedOnKitty</code> 中的函数调用。当它调用 <code>feedAndMultiply</code> 时，增加 <code>“kitty”</code> 作为最后一个参数。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 这里修改函数定义</span><br><span class="line">  function feedAndMultiply(uint _zombieId, uint _targetDna, string _species) public {</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    _targetDna = _targetDna % dnaModulus;</span><br><span class="line">    uint newDna = (myZombie.dna + _targetDna) / 2;</span><br><span class="line">    // 这里增加一个 if 语句</span><br><span class="line">    if(keccak256(_species) == keccak256("kitty")){</span><br><span class="line">        newDna = newDna - newDna % 100 + 99;</span><br><span class="line">    }</span><br><span class="line">    _createZombie("NoName", newDna);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  function feedOnKitty(uint _zombieId, uint _kittyId) public {</span><br><span class="line">    uint kittyDna;</span><br><span class="line">    (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId);</span><br><span class="line">    // 并修改函数调用</span><br><span class="line">    feedAndMultiply(_zombieId, kittyDna,"kitty");</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第14章-放在一起"><a href="#第14章-放在一起" class="headerlink" title="第14章: 放在一起"></a>第14章: 放在一起</h3><p>至此，你已经学完第二课了！</p>
<p>查看下→_→的演示，看看他们怎么运行起来得吧。继续，你肯定等不及看完这一页😉。点击小猫，攻击！看到你斩获一个新的小猫僵尸了吧！</p>
<p><strong>JavaScript 实现</strong></p>
<p>我们只用编译和部署 <code>ZombieFeeding</code>，就可以将这个合约部署到以太坊了。我们最终完成的这个合约继承自 <code>ZombieFactory</code>，因此它可以访问自己和父辈合约中的所有 public 方法。</p>
<p>我们来看一个与我们的刚部署的合约进行交互的例子， 这个例子使用了 JavaScript 和 web3.js：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">var abi = /* abi generated by the compiler */</span><br><span class="line">var ZombieFeedingContract = web3.eth.contract(abi)</span><br><span class="line">var contractAddress = /* our contract address on Ethereum after deploying */</span><br><span class="line">var ZombieFeeding = ZombieFeedingContract.at(contractAddress)</span><br><span class="line"></span><br><span class="line">// 假设我们有我们的僵尸ID和要攻击的猫咪ID</span><br><span class="line">let zombieId = 1;</span><br><span class="line">let kittyId = 1;</span><br><span class="line"></span><br><span class="line">// 要拿到猫咪的DNA，我们需要调用它的API。这些数据保存在它们的服务器上而不是区块链上。</span><br><span class="line">// 如果一切都在区块链上，我们就不用担心它们的服务器挂了，或者它们修改了API，</span><br><span class="line">// 或者因为不喜欢我们的僵尸游戏而封杀了我们</span><br><span class="line">let apiUrl = "https://api.cryptokitties.co/kitties/" + kittyId</span><br><span class="line">$.get(apiUrl, function(data) {</span><br><span class="line">  let imgUrl = data.image_url</span><br><span class="line">  // 一些显示图片的代码</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">// 当用户点击一只猫咪的时候:</span><br><span class="line">$(".kittyImage").click(function(e) {</span><br><span class="line">  // 调用我们合约的 `feedOnKitty` 函数</span><br><span class="line">  ZombieFeeding.feedOnKitty(zombieId, kittyId)</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">// 侦听来自我们合约的新僵尸事件好来处理</span><br><span class="line">ZombieFactory.NewZombie(function(error, result) {</span><br><span class="line">  if (error) return</span><br><span class="line">  // 这个函数用来显示僵尸:</span><br><span class="line">  generateZombie(result.zombieId, result.name, result.dna)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实战演习</strong></p>
<p>选择一只你想猎食的小猫。你自家僵尸的 DNA 会和小猫的 DNA 结合，生成一个新的小猫僵尸，加入你的军团！</p>
<p>看到新僵尸上那可爱的猫咪腿了么？这是新僵尸最后DNA中最后两位数字 <code>99</code> 的功劳！</p>
<p>你想要的话随时可以重新开始。捕获了一只猫咪僵尸，你一定很高兴吧！（不过你只能持有一只），继续前进到下一章，完成第二课吧！</p>
<h2 id="lesson3-高级-Solidity-理论"><a href="#lesson3-高级-Solidity-理论" class="headerlink" title="lesson3 高级 Solidity 理论"></a>lesson3 高级 Solidity 理论</h2><h3 id="第1章-智能协议的永固性"><a href="#第1章-智能协议的永固性" class="headerlink" title="第1章: 智能协议的永固性"></a>第1章: 智能协议的永固性</h3><p>到现在为止，我们讲的 Solidity 和其他语言没有质的区别，它长得也很像 JavaScript。</p>
<p>但是，在有几点以太坊上的 DApp 跟普通的应用程序有着天壤之别。</p>
<p>第一个例子，在你把智能协议传上以太坊之后，它就变得<strong>不可更改</strong>, 这种永固性意味着你的代码永远不能被调整或更新。</p>
<p>你编译的程序会一直，永久的，不可更改的，存在以太坊上。这就是 Solidity 代码的安全性如此重要的一个原因。如果你的智能协议有任何漏洞，即使你发现了也无法补救。你只能让你的用户们放弃这个智能协议，然后转移到一个新的修复后的合约上。</p>
<p>但这恰好也是智能合约的一大优势。代码说明一切。如果你去读智能合约的代码，并验证它，你会发现，一旦函数被定义下来，每一次的运行，程序都会严格遵照函数中原有的代码逻辑一丝不苟地执行，完全不用担心函数被人篡改而得到意外的结果。</p>
<p><strong>外部依赖关系</strong></p>
<p>在第2课中，我们将加密小猫（CryptoKitties）合约的地址硬编码到 DApp 中去了。有没有想过，如果加密小猫出了点问题，比方说，集体消失了会怎么样？ 虽然这种事情几乎不可能发生，但是，如果小猫没了，我们的 DApp 也会随之失效 – 因为我们在 DApp 的代码中用“硬编码”的方式指定了加密小猫的地址，如果这个根据地址找不到小猫，我们的僵尸也就吃不到小猫了，而按照前面的描述，我们却没法修改合约去应付这个变化！</p>
<p>因此，我们不能硬编码，而要采用“函数”，以便于 DApp 的关键部分可以以参数形式修改。</p>
<p>比方说，我们不再一开始就把猎物地址给写入代码，而是写个函数 <code>setKittyContractAddress</code>, 运行时再设定猎物的地址，这样我们就可以随时去锁定新的猎物，也不用担心加密小猫集体消失了。</p>
<p><strong>实战演习</strong></p>
<p>请修改第2课的代码，使得可以通过程序更改 CryptoKitties 合约地址。</p>
<ol>
<li>删除采用硬编码 方式的 <code>ckAddress</code> 代码行。</li>
<li>之前创建 <code>kittyContract</code> 变量的那行代码，修改为对 <code>kittyContract</code> 变量的声明 – 暂时不给它指定具体的实例。</li>
<li>创建名为 <code>setKittyContractAddress</code> 的函数， 它带一个参数 <code>_address</code>（<code>address</code>类型）， 可见性设为<code>external</code>。</li>
<li>在函数内部，添加一行代码，将 <code>kittyContract</code> 变量设置为返回值：<code>KittyInterface（_address）</code>。</li>
</ol>
<blockquote>
<p>注意：你可能会注意到这个功能有个安全漏洞，别担心 - 咱们到下一章里解决它;）</p>
</blockquote>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract ZombieFeeding is ZombieFactory {</span><br><span class="line"></span><br><span class="line">  // 1. 移除这一行:</span><br><span class="line">  //address ckAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;</span><br><span class="line">  // 2. 只声明变量:</span><br><span class="line">  KittyInterface kittyContract;</span><br><span class="line"></span><br><span class="line">  // 3. 增加 setKittyContractAddress 方法</span><br><span class="line">  function setKittyContractAddress(address _address) external{</span><br><span class="line">    kittyContract = KittyInterface(_address);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第2章-Ownable-Contracts"><a href="#第2章-Ownable-Contracts" class="headerlink" title="第2章: Ownable Contracts"></a>第2章: Ownable Contracts</h3><p>上一章中，您有没有发现任何安全漏洞呢？</p>
<p>呀！<code>setKittyContractAddress</code> 可见性居然申明为“外部的”（<code>external</code>），岂不是任何人都可以调用它！ 也就是说，任何调用该函数的人都可以更改 CryptoKitties 合约的地址，使得其他人都没法再运行我们的程序了。</p>
<p>我们确实是希望这个地址能够在合约中修改，但我可没说让每个人去改它呀。</p>
<p>要对付这样的情况，通常的做法是指定合约的“所有权” - 就是说，给它指定一个主人（没错，就是您），只有主人对它享有特权。</p>
<p><strong>OpenZeppelin库的<code>Ownable</code> 合约</strong></p>
<p>下面是一个 <code>Ownable</code> 合约的例子： 来自 <strong>_ OpenZeppelin _</strong> Solidity 库的 <code>Ownable</code> 合约。 OpenZeppelin 是主打安保和社区审查的智能合约库，您可以在自己的 DApps中引用。等把这一课学完，您不要催我们发布下一课，最好利用这个时间把 OpenZeppelin 的网站看看，保管您会学到很多东西！</p>
<p>把楼下这个合约读读通，是不是还有些没见过代码？别担心，我们随后会解释。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @title Ownable</span><br><span class="line"> * @dev The Ownable contract has an owner address, and provides basic authorization control</span><br><span class="line"> * functions, this simplifies the implementation of "user permissions".</span><br><span class="line"> */</span><br><span class="line">contract Ownable {</span><br><span class="line">  address public owner;</span><br><span class="line">  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev The Ownable constructor sets the original `owner` of the contract to the sender</span><br><span class="line">   * account.</span><br><span class="line">   */</span><br><span class="line">  function Ownable() public {</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev Throws if called by any account other than the owner.</span><br><span class="line">   */</span><br><span class="line">  modifier onlyOwner() {</span><br><span class="line">    require(msg.sender == owner);</span><br><span class="line">    _;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev Allows the current owner to transfer control of the contract to a newOwner.</span><br><span class="line">   * @param newOwner The address to transfer ownership to.</span><br><span class="line">   */</span><br><span class="line">  function transferOwnership(address newOwner) public onlyOwner {</span><br><span class="line">    require(newOwner != address(0));</span><br><span class="line">    OwnershipTransferred(owner, newOwner);</span><br><span class="line">    owner = newOwner;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>下面有没有您没学过的东东？</p>
<ul>
<li>构造函数：<code>function Ownable()</code>是一个 <strong>_ constructor_</strong> (构造函数)，构造函数不是必须的，它与合约同名，构造函数一生中唯一的一次执行，就是在合约最初被创建的时候。</li>
<li>函数修饰符：<code>modifier onlyOwner()</code>。 修饰符跟函数很类似，不过是用来修饰其他已有函数用的， 在其他语句执行前，为它检查下先验条件。 在这个例子中，我们就可以写个修饰符 <code>onlyOwner</code> 检查下调用者，确保只有合约的主人才能运行本函数。我们下一章中会详细讲述修饰符，以及那个奇怪的<code>_;</code>。</li>
<li><code>indexed</code> 关键字：别担心，我们还用不到它。</li>
</ul>
<p>所以<code>Ownable</code> 合约基本都会这么干：</p>
<ol>
<li>合约创建，构造函数先行，将其 <code>owner</code> 设置为<code>msg.sender</code>（其部署者）</li>
<li>为它加上一个修饰符 <code>onlyOwner</code>，它会限制陌生人的访问，将访问某些函数的权限锁定在 <code>owner</code> 上。</li>
<li>允许将合约所有权转让给他人。</li>
</ol>
<p><code>onlyOwner</code> 简直人见人爱，大多数人开发自己的 Solidity DApps，都是从复制/粘贴 <code>Ownable</code> 开始的，从它再继承出的子类，并在之上进行功能开发。</p>
<p>既然我们想把 <code>setKittyContractAddress</code> 限制为 <code>onlyOwner</code> ，我们也要做同样的事情。</p>
<p><strong>实战演习</strong></p>
<p>首先，将 <code>Ownable</code> 合约的代码复制一份到新文件 <code>ownable.sol</code> 中。 接下来，创建一个 <code>ZombieFactory</code>，继承 <code>Ownable</code>。</p>
<p>1.在程序中导入 <code>ownable.sol</code> 的内容。 如果您不记得怎么做了，参考下 <code>zombiefeeding.sol</code>。</p>
<p>2.修改 <code>ZombieFactory</code> 合约， 让它继承自 <code>Ownable</code>。 如果您不记得怎么做了，看看 <code>zombiefeeding.sol</code>。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 1. 在这里导入</span><br><span class="line">import "./ownable.sol";</span><br><span class="line">// 2. 在这里继承:</span><br><span class="line">contract ZombieFactory is Ownable{</span><br><span class="line"></span><br><span class="line">    event NewZombie(uint zombieId, string name, uint dna);</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第3章-onlyOwner-函数修饰符"><a href="#第3章-onlyOwner-函数修饰符" class="headerlink" title="第3章: onlyOwner 函数修饰符"></a>第3章: onlyOwner 函数修饰符</h3><p>现在我们有了个基本版的合约 <code>ZombieFactory</code> 了，它继承自 <code>Ownable</code> 接口，我们也可以给 <code>ZombieFeeding</code> 加上 <code>onlyOwner</code> 函数修饰符。</p>
<p>这就是合约继承的工作原理。记得：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZombieFeeding 是个 ZombieFactory</span><br><span class="line">ZombieFactory 是个 Ownable</span><br></pre></td></tr></tbody></table></figure>

<p>因此 <code>ZombieFeeding</code> 也是个 <code>Ownable</code>, 并可以通过 <code>Ownable</code> 接口访问父类中的函数/事件/修饰符。往后，<code>ZombieFeeding</code> 的继承者合约们同样也可以这么延续下去。</p>
<p><strong>函数修饰符</strong></p>
<p>函数修饰符看起来跟函数没什么不同，不过关键字<code>modifier</code> 告诉编译器，这是个<code>modifier(修饰符)</code>，而不是个<code>function(函数)</code>。它不能像函数那样被直接调用，只能被添加到函数定义的末尾，用以改变函数的行为。</p>
<p>咱们仔细读读 <code>onlyOwner</code>:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @dev 调用者不是‘主人’，就会抛出异常</span><br><span class="line"> */</span><br><span class="line">modifier onlyOwner() {</span><br><span class="line">  require(msg.sender == owner);</span><br><span class="line">  _;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>onlyOwner</code> 函数修饰符是这么用的：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">contract MyContract is Ownable {</span><br><span class="line">  event LaughManiacally(string laughter);</span><br><span class="line"></span><br><span class="line">  //注意！ `onlyOwner`上场 :</span><br><span class="line">  function likeABoss() external onlyOwner {</span><br><span class="line">    LaughManiacally("Muahahahaha");</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注意 <code>likeABoss</code> 函数上的 <code>onlyOwner</code> 修饰符。 当你调用 <code>likeABoss</code> 时，<strong>首先执行</strong> <code>onlyOwner</code> 中的代码， 执行到 <code>onlyOwner</code> 中的 <code>_;</code> 语句时，程序再返回并执行 <code>likeABoss</code> 中的代码。</p>
<p>可见，尽管函数修饰符也可以应用到各种场合，但最常见的还是放在函数执行之前添加快速的 <code>require</code>检查。</p>
<p>因为给函数添加了修饰符 <code>onlyOwner</code>，使得<strong>唯有合约的主人</strong>（也就是部署者）才能调用它。</p>
<blockquote>
<p>注意：主人对合约享有的特权当然是正当的，不过也可能被恶意使用。比如，万一，主人添加了个后门，允许他偷走别人的僵尸呢？</p>
</blockquote>
<blockquote>
<p>所以非常重要的是，部署在以太坊上的 DApp，并不能保证它真正做到去中心，你需要阅读并理解它的源代码，才能防止其中没有被部署者恶意植入后门；作为开发人员，如何做到既要给自己留下修复 bug 的余地，又要尽量地放权给使用者，以便让他们放心你，从而愿意把数据放在你的 DApp 中，这确实需要个微妙的平衡。</p>
</blockquote>
<p><strong>实战演习</strong></p>
<p>现在我们可以限制第三方对 <code>setKittyContractAddress</code>的访问，除了我们自己，谁都无法去修改它。</p>
<ol>
<li>将 <code>onlyOwner</code> 函数修饰符添加到 <code>setKittyContractAddress</code> 中。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 修改这个函数:</span><br><span class="line">function setKittyContractAddress(address _address) external onlyOwner {</span><br><span class="line">  kittyContract = KittyInterface(_address);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第4章-Gas"><a href="#第4章-Gas" class="headerlink" title="第4章: Gas"></a>第4章: Gas</h3><p>厉害！现在我们懂了如何在禁止第三方修改我们的合约的同时，留个后门给咱们自己去修改。</p>
<p>让我们来看另一种使得 Solidity 编程语言与众不同的特征：</p>
<p><strong>Gas - 驱动以太坊DApps的能源</strong></p>
<p>在 Solidity 中，你的用户想要每次执行你的 DApp 都需要支付一定的 ***gas***，gas 可以用以太币购买，因此，用户每次跑 DApp 都得花费以太币。</p>
<p>一个 DApp 收取多少 gas 取决于功能逻辑的复杂程度。每个操作背后，都在计算完成这个操作所需要的计算资源，（比如，存储数据就比做个加法运算贵得多）， 一次操作所需要花费的 *<strong>gas*</strong> 等于这个操作背后的所有运算花销的总和。</p>
<p>由于运行你的程序需要花费用户的真金白银，在以太坊中代码的编程语言，比其他任何编程语言都更强调优化。同样的功能，使用笨拙的代码开发的程序，比起经过精巧优化的代码来，运行花费更高，这显然会给成千上万的用户带来大量不必要的开销。</p>
<p>*<em>为什么要用 <em>gas* 来驱动？</em></em></p>
<p>以太坊就像一个巨大、缓慢、但非常安全的电脑。当你运行一个程序的时候，网络上的每一个节点都在进行相同的运算，以验证它的输出 —— 这就是所谓的“去中心化” 由于数以千计的节点同时在验证着每个功能的运行，这可以确保它的数据不会被被监控，或者被刻意修改。</p>
<p>可能会有用户用无限循环堵塞网络，抑或用密集运算来占用大量的网络资源，为了防止这种事情的发生，以太坊的创建者为以太坊上的资源制定了价格，想要在以太坊上运算或者存储，你需要先付费。</p>
<blockquote>
<p>注意：如果你使用侧链，倒是不一定需要付费，比如咱们在 Loom Network 上构建的 CryptoZombies 就免费。你不会想要在以太坊主网上玩儿“魔兽世界”吧？ - 所需要的 gas 可能会买到你破产。但是你可以找个算法理念不同的侧链来玩它。我们将在以后的课程中咱们会讨论到，什么样的 DApp 应该部署在太坊主链上，什么又最好放在侧链。</p>
</blockquote>
<p><strong>省 gas 的招数：结构封装 （Struct packing）</strong></p>
<p>在第1课中，我们提到除了基本版的 <code>uint</code> 外，还有其他变种 <code>uint</code>：<code>uint8</code>，<code>uint16</code>，<code>uint32</code>等。</p>
<p>通常情况下我们不会考虑使用 <code>uint</code> 变种，因为无论如何定义 <code>uint</code>的大小，Solidity 为它保留256位的存储空间。例如，使用 <code>uint8</code> 而不是<code>uint</code>（<code>uint256</code>）不会为你节省任何 gas。</p>
<p>除非，<u><strong>把 <code>uint</code> 绑定到 <code>struct</code> 里面</strong></u>。</p>
<p>如果一个 <code>struct</code> 中有多个 <code>uint</code>，则尽可能使用较小的 <code>uint</code>, Solidity 会将这些 <code>uint</code> 打包在一起，从而占用较少的存储空间。例如：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct NormalStruct {</span><br><span class="line">  uint a;</span><br><span class="line">  uint b;</span><br><span class="line">  uint c;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">struct MiniMe {</span><br><span class="line">  uint32 a;</span><br><span class="line">  uint32 b;</span><br><span class="line">  uint c;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 因为使用了结构打包，`mini` 比 `normal` 占用的空间更少</span><br><span class="line">NormalStruct normal = NormalStruct(10, 20, 30);</span><br><span class="line">MiniMe mini = MiniMe(10, 20, 30); </span><br></pre></td></tr></tbody></table></figure>

<p>所以，当 <code>uint</code> 定义在一个 <code>struct</code> 中的时候，尽量使用最小的整数子类型以节约空间。 **<u>并且把同样类型的变量放一起</u>**（即在 struct 中将把变量按照类型依次放置），<u>这样 Solidity 可以将存储空间最小化</u>。例如，有两个 <code>struct</code>：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint c; uint32 a; uint32 b;` 和 `uint32 a; uint c; uint32 b;</span><br></pre></td></tr></tbody></table></figure>

<p>前者比后者需要的gas更少，因为前者把<code>uint32</code>放一起了。</p>
<p><strong>实战演习</strong></p>
<p>在本课中，咱们给僵尸添2个新功能：<code>level</code> 和 <code>readyTime</code> - 后者是用来实现一个“冷却定时器”，以限制僵尸猎食的频率。</p>
<p>让我们回到 <code>zombiefactory.sol</code>。</p>
<ol>
<li>为 <code>Zombie</code> 结构体 添加两个属性：<code>level</code>（<code>uint32</code>）和<code>readyTime</code>（<code>uint32</code>）。因为希望同类型数据打成一个包，所以把它们放在结构体的末尾。</li>
</ol>
<p>32位足以保存僵尸的级别和时间戳了，这样比起使用普通的<code>uint</code>（256位），可以更紧密地封装数据，从而为我们省点 gas。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">contract ZombieFactory is Ownable {</span><br><span class="line"></span><br><span class="line">    event NewZombie(uint zombieId, string name, uint dna);</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">        //在这里添加数据</span><br><span class="line">        uint32 level;</span><br><span class="line">        uint32 readyTime;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第5章-时间单位"><a href="#第5章-时间单位" class="headerlink" title="第5章: 时间单位"></a>第5章: 时间单位</h3><p><code>level</code> 属性表示僵尸的级别。以后，在我们创建的战斗系统中，打胜仗的僵尸会逐渐升级并获得更多的能力。</p>
<p><code>readyTime</code> 稍微复杂点。我们希望增加一个“冷却周期”，表示僵尸在两次猎食或攻击之之间必须等待的时间。如果没有它，僵尸每天可能会攻击和繁殖1,000次，这样游戏就太简单了。</p>
<p>为了记录僵尸在下一次进击前需要等待的时间，我们使用了 Solidity 的时间单位。</p>
<p><strong>时间单位</strong></p>
<p>Solidity 使用自己的本地时间单位。</p>
<p>变量 <code>now</code> 将返回当前的unix时间戳（自1970年1月1日以来经过的秒数）。我写这句话时 unix 时间是 <code>1515527488</code>。</p>
<blockquote>
<p>注意：Unix时间传统用一个32位的整数进行存储。这会导致“2038年”问题，当这个32位的unix时间戳不够用，产生溢出，使用这个时间的遗留系统就麻烦了。所以，如果我们想让我们的 DApp 跑够20年，我们可以使用64位整数表示时间，但为此我们的用户又得支付更多的 gas。真是个两难的设计啊！</p>
</blockquote>
<p>Solidity 还包含<code>秒(seconds)</code>，<code>分钟(minutes)</code>，<code>小时(hours)</code>，<code>天(days)</code>，<code>周(weeks)</code> 和 <code>年(years)</code> 等时间单位。它们都会转换成对应的秒数放入 <code>uint</code> 中。所以 <code>1分钟</code> 就是 <code>60</code>，<code>1小时</code>是 <code>3600</code>（60秒×60分钟），<code>1天</code>是<code>86400</code>（24小时×60分钟×60秒），以此类推。</p>
<p>下面是一些使用时间单位的实用案例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">uint lastUpdated;</span><br><span class="line"></span><br><span class="line">// 将‘上次更新时间’ 设置为 ‘现在’</span><br><span class="line">function updateTimestamp() public {</span><br><span class="line">  lastUpdated = now;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 如果到上次`updateTimestamp` 超过5分钟，返回 'true'</span><br><span class="line">// 不到5分钟返回 'false'</span><br><span class="line">function fiveMinutesHavePassed() public view returns (bool) {</span><br><span class="line">  return (now &gt;= (lastUpdated + 5 minutes));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>有了这些工具，我们可以为僵尸设定“冷静时间”功能。</p>
<p><strong>实战演习</strong></p>
<p>现在咱们给DApp添加一个“冷却周期”的设定，让僵尸两次攻击或捕猎之间必须等待 <strong>1天</strong>。</p>
<ol>
<li><p>声明一个名为 <code>cooldownTime</code> 的<code>uint</code>，并将其设置为 <code>1 days</code>。（没错，”1 days“使用了复数， 否则通不过编译器）</p>
</li>
<li><p>因为在上一章中我们给 <code>Zombie</code> 结构体中添加 <code>level</code> 和 <code>readyTime</code> 两个参数，所以现在创建一个新的 <code>Zombie</code> 结构体时，需要修改 <code>_createZombie()</code>，在其中把新旧参数都初始化一下。</p>
<p> 修改 <code>zombies.push</code> 那一行， 添加加2个参数：<code>1</code>（表示当前的 <code>level</code> ）和<code>uint32（now + cooldownTime）</code>（现在+冷却时间，表示下次允许攻击的时间 <code>readyTime</code>）。</p>
</li>
</ol>
<blockquote>
<p>注意：必须使用 <code>uint32（...）</code> 进行强制类型转换，因为 <code>now</code> 返回类型 <code>uint256</code>。所以我们需要明确将它转换成一个 <code>uint32</code> 类型的变量。</p>
</blockquote>
<p><code>now + cooldownTime</code> 将等于当前的unix时间戳（以秒为单位）加上”1天“里的秒数 - 这将等于从现在起1天后的unix时间戳。然后我们就比较，看看这个僵尸的 <code>readyTime</code>是否大于 <code>now</code>，以决定再次启用僵尸的时机有没有到来。</p>
<p>下一章中，我们将讨论如何通过 <code>readyTime</code> 来规范僵尸的行为。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 1. 在这里定义 `cooldownTime`</span><br><span class="line">uint cooldownTime = 1 days;</span><br><span class="line">    </span><br><span class="line">function _createZombie(string _name, uint _dna) internal {</span><br><span class="line">        // 2. 修改下面这行:</span><br><span class="line">        uint id = zombies.push(Zombie(_name, _dna, 1, uint32(now + cooldownTime))) - 1;</span><br><span class="line">        zombieToOwner[id] = msg.sender;</span><br><span class="line">        ownerZombieCount[msg.sender]++;</span><br><span class="line">        NewZombie(id, _name, _dna);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第6章-僵尸冷却"><a href="#第6章-僵尸冷却" class="headerlink" title="第6章: 僵尸冷却"></a>第6章: 僵尸冷却</h3><p>现在，<code>Zombie</code> 结构体中定义好了一个 <code>readyTime</code> 属性，让我们跳到 <code>zombiefeeding.sol</code>， 去实现一个”冷却周期定时器“。</p>
<p>按照以下步骤修改 <code>feedAndMultiply</code>：</p>
<ol>
<li>”捕猎“行为会触发僵尸的”冷却周期“</li>
<li>僵尸在这段”冷却周期“结束前不可再捕猎小猫</li>
</ol>
<p>这将限制僵尸，防止其无限制地捕猎小猫或者整天不停地繁殖。将来，当我们增加战斗功能时，我们同样用”冷却周期“限制僵尸之间打斗的频率。</p>
<p>首先，我们要定义一些辅助函数，设置并检查僵尸的 <code>readyTime</code>。</p>
<p><strong>将结构体作为参数传入</strong></p>
<p>由于结构体的存储指针可以以参数的方式传递给一个 <code>private</code> 或 <code>internal</code> 的函数，因此结构体可以在多个函数之间相互传递。</p>
<p>遵循这样的语法：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function _doStuff(Zombie storage _zombie) internal {</span><br><span class="line">  // do stuff with _zombie</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这样我们可以将某僵尸的引用直接传递给一个函数，而不用是通过参数传入僵尸ID后，函数再依据ID去查找。</p>
<p><strong>实战演习</strong></p>
<ol>
<li>先定义一个 <code>_triggerCooldown</code> 函数。它要求一个参数，<code>_zombie</code>，表示一某个僵尸的存储指针。这个函数可见性设置为 <code>internal</code>。</li>
<li>在函数中，把 <code>_zombie.readyTime</code> 设置为 <code>uint32（now + cooldownTime）</code>。</li>
<li>接下来，创建一个名为 <code>_isReady</code> 的函数。这个函数的参数也是名为 <code>_zombie</code> 的 <code>Zombie storage</code>。这个功能只具有 <code>internal</code> 可见性，并返回一个 <code>bool</code> 值。</li>
<li>函数计算返回<code>(_zombie.readyTime &lt;= now)</code>，值为 <code>true</code> 或 <code>false</code>。这个功能的目的是判断下次允许猎食的时间是否已经到了。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 1. 在这里定义 `_triggerCooldown` 函数</span><br><span class="line">  function _triggerCooldown(Zombie storage _zombie) internal {</span><br><span class="line">    _zombie.readyTime = uint32(now + cooldownTime);</span><br><span class="line">  }</span><br><span class="line">  // 2. 在这里定义 `_isReady` 函数</span><br><span class="line">  function _isReady(Zombie storage _zombie) internal view returns(bool){</span><br><span class="line">    return (_zombie.readyTime &lt;= now);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第7章-公有函数和安全性"><a href="#第7章-公有函数和安全性" class="headerlink" title="第7章: 公有函数和安全性"></a>第7章: 公有函数和安全性</h3><p>现在来修改 <code>feedAndMultiply</code> ，实现冷却周期。</p>
<p>回顾一下这个函数，前一课上我们将其可见性设置为<code>public</code>。你必须仔细地检查所有声明为 <code>public</code> 和 <code>external</code>的函数，一个个排除用户滥用它们的可能，谨防安全漏洞。请记住，如果这些函数没有类似 <code>onlyOwner</code> 这样的函数修饰符，用户能利用各种可能的参数去调用它们。</p>
<p>检查完这个函数，用户就可以直接调用这个它，并传入他们所希望的 <code>_targetDna</code> 或 <code>species</code> 。打个游戏还得遵循这么多的规则，还能不能愉快地玩耍啊！</p>
<p>仔细观察，这个函数只需被 <code>feedOnKitty()</code> 调用，因此，想要防止漏洞，最简单的方法就是设其可见性为 <code>internal</code>。</p>
<p><strong>实战演习</strong></p>
<ol>
<li>目前函数 <code>feedAndMultiply</code> 可见性为 <code>public</code>。我们将其改为 <code>internal</code> 以保障合约安全。因为我们不希望用户调用它的时候塞进一堆乱七八糟的 DNA。</li>
<li><code>feedAndMultiply</code> 过程需要参考 <code>cooldownTime</code>。首先，在找到 <code>myZombie</code> 之后，添加一个 <code>require</code> 语句来检查 <code>_isReady()</code> 并将 <code>myZombie</code> 传递给它。这样用户必须等到僵尸的 <code>冷却周期</code> 结束后才能执行 <code>feedAndMultiply</code> 功能。</li>
<li>在函数结束时，调用 <code>_triggerCooldown(myZombie)</code>，标明捕猎行为触发了僵尸新的冷却周期。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 1. 使这个函数的可见性为 internal</span><br><span class="line">  function feedAndMultiply(uint _zombieId, uint _targetDna, string species) internal {</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    // 2. 在这里为 `_isReady` 增加一个检查</span><br><span class="line">    require(_isReady(myZombie));</span><br><span class="line">    _targetDna = _targetDna % dnaModulus;</span><br><span class="line">    uint newDna = (myZombie.dna + _targetDna) / 2;</span><br><span class="line">    if (keccak256(species) == keccak256("kitty")) {</span><br><span class="line">      newDna = newDna - newDna % 100 + 99;</span><br><span class="line">    }</span><br><span class="line">    _createZombie("NoName", newDna);</span><br><span class="line">    // 3. 调用 `_triggerCooldown`</span><br><span class="line">    _triggerCooldown(myZombie);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第8章-进一步了解函数修饰符"><a href="#第8章-进一步了解函数修饰符" class="headerlink" title="第8章: 进一步了解函数修饰符"></a>第8章: 进一步了解函数修饰符</h3><p>相当不错！我们的僵尸现在有了“冷却定时器”功能。</p>
<p>接下来，我们将添加一些辅助方法。我们为您创建了一个名为 <code>zombiehelper.sol</code> 的新文件，并且将 <code>zombiefeeding.sol</code> 导入其中，这让我们的代码更整洁。</p>
<p>我们打算让僵尸在达到一定水平后，获得特殊能力。但是达到这个小目标，我们还需要学一学什么是“函数修饰符”。</p>
<p><strong>带参数的函数修饰符</strong></p>
<p>之前我们已经读过一个简单的函数修饰符了：<code>onlyOwner</code>。函数修饰符也可以带参数。例如：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 存储用户年龄的映射</span><br><span class="line">mapping (uint =&gt; uint) public age;</span><br><span class="line"></span><br><span class="line">// 限定用户年龄的修饰符</span><br><span class="line">modifier olderThan(uint _age, uint _userId) {</span><br><span class="line">  require(age[_userId] &gt;= _age);</span><br><span class="line">  _;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 必须年满16周岁才允许开车 (至少在美国是这样的).</span><br><span class="line">// 我们可以用如下参数调用`olderThan` 修饰符:</span><br><span class="line">function driveCar(uint _userId) public olderThan(16, _userId) {</span><br><span class="line">  // 其余的程序逻辑</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>看到了吧， <code>olderThan</code> 修饰符可以像函数一样接收参数，是“宿主”函数 <code>driveCar</code> 把参数传递给它的修饰符的。</p>
<p>来，我们自己生产一个修饰符，通过传入的<code>level</code>参数来限制僵尸使用某些特殊功能。</p>
<p><strong>实战演习</strong></p>
<ol>
<li>在<code>ZombieHelper</code> 中，创建一个名为 <code>aboveLevel</code> 的<code>modifier</code>，它接收2个参数， <code>_level</code> (<code>uint</code>类型) 以及 <code>_zombieId</code> (<code>uint</code>类型)。</li>
<li>运用函数逻辑确保僵尸 <code>zombies[_zombieId].level</code> 大于或等于 <code>_level</code>。</li>
<li>记住，修饰符的最后一行为 <code>_;</code>，表示修饰符调用结束后返回，并执行调用函数余下的部分。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import "./zombiefeeding.sol";</span><br><span class="line"></span><br><span class="line">contract ZombieHelper is ZombieFeeding {</span><br><span class="line"></span><br><span class="line">  // 在这里开始</span><br><span class="line">  modifier aboveLevel(uint _level, uint _zombieId){</span><br><span class="line">    require(zombies[_zombieId].level &gt;= _level);</span><br><span class="line">    _;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第9章-僵尸修饰符"><a href="#第9章-僵尸修饰符" class="headerlink" title="第9章: 僵尸修饰符"></a>第9章: 僵尸修饰符</h3><p>现在让我们设计一些使用 <code>aboveLevel</code> 修饰符的函数。</p>
<p>作为游戏，您得有一些措施激励玩家们去升级他们的僵尸：</p>
<ul>
<li>2级以上的僵尸，玩家可给他们改名。</li>
<li>20级以上的僵尸，玩家能给他们定制的 DNA。</li>
</ul>
<p>是实现这些功能的时候了。以下是上一课的示例代码，供参考：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 存储用户年龄的映射</span><br><span class="line">mapping (uint =&gt; uint) public age;</span><br><span class="line"></span><br><span class="line">// 限定用户年龄的修饰符</span><br><span class="line">modifier olderThan(uint _age, uint _userId) {</span><br><span class="line">  require (age[_userId] &gt;= _age);</span><br><span class="line">  _;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 必须年满16周岁才允许开车 (至少在美国是这样的).</span><br><span class="line">// 我们可以用如下参数调用`olderThan` 修饰符:</span><br><span class="line">function driveCar(uint _userId) public olderThan(16, _userId) {</span><br><span class="line">  // 其余的程序逻辑</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实战演习</strong></p>
<ol>
<li>创建一个名为 <code>changeName</code> 的函数。它接收2个参数：<code>_zombieId</code>（<code>uint</code>类型）以及 <code>_newName</code>（<code>string</code>类型），可见性为 <code>external</code>。它带有一个 <code>aboveLevel</code> 修饰符，调用的时候通过 <code>_level</code> 参数传入<code>2</code>， 当然，别忘了同时传 <code>_zombieId</code> 参数。</li>
<li>在这个函数中，首先我们用 <code>require</code> 语句，验证 <code>msg.sender</code> 是否就是 <code>zombieToOwner [_zombieId]</code>。</li>
<li>然后函数将 <code>zombies[_zombieId] .name</code> 设置为 <code>_newName</code>。</li>
<li>在 <code>changeName</code> 下创建另一个名为 <code>changeDna</code> 的函数。它的定义和内容几乎和 <code>changeName</code> 相同，不过它第二个参数是 <code>_newDna</code>（<code>uint</code>类型），在修饰符 <code>aboveLevel</code> 的 <code>_level</code> 参数中传递 <code>20</code> 。现在，他可以把僵尸的 <code>dna</code> 设置为 <code>_newDna</code> 了。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 在这里开始</span><br><span class="line">  function changeName(uint _zombieId, string _newName) external aboveLevel(2, _zombieId){</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    zombies[_zombieId].name = _newName;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  function changeDna(uint _zombieId, uint _newDna) external aboveLevel(20, _zombieId){</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    zombies[_zombieId].dna = _newDna;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第10章-利用-‘View’-函数节省-Gas"><a href="#第10章-利用-‘View’-函数节省-Gas" class="headerlink" title="第10章: 利用 ‘View’ 函数节省 Gas"></a>第10章: 利用 ‘View’ 函数节省 Gas</h3><p>酷炫！现在高级别僵尸可以拥有特殊技能了，这一定会鼓动我们的玩家去打怪升级的。你喜欢的话，回头我们还能添加更多的特殊技能。</p>
<p>现在需要添加的一个功能是：我们的 DApp 需要一个方法来查看某玩家的整个僵尸军团 - 我们称之为 <code>getZombiesByOwner</code>。</p>
<p>实现这个功能只需从区块链中读取数据，所以它可以是一个 <code>view</code> 函数。这让我们不得不回顾一下“gas优化”这个重要话题。</p>
<p><strong>“view” 函数不花 “gas”</strong></p>
<p>当玩家从外部调用一个<code>view</code>函数，是不需要支付一分 gas 的。</p>
<p>这是因为 <code>view</code> 函数不会真正改变区块链上的任何数据 - 它们只是读取。因此用 <code>view</code> 标记一个函数，意味着告诉 <code>web3.js</code>，运行这个函数只需要查询你的本地以太坊节点，而不需要在区块链上创建一个事务（事务需要运行在每个节点上，因此花费 gas）。</p>
<p>稍后我们将介绍如何在自己的节点上设置 web3.js。但现在，你关键是要记住，在所能只读的函数上标记上表示“只读”的“<code>external view</code> 声明，就能为你的玩家减少在 DApp 中 gas 用量。</p>
<blockquote>
<p>注意：如果一个 <code>view</code> 函数在另一个函数的内部被调用，而调用函数与 <code>view</code> 函数的不属于同一个合约，也会产生调用成本。这是因为如果主调函数在以太坊创建了一个事务，它仍然需要逐个节点去验证。所以标记为 <code>view</code> 的函数只有在外部调用时才是免费的。</p>
</blockquote>
<p><strong>实战演习</strong></p>
<p>我们来写一个”返回某玩家的整个僵尸军团“的函数。当我们从 <code>web3.js</code> 中调用它，即可显示某一玩家的个人资料页。</p>
<p>这个函数的逻辑有点复杂，我们需要好几个章节来描述它的实现。</p>
<ol>
<li>创建一个名为 <code>getZombiesByOwner</code> 的新函数。它有一个名为 <code>_owner</code> 的 <code>address</code> 类型的参数。</li>
<li>将其申明为 <code>external view</code> 函数，这样当玩家从 <code>web3.js</code> 中调用它时，不需要花费任何 gas。</li>
<li>函数需要返回一个<code>uint []</code>（<code>uint</code>数组）。</li>
</ol>
<p>先这么声明着，我们将在下一章中填充函数体。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 在这里创建你的函数</span><br><span class="line"> function getZombiesByOwner(address _owner) external view returns(uint[]){</span><br><span class="line"></span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第11章-存储非常昂贵"><a href="#第11章-存储非常昂贵" class="headerlink" title="第11章: 存储非常昂贵"></a>第11章: 存储非常昂贵</h3><p>Solidity 使用<code>storage</code>(存储)是相当昂贵的，”写入“操作尤其贵。</p>
<p>这是因为，无论是写入还是更改一段数据， 这都将永久性地写入区块链。”永久性“啊！需要在全球数千个节点的硬盘上存入这些数据，随着区块链的增长，拷贝份数更多，存储量也就越大。这是需要成本的！</p>
<p>为了降低成本，不到万不得已，避免将数据写入存储。这也会导致效率低下的编程逻辑 - 比如每次调用一个函数，都需要在 <code>memory</code>(内存) 中重建一个数组，而不是简单地将上次计算的数组给存储下来以便快速查找。</p>
<p>在大多数编程语言中，遍历大数据集合都是昂贵的。但是在 Solidity 中，使用一个标记了<code>external view</code>的函数，遍历比 <code>storage</code> 要便宜太多，因为 <code>view</code> 函数不会产生任何花销。 （gas可是真金白银啊！）。</p>
<p>我们将在下一章讨论<code>for</code>循环，现在我们来看一下看如何如何在内存中声明数组。</p>
<p><strong>在内存中声明数组</strong></p>
<p>在数组后面加上 <code>memory</code>关键字， 表明这个数组是仅仅在内存中创建，不需要写入外部存储，并且在函数调用结束时它就解散了。与在程序结束时把数据保存进 <code>storage</code> 的做法相比，内存运算可以大大节省gas开销 – 把这数组放在<code>view</code>里用，完全不用花钱。</p>
<p>以下是申明一个内存数组的例子：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function getArray() external pure returns(uint[]) {</span><br><span class="line">  // 初始化一个长度为3的内存数组</span><br><span class="line">  uint[] memory values = new uint[](3);</span><br><span class="line">  // 赋值</span><br><span class="line">  values.push(1);</span><br><span class="line">  values.push(2);</span><br><span class="line">  values.push(3);</span><br><span class="line">  // 返回数组</span><br><span class="line">  return values;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个小例子展示了一些语法规则，下一章中，我们将通过一个实际用例，展示它和 <code>for</code> 循环结合的做法。</p>
<blockquote>
<p>注意：内存数组 <strong>必须</strong> 用长度参数（在本例中为<code>3</code>）创建。目前不支持 <code>array.push()</code>之类的方法调整数组大小，在未来的版本可能会支持长度修改。</p>
</blockquote>
<p><strong>实战演习</strong></p>
<p>我们要要创建一个名为 <code>getZombiesByOwner</code> 的函数，它以<code>uint []</code>数组的形式返回某一用户所拥有的所有僵尸。</p>
<ol>
<li>声明一个名为<code>result</code>的<code>uint [] memory'</code> （内存变量数组）</li>
<li>将其设置为一个新的 <code>uint</code> 类型数组。数组的长度为该 <code>_owner</code> 所拥有的僵尸数量，这可通过调用 <code>ownerZombieCount [_ owner]</code> 来获取。</li>
<li>函数结束，返回 <code>result</code> 。目前它只是个空数列，我们到下一章去实现它。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function getZombiesByOwner(address _owner) external view returns(uint[]) {</span><br><span class="line">    // 在这里开始</span><br><span class="line">    uint[] memory result = new uint[](ownerZombieCount[_owner]);</span><br><span class="line">    return result;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第12章-For-循环"><a href="#第12章-For-循环" class="headerlink" title="第12章: For 循环"></a>第12章: For 循环</h3><p>在之前的章节中，我们提到过，函数中使用的数组是运行时在内存中通过 <code>for</code> 循环实时构建，而不是预先建立在存储中的。</p>
<p>为什么要这样做呢？</p>
<p>为了实现 <code>getZombiesByOwner</code> 函数，一种“无脑式”的解决方案是在 <code>ZombieFactory</code> 中存入”主人“和”僵尸军团“的映射。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapping (address =&gt; uint[]) public ownerToZombies</span><br></pre></td></tr></tbody></table></figure>

<p>然后我们每次创建新僵尸时，执行 <code>ownerToZombies [owner] .push（zombieId）</code> 将其添加到主人的僵尸数组中。而 <code>getZombiesByOwner</code> 函数也非常简单：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function getZombiesByOwner(address _owner) external view returns (uint[]) {</span><br><span class="line">  return ownerToZombies[_owner];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>这个做法有问题</strong></p>
<p>做法倒是简单。可是如果我们需要一个函数来把一头僵尸转移到另一个主人名下（我们一定会在后面的课程中实现的），又会发生什么？</p>
<p>这个“换主”函数要做到：</p>
<p>1.将僵尸push到新主人的 <code>ownerToZombies</code> 数组中， 2.从旧主的 <code>ownerToZombies</code> 数组中移除僵尸， 3.将旧主僵尸数组中“换主僵尸”之后的的每头僵尸都往前挪一位，把挪走“换主僵尸”后留下的“空槽”填上， 4.将数组长度减1。</p>
<p>但是第三步实在是太贵了！因为每挪动一头僵尸，我们都要执行一次写操作。如果一个主人有20头僵尸，而第一头被挪走了，那为了保持数组的顺序，我们得做19个写操作。</p>
<p>由于写入存储是 Solidity 中最费 gas 的操作之一，使得换主函数的每次调用都非常昂贵。更糟糕的是，每次调用的时候花费的 gas 都不同！具体还取决于用户在原主军团中的僵尸头数，以及移走的僵尸所在的位置。以至于用户都不知道应该支付多少 gas。</p>
<blockquote>
<p>注意：当然，我们也可以把数组中最后一个僵尸往前挪来填补空槽，并将数组长度减少一。但这样每做一笔交易，都会改变僵尸军团的秩序。</p>
</blockquote>
<p>由于从外部调用一个 <code>view</code> 函数是免费的，我们也可以在 <code>getZombiesByOwner</code> 函数中用一个for循环遍历整个僵尸数组，把属于某个主人的僵尸挑出来构建出僵尸数组。那么我们的 <code>transfer</code> 函数将会便宜得多，因为我们不需要挪动存储里的僵尸数组重新排序，总体上这个方法会更便宜，虽然有点反直觉。</p>
<p><strong>使用 <code>for</code> 循环</strong></p>
<p><code>for</code>循环的语法在 Solidity 和 JavaScript 中类似。</p>
<p>来看一个创建偶数数组的例子：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function getEvens() pure external returns(uint[]) {</span><br><span class="line">  uint[] memory evens = new uint[](5);</span><br><span class="line">  // 在新数组中记录序列号</span><br><span class="line">  uint counter = 0;</span><br><span class="line">  // 在循环从1迭代到10：</span><br><span class="line">  for (uint i = 1; i &lt;= 10; i++) {</span><br><span class="line">    // 如果 `i` 是偶数...</span><br><span class="line">    if (i % 2 == 0) {</span><br><span class="line">      // 把它加入偶数数组</span><br><span class="line">      evens[counter] = i;</span><br><span class="line">      //索引加一， 指向下一个空的‘even’</span><br><span class="line">      counter++;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  return evens;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个函数将返回一个形为 <code>[2,4,6,8,10]</code> 的数组。</p>
<p><strong>实战演习</strong></p>
<p>我们回到 <code>getZombiesByOwner</code> 函数， 通过一条 <code>for</code> 循环来遍历 DApp 中所有的僵尸， 将给定的‘用户id’与每头僵尸的‘主人’进行比较，并在函数返回之前将它们推送到我们的<code>result</code> 数组中。</p>
<p>1.声明一个变量 <code>counter</code>，属性为 <code>uint</code>，设其值为 <code>0</code> 。我们用这个变量作为 <code>result</code> 数组的索引。</p>
<p>2.声明一个 <code>for</code> 循环， 从 <code>uint i = 0</code> 到 <code>i &lt;zombies.length</code>。它将遍历数组中的每一头僵尸。</p>
<p>3.在每一轮 <code>for</code> 循环中，用一个 <code>if</code> 语句来检查 <code>zombieToOwner [i]</code> 是否等于 <code>_owner</code>。这会比较两个地址是否匹配。</p>
<p>4.在 <code>if</code> 语句中：</p>
<ol>
<li>通过将 <code>result [counter]</code> 设置为 <code>i</code>，将僵尸ID添加到 <code>result</code> 数组中。</li>
<li>将counter加1（参见上面的for循环示例）。</li>
</ol>
<p>就是这样 - 这个函数能返回 <code>_owner</code> 所拥有的僵尸数组，不花一分钱 gas。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function getZombiesByOwner(address _owner) external view returns(uint[]) {</span><br><span class="line">    uint[] memory result = new uint[](ownerZombieCount[_owner]);</span><br><span class="line">    // 在这里开始</span><br><span class="line">    uint counter = 0;</span><br><span class="line">    for(uint i = 0; i &lt;zombies.length; i++){</span><br><span class="line">      if(zombieToOwner[i] == _owner){</span><br><span class="line">        result[counter] = i;</span><br><span class="line">        counter++;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    return result;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第13章-放在一起"><a href="#第13章-放在一起" class="headerlink" title="第13章: 放在一起"></a>第13章: 放在一起</h3><p>恭喜您啊，居然把第三课也学完了！</p>
<p><strong>让我们回顾一下：</strong></p>
<ul>
<li>添加了一种新方法来修改CryptoKitties合约</li>
<li>学会使用 <code>onlyOwner</code> 进行调用权限限制</li>
<li>了解了 gas 和 gas 的优化</li>
<li>为僵尸添加了 “级别” 和 “冷却周期”属性</li>
<li>当僵尸达到一定级别时，允许修改僵尸的名字和 DNA</li>
<li>最后，定义了一个函数，用以返回某个玩家的僵尸军团</li>
</ul>
<p><strong>领奖时间</strong></p>
<p>作为完成第三课的奖励，您的两个僵尸都已经升级了！</p>
<p>现在 NoName（你在第2课创建的小猫僵尸）已经升级到第2级，你可以调用 <code>changeName</code> 给它取个名字。 终于不再是无名之辈了！</p>
<p>去给您的 NoName 取个名字吧，等你做完下一章，本课程就结束了。</p>

      
    </div>
    <footer class="article-footer">
      
      
      
      
      
      
      
      
      

    </footer>
  </div>
  
  <nav id="article-nav" data-aos="fade-up">
    
    
    
    <div class="article-nav-link-wrap article-nav-link-right">
      
        
        
          <img data-src="/covers/1.jpg" data-sizes="auto" alt="Unphishable钓鱼攻防挑战" class="lazyload">
        
      
      <a href="/2025/08/10/unphishable-diao-yu-gong-fang-tiao-zhan/"></a>
      <div class="article-nav-caption">Older</div>
      <h3 class="article-nav-title">
        
          Unphishable钓鱼攻防挑战
        
      </h3>
    </div>
    
  </nav>


</article>










</section>
        </div>
        <footer id="footer">
  <div style="width: 100%; overflow: hidden">
    <div class="footer-line"></div>
  </div>
  <div id="footer-info">
    
    <div>
      <span class="icon-copyright"></span>
      
      
      
        2024-2025
      
      <span class="footer-info-sep "></span>
      mX1@0
    </div>
    
      <div>
        Powered by&nbsp;<a href="https://hexo.io/" rel="noopener external nofollow noreferrer" target="_blank">Hexo</a>&nbsp;
        Theme.<a href="https://github.com/D-Sketon/hexo-theme-reimu" rel="noopener external nofollow noreferrer" target="_blank">Reimu</a>
      </div>
    
    
      <div>
        <span class="icon-brush"></span>
        222.2k
        &nbsp;|&nbsp;
        <span class="icon-coffee"></span>
        13:41
      </div>
    
    
    
    
      <div>
        <span class="icon-eye"></span>
        <span id="busuanzi_container_site_pv">Number of visits&nbsp;<span id="busuanzi_value_site_pv"></span></span>
        &nbsp;|&nbsp;
        <span class="icon-user"></span>
        <span id="busuanzi_container_site_uv">Number of visitors&nbsp;<span id="busuanzi_value_site_uv"></span></span>
      </div>
    
  </div>
</footer>

        
          <div class="sidebar-top">
            <div class="sidebar-top-taichi rotate"></div>
            <div class="arrow-up"></div>
          </div>
        
        <div id="mask" class="hide"></div>
      </div>
      <nav id="mobile-nav">
  <div class="sidebar-wrap">
    
      
        <div class="sidebar-toc-sidebar"><div class="sidebar-toc">
  <h3 class="toc-title">Contents</h3>
  <div class="sidebar-toc-wrapper toc-div-class" >
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#CryptoZombiesx%E7%9A%84solidity%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.</span> <span class="toc-text">CryptoZombiesx的solidity学习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Solidity-Beginner-to-Intermediate-Smart-Contracts"><span class="toc-number">1.1.</span> <span class="toc-text">Solidity: Beginner to Intermediate Smart Contracts</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lesson1-%E6%90%AD%E5%BB%BA%E5%83%B5%E5%B0%B8%E5%B7%A5%E5%8E%82"><span class="toc-number">1.2.</span> <span class="toc-text">lesson1 搭建僵尸工厂</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E5%90%88%E7%BA%A6"><span class="toc-number">1.2.1.</span> <span class="toc-text">第2章: 合约</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B4%E6%95%B0"><span class="toc-number">1.2.2.</span> <span class="toc-text">第3章: 状态变量和整数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97"><span class="toc-number">1.2.3.</span> <span class="toc-text">第4章: 数学运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.2.4.</span> <span class="toc-text">第5章: 结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E6%95%B0%E7%BB%84"><span class="toc-number">1.2.5.</span> <span class="toc-text">第6章: 数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.6.</span> <span class="toc-text">第7章: 定义函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-number">1.2.7.</span> <span class="toc-text">第8章: 使用结构体和数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-%E7%A7%81%E6%9C%89-%E5%85%AC%E5%85%B1%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.8.</span> <span class="toc-text">第9章: 私有 &#x2F; 公共函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-%E5%87%BD%E6%95%B0%E7%9A%84%E6%9B%B4%E5%A4%9A%E5%B1%9E%E6%80%A7"><span class="toc-number">1.2.9.</span> <span class="toc-text">第10章: 函数的更多属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-Keccak256-%E5%92%8C-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.2.10.</span> <span class="toc-text">第11章: Keccak256 和 类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-%E6%94%BE%E5%9C%A8%E4%B8%80%E8%B5%B7"><span class="toc-number">1.2.11.</span> <span class="toc-text">第12章: 放在一起</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.2.12.</span> <span class="toc-text">第13章: 事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-Web3-js"><span class="toc-number">1.2.13.</span> <span class="toc-text">第14章: Web3.js</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lesson2-%E5%83%B5%E5%B0%B8%E6%94%BB%E5%87%BB%E4%BA%BA%E7%B1%BB"><span class="toc-number">1.3.</span> <span class="toc-text">lesson2 僵尸攻击人类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E6%98%A0%E5%B0%84%EF%BC%88Mapping%EF%BC%89%E5%92%8C%E5%9C%B0%E5%9D%80%EF%BC%88Address%EF%BC%89"><span class="toc-number">1.3.1.</span> <span class="toc-text">第2章: 映射（Mapping）和地址（Address）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-Msg-sender"><span class="toc-number">1.3.2.</span> <span class="toc-text">第3章: Msg.sender</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-Require"><span class="toc-number">1.3.3.</span> <span class="toc-text">第4章: Require</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E7%BB%A7%E6%89%BF%EF%BC%88Inheritance%EF%BC%89"><span class="toc-number">1.3.4.</span> <span class="toc-text">第5章: 继承（Inheritance）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E5%BC%95%E5%85%A5%EF%BC%88Import%EF%BC%89"><span class="toc-number">1.3.5.</span> <span class="toc-text">第6章: 引入（Import）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-Storage%E4%B8%8EMemory"><span class="toc-number">1.3.6.</span> <span class="toc-text">第7章: Storage与Memory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E5%83%B5%E5%B0%B8%E7%9A%84DNA"><span class="toc-number">1.3.7.</span> <span class="toc-text">第8章: 僵尸的DNA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-%E6%9B%B4%E5%A4%9A%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">1.3.8.</span> <span class="toc-text">第9章: 更多关于函数可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-%E5%83%B5%E5%B0%B8%E5%90%83%E4%BB%80%E4%B9%88"><span class="toc-number">1.3.9.</span> <span class="toc-text">第10章: 僵尸吃什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.3.10.</span> <span class="toc-text">第11章: 使用接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-%E5%A4%84%E7%90%86%E5%A4%9A%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.3.11.</span> <span class="toc-text">第12章: 处理多返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-%E5%A5%96%E5%8A%B1-Kitty-%E5%9F%BA%E5%9B%A0"><span class="toc-number">1.3.12.</span> <span class="toc-text">第13章: 奖励: Kitty 基因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-%E6%94%BE%E5%9C%A8%E4%B8%80%E8%B5%B7"><span class="toc-number">1.3.13.</span> <span class="toc-text">第14章: 放在一起</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lesson3-%E9%AB%98%E7%BA%A7-Solidity-%E7%90%86%E8%AE%BA"><span class="toc-number">1.4.</span> <span class="toc-text">lesson3 高级 Solidity 理论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-%E6%99%BA%E8%83%BD%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%B0%B8%E5%9B%BA%E6%80%A7"><span class="toc-number">1.4.1.</span> <span class="toc-text">第1章: 智能协议的永固性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-Ownable-Contracts"><span class="toc-number">1.4.2.</span> <span class="toc-text">第2章: Ownable Contracts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-onlyOwner-%E5%87%BD%E6%95%B0%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">1.4.3.</span> <span class="toc-text">第3章: onlyOwner 函数修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-Gas"><span class="toc-number">1.4.4.</span> <span class="toc-text">第4章: Gas</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E6%97%B6%E9%97%B4%E5%8D%95%E4%BD%8D"><span class="toc-number">1.4.5.</span> <span class="toc-text">第5章: 时间单位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E5%83%B5%E5%B0%B8%E5%86%B7%E5%8D%B4"><span class="toc-number">1.4.6.</span> <span class="toc-text">第6章: 僵尸冷却</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-%E5%85%AC%E6%9C%89%E5%87%BD%E6%95%B0%E5%92%8C%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">1.4.7.</span> <span class="toc-text">第7章: 公有函数和安全性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%87%BD%E6%95%B0%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">1.4.8.</span> <span class="toc-text">第8章: 进一步了解函数修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-%E5%83%B5%E5%B0%B8%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">1.4.9.</span> <span class="toc-text">第9章: 僵尸修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-%E5%88%A9%E7%94%A8-%E2%80%98View%E2%80%99-%E5%87%BD%E6%95%B0%E8%8A%82%E7%9C%81-Gas"><span class="toc-number">1.4.10.</span> <span class="toc-text">第10章: 利用 ‘View’ 函数节省 Gas</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-%E5%AD%98%E5%82%A8%E9%9D%9E%E5%B8%B8%E6%98%82%E8%B4%B5"><span class="toc-number">1.4.11.</span> <span class="toc-text">第11章: 存储非常昂贵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-For-%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.4.12.</span> <span class="toc-text">第12章: For 循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-%E6%94%BE%E5%9C%A8%E4%B8%80%E8%B5%B7"><span class="toc-number">1.4.13.</span> <span class="toc-text">第13章: 放在一起</span></a></li></ol></li></ol></li></ol>
      
  </div>
</div>
</div>
        <div class="sidebar-common-sidebar hidden"><div class="sidebar-author">
  <img data-src="/avatar/avatar.webp" data-sizes="auto" alt="mX1@0" class="lazyload">
  <div class="sidebar-author-name">mX1@0</div>
  <div class="sidebar-description"></div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>Post</div>
    <div class="sidebar-state-number">63</div>
  </div>
  <div class="sidebar-state-category">
    <div>Category</div>
    <div class="sidebar-state-number">18</div>
  </div>
  <div class="sidebar-state-tag">
    <div>Tag</div>
    <div class="sidebar-state-number">24</div>
  </div>
</div>
<div class="sidebar-social">
  
    <div class="icon-twitter sidebar-social-icon">
      <a href=https://x.com/0xMx1a0 itemprop="url" target="_blank" aria-label="twitter" rel="noopener external nofollow noreferrer"></a>
    </div>
  
</div>
<div class="sidebar-menu">
  
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/" aria-label="首页"></a>
        <div class="sidebar-menu-icon icon rotate">
          
            &#xe62b;
          
        </div>
        <div class="sidebar-menu-link">首页</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/archives" aria-label="归类"></a>
        <div class="sidebar-menu-icon icon rotate">
          
            &#xe62b;
          
        </div>
        <div class="sidebar-menu-link">归类</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/about" aria-label="关于"></a>
        <div class="sidebar-menu-icon icon rotate">
          
            &#xe62b;
          
        </div>
        <div class="sidebar-menu-link">关于</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/friend" aria-label="友链"></a>
        <div class="sidebar-menu-icon icon rotate">
          
            &#xe62b;
          
        </div>
        <div class="sidebar-menu-link">友链</div>
      </div>
    
  
</div>
</div>
      
    
  </div>
  
    
      <div class="sidebar-btn-wrapper">
        <div class="sidebar-toc-btn current"></div>
        <div class="sidebar-common-btn"></div>
      </div>
    
  
</nav>

    </div>
    
    
    
    
<script src="https://npm.webcache.cn/lazysizes@5.3.2/lazysizes.min.js" integrity="sha384-3gT&#x2F;vsepWkfz&#x2F;ff7PpWNUeMzeWoH3cDhm&#x2F;A8jM7ouoAK0&#x2F;fP&#x2F;9bcHHR5kHq2nf+e" crossorigin="anonymous"></script>


<script src="https://npm.webcache.cn/clipboard@2.0.11/dist/clipboard.min.js" integrity="sha384-J08i8An&#x2F;QeARD9ExYpvphB8BsyOj3Gh2TSh1aLINKO3L0cMSH2dN3E22zFoXEi0Q" crossorigin="anonymous"></script>





<script src="/js/script.js"></script>



  
<script src="/js/aos.js"></script>

  <script>
    var aosInit = () => {
      AOS.init({
        duration: 1000,
        easing: "ease",
        once: true,
        offset: 50,
      });
    };
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', aosInit);
    } else {
      aosInit();
    }
  </script>



<script src="/js/pjax_script.js" data-pjax></script>







  
<script src="https://npm.webcache.cn/mouse-firework@0.1.1/dist/index.umd.js" integrity="sha384-8LyaidD9GPxQQgLJO&#x2F;WRw&#x2F;O2h3BoNq&#x2F;ApI&#x2F;ecpvM6RsrCz2qP2ppBXUKihP4V&#x2F;2d" crossorigin="anonymous"></script>

  <script>
    window.firework && window.firework(JSON.parse('{"excludeElements":["a","button"],"particles":[{"shape":"circle","move":["emit"],"easing":"easeOutExpo","colors":["var(--red-1)","var(--red-2)","var(--red-3)","var(--red-4)"],"number":20,"duration":[1200,1800],"shapeOptions":{"radius":[16,32],"alpha":[0.3,0.5]}},{"shape":"circle","move":["diffuse"],"easing":"easeOutExpo","colors":["var(--red-0)"],"number":1,"duration":[1200,1800],"shapeOptions":{"radius":20,"alpha":[0.2,0.5],"lineWidth":6}}]}'))
  </script>










<div id="lazy-script">
  <div>
    
      
      
      <script data-pjax>
        window.REIMU_POST = {
          author: "mX1@0",
          title: "CryptoZombiesx的solidity学习",
          url: "http://example.com/2025/08/10/cryptozombiesx-de-solidity-xue-xi/",
          excerpt: "",
          description: "",
          stripContent: "CryptoZombiesx的solidity学习Solidity: Beginner to Intermediate Smart Contractslesson1 搭建僵尸工厂第2章: 合约从最基本的开始入手: Solidity 的代码都包裹在合约里面. 一份合约就是以太应币应用的基本模块， 所有的变量和函数都属于一份合约, 它是你所有应用的起点. 一份名为 HelloWorld 的空合约如下: 123contract HelloWorld {}  版本指令 所有的 Solidity 源码都必",
          date: "Sun Aug 10 2025 23:38:00 GMT+0800",
          updated: "Tue Aug 12 2025 01:12:23 GMT+0800",
          cover: "/images/%E7%8E%9B%E8%8E%8E%E6%8B%89%E8%92%82.jpg",
        };
      </script>
       
    
    
      
        
<script src="/js/insert_highlight.js" data-pjax></script>

        
      
    
    
      <script type="module" data-pjax>
        const PhotoSwipeLightbox = (await safeImport("https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe-lightbox.esm.min.js", "sha384-DiL6M/gG+wmTxmCRZyD1zee6lIhawn5TGvED0FOh7fXcN9B0aZ9dexSF/N6lrZi/")).default;
        
        const pswp = () => {
          if (_$$('.article-entry a.article-gallery-item').length > 0) {
            new PhotoSwipeLightbox({
              gallery: '.article-entry',
              children: 'a.article-gallery-item',
              pswpModule: () => safeImport("https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8+oTJ7m3DfYEWX1fu1scuS4+s")
            }).init();
          }
          if(_$$('.article-gallery a.article-gallery-item').length > 0) {
            new PhotoSwipeLightbox({
              gallery: '.article-gallery',
              children: 'a.article-gallery-item',
              pswpModule: () => safeImport("https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8+oTJ7m3DfYEWX1fu1scuS4+s")
            }).init();
          }
          window.lightboxStatus = 'done';
          window.removeEventListener('lightbox:ready', pswp);
        }
        if(window.lightboxStatus === 'ready') {
          pswp()
        } else {
          window.addEventListener('lightbox:ready', pswp);
        }
      </script>
      
        








      
    
  </div>
</div>


  <script>
    console.log(String.raw`%c 
 ______     ______     __     __    __     __  __    
/\  == \   /\  ___\   /\ \   /\ "-./  \   /\ \/\ \   
\ \  __<   \ \  __\   \ \ \  \ \ \-./\ \  \ \ \_\ \  
 \ \_\ \_\  \ \_____\  \ \_\  \ \_\ \ \_\  \ \_____\ 
  \/_/ /_/   \/_____/   \/_/   \/_/  \/_/   \/_____/ 
                                                  
`,'color: #ff5252;')
    console.log('%c Theme.Reimu v' + '1.9.0' + ' %c https://github.com/D-Sketon/hexo-theme-reimu ', 'color: white; background: #ff5252; padding:5px 0;', 'padding:4px;border:1px solid #ff5252;')
  </script>
  



  
<script src="https://npm.webcache.cn/busuanzi@2.3.0/bsz.pure.mini.js" integrity="sha384-0M75wtSkhjIInv4coYlaJU83+OypaRCIq2SukQVQX04eGTCBXJDuWAbJet56id+S" crossorigin="anonymous" async></script>




<script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.getRegistrations().then((registrations) => {
      for (let registration of registrations) {
        registration.unregister();
      }
    });
  }
</script>









    
  </body>
  </html>

