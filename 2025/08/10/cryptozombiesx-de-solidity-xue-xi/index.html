
  <!DOCTYPE html>
  <html lang="en"  
    
      data-theme-mode="auto"
    
  >
  <head>
  
  <meta charset="utf-8">
  

  

  

  <script>window.REIMU_CONFIG = {};window.REIMU_CONFIG.icon_font = '4552607_0khxww3tj3q9';window.REIMU_CONFIG.clipboard_tips = {"success":{"en":"复制成功","zh-CN":"复制成功","zh-TW":"複製成功 (*^▽^*)","ja":"コピー成功 (*^▽^*)","pt-BR":"Copiado com sucesso (*^▽^*)"},"fail":{"en":"复制失败","zh-CN":"复制失败","zh-TW":"複製失敗 (ﾟ⊿ﾟ)ﾂ","ja":"コピー失敗 (ﾟ⊿ﾟ)ﾂ","pt-BR":"Falha ao copiar (ﾟ⊿ﾟ)ﾂ"},"copyright":{"enable":false,"count":50,"license_type":"by-nc-sa"}};window.REIMU_CONFIG.clipboard_tips.copyright.content = 'All articles on this blog are licensed under the BY-NC-SA license agreement unless otherwise stated. Please indicate the source when reprinting!';window.REIMU_CONFIG.code_block = {"expand":true};window.REIMU_CONFIG.base = 'http://example.com';</script>
  
  <title>
    CryptoZombiesx的Solidity学习 |
    
    mX1@0_blog
  </title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
  
    <link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin><link rel="preload" as="style" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic&display=swap"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic&display=swap" media="print" onload="this.media&#x3D;&#39;all&#39;">
  
  
    <link rel="preload" href="//at.alicdn.com/t/c/font_4552607_0khxww3tj3q9.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  
  
    
<link rel="stylesheet" href="/css/loader.css">

  
  
    <meta name="description" content="CryptoZombiesx的solidity学习Solidity: Beginner to Intermediate Smart Contractslesson1 搭建僵尸工厂第2章: 合约从最基本的开始入手: Solidity 的代码都包裹在合约里面. 一份合约就是以太应币应用的基本模块， 所有的变量和函数都属于一份合约, 它是你所有应用的起点. 一份名为 HelloWorld 的空合约如下:">
<meta property="og:type" content="article">
<meta property="og:title" content="CryptoZombiesx的Solidity学习">
<meta property="og:url" content="http://example.com/2025/08/10/cryptozombiesx-de-solidity-xue-xi/index.html">
<meta property="og:site_name" content="mX1@0_blog">
<meta property="og:description" content="CryptoZombiesx的solidity学习Solidity: Beginner to Intermediate Smart Contractslesson1 搭建僵尸工厂第2章: 合约从最基本的开始入手: Solidity 的代码都包裹在合约里面. 一份合约就是以太应币应用的基本模块， 所有的变量和函数都属于一份合约, 它是你所有应用的起点. 一份名为 HelloWorld 的空合约如下:">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-08-10T15:38:00.671Z">
<meta property="article:modified_time" content="2025-08-20T09:38:52.963Z">
<meta property="article:author" content="mX1@0">
<meta property="article:tag" content="智能合约">
<meta property="article:tag" content="Solidity">
<meta property="article:tag" content="编程语言">
<meta name="twitter:card" content="summary">
  
  
  
    <link rel="shortcut icon" href="/images/%E5%9B%BE1.jpg">
  
  
<link rel="stylesheet" href="/css/style.css">

  <link rel="preload" as="style" onload="this.onload&#x3D;null;this.rel&#x3D;&#39;stylesheet&#39;" href="https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.css" integrity="sha384-IfxC36XL&#x2F;toUyJ939C73PcgMuRzAZuIzZxE38drsmO5p6jD7ei+Zx&#x2F;1oA&#x2F;0l8ysE" crossorigin="anonymous">
  
  
  
  
    
<script src="https://npm.webcache.cn/pace-js@1.2.4/pace.min.js" integrity="sha384-k6YtvFUEIuEFBdrLKJ3YAUbBki333tj1CSUisai5Cswsg9wcLNaPzsTHDswp4Az8" crossorigin="anonymous"></script>

  
  
    
<link rel="stylesheet" href="https://npm.webcache.cn/@reimujs/aos@0.1.2/dist/aos.css" integrity="sha384-GMRP93c6Hkz9JVKGAuRR3nTS7M07RwPgTFenXiosjq2VbVgvdDNcz1g6Mkj8AONa" crossorigin="anonymous">

  
  
  
<meta name="generator" content="Hexo 7.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

  <body>
    
    
  <div id='loader'>
    <div class="loading-left-bg loading-bg"></div>
    <div class="loading-right-bg loading-bg"></div>
    <div class="spinner-box">
      <div class="loading-taichi rotate">
        
          <svg width="150" height="150" viewBox="0 0 1024 1024" class="icon" version="1.1" xmlns="https://www.w3.org/2000/svg" shape-rendering="geometricPrecision">
            <path d="M303.5 432A80 80 0 0 1 291.5 592A80 80 0 0 1 303.5 432z" fill="var(--red-1, #ff5252)" />
            <path d="M512 65A447 447 0 0 1 512 959L512 929A417 417 0 0 0 512 95A417 417 0 0 0 512 929L512 959A447 447 0 0 1 512 65z 
           M512 95A417 417 0 0 1 929 512A208.5 208.5 0 0 1 720.5 720.5L720.5 592A80 80 0 0 0 720.5 432A80 80 0 0 0 720.5 592L720.5 720.5A208.5 208.5 0 0 1 512 512A208.5 208.5 0 0 0 303.5 303.5A208.5 208.5 0 0 0 95 512A417 417 0 0 1 512 95z" fill="var(--red-1, #ff5252)" />
          </svg>
        
      </div>
      
      
        
      
      <div class="loading-word">加载中...</div>
    </div>
  </div>
  </div>
  <script>
    var time = null;
    var startLoading = () => {
      time = Date.now();
      document.getElementById('loader').classList.remove("loading");
    }
    var endLoading = () => {
      if (!time) {
        document.body.style.overflow = 'auto';
        document.getElementById('loader').classList.add("loading");
      } else {
        if (Date.now() - time > 500) {
          time = null;
          document.body.style.overflow = 'auto';
          document.getElementById('loader').classList.add("loading");
        } else {
          setTimeout(endLoading, 500 - (Date.now() - time));
          time = null;
        }
      }
    }
    window.addEventListener('DOMContentLoaded', endLoading);
    document.getElementById('loader').addEventListener('click', endLoading);
  </script>

<div id="copy-tooltip" style="pointer-events: none; opacity: 0; transition: all 0.2s ease; position: fixed;top: 50%;left: 50%;z-index: 999;transform: translate(-50%, -50%);color: white;background: rgba(0, 0, 0, 0.5);padding: 10px 15px;border-radius: 10px;">
</div>
<div id="heatmap-tooltip"></div>


    <div id="container">
      <div id="wrap">
        <div id="header-nav">
  <nav id="main-nav">
    
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
             
              &#xe62b;
             
          </div>
          <a class="main-nav-link" href="/">首页</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
             
              &#xe62b;
             
          </div>
          <a class="main-nav-link" href="/archives">归类</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
             
              &#xe62b;
             
          </div>
          <a class="main-nav-link" href="/about">关于</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
             
              &#xe62b;
             
          </div>
          <a class="main-nav-link" href="/friend">友链</a>
        </span>
      
    
    <a id="main-nav-toggle" class="nav-icon"></a>
  </nav>
  <nav id="sub-nav">
    
    
    
  </nav>
  
</div>
<header id="header">
  
    
      
        <picture>
          
        </picture>
        
          <img  fetchpriority="high" src="/images/%E7%8E%9B%E8%8E%8E%E6%8B%89%E8%92%82.jpg" alt="CryptoZombiesx的Solidity学习">
        
      
    
  
  <div id="header-outer">
    <div id="header-title">
      
        
        
          <a href="/" id="logo">
            <h1 data-aos="slide-up">CryptoZombiesx的Solidity学习</h1>
          </a>
        
      
      
        
        <h2 id="subtitle-wrap" data-aos="slide-down">
          
        </h2>
      
    </div>
  </div>
</header>

        <div id="content" class="sidebar-left"  >
          <aside id="sidebar">
  
  
  
  <div class="sidebar-wrapper wrap-sticky">
    <div class="sidebar-wrap" data-aos="fade-up">
      
        
          <div class="sidebar-toc-sidebar"><div class="sidebar-toc">
  <h3 class="toc-title">Contents</h3>
  <div class="sidebar-toc-wrapper toc-div-class" >
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#CryptoZombiesx%E7%9A%84solidity%E5%AD%A6%E4%B9%A0"><span class="toc-text">CryptoZombiesx的solidity学习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Solidity-Beginner-to-Intermediate-Smart-Contracts"><span class="toc-text">Solidity: Beginner to Intermediate Smart Contracts</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lesson1-%E6%90%AD%E5%BB%BA%E5%83%B5%E5%B0%B8%E5%B7%A5%E5%8E%82"><span class="toc-text">lesson1 搭建僵尸工厂</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E5%90%88%E7%BA%A6"><span class="toc-text">第2章: 合约</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B4%E6%95%B0"><span class="toc-text">第3章: 状态变量和整数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97"><span class="toc-text">第4章: 数学运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">第5章: 结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E6%95%B0%E7%BB%84"><span class="toc-text">第6章: 数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><span class="toc-text">第7章: 定义函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-text">第8章: 使用结构体和数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-%E7%A7%81%E6%9C%89-%E5%85%AC%E5%85%B1%E5%87%BD%E6%95%B0"><span class="toc-text">第9章: 私有 &#x2F; 公共函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-%E5%87%BD%E6%95%B0%E7%9A%84%E6%9B%B4%E5%A4%9A%E5%B1%9E%E6%80%A7"><span class="toc-text">第10章: 函数的更多属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-Keccak256-%E5%92%8C-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">第11章: Keccak256 和 类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-%E6%94%BE%E5%9C%A8%E4%B8%80%E8%B5%B7"><span class="toc-text">第12章: 放在一起</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-%E4%BA%8B%E4%BB%B6"><span class="toc-text">第13章: 事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-Web3-js"><span class="toc-text">第14章: Web3.js</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lesson2-%E5%83%B5%E5%B0%B8%E6%94%BB%E5%87%BB%E4%BA%BA%E7%B1%BB"><span class="toc-text">lesson2 僵尸攻击人类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E6%98%A0%E5%B0%84%EF%BC%88Mapping%EF%BC%89%E5%92%8C%E5%9C%B0%E5%9D%80%EF%BC%88Address%EF%BC%89"><span class="toc-text">第2章: 映射（Mapping）和地址（Address）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-Msg-sender"><span class="toc-text">第3章: Msg.sender</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-Require"><span class="toc-text">第4章: Require</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E7%BB%A7%E6%89%BF%EF%BC%88Inheritance%EF%BC%89"><span class="toc-text">第5章: 继承（Inheritance）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E5%BC%95%E5%85%A5%EF%BC%88Import%EF%BC%89"><span class="toc-text">第6章: 引入（Import）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-Storage%E4%B8%8EMemory"><span class="toc-text">第7章: Storage与Memory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E5%83%B5%E5%B0%B8%E7%9A%84DNA"><span class="toc-text">第8章: 僵尸的DNA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-%E6%9B%B4%E5%A4%9A%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-text">第9章: 更多关于函数可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-%E5%83%B5%E5%B0%B8%E5%90%83%E4%BB%80%E4%B9%88"><span class="toc-text">第10章: 僵尸吃什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3"><span class="toc-text">第11章: 使用接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-%E5%A4%84%E7%90%86%E5%A4%9A%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">第12章: 处理多返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-%E5%A5%96%E5%8A%B1-Kitty-%E5%9F%BA%E5%9B%A0"><span class="toc-text">第13章: 奖励: Kitty 基因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-%E6%94%BE%E5%9C%A8%E4%B8%80%E8%B5%B7"><span class="toc-text">第14章: 放在一起</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lesson3-%E9%AB%98%E7%BA%A7-Solidity-%E7%90%86%E8%AE%BA"><span class="toc-text">lesson3 高级 Solidity 理论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-%E6%99%BA%E8%83%BD%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%B0%B8%E5%9B%BA%E6%80%A7"><span class="toc-text">第1章: 智能协议的永固性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-Ownable-Contracts"><span class="toc-text">第2章: Ownable Contracts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-onlyOwner-%E5%87%BD%E6%95%B0%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">第3章: onlyOwner 函数修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-Gas"><span class="toc-text">第4章: Gas</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E6%97%B6%E9%97%B4%E5%8D%95%E4%BD%8D"><span class="toc-text">第5章: 时间单位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E5%83%B5%E5%B0%B8%E5%86%B7%E5%8D%B4"><span class="toc-text">第6章: 僵尸冷却</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-%E5%85%AC%E6%9C%89%E5%87%BD%E6%95%B0%E5%92%8C%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-text">第7章: 公有函数和安全性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%87%BD%E6%95%B0%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">第8章: 进一步了解函数修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-%E5%83%B5%E5%B0%B8%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">第9章: 僵尸修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-%E5%88%A9%E7%94%A8-%E2%80%98View%E2%80%99-%E5%87%BD%E6%95%B0%E8%8A%82%E7%9C%81-Gas"><span class="toc-text">第10章: 利用 ‘View’ 函数节省 Gas</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-%E5%AD%98%E5%82%A8%E9%9D%9E%E5%B8%B8%E6%98%82%E8%B4%B5"><span class="toc-text">第11章: 存储非常昂贵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-For-%E5%BE%AA%E7%8E%AF"><span class="toc-text">第12章: For 循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-%E6%94%BE%E5%9C%A8%E4%B8%80%E8%B5%B7"><span class="toc-text">第13章: 放在一起</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lesson4-%E5%83%B5%E5%B0%B8%E4%BD%9C%E6%88%98%E7%B3%BB%E7%BB%9F"><span class="toc-text">lesson4 僵尸作战系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-%E5%8F%AF%E6%94%AF%E4%BB%98"><span class="toc-text">第1章: 可支付</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E6%8F%90%E7%8E%B0"><span class="toc-text">第2章: 提现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-%E5%83%B5%E5%B0%B8%E6%88%98%E6%96%97"><span class="toc-text">第3章: 僵尸战斗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="toc-text">第4章: 随机数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E5%83%B5%E5%B0%B8%E5%AF%B9%E6%88%98"><span class="toc-text">第5章: 僵尸对战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E9%87%8D%E6%9E%84%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91"><span class="toc-text">第6章: 重构通用逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-%E6%9B%B4%E5%A4%9A%E9%87%8D%E6%9E%84"><span class="toc-text">第7章: 更多重构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E5%9B%9E%E5%88%B0%E6%94%BB%E5%87%BB%EF%BC%81"><span class="toc-text">第8章: 回到攻击！</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-%E5%83%B5%E5%B0%B8%E7%9A%84%E8%BE%93%E8%B5%A2"><span class="toc-text">第9章: 僵尸的输赢</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-%E5%83%B5%E5%B0%B8%E8%83%9C%E5%88%A9%E4%BA%86-%F0%9F%98%84"><span class="toc-text">第10章: 僵尸胜利了 😄</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-%E5%83%B5%E5%B0%B8%E5%A4%B1%E8%B4%A5-%F0%9F%98%9E"><span class="toc-text">第11章: 僵尸失败 😞</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lesson5-ERC721-%E6%A0%87%E5%87%86%E5%92%8C%E5%8A%A0%E5%AF%86%E6%94%B6%E8%97%8F%E5%93%81"><span class="toc-text">lesson5 ERC721 标准和加密收藏品</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%B8%8A%E7%9A%84%E4%BB%A3%E5%B8%81"><span class="toc-text">第1章: 以太坊上的代币</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-ERC721-%E6%A0%87%E5%87%86-%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-text">第2章: ERC721 标准, 多重继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-balanceOf-%E5%92%8C-ownerOf"><span class="toc-text">第3章: balanceOf 和 ownerOf</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E9%87%8D%E6%9E%84"><span class="toc-text">第4章: 重构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-ERC721-%E8%BD%AC%E7%A7%BB%E6%A0%87%E5%87%86"><span class="toc-text">第5章: ERC721: 转移标准</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-ERC721-%E8%BD%AC%E7%A7%BB-%E7%BB%AD"><span class="toc-text">第6章: ERC721: 转移-续</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-ERC721-%E6%89%B9%E5%87%86"><span class="toc-text">第7章: ERC721: 批准</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-ERC721-takeOwnership"><span class="toc-text">第8章: ERC721: takeOwnership</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-%E9%A2%84%E9%98%B2%E6%BA%A2%E5%87%BA"><span class="toc-text">第9章: 预防溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-SafeMath-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86"><span class="toc-text">第10章: SafeMath 第二部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-SafeMath-%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86"><span class="toc-text">第11章: SafeMath 第三部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-SafeMath-%E7%AC%AC4%E9%83%A8%E5%88%86"><span class="toc-text">第12章: SafeMath 第4部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-%E6%B3%A8%E9%87%8A"><span class="toc-text">第13章: 注释</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B"><span class="toc-text">总结一下</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lesson6-%E5%BA%94%E7%94%A8%E5%89%8D%E7%AB%AF%E5%92%8C-Web3-js"><span class="toc-text">lesson6 应用前端和 Web3.js</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-%E4%BB%8B%E7%BB%8D-Web3-js"><span class="toc-text">第1章: 介绍 Web3.js</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-Web3-%E6%8F%90%E4%BE%9B%E8%80%85"><span class="toc-text">第2章: Web3 提供者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-%E5%92%8C%E5%90%88%E7%BA%A6%E5%AF%B9%E8%AF%9D"><span class="toc-text">第3章: 和合约对话</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E8%B0%83%E7%94%A8%E5%92%8C%E5%90%88%E7%BA%A6%E5%87%BD%E6%95%B0"><span class="toc-text">第4章: 调用和合约函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-MetaMask-%E5%92%8C%E8%B4%A6%E6%88%B7"><span class="toc-text">第5章: MetaMask 和账户</span></a></li></ol></li></ol></li></ol>
      
  </div>
</div>
</div>
          <div class="sidebar-common-sidebar hidden"><div class="sidebar-author">
  <img data-src="/avatar/avatar.webp" data-sizes="auto" alt="mX1@0" class="lazyload">
  <div class="sidebar-author-name">mX1@0</div>
  <div class="sidebar-description"></div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>Post</div>
    <div class="sidebar-state-number">54</div>
  </div>
  <div class="sidebar-state-category">
    <div>Category</div>
    <div class="sidebar-state-number">25</div>
  </div>
  <div class="sidebar-state-tag">
    <div>Tag</div>
    <div class="sidebar-state-number">65</div>
  </div>
</div>
<div class="sidebar-social">
  
    <div class="icon-twitter sidebar-social-icon">
      <a href=https://x.com/0xMx1a0 itemprop="url" target="_blank" aria-label="twitter" rel="noopener external nofollow noreferrer"></a>
    </div>
  
</div>
<div class="sidebar-menu">
  
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/" aria-label="首页"></a>
        <div class="sidebar-menu-icon icon rotate">
          
            &#xe62b;
          
        </div>
        <div class="sidebar-menu-link">首页</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/archives" aria-label="归类"></a>
        <div class="sidebar-menu-icon icon rotate">
          
            &#xe62b;
          
        </div>
        <div class="sidebar-menu-link">归类</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/about" aria-label="关于"></a>
        <div class="sidebar-menu-icon icon rotate">
          
            &#xe62b;
          
        </div>
        <div class="sidebar-menu-link">关于</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/friend" aria-label="友链"></a>
        <div class="sidebar-menu-icon icon rotate">
          
            &#xe62b;
          
        </div>
        <div class="sidebar-menu-link">友链</div>
      </div>
    
  
</div>
</div>
        
      
      
        
          <div class="sidebar-btn-wrapper" style="position:static">
            <div class="sidebar-toc-btn current"></div>
            <div class="sidebar-common-btn"></div>
          </div>
        
      
    </div>
  </div>

  <div class="sidebar-widget">
  
  </div>
  
</aside>

          <section id="main"><article id="post-CryptoZombiesx的Solidity学习" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner" data-aos="fade-up">
    <div class="article-meta">
      <div class="article-date">
  <span class="article-date-link" data-aos="zoom-in">
    <time datetime="2025-08-10T15:38:00.671Z" itemprop="datePublished">2025-08-10</time>
    <time style="display: none;" id="post-update-time">2025-08-20</time>
  </span>
</div>

      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" data-aos="zoom-in">编程语言</a>
  </div>


    </div>
    <div class="hr-line"></div>
    

    <div class="e-content article-entry" itemprop="articleBody">
      
      
        <h1 id="CryptoZombiesx的solidity学习"><a href="#CryptoZombiesx的solidity学习" class="headerlink" title="CryptoZombiesx的solidity学习"></a>CryptoZombiesx的solidity学习</h1><h2 id="Solidity-Beginner-to-Intermediate-Smart-Contracts"><a href="#Solidity-Beginner-to-Intermediate-Smart-Contracts" class="headerlink" title="Solidity: Beginner to Intermediate Smart Contracts"></a>Solidity: Beginner to Intermediate Smart Contracts</h2><h2 id="lesson1-搭建僵尸工厂"><a href="#lesson1-搭建僵尸工厂" class="headerlink" title="lesson1 搭建僵尸工厂"></a>lesson1 搭建僵尸工厂</h2><h3 id="第2章-合约"><a href="#第2章-合约" class="headerlink" title="第2章: 合约"></a>第2章: 合约</h3><p>从最基本的开始入手:</p>
<p>Solidity 的代码都包裹在<strong>合约</strong>里面. 一份<code>合约</code>就是以太应币应用的基本模块， 所有的变量和函数都属于一份合约, 它是你所有应用的起点.</p>
<p>一份名为 <code>HelloWorld</code> 的空合约如下:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract HelloWorld {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>版本指令</strong></p>
<p>所有的 Solidity 源码都必须冠以 “version pragma” — 标明 Solidity 编译器的版本. 以避免将来新的编译器可能破坏你的代码。</p>
<p>例如: <code>pragma solidity ^0.4.19;</code> (当前 Solidity 的最新版本是 0.4.19).</p>
<p>综上所述， 下面就是一个最基本的合约 — 每次建立一个新的项目时的第一段代码:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract HelloWorld {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实战演习</strong></p>
<p>为了建立我们的僵尸部队， 让我们先建立一个基础合约，称为 <code>ZombieFactory</code>。</p>
<ol>
<li>在右边的输入框里输入 <code>0.4.19</code>，我们的合约基于这个版本的编译器。</li>
<li>建立一个空合约 <code>ZombieFactory</code>。</li>
</ol>
<p>一切完毕，点击下面 “答案” . 如果没效果，点击 “提示”。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第3章-状态变量和整数"><a href="#第3章-状态变量和整数" class="headerlink" title="第3章: 状态变量和整数"></a>第3章: 状态变量和整数</h3><p>真棒！我们已经为我们的合约做了一个外壳， 下面学习 Solidity 中如何使用变量。</p>
<p><strong>状态变量</strong>是被永久地保存在合约中。也就是说它们被写入以太币区块链中. 想象成写入一个数据库。</p>
<p>例子:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">contract Example {</span><br><span class="line">  // 这个无符号整数将会永久的被保存在区块链中</span><br><span class="line">  uint myUnsignedInteger = 100;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在上面的例子中，定义 <code>myUnsignedInteger</code> 为 <code>uint</code> 类型，并赋值100。</p>
<p><strong>无符号整数: <code>uint</code></strong></p>
<p><code>uint</code> 无符号数据类型， 指<strong>其值不能是负数</strong>，对于有符号的整数存在名为 <code>int</code> 的数据类型。</p>
<blockquote>
<p>注: Solidity中， <code>uint</code> 实际上是 <code>uint256</code>代名词， 一个256位的无符号整数。你也可以定义位数少的uints — <code>uint8</code>， <code>uint16</code>， <code>uint32</code>， 等…… 但一般来讲你愿意使用简单的 <code>uint</code>， 除非在某些特殊情况下，这我们后面会讲。</p>
</blockquote>
<p><strong>实战演习</strong></p>
<p>我们的僵尸DNA将由一个十六位数字组成。</p>
<p>定义 <code>dnaDigits</code> 为 <code>uint</code> 数据类型, 并赋值 <code>16</code>。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第4章-数学运算"><a href="#第4章-数学运算" class="headerlink" title="第4章: 数学运算"></a>第4章: 数学运算</h3><p>在 Solidity 中，数学运算很直观明了，与其它程序设计语言相同:</p>
<ul>
<li>加法: <code>x + y</code></li>
<li>减法: <code>x - y</code>,</li>
<li>乘法: <code>x * y</code></li>
<li>除法: <code>x / y</code></li>
<li>取模 / 求余: <code>x % y</code> <em>(例如, <code>13 % 5</code> 余 <code>3</code>, 因为13除以5，余3)</em></li>
</ul>
<p>Solidity 还支持 *<strong>乘方操作*</strong> (如：x 的 y次方） // 例如： 5 ** 2 = 25</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint x = 5 ** 2; // equal to 5^2 = 25</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实战演习</strong></p>
<p>为了保证我们的僵尸的DNA只含有16个字符，我们先造一个<code>uint</code>数据，让它等于10^16。这样一来以后我们可以用模运算符 <code>%</code> 把一个整数变成16位。</p>
<ol>
<li>建立一个<code>uint</code>类型的变量，名字叫<code>dnaModulus</code>, 令其等于 <strong>10 的 <code>dnaDigits</code> 次方</strong>.</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第5章-结构体"><a href="#第5章-结构体" class="headerlink" title="第5章: 结构体"></a>第5章: 结构体</h3><p>有时你需要更复杂的数据类型，Solidity 提供了 <strong>结构体</strong>:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct Person {</span><br><span class="line">  uint age;</span><br><span class="line">  string name;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>结构体允许你生成一个更复杂的数据类型，它有多个属性。</p>
<blockquote>
<p>注：我们刚刚引进了一个新类型, <code>string</code>。 字符串用于保存任意长度的 UTF-8 编码数据。 如： <code>string greeting = "Hello world!"</code>。</p>
</blockquote>
<p><strong>实战演习</strong></p>
<p>在我们的程序中，我们将创建一些僵尸！每个僵尸将拥有多个属性，所以这是一个展示结构体的完美例子。</p>
<ol>
<li>建立一个<code>struct</code> 命名为 <code>Zombie</code>.</li>
<li>我们的 <code>Zombie</code> 结构体有两个属性： <code>name</code> (类型为 <code>string</code>), 和 <code>dna</code> (类型为 <code>uint</code>)。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第6章-数组"><a href="#第6章-数组" class="headerlink" title="第6章: 数组"></a>第6章: 数组</h3><p>如果你想建立一个集合，可以用 <strong>数组</strong>这样的数据类型. Solidity 支持两种数组: <strong>静态</strong>数组和<strong>动态</strong>数组:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 固定长度为2的静态数组:</span><br><span class="line">uint[2] fixedArray;</span><br><span class="line">// 固定长度为5的string类型的静态数组:</span><br><span class="line">string[5] stringArray;</span><br><span class="line">// 动态数组，长度不固定，可以动态添加元素:</span><br><span class="line">uint[] dynamicArray;</span><br></pre></td></tr></tbody></table></figure>

<p>你也可以建立一个 <strong>结构体</strong>类型的数组 例如，上一章提到的 <code>Person</code>:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person[] people; // 这是动态数组，我们可以不断添加元素</span><br></pre></td></tr></tbody></table></figure>

<p>记住：状态变量被永久保存在区块链中。所以在你的合约中创建动态数组来保存成结构的数据是非常有意义的。</p>
<p><strong>公共数组</strong></p>
<p>你可以定义 <code>public</code> 数组, Solidity 会自动创建 <strong>getter</strong> 方法. 语法如下:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person[] public people;</span><br></pre></td></tr></tbody></table></figure>

<p>其它的合约可以从这个数组读取数据（但不能写入数据），所以这在合约中是一个有用的保存公共数据的模式。</p>
<p><strong>实战演习</strong></p>
<p>为了把一个僵尸部队保存在我们的APP里，并且能够让其它APP看到这些僵尸，我们需要一个公共数组。</p>
<ol>
<li>创建一个数据类型为 <code>Zombie</code> 的结构体数组，用 <code>public</code> 修饰，命名为：<code>zombies</code>.</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第7章-定义函数"><a href="#第7章-定义函数" class="headerlink" title="第7章: 定义函数"></a>第7章: 定义函数</h3><p>在 Solidity 中函数定义的句法如下:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function eatHamburgers(string _name, uint _amount) {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这是一个名为 <code>eatHamburgers</code> 的函数，它接受两个参数：一个 <code>string</code>类型的 和 一个 <code>uint</code>类型的。现在函数内部还是空的。</p>
<blockquote>
<p>注：: 习惯上函数里的变量都是以(<code>_</code>)开头 (但不是硬性规定) 以区别全局变量。我们整个教程都会沿用这个习惯。</p>
</blockquote>
<p>我们的函数定义如下:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eatHamburgers("vitalik", 100);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实战演习</strong></p>
<p>在我们的应用里，我们要能创建一些僵尸，让我们写一个函数做这件事吧！</p>
<ol>
<li>建立一个函数 <code>createZombie</code>。 它有两个参数: <strong>_name</strong> (类型为<code>string</code>), 和 <strong>_dna</strong> (类型为<code>uint</code>)。</li>
</ol>
<p>暂时让函数空着——我们在后面会增加内容。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    function createZombie(string _name, uint _dna) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第8章-使用结构体和数组"><a href="#第8章-使用结构体和数组" class="headerlink" title="第8章: 使用结构体和数组"></a>第8章: 使用结构体和数组</h3><p><strong>创建新的结构体</strong></p>
<p>还记得上个例子中的 <code>Person</code> 结构吗？</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Person {</span><br><span class="line">  uint age;</span><br><span class="line">  string name;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Person[] public people;</span><br></pre></td></tr></tbody></table></figure>

<p>现在我们学习创建新的 <code>Person</code> 结构，然后把它加入到名为 <code>people</code> 的数组中.</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个新的Person:</span><br><span class="line">Person satoshi = Person(172, "Satoshi");</span><br><span class="line"></span><br><span class="line">// 将新创建的satoshi添加进people数组:</span><br><span class="line">people.push(satoshi);</span><br></pre></td></tr></tbody></table></figure>

<p>你也可以两步并一步，用一行代码更简洁:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">people.push(Person(16, "Vitalik"));</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注：<code>array.push()</code> 在数组的 <strong>尾部</strong> 加入新元素 ，所以元素在数组中的顺序就是我们添加的顺序， 如:</p>
</blockquote>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uint[] numbers;</span><br><span class="line">numbers.push(5);</span><br><span class="line">numbers.push(10);</span><br><span class="line">numbers.push(15);</span><br><span class="line">// The `numbers` array is now equal to [5, 10, 15]</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实战演习</strong></p>
<p>让我们创建名为createZombie的函数来做点儿什么吧。</p>
<ol>
<li>在函数体里新创建一个 <code>Zombie</code>， 然后把它加入 <code>zombies</code> 数组中。 新创建的僵尸的 <code>name</code> 和 <code>dna</code>，来自于函数的参数。</li>
<li>让我们用一行代码简洁地完成它。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    function createZombie(string _name, uint _dna) {</span><br><span class="line">        zombies.push(Zombie(_name, _dna));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第9章-私有-公共函数"><a href="#第9章-私有-公共函数" class="headerlink" title="第9章: 私有 / 公共函数"></a>第9章: 私有 / 公共函数</h3><p>Solidity 定义的函数的属性默认为<code>公共</code>。 这就意味着任何一方 (或其它合约) 都可以调用你合约里的函数。</p>
<p>显然，不是什么时候都需要这样，而且这样的合约易于受到攻击。 所以将自己的函数定义为<code>私有</code>是一个好的编程习惯，只有当你需要外部世界调用它时才将它设置为<code>公共</code>。</p>
<p>如何定义一个私有的函数呢？</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uint[] numbers;</span><br><span class="line"></span><br><span class="line">function _addToArray(uint _number) private {</span><br><span class="line">  numbers.push(_number);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这意味着只有我们合约中的其它函数才能够调用这个函数，给 <code>numbers</code> 数组添加新成员。</p>
<p>可以看到，在**<u>函数名字后面使用关键字 <code>private</code> 即可</u><strong>。</strong><u>和函数的参数类似，私有函数的名字用(<code>_</code>)起始。</u>**</p>
<p><strong>实战演习</strong></p>
<p>我们合约的函数 <code>createZombie</code> 的默认属性是公共的，这意味着任何一方都可以调用它去创建一个僵尸。 咱们来把它变成私有吧！</p>
<ol>
<li>变 <code>createZombie</code> 为私有函数，不要忘记遵守命名的规矩哦！</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    function _createZombie(string _name, uint _dna) private {</span><br><span class="line">        zombies.push(Zombie(_name, _dna));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第10章-函数的更多属性"><a href="#第10章-函数的更多属性" class="headerlink" title="第10章: 函数的更多属性"></a>第10章: 函数的更多属性</h3><p>本章中我们将学习函数的返回值和修饰符。</p>
<p><strong>返回值</strong></p>
<p>要想函数返回一个数值，按如下定义：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string greeting = "What's up dog";</span><br><span class="line"></span><br><span class="line">function sayHello() public returns (string) {</span><br><span class="line">  return greeting;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Solidity 里，函数的定义里可包含返回值的数据类型(如本例中 <code>string</code>)。</p>
<p><strong>函数的修饰符</strong></p>
<p>上面的函数实际上没有改变 Solidity 里的状态，即，它没有改变任何值或者写任何东西。</p>
<p>这种情况下我们可以把函数定义为 <strong>view</strong>, 意味着它只能读取数据不能更改数据:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function sayHello() public view returns (string) {</span><br></pre></td></tr></tbody></table></figure>

<p>Solidity 还支持 <strong>pure</strong> 函数, 表明这个函数甚至都不访问应用里的数据，例如：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function _multiply(uint a, uint b) private pure returns (uint) {</span><br><span class="line">  return a * b;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><u><strong>这个函数甚至都不读取应用里的状态 — 它的返回值完全取决于它的输入参数，在这种情况下我们把函数定义为 pure.</strong></u></p>
<blockquote>
<p>注：可能很难记住何时把函数标记为 pure/view。 幸运的是， Solidity 编辑器会给出提示，提醒你使用这些修饰符。</p>
</blockquote>
<p><strong>实战演习</strong></p>
<p>我们想建立一个帮助函数，它根据一个字符串随机生成一个DNA数据。</p>
<ol>
<li>创建一个 <code>private</code> 函数，命名为 <code>_generateRandomDna</code>。它只接收一个输入变量 <code>_str</code> (类型 <code>string</code>), 返回一个 <code>uint</code> 类型的数值。</li>
<li>此函数只读取我们合约中的一些变量，所以标记为<code>view</code>。</li>
<li>函数内部暂时留空，以后我们再添加代码。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    function _createZombie(string _name, uint _dna) private {</span><br><span class="line">        zombies.push(Zombie(_name, _dna));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function _generateRandomDna(string _str) private view returns (uint) {</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第11章-Keccak256-和-类型转换"><a href="#第11章-Keccak256-和-类型转换" class="headerlink" title="第11章: Keccak256 和 类型转换"></a>第11章: Keccak256 和 类型转换</h3><p>如何让 <code>_generateRandomDna</code> 函数返回一个全(半) 随机的 <code>uint</code>?</p>
<p>Ethereum 内部有一个散列函数<code>keccak256</code>，它用了SHA3版本。一个散列函数基本上就是把一个字符串转换为一个256位的16进制数字。字符串的一个微小变化会引起散列数据极大变化。</p>
<p>这在 Ethereum 中有很多应用，但是现在我们只是用它造一个伪随机数。</p>
<p>例子:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//6e91ec6b618bb462a4a6ee5aa2cb0e9cf30f7a052bb467b0ba58b8748c00d2e5</span><br><span class="line">keccak256("aaaab");</span><br><span class="line">//b1f078126895a1424524de5321b339ab00408010b7cf0e6ed451514981e58aa9</span><br><span class="line">keccak256("aaaac");</span><br></pre></td></tr></tbody></table></figure>

<p>显而易见，输入字符串只改变了一个字母，输出就已经天壤之别了。</p>
<blockquote>
<p>注: 在区块链中<strong>安全地</strong>产生一个随机数是一个很难的问题， 本例的方法不安全，但是在我们的Zombie DNA算法里不是那么重要，已经很好地满足我们的需要了。</p>
</blockquote>
<p><strong>类型转换</strong></p>
<p>有时你需要变换数据类型。例如:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">uint8 a = 5;</span><br><span class="line">uint b = 6;</span><br><span class="line">// 将会抛出错误，因为 a * b 返回 uint, 而不是 uint8:</span><br><span class="line">uint8 c = a * b;</span><br><span class="line">// 我们需要将 b 转换为 uint8:</span><br><span class="line">uint8 c = a * uint8(b);</span><br></pre></td></tr></tbody></table></figure>

<p>上面, <code>a * b</code> 返回类型是 <code>uint</code>, 但是当我们尝试用 <code>uint8</code> 类型接收时, 就会造成潜在的错误。如果把它的数据类型转换为 <code>uint8</code>, 就可以了，编译器也不会出错。</p>
<p><strong>实战演习</strong></p>
<p>给 <code>_generateRandomDna</code> 函数添加代码! 它应该完成如下功能:</p>
<ol>
<li>第一行代码取 <code>_str</code> 的 <code>keccak256</code> 散列值生成一个伪随机十六进制数，类型转换为 <code>uint</code>, 最后保存在类型为 <code>uint</code> 名为 <code>rand</code> 的变量中。</li>
<li>我们只想让我们的DNA的长度为16位 (还记得 <code>dnaModulus</code>?)。所以第二行代码应该 <code>return</code> 上面计算的数值对 <code>dnaModulus</code> 求余数(<code>%</code>)。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    function _createZombie(string _name, uint _dna) private {</span><br><span class="line">        zombies.push(Zombie(_name, _dna));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function _generateRandomDna(string _str) private view returns (uint) {</span><br><span class="line">        uint rand = uint(keccak256(_str));</span><br><span class="line">        return rand % dnaModulus;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第12章-放在一起"><a href="#第12章-放在一起" class="headerlink" title="第12章: 放在一起"></a>第12章: 放在一起</h3><p>我们就快完成我们的随机僵尸制造器了，来写一个公共的函数把所有的部件连接起来。</p>
<p>写一个公共函数，它有一个参数，用来接收僵尸的名字，之后用它生成僵尸的DNA。</p>
<p><strong>实战演习</strong></p>
<ol>
<li>创建一个 <code>public</code> 函数，命名为 <code>createRandomZombie</code>. 它将被传入一个变量 <code>_name</code> (数据类型是 <code>string</code>)。 *(注: 定义公共函数 <code>public</code> 和定义一个私有 <code>private</code> 函数的做法一样)*。</li>
<li>函数的第一行应该调用 <code>_generateRandomDna</code> 函数，传入 <code>_name</code> 参数, 结果保存在一个类型为 <code>uint</code> 的变量里，命名为 <code>randDna</code>。</li>
<li>第二行调用 <code>_createZombie</code> 函数， 传入参数： <code>_name</code> 和 <code>randDna</code>。</li>
<li>整个函数应该是4行代码 (包括函数的结束符号 <code>}</code> )。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line"></span><br><span class="line">    // 这里建立事件</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    function _createZombie(string _name, uint _dna) private {</span><br><span class="line">        zombies.push(Zombie(_name, _dna));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function _generateRandomDna(string _str) private view returns (uint) {</span><br><span class="line">        uint rand = uint(keccak256(_str));</span><br><span class="line">        return rand % dnaModulus;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function createRandomZombie(string _name) public {</span><br><span class="line">        uint randDna = _generateRandomDna(_name);</span><br><span class="line">        _createZombie(_name, randDna);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第13章-事件"><a href="#第13章-事件" class="headerlink" title="第13章: 事件"></a>第13章: 事件</h3><p>我们的合约几乎就要完成了！让我们加上一个<strong>事件</strong>.</p>
<p><strong>事件</strong> 是合约和区块链通讯的一种机制。你的前端应用“监听”某些事件，并做出反应。</p>
<p>例子:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 这里建立事件</span><br><span class="line">event IntegersAdded(uint x, uint y, uint result);</span><br><span class="line"></span><br><span class="line">function add(uint _x, uint _y) public {</span><br><span class="line">  uint result = _x + _y;</span><br><span class="line">  //触发事件，通知app</span><br><span class="line">  IntegersAdded(_x, _y, result);</span><br><span class="line">  return result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>你的 app 前端可以监听这个事件。JavaScript 实现如下:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YourContract.IntegersAdded(function(error, result) {</span><br><span class="line">  // 干些事</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实战演习</strong></p>
<p>我们想每当一个僵尸创造出来时，我们的前端都能监听到这个事件，并将它显示出来。</p>
<p>1。 定义一个 <code>事件</code> 叫做 <code>NewZombie</code>。 它有3个参数: <code>zombieId</code> (<code>uint</code>)， <code>name</code> (<code>string</code>)， 和 <code>dna</code> (<code>uint</code>)。</p>
<p>2。 修改 <code>_createZombie</code> 函数使得当新僵尸造出来并加入 <code>zombies</code>数组后，生成事件<code>NewZombie</code>。</p>
<p>3。 需要定义僵尸<code>id</code>。 <code>array.push()</code> 返回数组的长度类型是<code>uint</code> - 因为数组的第一个元素的索引是 0， <code>array.push() - 1</code> 将是我们加入的僵尸的索引。 <code>zombies.push() - 1</code> 就是 <code>id</code>，数据类型是 <code>uint</code>。在下一行中你可以把它用到 <code>NewZombie</code> 事件中。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory {</span><br><span class="line">	</span><br><span class="line">	// 这里建立事件</span><br><span class="line">    event NewZombie(uint zombieId, string name, uint dna);</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    function _createZombie(string _name, uint _dna) private {</span><br><span class="line">        uint id = zombies.push(Zombie(_name, _dna)) - 1;</span><br><span class="line">        //// 这里触发事件</span><br><span class="line">        NewZombie(id, _name, _dna);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function _generateRandomDna(string _str) private view returns (uint) {</span><br><span class="line">        uint rand = uint(keccak256(_str));</span><br><span class="line">        return rand % dnaModulus;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function createRandomZombie(string _name) public {</span><br><span class="line">        uint randDna = _generateRandomDna(_name);</span><br><span class="line">        _createZombie(_name, randDna);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第14章-Web3-js"><a href="#第14章-Web3-js" class="headerlink" title="第14章: Web3.js"></a>第14章: Web3.js</h3><p>我们的 Solidity 合约完工了！ 现在我们要写一段 JavaScript 前端代码来调用这个合约。</p>
<p>以太坊有一个 JavaScript 库，名为<strong>Web3.js</strong>。</p>
<p>在后面的课程里，我们会进一步地教你如何安装一个合约，如何设置Web3.js。 但是现在我们通过一段代码来了解 Web3.js 是如何和我们发布的合约交互的吧。</p>
<p>如果下面的代码你不能全都理解，不用担心。</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面是调用合约的方式:</span></span><br><span class="line"><span class="keyword">var</span> abi = <span class="comment">/* abi是由编译器生成的 */</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">ZombieFactoryContract</span> = web3.<span class="property">eth</span>.<span class="title function_">contract</span>(abi)</span><br><span class="line"><span class="keyword">var</span> contractAddress = <span class="comment">/* 发布之后在以太坊上生成的合约地址 */</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">ZombieFactory</span> = <span class="title class_">ZombieFactoryContract</span>.<span class="title function_">at</span>(contractAddress)</span><br><span class="line"><span class="comment">// `ZombieFactory` 能访问公共的函数以及事件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 某个监听文本输入的监听器:</span></span><br><span class="line">$(<span class="string">"#ourButton"</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params">e</span>) {</span><br><span class="line">  <span class="keyword">var</span> name = $(<span class="string">"#nameInput"</span>).<span class="title function_">val</span>()</span><br><span class="line">  <span class="comment">//调用合约的 `createRandomZombie` 函数:</span></span><br><span class="line">  <span class="title class_">ZombieFactory</span>.<span class="title function_">createRandomZombie</span>(name)</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听 `NewZombie` 事件, 并且更新UI</span></span><br><span class="line"><span class="keyword">var</span> event = <span class="title class_">ZombieFactory</span>.<span class="title class_">NewZombie</span>(<span class="keyword">function</span>(<span class="params">error, result</span>) {</span><br><span class="line">  <span class="keyword">if</span> (error) <span class="keyword">return</span></span><br><span class="line">  <span class="title function_">generateZombie</span>(result.<span class="property">zombieId</span>, result.<span class="property">name</span>, result.<span class="property">dna</span>)</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 Zombie 的 dna, 更新图像</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">generateZombie</span>(<span class="params">id, name, dna</span>) {</span><br><span class="line">  <span class="keyword">let</span> dnaStr = <span class="title class_">String</span>(dna)</span><br><span class="line">  <span class="comment">// 如果dna少于16位,在它前面用0补上</span></span><br><span class="line">  <span class="keyword">while</span> (dnaStr.<span class="property">length</span> &lt; <span class="number">16</span>)</span><br><span class="line">    dnaStr = <span class="string">"0"</span> + dnaStr</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> zombieDetails = {</span><br><span class="line">    <span class="comment">// 前两位数构成头部.我们可能有7种头部, 所以 % 7</span></span><br><span class="line">    <span class="comment">// 得到的数在0-6,再加上1,数的范围变成1-7</span></span><br><span class="line">    <span class="comment">// 通过这样计算：</span></span><br><span class="line">    <span class="attr">headChoice</span>: dnaStr.<span class="title function_">substring</span>(<span class="number">0</span>, <span class="number">2</span>) % <span class="number">7</span> + <span class="number">1</span>，</span><br><span class="line">    <span class="comment">// 我们得到的图片名称从head1.png 到 head7.png</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来的两位数构成眼睛, 眼睛变化就对11取模:</span></span><br><span class="line">    <span class="attr">eyeChoice</span>: dnaStr.<span class="title function_">substring</span>(<span class="number">2</span>, <span class="number">4</span>) % <span class="number">11</span> + <span class="number">1</span>,</span><br><span class="line">    <span class="comment">// 再接下来的两位数构成衣服，衣服变化就对6取模:</span></span><br><span class="line">    <span class="attr">shirtChoice</span>: dnaStr.<span class="title function_">substring</span>(<span class="number">4</span>, <span class="number">6</span>) % <span class="number">6</span> + <span class="number">1</span>,</span><br><span class="line">    <span class="comment">//最后6位控制颜色. 用css选择器: hue-rotate来更新</span></span><br><span class="line">    <span class="comment">// 360度:</span></span><br><span class="line">    <span class="attr">skinColorChoice</span>: <span class="built_in">parseInt</span>(dnaStr.<span class="title function_">substring</span>(<span class="number">6</span>, <span class="number">8</span>) / <span class="number">100</span> * <span class="number">360</span>),</span><br><span class="line">    <span class="attr">eyeColorChoice</span>: <span class="built_in">parseInt</span>(dnaStr.<span class="title function_">substring</span>(<span class="number">8</span>, <span class="number">10</span>) / <span class="number">100</span> * <span class="number">360</span>),</span><br><span class="line">    <span class="attr">clothesColorChoice</span>: <span class="built_in">parseInt</span>(dnaStr.<span class="title function_">substring</span>(<span class="number">10</span>, <span class="number">12</span>) / <span class="number">100</span> * <span class="number">360</span>),</span><br><span class="line">    <span class="attr">zombieName</span>: name,</span><br><span class="line">    <span class="attr">zombieDescription</span>: <span class="string">"A Level 1 CryptoZombie"</span>,</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> zombieDetails</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们的 JavaScript 所做的就是获取由<code>zombieDetails</code> 产生的数据, 并且利用浏览器里的 JavaScript 神奇功能 (我们用 Vue.js)，置换出图像以及使用CSS过滤器。在后面的课程中，你可以看到全部的代码。</p>
<h2 id="lesson2-僵尸攻击人类"><a href="#lesson2-僵尸攻击人类" class="headerlink" title="lesson2 僵尸攻击人类"></a>lesson2 僵尸攻击人类</h2><h3 id="第2章-映射（Mapping）和地址（Address）"><a href="#第2章-映射（Mapping）和地址（Address）" class="headerlink" title="第2章: 映射（Mapping）和地址（Address）"></a>第2章: 映射（Mapping）和地址（Address）</h3><p>我们通过给数据库中的僵尸指定“主人”， 来支持“多玩家”模式。</p>
<p>如此一来，我们需要引入2个新的数据类型：<code>mapping</code>（映射） 和 <code>address</code>（地址）。</p>
<p><strong>Addresses （地址）</strong></p>
<p>以太坊区块链由 <strong>_ account _</strong> (账户)组成，你可以把它想象成银行账户。一个帐户的余额是 <strong><em>以太</em></strong> （在以太坊区块链上使用的币种），你可以和其他帐户之间支付和接受以太币，就像你的银行帐户可以电汇资金到其他银行帐户一样。</p>
<p>每个帐户都有一个“地址”，你可以把它想象成银行账号。这是账户唯一的标识符，它看起来长这样：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0cE446255506E92DF41614C46F1d6df9Cc969183</span><br></pre></td></tr></tbody></table></figure>

<p>（这是 CryptoZombies 团队的地址，如果你喜欢 CryptoZombies 的话，请打赏我们一些以太币！😉）</p>
<p>我们将在后面的课程中介绍地址的细节，现在你只需要了解<strong>地址属于特定用户（或智能合约）的</strong>。</p>
<p>所以我们可以指定“地址”作为僵尸主人的 ID。当用户通过与我们的应用程序交互来创建新的僵尸时，新僵尸的所有权被设置到调用者的以太坊地址下。</p>
<p><strong>Mapping（映射）</strong></p>
<p>在第1课中，我们看到了 <strong>结构体</strong> 和 <strong>数组</strong> 。 <strong>映射</strong> 是另一种在 Solidity 中存储有组织数据的方法。</p>
<p>映射是这样定义的：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//对于金融应用程序，将用户的余额保存在一个 uint类型的变量中：</span><br><span class="line">mapping (address =&gt; uint) public accountBalance;</span><br><span class="line">//或者可以用来通过userId 存储/查找的用户名</span><br><span class="line">mapping (uint =&gt; string) userIdToName;</span><br></pre></td></tr></tbody></table></figure>

<p>映射本质上是存储和查找数据所用的<strong>键-值对</strong>。在第一个例子中，键是一个 <code>address</code>，值是一个 <code>uint</code>，在第二个例子中，键是一个<code>uint</code>，值是一个 <code>string</code>。</p>
<p><strong>实战演习</strong></p>
<p>为了存储僵尸的所有权，我们会使用到两个映射：一个记录僵尸拥有者的地址，另一个记录某地址所拥有僵尸的数量。</p>
<p>1.创建一个叫做 <code>zombieToOwner</code> 的映射。其键是一个<code>uint</code>（我们将根据它的 id 存储和查找僵尸），值为 <code>address</code>。映射属性为<code>public</code>。</p>
<p>2.创建一个名为 <code>ownerZombieCount</code> 的映射，其中键是 <code>address</code>，值是 <code>uint</code>。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 在这里定义映射</span><br><span class="line">mapping (uint =&gt; address ) public zombieToOwner;</span><br><span class="line">mapping ( address =&gt; uint) ownerZombieCount;</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第3章-Msg-sender"><a href="#第3章-Msg-sender" class="headerlink" title="第3章: Msg.sender"></a>第3章: Msg.sender</h3><p>现在有了一套映射来记录僵尸的所有权了，我们可以修改 <code>_createZombie</code> 方法来运用它们。</p>
<p>为了做到这一点，我们要用到 <code>msg.sender</code>。</p>
<p><strong>msg.sender</strong></p>
<p>在 Solidity 中，有一些全局变量可以被所有函数调用。 其中一个就是 <code>msg.sender</code>，它指的是当前调用者（或智能合约）的 <code>address</code>。</p>
<blockquote>
<p>注意：在 Solidity 中，功能执行始终需要从外部调用者开始。 一个合约只会在区块链上什么也不做，除非有人调用其中的函数。所以 <code>msg.sender</code>总是存在的。</p>
</blockquote>
<p>以下是使用 <code>msg.sender</code> 来更新 <code>mapping</code> 的例子：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mapping (address =&gt; uint) favoriteNumber;</span><br><span class="line"></span><br><span class="line">function setMyNumber(uint _myNumber) public {</span><br><span class="line">  // 更新我们的 `favoriteNumber` 映射来将 `_myNumber`存储在 `msg.sender`名下</span><br><span class="line">  favoriteNumber[msg.sender] = _myNumber;</span><br><span class="line">  // 存储数据至映射的方法和将数据存储在数组相似</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function whatIsMyNumber() public view returns (uint) {</span><br><span class="line">  // 拿到存储在调用者地址名下的值</span><br><span class="line">  // 若调用者还没调用 setMyNumber， 则值为 `0`</span><br><span class="line">  return favoriteNumber[msg.sender];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在这个小小的例子中，任何人都可以调用 <code>setMyNumber</code> 在我们的合约中存下一个 <code>uint</code> 并且与他们的地址相绑定。 然后，他们调用 <code>whatIsMyNumber</code> 就会返回他们存储的 <code>uint</code>。</p>
<p>使用 <code>msg.sender</code> 很安全，因为它具有以太坊区块链的安全保障 —— 除非窃取与以太坊地址相关联的私钥，否则是没有办法修改其他人的数据的。</p>
<p><strong>实战演习</strong></p>
<p>我们来修改第1课的 <code>_createZombie</code> 方法，将僵尸分配给函数调用者吧。</p>
<ol>
<li>首先，在得到新的僵尸 <code>id</code> 后，更新 <code>zombieToOwner</code> 映射，在 <code>id</code> 下面存入 <code>msg.sender</code>。</li>
<li>然后，我们为这个 <code>msg.sender</code> 名下的 <code>ownerZombieCount</code> 加 1。</li>
</ol>
<p>跟在 JavaScript 中一样， 在 Solidity 中你也可以用 <code>++</code> 使 <code>uint</code> 递增。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uint number = 0;</span><br><span class="line">number++;</span><br><span class="line">// `number` 现在是 `1`了</span><br></pre></td></tr></tbody></table></figure>

<p>修改两行代码即可。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function _createZombie(string _name, uint _dna) private {</span><br><span class="line">        uint id = zombies.push(Zombie(_name, _dna)) - 1;</span><br><span class="line">        // 从这里开始</span><br><span class="line">        zombieToOwner[id] = msg.sender;</span><br><span class="line">        ownerZombieCount[msg.sender]++;</span><br><span class="line">        NewZombie(id, _name, _dna);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第4章-Require"><a href="#第4章-Require" class="headerlink" title="第4章: Require"></a>第4章: Require</h3><p>在第一课中，我们成功让用户通过调用 <code>createRandomZombie</code>函数 并输入一个名字来创建新的僵尸。 但是，如果用户能持续调用这个函数来创建出无限多个僵尸加入他们的军团，这游戏就太没意思了！</p>
<p>于是，我们作出限定：每个玩家只能调用一次这个函数。 这样一来，新玩家可以在刚开始玩游戏时通过调用它，为其军团创建初始僵尸。</p>
<p>我们怎样才能限定每个玩家只调用一次这个函数呢？</p>
<p>答案是使用<code>require</code>。 <code>require</code>使得函数在执行过程中，当不满足某些条件时抛出错误，并停止执行：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function sayHiToVitalik(string _name) public returns (string) {</span><br><span class="line">  // 比较 _name 是否等于 "Vitalik". 如果不成立，抛出异常并终止程序</span><br><span class="line">  // (敲黑板: Solidity 并不支持原生的字符串比较, 我们只能通过比较</span><br><span class="line">  // 两字符串的 keccak256 哈希值来进行判断)</span><br><span class="line">  require(keccak256(_name) == keccak256("Vitalik"));</span><br><span class="line">  // 如果返回 true, 运行如下语句</span><br><span class="line">  return "Hi!";</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果你这样调用函数 <code>sayHiToVitalik（“Vitalik”）</code> ,它会返回“Hi！”。而如果调用的时候使用了其他参数，它则会抛出错误并停止执行。</p>
<p>因此，在调用一个函数之前，用 <code>require</code> 验证前置条件是非常有必要的。</p>
<p><strong>实战演习</strong></p>
<p>在我们的僵尸游戏中，我们不希望用户通过反复调用 <code>createRandomZombie</code> 来給他们的军队创建无限多个僵尸 —— 这将使得游戏非常无聊。</p>
<p>我们使用了 <code>require</code> 来确保这个函数只有在每个用户第一次调用它的时候执行，用以创建初始僵尸。</p>
<ol>
<li>在 <code>createRandomZombie</code> 的前面放置 <code>require</code> 语句。 使得函数先检查 <code>ownerZombieCount [msg.sender]</code> 的值为 <code>0</code> ，不然就抛出一个错误。</li>
</ol>
<blockquote>
<p>注意：在 Solidity 中，关键词放置的顺序并不重要</p>
<ul>
<li>虽然参数的两个位置是等效的。 但是，由于我们的答案检查器比较呆板，它只能认定其中一个为正确答案</li>
<li>于是在这里，我们就约定把<code>ownerZombieCount [msg.sender]</code>放前面吧</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function createRandomZombie(string _name) public {</span><br><span class="line">        // start here</span><br><span class="line">        require(ownerZombieCount[msg.sender] == 0);</span><br><span class="line">        uint randDna = _generateRandomDna(_name);</span><br><span class="line">        _createZombie(_name, randDna);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第5章-继承（Inheritance）"><a href="#第5章-继承（Inheritance）" class="headerlink" title="第5章: 继承（Inheritance）"></a>第5章: 继承（Inheritance）</h3><p>我们的游戏代码越来越长。 当代码过于冗长的时候，最好将代码和逻辑分拆到多个不同的合约中，以便于管理。</p>
<p>有个让 Solidity 的代码易于管理的功能，就是合约 *<strong>inheritance*</strong> (继承)：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract Doge {</span><br><span class="line">  function catchphrase() public returns (string) {</span><br><span class="line">    return "So Wow CryptoDoge";</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">contract BabyDoge is Doge {</span><br><span class="line">  function anotherCatchphrase() public returns (string) {</span><br><span class="line">    return "Such Moon BabyDoge";</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>由于 <code>BabyDoge</code> 是从 <code>Doge</code> 那里 *<strong>inherits*</strong> （继承)过来的。 这意味着当你编译和部署了 <code>BabyDoge</code>，它将可以访问 <code>catchphrase()</code> 和 <code>anotherCatchphrase()</code>和其他我们在 <code>Doge</code> 中定义的其他公共函数。</p>
<p>这可以用于逻辑继承（比如表达子类的时候，<code>Cat</code> 是一种 <code>Animal</code>）。 但也可以简单地将类似的逻辑组合到不同的合约中以组织代码。</p>
<p><strong>实战演习</strong></p>
<p>在接下来的章节中，我们将要为僵尸实现各种功能，让它可以“猎食”和“繁殖”。 通过将这些运算放到父类 <code>ZombieFactory</code> 中，使得所有 <code>ZombieFactory</code> 的继承者合约都可以使用这些方法。</p>
<ol>
<li>在 <code>ZombieFactory</code> 下创建一个叫 <code>ZombieFeeding</code> 的合约，它是继承自 `ZombieFactory 合约的。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Start here</span><br><span class="line">contract ZombieFeeding is ZombieFactory {</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第6章-引入（Import）"><a href="#第6章-引入（Import）" class="headerlink" title="第6章: 引入（Import）"></a>第6章: 引入（Import）</h3><p>哇！你有没有注意到，我们只是清理了下右边的代码，现在你的编辑器的顶部就多了个选项卡。 尝试点击它的标签，看看会发生什么吧！</p>
<p>代码已经够长了，我们把它分成多个文件以便于管理。 通常情况下，当 Solidity 项目中的代码太长的时候我们就是这么做的。</p>
<p>在 Solidity 中，当你有多个文件并且想把一个文件导入另一个文件时，可以使用 <code>import</code> 语句：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import "./someothercontract.sol";</span><br><span class="line"></span><br><span class="line">contract newContract is SomeOtherContract {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这样当我们在合约（contract）目录下有一个名为 <code>someothercontract.sol</code> 的文件（ <code>./</code> 就是同一目录的意思），它就会被编译器导入。</p>
<p><strong>实战演习</strong></p>
<p>现在我们已经建立了一个多文件架构，并用 <code>import</code> 来读取来自另一个文件中合约的内容：</p>
<p>1.将 <code>zombiefactory.sol</code> 导入到我们的新文件 <code>zombiefeeding.sol</code> 中。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// put import statement here</span><br><span class="line">import "./zombiefactory.sol";</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第7章-Storage与Memory"><a href="#第7章-Storage与Memory" class="headerlink" title="第7章: Storage与Memory"></a>第7章: Storage与Memory</h3><p>在 Solidity 中，有两个地方可以存储变量 —— <code>storage</code> 或 <code>memory</code>。</p>
<p><strong>Storage</strong> 变量是指**<u>永久存储</u><strong>在区块链中的变量。 <strong>Memory</strong> 变量则是</strong><u>临时的</u>**，当外部函数对某合约调用完成时，内存型变量即被移除。 你可以把它想象成存储在你电脑的硬盘或是RAM中数据的关系。</p>
<p>大多数时候你都用不到这些关键字，默认情况下 Solidity 会自动处理它们。 状态变量（在函数之外声明的变量）默认为“存储”形式，并永久写入区块链；而在函数内部声明的变量是“内存”型的，它们函数调用结束后消失。</p>
<p>然而也有一些情况下，你需要手动声明存储类型，主要用于处理函数内的 <strong>结构体</strong> 和 <strong>数组</strong> 时：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">contract SandwichFactory {</span><br><span class="line">  struct Sandwich {</span><br><span class="line">    string name;</span><br><span class="line">    string status;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  Sandwich[] sandwiches;</span><br><span class="line"></span><br><span class="line">  function eatSandwich(uint _index) public {</span><br><span class="line">    // Sandwich mySandwich = sandwiches[_index];</span><br><span class="line"></span><br><span class="line">    // ^ 看上去很直接，不过 Solidity 将会给出警告</span><br><span class="line">    // 告诉你应该明确在这里定义 `storage` 或者 `memory`。</span><br><span class="line"></span><br><span class="line">    // 所以你应该明确定义 `storage`:</span><br><span class="line">    Sandwich storage mySandwich = sandwiches[_index];</span><br><span class="line">    // ...这样 `mySandwich` 是指向 `sandwiches[_index]`的指针</span><br><span class="line">    // 在存储里，另外...</span><br><span class="line">    mySandwich.status = "Eaten!";</span><br><span class="line">    // ...这将永久把 `sandwiches[_index]` 变为区块链上的存储</span><br><span class="line"></span><br><span class="line">    // 如果你只想要一个副本，可以使用`memory`:</span><br><span class="line">    Sandwich memory anotherSandwich = sandwiches[_index + 1];</span><br><span class="line">    // ...这样 `anotherSandwich` 就仅仅是一个内存里的副本了</span><br><span class="line">    // 另外</span><br><span class="line">    anotherSandwich.status = "Eaten!";</span><br><span class="line">    // ...将仅仅修改临时变量，对 `sandwiches[_index + 1]` 没有任何影响</span><br><span class="line">    // 不过你可以这样做:</span><br><span class="line">    sandwiches[_index + 1] = anotherSandwich;</span><br><span class="line">    // ...如果你想把副本的改动保存回区块链存储</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果你还没有完全理解究竟应该使用哪一个，也不用担心 —— 在本教程中，我们将告诉你何时使用 <code>storage</code> 或是 <code>memory</code>，并且当你不得不使用到这些关键字的时候，Solidity 编译器也发警示提醒你的。</p>
<p>现在，只要知道在某些场合下也需要你显式地声明 <code>storage</code> 或 <code>memory</code>就够了！</p>
<p><strong>实战演习</strong></p>
<p>是时候给我们的僵尸增加“猎食”和“繁殖”功能了！</p>
<p>当一个僵尸猎食其他生物体时，它自身的DNA将与猎物生物的DNA结合在一起，形成一个新的僵尸DNA。</p>
<ol>
<li>创建一个名为 <code>feedAndMultiply</code> 的函数。 使用两个参数：<code>_zombieId</code>（ <code>uint</code>类型 ）和<code>_targetDna</code> （也是 <code>uint</code> 类型）。 设置属性为 <code>public</code> 的。</li>
<li>我们不希望别人用我们的僵尸去捕猎。 首先，我们确保对自己僵尸的所有权。 通过添加一个<code>require</code> 语句来确保 <code>msg.sender</code> 只能是这个僵尸的主人（类似于我们在 <code>createRandomZombie</code> 函数中做过的那样）。</li>
</ol>
<blockquote>
<p>注意：同样，因为我们的答案检查器比较呆萌，只认识把 <code>msg.sender</code> 放在前面的答案，如果你切换了参数的顺序，它就不认得了。 但你正常编码时，如何安排参数顺序都是正确的。</p>
</blockquote>
<ol>
<li>为了获取这个僵尸的DNA，我们的函数需要声明一个名为 <code>myZombie</code> 数据类型为<code>Zombie</code>的本地变量（这是一个 <code>storage</code> 型的指针）。 将其值设定为在 <code>zombies</code> 数组中索引为<code>_zombieId</code>所指向的值。</li>
</ol>
<p>到目前为止，包括函数结束符 <code>}</code> 的那一行， 总共4行代码。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Start here</span><br><span class="line">    function feedAndMultiply(uint _zombieId, uint _targetDna) public{</span><br><span class="line">        require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">        Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第8章-僵尸的DNA"><a href="#第8章-僵尸的DNA" class="headerlink" title="第8章: 僵尸的DNA"></a>第8章: 僵尸的DNA</h3><p>我们来把 <code>feedAndMultiply</code> 函数写完吧。</p>
<p>获取新的僵尸DNA的公式很简单：计算猎食僵尸DNA和被猎僵尸DNA之间的平均值。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function testDnaSplicing() public {</span><br><span class="line">  uint zombieDna = 2222222222222222;</span><br><span class="line">  uint targetDna = 4444444444444444;</span><br><span class="line">  uint newZombieDna = (zombieDna + targetDna) / 2;</span><br><span class="line">  // newZombieDna 将等于 3333333333333333</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以后，我们也可以让函数变得更复杂些，比方给新的僵尸的 DNA 增加一些随机性之类的。但现在先从最简单的开始 —— 以后还可以回来完善它嘛。</p>
<p><strong>实战演习</strong></p>
<ol>
<li>首先我们确保 <code>_targetDna</code> 不长于16位。要做到这一点，我们可以设置 <code>_targetDna</code> 为 <code>_targetDna ％ dnaModulus</code> ，并且只取其最后16位数字。</li>
<li>接下来为我们的函数声明一个名叫 <code>newDna</code> 的 <code>uint</code>类型的变量，并将其值设置为 <code>myZombie</code>的 DNA 和 <code>_targetDna</code> 的平均值（如上例所示）。</li>
</ol>
<blockquote>
<p>注意：您可以用 <code>myZombie.name</code> 或 <code>myZombie.dna</code> 访问 <code>myZombie</code> 的属性。</p>
</blockquote>
<ol>
<li>一旦我们计算出新的DNA，再调用 <code>_createZombie</code> 就可以生成新的僵尸了。如果你忘了调用这个函数所需要的参数，可以查看 <code>zombiefactory.sol</code> 选项卡。请注意，需要先给它命名，所以现在我们把新的僵尸的名字设为<code>NoName</code> - 我们回头可以编写一个函数来更改僵尸的名字。</li>
</ol>
<blockquote>
<p>注意：对于 Solidity 高手，你可能会注意到我们的代码存在一个问题。别担心，下一章会解决这个问题的 ;）</p>
</blockquote>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function feedAndMultiply(uint _zombieId, uint _targetDna) public {</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    // start here</span><br><span class="line">    _targetDna = _targetDna % dnaModulus;</span><br><span class="line">    uint newDna = (myZombie.dna + _targetDna) / 2;</span><br><span class="line">    _createZombie("NoName", newDna);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第9章-更多关于函数可见性"><a href="#第9章-更多关于函数可见性" class="headerlink" title="第9章: 更多关于函数可见性"></a>第9章: 更多关于函数可见性</h3><p><strong>我们上一课的代码有问题！</strong></p>
<p>编译的时候编译器就会报错。</p>
<p>错误在于，我们尝试从 <code>ZombieFeeding</code> 中调用 <code>_createZombie</code> 函数，但 <code>_createZombie</code> 却是 <code>ZombieFactory</code> 的 <code>private</code> （私有）函数。这意味着任何继承自 <code>ZombieFactory</code> 的子合约都不能访问它。</p>
<p><strong>internal 和 external</strong></p>
<p>除 <code>public</code> 和 <code>private</code> 属性之外，Solidity 还使用了另外两个描述函数可见性的修饰词：<code>internal</code>（内部） 和 <code>external</code>（外部）。</p>
<p><code>internal</code> 和 <code>private</code> 类似，不过， 如果某个合约继承自其父合约，这个合约即可以访问父合约中定义的“内部”函数。（嘿，这听起来正是我们想要的那样！）。</p>
<p><code>external</code> 与<code>public</code> 类似，只不过这些函数只能在合约之外调用 - 它们不能被合约内的其他函数调用。稍后我们将讨论什么时候使用 <code>external</code> 和 <code>public</code>。</p>
<p>声明函数 <code>internal</code> 或 <code>external</code> 类型的语法，与声明 <code>private</code> 和 <code>public</code>类 型相同：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">contract Sandwich {</span><br><span class="line">  uint private sandwichesEaten = 0;</span><br><span class="line"></span><br><span class="line">  function eat() internal {</span><br><span class="line">    sandwichesEaten++;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">contract BLT is Sandwich {</span><br><span class="line">  uint private baconSandwichesEaten = 0;</span><br><span class="line"></span><br><span class="line">  function eatWithBacon() public returns (string) {</span><br><span class="line">    baconSandwichesEaten++;</span><br><span class="line">    // 因为eat() 是internal 的，所以我们能在这里调用</span><br><span class="line">    eat();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实战演习</strong></p>
<ol>
<li><p>将 <code>_createZombie()</code> 函数的属性从 <code>private</code> 改为 <code>internal</code> ， 使得其他的合约也能访问到它。</p>
<p> 我们已经成功把你的注意力集中在到<code>zombiefactory.sol</code>这个选项卡上啦。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 在这里修改函数的功能</span><br><span class="line">    function _createZombie(string _name, uint _dna) internal {</span><br><span class="line">        uint id = zombies.push(Zombie(_name, _dna)) - 1;</span><br><span class="line">        zombieToOwner[id] = msg.sender;</span><br><span class="line">        ownerZombieCount[msg.sender]++;</span><br><span class="line">        NewZombie(id, _name, _dna);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第10章-僵尸吃什么"><a href="#第10章-僵尸吃什么" class="headerlink" title="第10章: 僵尸吃什么?"></a>第10章: 僵尸吃什么?</h3><p>是时候让我们的僵尸去捕猎！ 那僵尸最喜欢的食物是什么呢？</p>
<p>Crypto 僵尸喜欢吃的是…</p>
<p><strong>CryptoKitties！</strong> 😱😱😱</p>
<p>（正经点，我可不是开玩笑😆）</p>
<p>为了做到这一点，我们要读出 CryptoKitties 智能合约中的 kittyDna。这些数据是公开存储在区块链上的。区块链是不是很酷？</p>
<p>别担心 —— 我们的游戏并不会伤害到任何真正的CryptoKitty。 我们只 <em>读取</em> CryptoKitties 数据，但却无法在物理上删除它。</p>
<p><strong>与其他合约的交互</strong></p>
<p>如果我们的合约需要和区块链上的其他的合约会话，则需先定义一个 <strong>interface</strong> (接口)。</p>
<p>先举一个简单的栗子。 假设在区块链上有这么一个合约：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract LuckyNumber {</span><br><span class="line">  mapping(address =&gt; uint) numbers;</span><br><span class="line"></span><br><span class="line">  function setNum(uint _num) public {</span><br><span class="line">    numbers[msg.sender] = _num;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  function getNum(address _myAddress) public view returns (uint) {</span><br><span class="line">    return numbers[_myAddress];</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这是个很简单的合约，您可以用它存储自己的幸运号码，并将其与您的以太坊地址关联。 这样其他人就可以通过您的地址查找您的幸运号码了。</p>
<p>现在假设我们有一个外部合约，使用 <code>getNum</code> 函数可读取其中的数据。</p>
<p>首先，我们定义 <code>LuckyNumber</code> 合约的 <strong>interface</strong> ：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract NumberInterface {</span><br><span class="line">  function getNum(address _myAddress) public view returns (uint);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>请注意，这个过程虽然看起来像在定义一个合约，但其实内里不同：</p>
<p>首先，我们只声明了要与之交互的函数 —— 在本例中为 <code>getNum</code> —— 在其中我们没有使用到任何其他的函数或状态变量。</p>
<p>其次，我们并没有使用大括号（<code>{</code> 和 <code>}</code>）定义函数体，我们单单用分号（<code>;</code>）结束了函数声明。这使它看起来像一个合约框架。</p>
<p>编译器就是靠这些特征认出它是一个接口的。</p>
<p>在我们的 app 代码中使用这个接口，合约就知道其他合约的函数是怎样的，应该如何调用，以及可期待什么类型的返回值。</p>
<p>在下一课中，我们将真正调用其他合约的函数。目前我们只要声明一个接口，用于调用 CryptoKitties 合约就行了。</p>
<p><strong>实战演习</strong></p>
<p>我们已经为你查看过了 CryptoKitties 的源代码，并且找到了一个名为 <code>getKitty</code>的函数，它返回所有的加密猫的数据，包括它的“基因”（我们的僵尸游戏要用它生成新的僵尸）。</p>
<p>该函数如下所示：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function getKitty(uint256 _id) external view returns (</span><br><span class="line">    bool isGestating,</span><br><span class="line">    bool isReady,</span><br><span class="line">    uint256 cooldownIndex,</span><br><span class="line">    uint256 nextActionAt,</span><br><span class="line">    uint256 siringWithId,</span><br><span class="line">    uint256 birthTime,</span><br><span class="line">    uint256 matronId,</span><br><span class="line">    uint256 sireId,</span><br><span class="line">    uint256 generation,</span><br><span class="line">    uint256 genes</span><br><span class="line">) {</span><br><span class="line">    Kitty storage kit = kitties[_id];</span><br><span class="line"></span><br><span class="line">    // if this variable is 0 then it's not gestating</span><br><span class="line">    isGestating = (kit.siringWithId != 0);</span><br><span class="line">    isReady = (kit.cooldownEndBlock &lt;= block.number);</span><br><span class="line">    cooldownIndex = uint256(kit.cooldownIndex);</span><br><span class="line">    nextActionAt = uint256(kit.cooldownEndBlock);</span><br><span class="line">    siringWithId = uint256(kit.siringWithId);</span><br><span class="line">    birthTime = uint256(kit.birthTime);</span><br><span class="line">    matronId = uint256(kit.matronId);</span><br><span class="line">    sireId = uint256(kit.sireId);</span><br><span class="line">    generation = uint256(kit.generation);</span><br><span class="line">    genes = kit.genes;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个函数看起来跟我们习惯的函数不太一样。 它竟然返回了…一堆不同的值！ 如果您用过 JavaScript 之类的编程语言，一定会感到奇怪 —— 在 Solidity中，您可以让一个函数返回多个值。</p>
<p>现在我们知道这个函数长什么样的了，就可以用它来创建一个接口：</p>
<p>1.定义一个名为 <code>KittyInterface</code> 的接口。 请注意，因为我们使用了 <code>contract</code> 关键字， 这过程看起来就像创建一个新的合约一样。</p>
<p>2.在interface里定义了 <code>getKitty</code> 函数（不过是复制/粘贴上面的函数，但在 <code>returns</code> 语句之后用分号，而不是大括号内的所有内容。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Create KittyInterface here</span><br><span class="line">contract KittyInterface {</span><br><span class="line">    function getKitty(uint256 _id) external view returns (</span><br><span class="line">    bool isGestating,</span><br><span class="line">    bool isReady,</span><br><span class="line">    uint256 cooldownIndex,</span><br><span class="line">    uint256 nextActionAt,</span><br><span class="line">    uint256 siringWithId,</span><br><span class="line">    uint256 birthTime,</span><br><span class="line">    uint256 matronId,</span><br><span class="line">    uint256 sireId,</span><br><span class="line">    uint256 generation,</span><br><span class="line">    uint256 genes</span><br><span class="line">    );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第11章-使用接口"><a href="#第11章-使用接口" class="headerlink" title="第11章: 使用接口"></a>第11章: 使用接口</h3><p>继续前面 <code>NumberInterface</code> 的例子，我们既然将接口定义为：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract NumberInterface {</span><br><span class="line">  function getNum(address _myAddress) public view returns (uint);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们可以在合约中这样使用：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">contract MyContract {</span><br><span class="line">  address NumberInterfaceAddress = 0xab38...;</span><br><span class="line">  // ^ 这是FavoriteNumber合约在以太坊上的地址</span><br><span class="line">  NumberInterface numberContract = NumberInterface(NumberInterfaceAddress);</span><br><span class="line">  // 现在变量 `numberContract` 指向另一个合约对象</span><br><span class="line"></span><br><span class="line">  function someFunction() public {</span><br><span class="line">    // 现在我们可以调用在那个合约中声明的 `getNum`函数:</span><br><span class="line">    uint num = numberContract.getNum(msg.sender);</span><br><span class="line">    // ...在这儿使用 `num`变量做些什么</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过这种方式，只要将您合约的可见性设置为<code>public</code>(公共)或<code>external</code>(外部)，它们就可以与以太坊区块链上的任何其他合约进行交互。</p>
<p><strong>实战演习</strong></p>
<p>我们来建个自己的合约去读取另一个智能合约– CryptoKitties 的内容吧！</p>
<ol>
<li>我已经将代码中 CryptoKitties 合约的地址保存在一个名为 <code>ckAddress</code> 的变量中。在下一行中，请创建一个名为 <code>kittyContract</code> 的 KittyInterface，并用 <code>ckAddress</code> 为它初始化 —— 就像我们为 <code>numberContract</code>所做的一样。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">contract ZombieFeeding is ZombieFactory {</span><br><span class="line"></span><br><span class="line">  address ckAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;</span><br><span class="line">  // Initialize kittyContract here using `ckAddress` from above</span><br><span class="line">    KittyInterface kittyContract = KittyInterface(ckAddress);</span><br><span class="line"></span><br><span class="line">  function feedAndMultiply(uint _zombieId, uint _targetDna) public {</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    _targetDna = _targetDna % dnaModulus;</span><br><span class="line">    uint newDna = (myZombie.dna + _targetDna) / 2;</span><br><span class="line">    _createZombie("NoName", newDna);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第12章-处理多返回值"><a href="#第12章-处理多返回值" class="headerlink" title="第12章: 处理多返回值"></a>第12章: 处理多返回值</h3><p><code>getKitty</code> 是我们所看到的第一个返回多个值的函数。我们来看看是如何处理的：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function multipleReturns() internal returns(uint a, uint b, uint c) {</span><br><span class="line">  return (1, 2, 3);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function processMultipleReturns() external {</span><br><span class="line">  uint a;</span><br><span class="line">  uint b;</span><br><span class="line">  uint c;</span><br><span class="line">  // 这样来做批量赋值:</span><br><span class="line">  (a, b, c) = multipleReturns();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 或者如果我们只想返回其中一个变量:</span><br><span class="line">function getLastReturnValue() external {</span><br><span class="line">  uint c;</span><br><span class="line">  // 可以对其他字段留空:</span><br><span class="line">  (,,c) = multipleReturns();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实战演习</strong></p>
<p>是时候与 CryptoKitties 合约交互起来了！</p>
<p>我们来定义一个函数，从 kitty 合约中获取它的基因：</p>
<ol>
<li><p>创建一个名为 <code>feedOnKitty</code> 的函数。它需要2个 <code>uint</code> 类型的参数，<code>_zombieId</code> 和<code>_kittyId</code> ，这是一个 <code>public</code> 类型的函数。</p>
</li>
<li><p>函数首先要声明一个名为 <code>kittyDna</code> 的 <code>uint</code>。</p>
<blockquote>
<p>注意：在我们的 <code>KittyInterface</code> 中，<code>genes</code> 是一个 <code>uint256</code> 类型的变量，但是如果你记得，我们在第一课中提到过，<code>uint</code> 是 <code>uint256</code> 的别名，也就是说它们是一回事。</p>
</blockquote>
</li>
<li><p>这个函数接下来调用 <code>kittyContract.getKitty</code>函数, 传入 <code>_kittyId</code> ，将返回的 <code>genes</code> 存储在 <code>kittyDna</code> 中。记住 —— <code>getKitty</code> 会返回一大堆变量。 （确切地说10个 - 我已经为你数过了，不错吧！）。但是我们只关心最后一个– <code>genes</code>。数逗号的时候小心点哦！</p>
</li>
<li><p>最后，函数调用了 <code>feedAndMultiply</code> ，并传入了 <code>_zombieId</code> 和 <code>kittyDna</code> 两个参数。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// define function here</span><br><span class="line">    function feedOnKitty(uint _zombieId, uint _kittyId) public{</span><br><span class="line">        uint kittyDna;</span><br><span class="line">        (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId);</span><br><span class="line">        feedAndMultiply(_zombieId,kittyDna);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第13章-奖励-Kitty-基因"><a href="#第13章-奖励-Kitty-基因" class="headerlink" title="第13章: 奖励: Kitty 基因"></a>第13章: 奖励: Kitty 基因</h3><p>我们的功能逻辑主体已经完成了…现在让我们来添一个奖励功能吧。</p>
<p>这样吧，给从小猫制造出的僵尸添加些特征，以显示他们是猫僵尸。</p>
<p>要做到这一点，咱们在新僵尸的DNA中添加一些特殊的小猫代码。</p>
<p>还记得吗，第一课中我们提到，我们目前只使用16位DNA的前12位数来指定僵尸的外观。所以现在我们可以使用最后2个数字来处理“特殊”的特征。</p>
<p>这样吧，把猫僵尸DNA的最后两个数字设定为<code>99</code>（因为猫有9条命）。所以在我们这么来写代码：<code>如果</code>这个僵尸是一只猫变来的，就将它DNA的最后两位数字设置为<code>99</code>。</p>
<p><strong>if 语句</strong></p>
<p>if语句的语法在 Solidity 中，与在 JavaScript 中差不多：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function eatBLT(string sandwich) public {</span><br><span class="line">  // 看清楚了，当我们比较字符串的时候，需要比较他们的 keccak256 哈希码</span><br><span class="line">  if (keccak256(sandwich) == keccak256("BLT")) {</span><br><span class="line">    eat();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实战演习</strong></p>
<p>让我们在我们的僵尸代码中实现小猫的基因。</p>
<ol>
<li><p>首先，我们修改下 <code>feedAndMultiply</code> 函数的定义，给它传入第三个参数：一条名为 <code>_species</code> 的字符串。</p>
</li>
<li><p>接下来，在我们计算出新的僵尸的DNA之后，添加一个 <code>if</code> 语句来比较 <code>_species</code> 和字符串 <code>"kitty"</code> 的 <code>keccak256</code> 哈希值。</p>
</li>
<li><p>在 <code>if</code> 语句中，我们用 <code>99</code> 替换了新僵尸DNA的最后两位数字。可以这么做：<code>newDna = newDna - newDna % 100 + 99;</code>。</p>
<blockquote>
<p>解释：假设 <code>newDna</code> 是 <code>334455</code>。那么 <code>newDna % 100</code> 是 <code>55</code>，所以 <code>newDna - newDna % 100</code> 得到 <code>334400</code>。最后加上 <code>99</code> 可得到 <code>334499</code>。</p>
</blockquote>
</li>
<li><p>最后，我们修改了 <code>feedOnKitty</code> 中的函数调用。当它调用 <code>feedAndMultiply</code> 时，增加 <code>“kitty”</code> 作为最后一个参数。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 这里修改函数定义</span><br><span class="line">  function feedAndMultiply(uint _zombieId, uint _targetDna, string _species) public {</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    _targetDna = _targetDna % dnaModulus;</span><br><span class="line">    uint newDna = (myZombie.dna + _targetDna) / 2;</span><br><span class="line">    // 这里增加一个 if 语句</span><br><span class="line">    if(keccak256(_species) == keccak256("kitty")){</span><br><span class="line">        newDna = newDna - newDna % 100 + 99;</span><br><span class="line">    }</span><br><span class="line">    _createZombie("NoName", newDna);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  function feedOnKitty(uint _zombieId, uint _kittyId) public {</span><br><span class="line">    uint kittyDna;</span><br><span class="line">    (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId);</span><br><span class="line">    // 并修改函数调用</span><br><span class="line">    feedAndMultiply(_zombieId, kittyDna,"kitty");</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第14章-放在一起"><a href="#第14章-放在一起" class="headerlink" title="第14章: 放在一起"></a>第14章: 放在一起</h3><p>至此，你已经学完第二课了！</p>
<p>查看下→_→的演示，看看他们怎么运行起来得吧。继续，你肯定等不及看完这一页😉。点击小猫，攻击！看到你斩获一个新的小猫僵尸了吧！</p>
<p><strong>JavaScript 实现</strong></p>
<p>我们只用编译和部署 <code>ZombieFeeding</code>，就可以将这个合约部署到以太坊了。我们最终完成的这个合约继承自 <code>ZombieFactory</code>，因此它可以访问自己和父辈合约中的所有 public 方法。</p>
<p>我们来看一个与我们的刚部署的合约进行交互的例子， 这个例子使用了 JavaScript 和 web3.js：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">var abi = /* abi generated by the compiler */</span><br><span class="line">var ZombieFeedingContract = web3.eth.contract(abi)</span><br><span class="line">var contractAddress = /* our contract address on Ethereum after deploying */</span><br><span class="line">var ZombieFeeding = ZombieFeedingContract.at(contractAddress)</span><br><span class="line"></span><br><span class="line">// 假设我们有我们的僵尸ID和要攻击的猫咪ID</span><br><span class="line">let zombieId = 1;</span><br><span class="line">let kittyId = 1;</span><br><span class="line"></span><br><span class="line">// 要拿到猫咪的DNA，我们需要调用它的API。这些数据保存在它们的服务器上而不是区块链上。</span><br><span class="line">// 如果一切都在区块链上，我们就不用担心它们的服务器挂了，或者它们修改了API，</span><br><span class="line">// 或者因为不喜欢我们的僵尸游戏而封杀了我们</span><br><span class="line">let apiUrl = "https://api.cryptokitties.co/kitties/" + kittyId</span><br><span class="line">$.get(apiUrl, function(data) {</span><br><span class="line">  let imgUrl = data.image_url</span><br><span class="line">  // 一些显示图片的代码</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">// 当用户点击一只猫咪的时候:</span><br><span class="line">$(".kittyImage").click(function(e) {</span><br><span class="line">  // 调用我们合约的 `feedOnKitty` 函数</span><br><span class="line">  ZombieFeeding.feedOnKitty(zombieId, kittyId)</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">// 侦听来自我们合约的新僵尸事件好来处理</span><br><span class="line">ZombieFactory.NewZombie(function(error, result) {</span><br><span class="line">  if (error) return</span><br><span class="line">  // 这个函数用来显示僵尸:</span><br><span class="line">  generateZombie(result.zombieId, result.name, result.dna)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实战演习</strong></p>
<p>选择一只你想猎食的小猫。你自家僵尸的 DNA 会和小猫的 DNA 结合，生成一个新的小猫僵尸，加入你的军团！</p>
<p>看到新僵尸上那可爱的猫咪腿了么？这是新僵尸最后DNA中最后两位数字 <code>99</code> 的功劳！</p>
<p>你想要的话随时可以重新开始。捕获了一只猫咪僵尸，你一定很高兴吧！（不过你只能持有一只），继续前进到下一章，完成第二课吧！</p>
<h2 id="lesson3-高级-Solidity-理论"><a href="#lesson3-高级-Solidity-理论" class="headerlink" title="lesson3 高级 Solidity 理论"></a>lesson3 高级 Solidity 理论</h2><h3 id="第1章-智能协议的永固性"><a href="#第1章-智能协议的永固性" class="headerlink" title="第1章: 智能协议的永固性"></a>第1章: 智能协议的永固性</h3><p>到现在为止，我们讲的 Solidity 和其他语言没有质的区别，它长得也很像 JavaScript。</p>
<p>但是，在有几点以太坊上的 DApp 跟普通的应用程序有着天壤之别。</p>
<p>第一个例子，在你把智能协议传上以太坊之后，它就变得<strong>不可更改</strong>, 这种永固性意味着你的代码永远不能被调整或更新。</p>
<p>你编译的程序会一直，永久的，不可更改的，存在以太坊上。这就是 Solidity 代码的安全性如此重要的一个原因。如果你的智能协议有任何漏洞，即使你发现了也无法补救。你只能让你的用户们放弃这个智能协议，然后转移到一个新的修复后的合约上。</p>
<p>但这恰好也是智能合约的一大优势。代码说明一切。如果你去读智能合约的代码，并验证它，你会发现，一旦函数被定义下来，每一次的运行，程序都会严格遵照函数中原有的代码逻辑一丝不苟地执行，完全不用担心函数被人篡改而得到意外的结果。</p>
<p><strong>外部依赖关系</strong></p>
<p>在第2课中，我们将加密小猫（CryptoKitties）合约的地址硬编码到 DApp 中去了。有没有想过，如果加密小猫出了点问题，比方说，集体消失了会怎么样？ 虽然这种事情几乎不可能发生，但是，如果小猫没了，我们的 DApp 也会随之失效 – 因为我们在 DApp 的代码中用“硬编码”的方式指定了加密小猫的地址，如果这个根据地址找不到小猫，我们的僵尸也就吃不到小猫了，而按照前面的描述，我们却没法修改合约去应付这个变化！</p>
<p>因此，我们不能硬编码，而要采用“函数”，以便于 DApp 的关键部分可以以参数形式修改。</p>
<p>比方说，我们不再一开始就把猎物地址给写入代码，而是写个函数 <code>setKittyContractAddress</code>, 运行时再设定猎物的地址，这样我们就可以随时去锁定新的猎物，也不用担心加密小猫集体消失了。</p>
<p><strong>实战演习</strong></p>
<p>请修改第2课的代码，使得可以通过程序更改 CryptoKitties 合约地址。</p>
<ol>
<li>删除采用硬编码 方式的 <code>ckAddress</code> 代码行。</li>
<li>之前创建 <code>kittyContract</code> 变量的那行代码，修改为对 <code>kittyContract</code> 变量的声明 – 暂时不给它指定具体的实例。</li>
<li>创建名为 <code>setKittyContractAddress</code> 的函数， 它带一个参数 <code>_address</code>（<code>address</code>类型）， 可见性设为<code>external</code>。</li>
<li>在函数内部，添加一行代码，将 <code>kittyContract</code> 变量设置为返回值：<code>KittyInterface（_address）</code>。</li>
</ol>
<blockquote>
<p>注意：你可能会注意到这个功能有个安全漏洞，别担心 - 咱们到下一章里解决它;）</p>
</blockquote>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract ZombieFeeding is ZombieFactory {</span><br><span class="line"></span><br><span class="line">  // 1. 移除这一行:</span><br><span class="line">  //address ckAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;</span><br><span class="line">  // 2. 只声明变量:</span><br><span class="line">  KittyInterface kittyContract;</span><br><span class="line"></span><br><span class="line">  // 3. 增加 setKittyContractAddress 方法</span><br><span class="line">  function setKittyContractAddress(address _address) external{</span><br><span class="line">    kittyContract = KittyInterface(_address);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第2章-Ownable-Contracts"><a href="#第2章-Ownable-Contracts" class="headerlink" title="第2章: Ownable Contracts"></a>第2章: Ownable Contracts</h3><p>上一章中，您有没有发现任何安全漏洞呢？</p>
<p>呀！<code>setKittyContractAddress</code> 可见性居然申明为“外部的”（<code>external</code>），岂不是任何人都可以调用它！ 也就是说，任何调用该函数的人都可以更改 CryptoKitties 合约的地址，使得其他人都没法再运行我们的程序了。</p>
<p>我们确实是希望这个地址能够在合约中修改，但我可没说让每个人去改它呀。</p>
<p>要对付这样的情况，通常的做法是指定合约的“所有权” - 就是说，给它指定一个主人（没错，就是您），只有主人对它享有特权。</p>
<p><strong>OpenZeppelin库的<code>Ownable</code> 合约</strong></p>
<p>下面是一个 <code>Ownable</code> 合约的例子： 来自 <strong>_ OpenZeppelin _</strong> Solidity 库的 <code>Ownable</code> 合约。 OpenZeppelin 是主打安保和社区审查的智能合约库，您可以在自己的 DApps中引用。等把这一课学完，您不要催我们发布下一课，最好利用这个时间把 OpenZeppelin 的网站看看，保管您会学到很多东西！</p>
<p>把楼下这个合约读读通，是不是还有些没见过代码？别担心，我们随后会解释。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @title Ownable</span><br><span class="line"> * @dev The Ownable contract has an owner address, and provides basic authorization control</span><br><span class="line"> * functions, this simplifies the implementation of "user permissions".</span><br><span class="line"> */</span><br><span class="line">contract Ownable {</span><br><span class="line">  address public owner;</span><br><span class="line">  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev The Ownable constructor sets the original `owner` of the contract to the sender</span><br><span class="line">   * account.</span><br><span class="line">   */</span><br><span class="line">  function Ownable() public {</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev Throws if called by any account other than the owner.</span><br><span class="line">   */</span><br><span class="line">  modifier onlyOwner() {</span><br><span class="line">    require(msg.sender == owner);</span><br><span class="line">    _;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev Allows the current owner to transfer control of the contract to a newOwner.</span><br><span class="line">   * @param newOwner The address to transfer ownership to.</span><br><span class="line">   */</span><br><span class="line">  function transferOwnership(address newOwner) public onlyOwner {</span><br><span class="line">    require(newOwner != address(0));</span><br><span class="line">    OwnershipTransferred(owner, newOwner);</span><br><span class="line">    owner = newOwner;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>下面有没有您没学过的东东？</p>
<ul>
<li>构造函数：<code>function Ownable()</code>是一个 <strong>_ constructor_</strong> (构造函数)，构造函数不是必须的，它与合约同名，构造函数一生中唯一的一次执行，就是在合约最初被创建的时候。</li>
<li>函数修饰符：<code>modifier onlyOwner()</code>。 修饰符跟函数很类似，不过是用来修饰其他已有函数用的， 在其他语句执行前，为它检查下先验条件。 在这个例子中，我们就可以写个修饰符 <code>onlyOwner</code> 检查下调用者，确保只有合约的主人才能运行本函数。我们下一章中会详细讲述修饰符，以及那个奇怪的<code>_;</code>。</li>
<li><code>indexed</code> 关键字：别担心，我们还用不到它。</li>
</ul>
<p>所以<code>Ownable</code> 合约基本都会这么干：</p>
<ol>
<li>合约创建，构造函数先行，将其 <code>owner</code> 设置为<code>msg.sender</code>（其部署者）</li>
<li>为它加上一个修饰符 <code>onlyOwner</code>，它会限制陌生人的访问，将访问某些函数的权限锁定在 <code>owner</code> 上。</li>
<li>允许将合约所有权转让给他人。</li>
</ol>
<p><code>onlyOwner</code> 简直人见人爱，大多数人开发自己的 Solidity DApps，都是从复制/粘贴 <code>Ownable</code> 开始的，从它再继承出的子类，并在之上进行功能开发。</p>
<p>既然我们想把 <code>setKittyContractAddress</code> 限制为 <code>onlyOwner</code> ，我们也要做同样的事情。</p>
<p><strong>实战演习</strong></p>
<p>首先，将 <code>Ownable</code> 合约的代码复制一份到新文件 <code>ownable.sol</code> 中。 接下来，创建一个 <code>ZombieFactory</code>，继承 <code>Ownable</code>。</p>
<p>1.在程序中导入 <code>ownable.sol</code> 的内容。 如果您不记得怎么做了，参考下 <code>zombiefeeding.sol</code>。</p>
<p>2.修改 <code>ZombieFactory</code> 合约， 让它继承自 <code>Ownable</code>。 如果您不记得怎么做了，看看 <code>zombiefeeding.sol</code>。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 1. 在这里导入</span><br><span class="line">import "./ownable.sol";</span><br><span class="line">// 2. 在这里继承:</span><br><span class="line">contract ZombieFactory is Ownable{</span><br><span class="line"></span><br><span class="line">    event NewZombie(uint zombieId, string name, uint dna);</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第3章-onlyOwner-函数修饰符"><a href="#第3章-onlyOwner-函数修饰符" class="headerlink" title="第3章: onlyOwner 函数修饰符"></a>第3章: onlyOwner 函数修饰符</h3><p>现在我们有了个基本版的合约 <code>ZombieFactory</code> 了，它继承自 <code>Ownable</code> 接口，我们也可以给 <code>ZombieFeeding</code> 加上 <code>onlyOwner</code> 函数修饰符。</p>
<p>这就是合约继承的工作原理。记得：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZombieFeeding 是个 ZombieFactory</span><br><span class="line">ZombieFactory 是个 Ownable</span><br></pre></td></tr></tbody></table></figure>

<p>因此 <code>ZombieFeeding</code> 也是个 <code>Ownable</code>, 并可以通过 <code>Ownable</code> 接口访问父类中的函数/事件/修饰符。往后，<code>ZombieFeeding</code> 的继承者合约们同样也可以这么延续下去。</p>
<p><strong>函数修饰符</strong></p>
<p>函数修饰符看起来跟函数没什么不同，不过关键字<code>modifier</code> 告诉编译器，这是个<code>modifier(修饰符)</code>，而不是个<code>function(函数)</code>。它不能像函数那样被直接调用，只能被添加到函数定义的末尾，用以改变函数的行为。</p>
<p>咱们仔细读读 <code>onlyOwner</code>:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @dev 调用者不是‘主人’，就会抛出异常</span><br><span class="line"> */</span><br><span class="line">modifier onlyOwner() {</span><br><span class="line">  require(msg.sender == owner);</span><br><span class="line">  _;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>onlyOwner</code> 函数修饰符是这么用的：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">contract MyContract is Ownable {</span><br><span class="line">  event LaughManiacally(string laughter);</span><br><span class="line"></span><br><span class="line">  //注意！ `onlyOwner`上场 :</span><br><span class="line">  function likeABoss() external onlyOwner {</span><br><span class="line">    LaughManiacally("Muahahahaha");</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注意 <code>likeABoss</code> 函数上的 <code>onlyOwner</code> 修饰符。 当你调用 <code>likeABoss</code> 时，<strong>首先执行</strong> <code>onlyOwner</code> 中的代码， 执行到 <code>onlyOwner</code> 中的 <code>_;</code> 语句时，程序再返回并执行 <code>likeABoss</code> 中的代码。</p>
<p>可见，尽管函数修饰符也可以应用到各种场合，但最常见的还是放在函数执行之前添加快速的 <code>require</code>检查。</p>
<p>因为给函数添加了修饰符 <code>onlyOwner</code>，使得<strong>唯有合约的主人</strong>（也就是部署者）才能调用它。</p>
<blockquote>
<p>注意：主人对合约享有的特权当然是正当的，不过也可能被恶意使用。比如，万一，主人添加了个后门，允许他偷走别人的僵尸呢？</p>
</blockquote>
<blockquote>
<p>所以非常重要的是，部署在以太坊上的 DApp，并不能保证它真正做到去中心，你需要阅读并理解它的源代码，才能防止其中没有被部署者恶意植入后门；作为开发人员，如何做到既要给自己留下修复 bug 的余地，又要尽量地放权给使用者，以便让他们放心你，从而愿意把数据放在你的 DApp 中，这确实需要个微妙的平衡。</p>
</blockquote>
<p><strong>实战演习</strong></p>
<p>现在我们可以限制第三方对 <code>setKittyContractAddress</code>的访问，除了我们自己，谁都无法去修改它。</p>
<ol>
<li>将 <code>onlyOwner</code> 函数修饰符添加到 <code>setKittyContractAddress</code> 中。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 修改这个函数:</span><br><span class="line">function setKittyContractAddress(address _address) external onlyOwner {</span><br><span class="line">  kittyContract = KittyInterface(_address);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第4章-Gas"><a href="#第4章-Gas" class="headerlink" title="第4章: Gas"></a>第4章: Gas</h3><p>厉害！现在我们懂了如何在禁止第三方修改我们的合约的同时，留个后门给咱们自己去修改。</p>
<p>让我们来看另一种使得 Solidity 编程语言与众不同的特征：</p>
<p><strong>Gas - 驱动以太坊DApps的能源</strong></p>
<p>在 Solidity 中，你的用户想要每次执行你的 DApp 都需要支付一定的 ***gas***，gas 可以用以太币购买，因此，用户每次跑 DApp 都得花费以太币。</p>
<p>一个 DApp 收取多少 gas 取决于功能逻辑的复杂程度。每个操作背后，都在计算完成这个操作所需要的计算资源，（比如，存储数据就比做个加法运算贵得多）， 一次操作所需要花费的 *<strong>gas*</strong> 等于这个操作背后的所有运算花销的总和。</p>
<p>由于运行你的程序需要花费用户的真金白银，在以太坊中代码的编程语言，比其他任何编程语言都更强调优化。同样的功能，使用笨拙的代码开发的程序，比起经过精巧优化的代码来，运行花费更高，这显然会给成千上万的用户带来大量不必要的开销。</p>
<p>*<em>为什么要用 <em>gas* 来驱动？</em></em></p>
<p>以太坊就像一个巨大、缓慢、但非常安全的电脑。当你运行一个程序的时候，网络上的每一个节点都在进行相同的运算，以验证它的输出 —— 这就是所谓的“去中心化” 由于数以千计的节点同时在验证着每个功能的运行，这可以确保它的数据不会被被监控，或者被刻意修改。</p>
<p>可能会有用户用无限循环堵塞网络，抑或用密集运算来占用大量的网络资源，为了防止这种事情的发生，以太坊的创建者为以太坊上的资源制定了价格，想要在以太坊上运算或者存储，你需要先付费。</p>
<blockquote>
<p>注意：如果你使用侧链，倒是不一定需要付费，比如咱们在 Loom Network 上构建的 CryptoZombies 就免费。你不会想要在以太坊主网上玩儿“魔兽世界”吧？ - 所需要的 gas 可能会买到你破产。但是你可以找个算法理念不同的侧链来玩它。我们将在以后的课程中咱们会讨论到，什么样的 DApp 应该部署在太坊主链上，什么又最好放在侧链。</p>
</blockquote>
<p><strong>省 gas 的招数：结构封装 （Struct packing）</strong></p>
<p>在第1课中，我们提到除了基本版的 <code>uint</code> 外，还有其他变种 <code>uint</code>：<code>uint8</code>，<code>uint16</code>，<code>uint32</code>等。</p>
<p>通常情况下我们不会考虑使用 <code>uint</code> 变种，因为无论如何定义 <code>uint</code>的大小，Solidity 为它保留256位的存储空间。例如，使用 <code>uint8</code> 而不是<code>uint</code>（<code>uint256</code>）不会为你节省任何 gas。</p>
<p>除非，<u><strong>把 <code>uint</code> 绑定到 <code>struct</code> 里面</strong></u>。</p>
<p>如果一个 <code>struct</code> 中有多个 <code>uint</code>，则尽可能使用较小的 <code>uint</code>, Solidity 会将这些 <code>uint</code> 打包在一起，从而占用较少的存储空间。例如：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct NormalStruct {</span><br><span class="line">  uint a;</span><br><span class="line">  uint b;</span><br><span class="line">  uint c;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">struct MiniMe {</span><br><span class="line">  uint32 a;</span><br><span class="line">  uint32 b;</span><br><span class="line">  uint c;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 因为使用了结构打包，`mini` 比 `normal` 占用的空间更少</span><br><span class="line">NormalStruct normal = NormalStruct(10, 20, 30);</span><br><span class="line">MiniMe mini = MiniMe(10, 20, 30); </span><br></pre></td></tr></tbody></table></figure>

<p>所以，当 <code>uint</code> 定义在一个 <code>struct</code> 中的时候，尽量使用最小的整数子类型以节约空间。 **<u>并且把同样类型的变量放一起</u>**（即在 struct 中将把变量按照类型依次放置），<u>这样 Solidity 可以将存储空间最小化</u>。例如，有两个 <code>struct</code>：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint c; uint32 a; uint32 b;` 和 `uint32 a; uint c; uint32 b;</span><br></pre></td></tr></tbody></table></figure>

<p>前者比后者需要的gas更少，因为前者把<code>uint32</code>放一起了。</p>
<p><strong>实战演习</strong></p>
<p>在本课中，咱们给僵尸添2个新功能：<code>level</code> 和 <code>readyTime</code> - 后者是用来实现一个“冷却定时器”，以限制僵尸猎食的频率。</p>
<p>让我们回到 <code>zombiefactory.sol</code>。</p>
<ol>
<li>为 <code>Zombie</code> 结构体 添加两个属性：<code>level</code>（<code>uint32</code>）和<code>readyTime</code>（<code>uint32</code>）。因为希望同类型数据打成一个包，所以把它们放在结构体的末尾。</li>
</ol>
<p>32位足以保存僵尸的级别和时间戳了，这样比起使用普通的<code>uint</code>（256位），可以更紧密地封装数据，从而为我们省点 gas。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">contract ZombieFactory is Ownable {</span><br><span class="line"></span><br><span class="line">    event NewZombie(uint zombieId, string name, uint dna);</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie {</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">        //在这里添加数据</span><br><span class="line">        uint32 level;</span><br><span class="line">        uint32 readyTime;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第5章-时间单位"><a href="#第5章-时间单位" class="headerlink" title="第5章: 时间单位"></a>第5章: 时间单位</h3><p><code>level</code> 属性表示僵尸的级别。以后，在我们创建的战斗系统中，打胜仗的僵尸会逐渐升级并获得更多的能力。</p>
<p><code>readyTime</code> 稍微复杂点。我们希望增加一个“冷却周期”，表示僵尸在两次猎食或攻击之之间必须等待的时间。如果没有它，僵尸每天可能会攻击和繁殖1,000次，这样游戏就太简单了。</p>
<p>为了记录僵尸在下一次进击前需要等待的时间，我们使用了 Solidity 的时间单位。</p>
<p><strong>时间单位</strong></p>
<p>Solidity 使用自己的本地时间单位。</p>
<p>变量 <code>now</code> 将返回当前的unix时间戳（自1970年1月1日以来经过的秒数）。我写这句话时 unix 时间是 <code>1515527488</code>。</p>
<blockquote>
<p>注意：Unix时间传统用一个32位的整数进行存储。这会导致“2038年”问题，当这个32位的unix时间戳不够用，产生溢出，使用这个时间的遗留系统就麻烦了。所以，如果我们想让我们的 DApp 跑够20年，我们可以使用64位整数表示时间，但为此我们的用户又得支付更多的 gas。真是个两难的设计啊！</p>
</blockquote>
<p>Solidity 还包含<code>秒(seconds)</code>，<code>分钟(minutes)</code>，<code>小时(hours)</code>，<code>天(days)</code>，<code>周(weeks)</code> 和 <code>年(years)</code> 等时间单位。它们都会转换成对应的秒数放入 <code>uint</code> 中。所以 <code>1分钟</code> 就是 <code>60</code>，<code>1小时</code>是 <code>3600</code>（60秒×60分钟），<code>1天</code>是<code>86400</code>（24小时×60分钟×60秒），以此类推。</p>
<p>下面是一些使用时间单位的实用案例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">uint lastUpdated;</span><br><span class="line"></span><br><span class="line">// 将‘上次更新时间’ 设置为 ‘现在’</span><br><span class="line">function updateTimestamp() public {</span><br><span class="line">  lastUpdated = now;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 如果到上次`updateTimestamp` 超过5分钟，返回 'true'</span><br><span class="line">// 不到5分钟返回 'false'</span><br><span class="line">function fiveMinutesHavePassed() public view returns (bool) {</span><br><span class="line">  return (now &gt;= (lastUpdated + 5 minutes));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>有了这些工具，我们可以为僵尸设定“冷静时间”功能。</p>
<p><strong>实战演习</strong></p>
<p>现在咱们给DApp添加一个“冷却周期”的设定，让僵尸两次攻击或捕猎之间必须等待 <strong>1天</strong>。</p>
<ol>
<li><p>声明一个名为 <code>cooldownTime</code> 的<code>uint</code>，并将其设置为 <code>1 days</code>。（没错，”1 days“使用了复数， 否则通不过编译器）</p>
</li>
<li><p>因为在上一章中我们给 <code>Zombie</code> 结构体中添加 <code>level</code> 和 <code>readyTime</code> 两个参数，所以现在创建一个新的 <code>Zombie</code> 结构体时，需要修改 <code>_createZombie()</code>，在其中把新旧参数都初始化一下。</p>
<p> 修改 <code>zombies.push</code> 那一行， 添加加2个参数：<code>1</code>（表示当前的 <code>level</code> ）和<code>uint32（now + cooldownTime）</code>（现在+冷却时间，表示下次允许攻击的时间 <code>readyTime</code>）。</p>
</li>
</ol>
<blockquote>
<p>注意：必须使用 <code>uint32（...）</code> 进行强制类型转换，因为 <code>now</code> 返回类型 <code>uint256</code>。所以我们需要明确将它转换成一个 <code>uint32</code> 类型的变量。</p>
</blockquote>
<p><code>now + cooldownTime</code> 将等于当前的unix时间戳（以秒为单位）加上”1天“里的秒数 - 这将等于从现在起1天后的unix时间戳。然后我们就比较，看看这个僵尸的 <code>readyTime</code>是否大于 <code>now</code>，以决定再次启用僵尸的时机有没有到来。</p>
<p>下一章中，我们将讨论如何通过 <code>readyTime</code> 来规范僵尸的行为。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 1. 在这里定义 `cooldownTime`</span><br><span class="line">uint cooldownTime = 1 days;</span><br><span class="line">    </span><br><span class="line">function _createZombie(string _name, uint _dna) internal {</span><br><span class="line">        // 2. 修改下面这行:</span><br><span class="line">        uint id = zombies.push(Zombie(_name, _dna, 1, uint32(now + cooldownTime))) - 1;</span><br><span class="line">        zombieToOwner[id] = msg.sender;</span><br><span class="line">        ownerZombieCount[msg.sender]++;</span><br><span class="line">        NewZombie(id, _name, _dna);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第6章-僵尸冷却"><a href="#第6章-僵尸冷却" class="headerlink" title="第6章: 僵尸冷却"></a>第6章: 僵尸冷却</h3><p>现在，<code>Zombie</code> 结构体中定义好了一个 <code>readyTime</code> 属性，让我们跳到 <code>zombiefeeding.sol</code>， 去实现一个”冷却周期定时器“。</p>
<p>按照以下步骤修改 <code>feedAndMultiply</code>：</p>
<ol>
<li>”捕猎“行为会触发僵尸的”冷却周期“</li>
<li>僵尸在这段”冷却周期“结束前不可再捕猎小猫</li>
</ol>
<p>这将限制僵尸，防止其无限制地捕猎小猫或者整天不停地繁殖。将来，当我们增加战斗功能时，我们同样用”冷却周期“限制僵尸之间打斗的频率。</p>
<p>首先，我们要定义一些辅助函数，设置并检查僵尸的 <code>readyTime</code>。</p>
<p><strong>将结构体作为参数传入</strong></p>
<p>由于结构体的存储指针可以以参数的方式传递给一个 <code>private</code> 或 <code>internal</code> 的函数，因此结构体可以在多个函数之间相互传递。</p>
<p>遵循这样的语法：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function _doStuff(Zombie storage _zombie) internal {</span><br><span class="line">  // do stuff with _zombie</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这样我们可以将某僵尸的引用直接传递给一个函数，而不用是通过参数传入僵尸ID后，函数再依据ID去查找。</p>
<p><strong>实战演习</strong></p>
<ol>
<li>先定义一个 <code>_triggerCooldown</code> 函数。它要求一个参数，<code>_zombie</code>，表示一某个僵尸的存储指针。这个函数可见性设置为 <code>internal</code>。</li>
<li>在函数中，把 <code>_zombie.readyTime</code> 设置为 <code>uint32（now + cooldownTime）</code>。</li>
<li>接下来，创建一个名为 <code>_isReady</code> 的函数。这个函数的参数也是名为 <code>_zombie</code> 的 <code>Zombie storage</code>。这个功能只具有 <code>internal</code> 可见性，并返回一个 <code>bool</code> 值。</li>
<li>函数计算返回<code>(_zombie.readyTime &lt;= now)</code>，值为 <code>true</code> 或 <code>false</code>。这个功能的目的是判断下次允许猎食的时间是否已经到了。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 1. 在这里定义 `_triggerCooldown` 函数</span><br><span class="line">  function _triggerCooldown(Zombie storage _zombie) internal {</span><br><span class="line">    _zombie.readyTime = uint32(now + cooldownTime);</span><br><span class="line">  }</span><br><span class="line">  // 2. 在这里定义 `_isReady` 函数</span><br><span class="line">  function _isReady(Zombie storage _zombie) internal view returns(bool){</span><br><span class="line">    return (_zombie.readyTime &lt;= now);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第7章-公有函数和安全性"><a href="#第7章-公有函数和安全性" class="headerlink" title="第7章: 公有函数和安全性"></a>第7章: 公有函数和安全性</h3><p>现在来修改 <code>feedAndMultiply</code> ，实现冷却周期。</p>
<p>回顾一下这个函数，前一课上我们将其可见性设置为<code>public</code>。你必须仔细地检查所有声明为 <code>public</code> 和 <code>external</code>的函数，一个个排除用户滥用它们的可能，谨防安全漏洞。请记住，如果这些函数没有类似 <code>onlyOwner</code> 这样的函数修饰符，用户能利用各种可能的参数去调用它们。</p>
<p>检查完这个函数，用户就可以直接调用这个它，并传入他们所希望的 <code>_targetDna</code> 或 <code>species</code> 。打个游戏还得遵循这么多的规则，还能不能愉快地玩耍啊！</p>
<p>仔细观察，这个函数只需被 <code>feedOnKitty()</code> 调用，因此，想要防止漏洞，最简单的方法就是设其可见性为 <code>internal</code>。</p>
<p><strong>实战演习</strong></p>
<ol>
<li>目前函数 <code>feedAndMultiply</code> 可见性为 <code>public</code>。我们将其改为 <code>internal</code> 以保障合约安全。因为我们不希望用户调用它的时候塞进一堆乱七八糟的 DNA。</li>
<li><code>feedAndMultiply</code> 过程需要参考 <code>cooldownTime</code>。首先，在找到 <code>myZombie</code> 之后，添加一个 <code>require</code> 语句来检查 <code>_isReady()</code> 并将 <code>myZombie</code> 传递给它。这样用户必须等到僵尸的 <code>冷却周期</code> 结束后才能执行 <code>feedAndMultiply</code> 功能。</li>
<li>在函数结束时，调用 <code>_triggerCooldown(myZombie)</code>，标明捕猎行为触发了僵尸新的冷却周期。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 1. 使这个函数的可见性为 internal</span><br><span class="line">  function feedAndMultiply(uint _zombieId, uint _targetDna, string species) internal {</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    // 2. 在这里为 `_isReady` 增加一个检查</span><br><span class="line">    require(_isReady(myZombie));</span><br><span class="line">    _targetDna = _targetDna % dnaModulus;</span><br><span class="line">    uint newDna = (myZombie.dna + _targetDna) / 2;</span><br><span class="line">    if (keccak256(species) == keccak256("kitty")) {</span><br><span class="line">      newDna = newDna - newDna % 100 + 99;</span><br><span class="line">    }</span><br><span class="line">    _createZombie("NoName", newDna);</span><br><span class="line">    // 3. 调用 `_triggerCooldown`</span><br><span class="line">    _triggerCooldown(myZombie);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第8章-进一步了解函数修饰符"><a href="#第8章-进一步了解函数修饰符" class="headerlink" title="第8章: 进一步了解函数修饰符"></a>第8章: 进一步了解函数修饰符</h3><p>相当不错！我们的僵尸现在有了“冷却定时器”功能。</p>
<p>接下来，我们将添加一些辅助方法。我们为您创建了一个名为 <code>zombiehelper.sol</code> 的新文件，并且将 <code>zombiefeeding.sol</code> 导入其中，这让我们的代码更整洁。</p>
<p>我们打算让僵尸在达到一定水平后，获得特殊能力。但是达到这个小目标，我们还需要学一学什么是“函数修饰符”。</p>
<p><strong>带参数的函数修饰符</strong></p>
<p>之前我们已经读过一个简单的函数修饰符了：<code>onlyOwner</code>。函数修饰符也可以带参数。例如：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 存储用户年龄的映射</span><br><span class="line">mapping (uint =&gt; uint) public age;</span><br><span class="line"></span><br><span class="line">// 限定用户年龄的修饰符</span><br><span class="line">modifier olderThan(uint _age, uint _userId) {</span><br><span class="line">  require(age[_userId] &gt;= _age);</span><br><span class="line">  _;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 必须年满16周岁才允许开车 (至少在美国是这样的).</span><br><span class="line">// 我们可以用如下参数调用`olderThan` 修饰符:</span><br><span class="line">function driveCar(uint _userId) public olderThan(16, _userId) {</span><br><span class="line">  // 其余的程序逻辑</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>看到了吧， <code>olderThan</code> 修饰符可以像函数一样接收参数，是“宿主”函数 <code>driveCar</code> 把参数传递给它的修饰符的。</p>
<p>来，我们自己生产一个修饰符，通过传入的<code>level</code>参数来限制僵尸使用某些特殊功能。</p>
<p><strong>实战演习</strong></p>
<ol>
<li>在<code>ZombieHelper</code> 中，创建一个名为 <code>aboveLevel</code> 的<code>modifier</code>，它接收2个参数， <code>_level</code> (<code>uint</code>类型) 以及 <code>_zombieId</code> (<code>uint</code>类型)。</li>
<li>运用函数逻辑确保僵尸 <code>zombies[_zombieId].level</code> 大于或等于 <code>_level</code>。</li>
<li>记住，修饰符的最后一行为 <code>_;</code>，表示修饰符调用结束后返回，并执行调用函数余下的部分。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import "./zombiefeeding.sol";</span><br><span class="line"></span><br><span class="line">contract ZombieHelper is ZombieFeeding {</span><br><span class="line"></span><br><span class="line">  // 在这里开始</span><br><span class="line">  modifier aboveLevel(uint _level, uint _zombieId){</span><br><span class="line">    require(zombies[_zombieId].level &gt;= _level);</span><br><span class="line">    _;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第9章-僵尸修饰符"><a href="#第9章-僵尸修饰符" class="headerlink" title="第9章: 僵尸修饰符"></a>第9章: 僵尸修饰符</h3><p>现在让我们设计一些使用 <code>aboveLevel</code> 修饰符的函数。</p>
<p>作为游戏，您得有一些措施激励玩家们去升级他们的僵尸：</p>
<ul>
<li>2级以上的僵尸，玩家可给他们改名。</li>
<li>20级以上的僵尸，玩家能给他们定制的 DNA。</li>
</ul>
<p>是实现这些功能的时候了。以下是上一课的示例代码，供参考：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 存储用户年龄的映射</span><br><span class="line">mapping (uint =&gt; uint) public age;</span><br><span class="line"></span><br><span class="line">// 限定用户年龄的修饰符</span><br><span class="line">modifier olderThan(uint _age, uint _userId) {</span><br><span class="line">  require (age[_userId] &gt;= _age);</span><br><span class="line">  _;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 必须年满16周岁才允许开车 (至少在美国是这样的).</span><br><span class="line">// 我们可以用如下参数调用`olderThan` 修饰符:</span><br><span class="line">function driveCar(uint _userId) public olderThan(16, _userId) {</span><br><span class="line">  // 其余的程序逻辑</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实战演习</strong></p>
<ol>
<li>创建一个名为 <code>changeName</code> 的函数。它接收2个参数：<code>_zombieId</code>（<code>uint</code>类型）以及 <code>_newName</code>（<code>string</code>类型），可见性为 <code>external</code>。它带有一个 <code>aboveLevel</code> 修饰符，调用的时候通过 <code>_level</code> 参数传入<code>2</code>， 当然，别忘了同时传 <code>_zombieId</code> 参数。</li>
<li>在这个函数中，首先我们用 <code>require</code> 语句，验证 <code>msg.sender</code> 是否就是 <code>zombieToOwner [_zombieId]</code>。</li>
<li>然后函数将 <code>zombies[_zombieId] .name</code> 设置为 <code>_newName</code>。</li>
<li>在 <code>changeName</code> 下创建另一个名为 <code>changeDna</code> 的函数。它的定义和内容几乎和 <code>changeName</code> 相同，不过它第二个参数是 <code>_newDna</code>（<code>uint</code>类型），在修饰符 <code>aboveLevel</code> 的 <code>_level</code> 参数中传递 <code>20</code> 。现在，他可以把僵尸的 <code>dna</code> 设置为 <code>_newDna</code> 了。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 在这里开始</span><br><span class="line">  function changeName(uint _zombieId, string _newName) external aboveLevel(2, _zombieId){</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    zombies[_zombieId].name = _newName;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  function changeDna(uint _zombieId, uint _newDna) external aboveLevel(20, _zombieId){</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    zombies[_zombieId].dna = _newDna;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第10章-利用-‘View’-函数节省-Gas"><a href="#第10章-利用-‘View’-函数节省-Gas" class="headerlink" title="第10章: 利用 ‘View’ 函数节省 Gas"></a>第10章: 利用 ‘View’ 函数节省 Gas</h3><p>酷炫！现在高级别僵尸可以拥有特殊技能了，这一定会鼓动我们的玩家去打怪升级的。你喜欢的话，回头我们还能添加更多的特殊技能。</p>
<p>现在需要添加的一个功能是：我们的 DApp 需要一个方法来查看某玩家的整个僵尸军团 - 我们称之为 <code>getZombiesByOwner</code>。</p>
<p>实现这个功能只需从区块链中读取数据，所以它可以是一个 <code>view</code> 函数。这让我们不得不回顾一下“gas优化”这个重要话题。</p>
<p><strong>“view” 函数不花 “gas”</strong></p>
<p>当玩家从外部调用一个<code>view</code>函数，是不需要支付一分 gas 的。</p>
<p>这是因为 <code>view</code> 函数不会真正改变区块链上的任何数据 - 它们只是读取。因此用 <code>view</code> 标记一个函数，意味着告诉 <code>web3.js</code>，运行这个函数只需要查询你的本地以太坊节点，而不需要在区块链上创建一个事务（事务需要运行在每个节点上，因此花费 gas）。</p>
<p>稍后我们将介绍如何在自己的节点上设置 web3.js。但现在，你关键是要记住，在所能只读的函数上标记上表示“只读”的“<code>external view</code> 声明，就能为你的玩家减少在 DApp 中 gas 用量。</p>
<blockquote>
<p>注意：如果一个 <code>view</code> 函数在另一个函数的内部被调用，而调用函数与 <code>view</code> 函数的不属于同一个合约，也会产生调用成本。这是因为如果主调函数在以太坊创建了一个事务，它仍然需要逐个节点去验证。所以标记为 <code>view</code> 的函数只有在外部调用时才是免费的。</p>
</blockquote>
<p><strong>实战演习</strong></p>
<p>我们来写一个”返回某玩家的整个僵尸军团“的函数。当我们从 <code>web3.js</code> 中调用它，即可显示某一玩家的个人资料页。</p>
<p>这个函数的逻辑有点复杂，我们需要好几个章节来描述它的实现。</p>
<ol>
<li>创建一个名为 <code>getZombiesByOwner</code> 的新函数。它有一个名为 <code>_owner</code> 的 <code>address</code> 类型的参数。</li>
<li>将其申明为 <code>external view</code> 函数，这样当玩家从 <code>web3.js</code> 中调用它时，不需要花费任何 gas。</li>
<li>函数需要返回一个<code>uint []</code>（<code>uint</code>数组）。</li>
</ol>
<p>先这么声明着，我们将在下一章中填充函数体。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 在这里创建你的函数</span><br><span class="line"> function getZombiesByOwner(address _owner) external view returns(uint[]){</span><br><span class="line"></span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第11章-存储非常昂贵"><a href="#第11章-存储非常昂贵" class="headerlink" title="第11章: 存储非常昂贵"></a>第11章: 存储非常昂贵</h3><p>Solidity 使用<code>storage</code>(存储)是相当昂贵的，”写入“操作尤其贵。</p>
<p>这是因为，无论是写入还是更改一段数据， 这都将永久性地写入区块链。”永久性“啊！需要在全球数千个节点的硬盘上存入这些数据，随着区块链的增长，拷贝份数更多，存储量也就越大。这是需要成本的！</p>
<p>为了降低成本，不到万不得已，避免将数据写入存储。这也会导致效率低下的编程逻辑 - 比如每次调用一个函数，都需要在 <code>memory</code>(内存) 中重建一个数组，而不是简单地将上次计算的数组给存储下来以便快速查找。</p>
<p>在大多数编程语言中，遍历大数据集合都是昂贵的。但是在 Solidity 中，使用一个标记了<code>external view</code>的函数，遍历比 <code>storage</code> 要便宜太多，因为 <code>view</code> 函数不会产生任何花销。 （gas可是真金白银啊！）。</p>
<p>我们将在下一章讨论<code>for</code>循环，现在我们来看一下看如何如何在内存中声明数组。</p>
<p><strong>在内存中声明数组</strong></p>
<p>在数组后面加上 <code>memory</code>关键字， 表明这个数组是仅仅在内存中创建，不需要写入外部存储，并且在函数调用结束时它就解散了。与在程序结束时把数据保存进 <code>storage</code> 的做法相比，内存运算可以大大节省gas开销 – 把这数组放在<code>view</code>里用，完全不用花钱。</p>
<p>以下是申明一个内存数组的例子：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function getArray() external pure returns(uint[]) {</span><br><span class="line">  // 初始化一个长度为3的内存数组</span><br><span class="line">  uint[] memory values = new uint[](3);</span><br><span class="line">  // 赋值</span><br><span class="line">  values.push(1);</span><br><span class="line">  values.push(2);</span><br><span class="line">  values.push(3);</span><br><span class="line">  // 返回数组</span><br><span class="line">  return values;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个小例子展示了一些语法规则，下一章中，我们将通过一个实际用例，展示它和 <code>for</code> 循环结合的做法。</p>
<blockquote>
<p>注意：内存数组 <strong>必须</strong> 用长度参数（在本例中为<code>3</code>）创建。目前不支持 <code>array.push()</code>之类的方法调整数组大小，在未来的版本可能会支持长度修改。</p>
</blockquote>
<p><strong>实战演习</strong></p>
<p>我们要要创建一个名为 <code>getZombiesByOwner</code> 的函数，它以<code>uint []</code>数组的形式返回某一用户所拥有的所有僵尸。</p>
<ol>
<li>声明一个名为<code>result</code>的<code>uint [] memory'</code> （内存变量数组）</li>
<li>将其设置为一个新的 <code>uint</code> 类型数组。数组的长度为该 <code>_owner</code> 所拥有的僵尸数量，这可通过调用 <code>ownerZombieCount [_ owner]</code> 来获取。</li>
<li>函数结束，返回 <code>result</code> 。目前它只是个空数列，我们到下一章去实现它。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function getZombiesByOwner(address _owner) external view returns(uint[]) {</span><br><span class="line">    // 在这里开始</span><br><span class="line">    uint[] memory result = new uint[](ownerZombieCount[_owner]);</span><br><span class="line">    return result;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第12章-For-循环"><a href="#第12章-For-循环" class="headerlink" title="第12章: For 循环"></a>第12章: For 循环</h3><p>在之前的章节中，我们提到过，函数中使用的数组是运行时在内存中通过 <code>for</code> 循环实时构建，而不是预先建立在存储中的。</p>
<p>为什么要这样做呢？</p>
<p>为了实现 <code>getZombiesByOwner</code> 函数，一种“无脑式”的解决方案是在 <code>ZombieFactory</code> 中存入”主人“和”僵尸军团“的映射。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapping (address =&gt; uint[]) public ownerToZombies</span><br></pre></td></tr></tbody></table></figure>

<p>然后我们每次创建新僵尸时，执行 <code>ownerToZombies [owner] .push（zombieId）</code> 将其添加到主人的僵尸数组中。而 <code>getZombiesByOwner</code> 函数也非常简单：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function getZombiesByOwner(address _owner) external view returns (uint[]) {</span><br><span class="line">  return ownerToZombies[_owner];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>这个做法有问题</strong></p>
<p>做法倒是简单。可是如果我们需要一个函数来把一头僵尸转移到另一个主人名下（我们一定会在后面的课程中实现的），又会发生什么？</p>
<p>这个“换主”函数要做到：</p>
<p>1.将僵尸push到新主人的 <code>ownerToZombies</code> 数组中， 2.从旧主的 <code>ownerToZombies</code> 数组中移除僵尸， 3.将旧主僵尸数组中“换主僵尸”之后的的每头僵尸都往前挪一位，把挪走“换主僵尸”后留下的“空槽”填上， 4.将数组长度减1。</p>
<p>但是第三步实在是太贵了！因为每挪动一头僵尸，我们都要执行一次写操作。如果一个主人有20头僵尸，而第一头被挪走了，那为了保持数组的顺序，我们得做19个写操作。</p>
<p>由于写入存储是 Solidity 中最费 gas 的操作之一，使得换主函数的每次调用都非常昂贵。更糟糕的是，每次调用的时候花费的 gas 都不同！具体还取决于用户在原主军团中的僵尸头数，以及移走的僵尸所在的位置。以至于用户都不知道应该支付多少 gas。</p>
<blockquote>
<p>注意：当然，我们也可以把数组中最后一个僵尸往前挪来填补空槽，并将数组长度减少一。但这样每做一笔交易，都会改变僵尸军团的秩序。</p>
</blockquote>
<p>由于从外部调用一个 <code>view</code> 函数是免费的，我们也可以在 <code>getZombiesByOwner</code> 函数中用一个for循环遍历整个僵尸数组，把属于某个主人的僵尸挑出来构建出僵尸数组。那么我们的 <code>transfer</code> 函数将会便宜得多，因为我们不需要挪动存储里的僵尸数组重新排序，总体上这个方法会更便宜，虽然有点反直觉。</p>
<p><strong>使用 <code>for</code> 循环</strong></p>
<p><code>for</code>循环的语法在 Solidity 和 JavaScript 中类似。</p>
<p>来看一个创建偶数数组的例子：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function getEvens() pure external returns(uint[]) {</span><br><span class="line">  uint[] memory evens = new uint[](5);</span><br><span class="line">  // 在新数组中记录序列号</span><br><span class="line">  uint counter = 0;</span><br><span class="line">  // 在循环从1迭代到10：</span><br><span class="line">  for (uint i = 1; i &lt;= 10; i++) {</span><br><span class="line">    // 如果 `i` 是偶数...</span><br><span class="line">    if (i % 2 == 0) {</span><br><span class="line">      // 把它加入偶数数组</span><br><span class="line">      evens[counter] = i;</span><br><span class="line">      //索引加一， 指向下一个空的‘even’</span><br><span class="line">      counter++;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  return evens;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个函数将返回一个形为 <code>[2,4,6,8,10]</code> 的数组。</p>
<p><strong>实战演习</strong></p>
<p>我们回到 <code>getZombiesByOwner</code> 函数， 通过一条 <code>for</code> 循环来遍历 DApp 中所有的僵尸， 将给定的‘用户id’与每头僵尸的‘主人’进行比较，并在函数返回之前将它们推送到我们的<code>result</code> 数组中。</p>
<p>1.声明一个变量 <code>counter</code>，属性为 <code>uint</code>，设其值为 <code>0</code> 。我们用这个变量作为 <code>result</code> 数组的索引。</p>
<p>2.声明一个 <code>for</code> 循环， 从 <code>uint i = 0</code> 到 <code>i &lt;zombies.length</code>。它将遍历数组中的每一头僵尸。</p>
<p>3.在每一轮 <code>for</code> 循环中，用一个 <code>if</code> 语句来检查 <code>zombieToOwner [i]</code> 是否等于 <code>_owner</code>。这会比较两个地址是否匹配。</p>
<p>4.在 <code>if</code> 语句中：</p>
<ol>
<li>通过将 <code>result [counter]</code> 设置为 <code>i</code>，将僵尸ID添加到 <code>result</code> 数组中。</li>
<li>将counter加1（参见上面的for循环示例）。</li>
</ol>
<p>就是这样 - 这个函数能返回 <code>_owner</code> 所拥有的僵尸数组，不花一分钱 gas。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function getZombiesByOwner(address _owner) external view returns(uint[]) {</span><br><span class="line">    uint[] memory result = new uint[](ownerZombieCount[_owner]);</span><br><span class="line">    // 在这里开始</span><br><span class="line">    uint counter = 0;</span><br><span class="line">    for(uint i = 0; i &lt;zombies.length; i++){</span><br><span class="line">      if(zombieToOwner[i] == _owner){</span><br><span class="line">        result[counter] = i;</span><br><span class="line">        counter++;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    return result;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第13章-放在一起"><a href="#第13章-放在一起" class="headerlink" title="第13章: 放在一起"></a>第13章: 放在一起</h3><p>恭喜您啊，居然把第三课也学完了！</p>
<p><strong>让我们回顾一下：</strong></p>
<ul>
<li>添加了一种新方法来修改CryptoKitties合约</li>
<li>学会使用 <code>onlyOwner</code> 进行调用权限限制</li>
<li>了解了 gas 和 gas 的优化</li>
<li>为僵尸添加了 “级别” 和 “冷却周期”属性</li>
<li>当僵尸达到一定级别时，允许修改僵尸的名字和 DNA</li>
<li>最后，定义了一个函数，用以返回某个玩家的僵尸军团</li>
</ul>
<p><strong>领奖时间</strong></p>
<p>作为完成第三课的奖励，您的两个僵尸都已经升级了！</p>
<p>现在 NoName（你在第2课创建的小猫僵尸）已经升级到第2级，你可以调用 <code>changeName</code> 给它取个名字。 终于不再是无名之辈了！</p>
<p>去给您的 NoName 取个名字吧，等你做完下一章，本课程就结束了。</p>
<h2 id="lesson4-僵尸作战系统"><a href="#lesson4-僵尸作战系统" class="headerlink" title="lesson4 僵尸作战系统"></a>lesson4 僵尸作战系统</h2><h3 id="第1章-可支付"><a href="#第1章-可支付" class="headerlink" title="第1章: 可支付"></a>第1章: 可支付</h3><p>截至目前，我们只接触到很少的 <strong>函数修饰符</strong>。 要记住所有的东西很难，所以我们来个概览：</p>
<ol>
<li>我们有决定函数何时和被谁调用的可见性修饰符: <code>private</code> 意味着它只能被合约内部调用； <code>internal</code> 就像 <code>private</code> 但是也能被继承的合约调用； <code>external</code> 只能从合约外部调用；最后 <code>public</code> 可以在任何地方调用，不管是内部还是外部。</li>
<li>我们也有状态修饰符， 告诉我们函数如何和区块链交互: <code>view</code> 告诉我们运行这个函数不会更改和保存任何数据； <code>pure</code> 告诉我们这个函数不但不会往区块链写数据，它甚至不从区块链读取数据。这两种在被从合约外部调用的时候都不花费任何gas（但是它们在被内部其他函数调用的时候将会耗费gas）。</li>
<li>然后我们有了自定义的 <code>modifiers</code>，例如在第三课学习的: <code>onlyOwner</code> 和 <code>aboveLevel</code>。 对于这些修饰符我们可以自定义其对函数的约束逻辑。</li>
</ol>
<p>这些修饰符可以同时作用于一个函数定义上：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function test() external view onlyOwner anotherModifier { /* ... */ }</span><br></pre></td></tr></tbody></table></figure>

<p>在这一章，我们来学习一个新的修饰符 <code>payable</code>.</p>
<p><strong><code>payable</code> 修饰符</strong></p>
<p><code>payable</code> 方法是让 Solidity 和以太坊变得如此酷的一部分 —— 它们是一种可以接收以太的特殊函数。</p>
<p>先放一下。当你在调用一个普通网站服务器上的API函数的时候，你无法用你的函数传送美元——你也不能传送比特币。</p>
<p>但是在以太坊中， 因为钱 (<em>以太</em>), 数据 (<em>事务负载</em>)， 以及合约代码本身都存在于以太坊。你可以在同时调用函数 <strong>并</strong>付钱给另外一个合约。</p>
<p>这就允许出现很多有趣的逻辑， 比如向一个合约要求支付一定的钱来运行一个函数。</p>
<p><strong>来看个例子</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">contract OnlineStore {</span><br><span class="line">  function buySomething() external payable {</span><br><span class="line">    // 检查以确定0.001以太发送出去来运行函数:</span><br><span class="line">    require(msg.value == 0.001 ether);</span><br><span class="line">    // 如果为真，一些用来向函数调用者发送数字内容的逻辑</span><br><span class="line">    transferThing(msg.sender);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在这里，<code>msg.value</code> 是一种可以查看向合约发送了多少以太的方法，另外 <code>ether</code> 是一个內建单元。</p>
<p>这里发生的事是，一些人会从 web3.js 调用这个函数 (从DApp的前端)， 像这样 :</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 假设 `OnlineStore` 在以太坊上指向你的合约:</span><br><span class="line">OnlineStore.buySomething().send(from: web3.eth.defaultAccount, value: web3.utils.toWei(0.001))</span><br></pre></td></tr></tbody></table></figure>

<p>注意这个 <code>value</code> 字段， JavaScript 调用来指定发送多少(0.001)<code>以太</code>。如果把事务想象成一个信封，你发送到函数的参数就是信的内容。 添加一个 <code>value</code> 很像在信封里面放钱 —— 信件内容和钱同时发送给了接收者。</p>
<blockquote>
<p>注意： 如果一个函数没标记为<code>payable</code>， 而你尝试利用上面的方法发送以太，函数将拒绝你的事务。</p>
</blockquote>
<p><strong>实战演习</strong></p>
<p>我们来在僵尸游戏里面创建一个<code>payable</code> 函数。</p>
<p>假定在我们的游戏中，玩家可以通过支付ETH来升级他们的僵尸。ETH将存储在你拥有的合约中 —— 一个简单明了的例子，向你展示你可以通过自己的游戏赚钱。</p>
<ol>
<li>定义一个 <code>uint</code> ，命名为 <code>levelUpFee</code>, 将值设定为 <code>0.001 ether</code>。</li>
<li>定义一个名为 <code>levelUp</code> 的函数。 它将接收一个 <code>uint</code> 参数 <code>_zombieId</code>。 函数应该修饰为 <code>external</code> 以及 <code>payable</code>。</li>
<li>这个函数首先应该 <code>require</code> 确保 <code>msg.value</code> 等于 <code>levelUpFee</code>。</li>
<li>然后它应该增加僵尸的 <code>level</code>: <code>zombies[_zombieId].level++</code>。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 1. 在这里定义 levelUpFee</span><br><span class="line">  uint levelUpFee = 0.001 ether;</span><br><span class="line"></span><br><span class="line">  modifier aboveLevel(uint _level, uint _zombieId) {</span><br><span class="line">    require(zombies[_zombieId].level &gt;= _level);</span><br><span class="line">    _;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  // 2. 在这里插入 levelUp 函数 </span><br><span class="line">  function levelUp(uint _zombieId) external payable {</span><br><span class="line">    require(msg.value == levelUpFee);</span><br><span class="line">    zombies[_zombieId].level++;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第2章-提现"><a href="#第2章-提现" class="headerlink" title="第2章: 提现"></a>第2章: 提现</h3><p>在上一章，我们学习了如何向合约发送以太，那么在发送之后会发生什么呢？</p>
<p>在你发送以太之后，它将被存储进以合约的以太坊账户中， 并冻结在哪里 —— 除非你添加一个函数来从合约中把以太提现。</p>
<p>你可以写一个函数来从合约中提现以太，类似这样：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">contract GetPaid is Ownable {</span><br><span class="line">  function withdraw() external onlyOwner {</span><br><span class="line">    owner.transfer(this.balance);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注意我们使用 <code>Ownable</code> 合约中的 <code>owner</code> 和 <code>onlyOwner</code>，假定它已经被引入了。</p>
<p>你可以通过 <code>transfer</code> 函数向一个地址发送以太， 然后 <code>this.balance</code> 将返回当前合约存储了多少以太。 所以如果100个用户每人向我们支付1以太， <code>this.balance</code> 将是100以太。</p>
<p>你可以通过 <code>transfer</code> 向任何以太坊地址付钱。 比如，你可以有一个函数在 <code>msg.sender</code> 超额付款的时候给他们退钱：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint itemFee = 0.001 ether;</span><br><span class="line">msg.sender.transfer(msg.value - itemFee);</span><br></pre></td></tr></tbody></table></figure>

<p>或者在一个有卖家和卖家的合约中， 你可以把卖家的地址存储起来， 当有人买了它的东西的时候，把买家支付的钱发送给它 <code>seller.transfer(msg.value)</code>。</p>
<p>有很多例子来展示什么让以太坊编程如此之酷 —— 你可以拥有一个不被任何人控制的去中心化市场。</p>
<p><strong>实战演习</strong></p>
<ol>
<li><p>在我们的合约里创建一个 <code>withdraw</code> 函数，它应该几乎和上面的<code>GetPaid</code>一样。</p>
</li>
<li><p>以太的价格在过去几年内翻了十几倍，在我们写这个教程的时候 0.01 以太相当于1美元，如果它再翻十倍 0.001 以太将是10美元，那我们的游戏就太贵了。</p>
<p> 所以我们应该再创建一个函数，允许我们以合约拥有者的身份来设置 <code>levelUpFee</code>。</p>
<p> a. 创建一个函数，名为 <code>setLevelUpFee</code>， 其接收一个参数 <code>uint _fee</code>，是 <code>external</code> 并使用修饰符 <code>onlyOwner</code>。</p>
<p> b. 这个函数应该设置 <code>levelUpFee</code> 等于 <code>_fee</code>。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 1. 在这里创建 withdraw 函数</span><br><span class="line">  function withdraw() external onlyOwner {</span><br><span class="line">    owner.transfer(this.balance);</span><br><span class="line">  }</span><br><span class="line">  // 2. 在这里创建 setLevelUpFee 函数 </span><br><span class="line">  function setLevelUpFee(uint _fee) external onlyOwner {</span><br><span class="line">    levelUpFee = _fee;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第3章-僵尸战斗"><a href="#第3章-僵尸战斗" class="headerlink" title="第3章: 僵尸战斗"></a>第3章: 僵尸战斗</h3><p>在我们学习了可支付函数和合约余额之后，是时候为僵尸战斗添加功能了。</p>
<p>遵循上一章的格式，我们新建一个攻击功能合约，并将代码放进新的文件中，引入上一个合约。</p>
<p><strong>实战演习</strong></p>
<p>再来新建一个合约吧。熟能生巧。</p>
<p>如果你不记得怎么做了, 查看一下 <code>zombiehelper.sol</code> — 不过最好先试着做一下，检查一下你掌握的情况。</p>
<ol>
<li>在文件开头定义 Solidity 的版本 <code>^0.4.19</code>.</li>
<li><code>import</code> 自 <code>zombiehelper.sol</code> .</li>
<li>声明一个新的 <code>contract</code>，命名为 <code>ZombieBattle</code>， 继承自<code>ZombieHelper</code>。函数体就先空着吧。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import "./zombiehelper.sol";</span><br><span class="line"></span><br><span class="line">contract ZombieBattle is ZombieHelper{</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第4章-随机数"><a href="#第4章-随机数" class="headerlink" title="第4章: 随机数"></a>第4章: 随机数</h3><p>你太棒了！接下来我们梳理一下战斗逻辑。</p>
<p>优秀的游戏都需要一些随机元素，那么我们在 Solidity 里如何生成随机数呢？</p>
<p>真正的答案是你不能，或者最起码，你无法安全地做到这一点。</p>
<p>我们来看看为什么</p>
<p><strong>用 <code>keccak256</code> 来制造随机数</strong></p>
<p>Solidity 中最好的随机数生成器是 <code>keccak256</code> 哈希函数.</p>
<p>我们可以这样来生成一些随机数</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 生成一个0到100的随机数:</span><br><span class="line">uint randNonce = 0;</span><br><span class="line">uint random = uint(keccak256(now, msg.sender, randNonce)) % 100;</span><br><span class="line">randNonce++;</span><br><span class="line">uint random2 = uint(keccak256(now, msg.sender, randNonce)) % 100;</span><br></pre></td></tr></tbody></table></figure>

<p>这个方法首先拿到 <code>now</code> 的时间戳、 <code>msg.sender</code>、 以及一个自增数 <code>nonce</code> （一个仅会被使用一次的数，这样我们就不会对相同的输入值调用一次以上哈希函数了）。</p>
<p>然后利用 <code>keccak</code> 把输入的值转变为一个哈希值, 再将哈希值转换为 <code>uint</code>, 然后利用 <code>% 100</code> 来取最后两位, 就生成了一个0到100之间随机数了。</p>
<p><strong>这个方法很容易被不诚实的节点攻击</strong></p>
<p>在以太坊上, 当你在和一个合约上调用函数的时候, 你会把它广播给一个节点或者在网络上的 *<strong>transaction*</strong> 节点们。 网络上的节点将收集很多事务, 试着成为第一个解决计算密集型数学问题的人，作为“工作证明”，然后将“工作证明”(Proof of Work, PoW)和事务一起作为一个 *<strong>block*</strong> 发布在网络上。</p>
<p>一旦一个节点解决了一个PoW, 其他节点就会停止尝试解决这个 PoW, 并验证其他节点的事务列表是有效的，然后接受这个节点转而尝试解决下一个节点。</p>
<p><strong>这就让我们的随机数函数变得可利用了</strong></p>
<p>我们假设我们有一个硬币翻转合约——正面你赢双倍钱，反面你输掉所有的钱。假如它使用上面的方法来决定是正面还是反面 (<code>random &gt;= 50</code> 算正面, <code>random &lt; 50</code> 算反面)。</p>
<p>如果我正运行一个节点，我可以 <strong>只对我自己的节点</strong> 发布一个事务，且不分享它。 我可以运行硬币翻转方法来偷窥我的输赢 — 如果我输了，我就不把这个事务包含进我要解决的下一个区块中去。我可以一直运行这个方法，直到我赢得了硬币翻转并解决了下一个区块，然后获利。</p>
<p><strong>所以我们该如何在以太坊上安全地生成随机数呢</strong></p>
<p>因为区块链的全部内容对所有参与者来说是透明的， 这就让这个问题变得很难，它的解决方法不在本课程讨论范围，你可以阅读 <a target="_blank" rel="noopener" href="https://ethereum.stackexchange.com/questions/191/how-can-i-securely-generate-a-random-number-in-my-smart-contract">这个 StackOverflow 上的讨论</a> 来获得一些主意。 一个方法是利用 *<strong>oracle*</strong> 来访问以太坊区块链之外的随机数函数。</p>
<p>当然， 因为网络上成千上万的以太坊节点都在竞争解决下一个区块，我能成功解决下一个区块的几率非常之低。 这将花费我们巨大的计算资源来开发这个获利方法 — 但是如果奖励异常地高(比如我可以在硬币翻转函数中赢得 1个亿)， 那就很值得去攻击了。</p>
<p>所以尽管这个方法在以太坊上不安全，在实际中，除非我们的随机函数有一大笔钱在上面，你游戏的用户一般是没有足够的资源去攻击的。</p>
<p>因为在这个教程中，我们只是在编写一个简单的游戏来做演示，也没有真正的钱在里面，所以我们决定接受这个不足之处，使用这个简单的随机数生成函数。但是要谨记它是不安全的。</p>
<p><strong>实战演习</strong></p>
<p>我们来实现一个随机数生成函数，好来计算战斗的结果。虽然这个函数一点儿也不安全。</p>
<ol>
<li>给我们合约一个名为 <code>randNonce</code> 的 <code>uint</code>，将其值设置为 <code>0</code>。</li>
<li>建立一个函数，命名为 <code>randMod</code> (random-modulus)。它将作为<code>internal</code> 函数，传入一个名为 <code>_modulus</code>的 <code>uint</code>，并 <code>returns</code> 一个 <code>uint</code>。</li>
<li>这个函数首先将为 <code>randNonce</code>加一， (使用 <code>randNonce++</code> 语句)。</li>
<li>最后，它应该 (在一行代码中) 计算 <code>now</code>, <code>msg.sender</code>, 以及 <code>randNonce</code> 的 <code>keccak256</code> 哈希值并转换为 <code>uint</code>—— 最后 <code>return</code> <code>% _modulus</code> 的值。 （天! 听起来太拗口了。如果你有点理解不过来，看一下我们上面计算随机数的例子，它们的逻辑非常相似）</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">contract ZombieBattle is ZombieHelper {</span><br><span class="line">  // 在这里开始</span><br><span class="line">  uint randNonce = 0;</span><br><span class="line"></span><br><span class="line">  function randMod(uint _modulus) internal returns(uint){</span><br><span class="line">    randNonce++;</span><br><span class="line">    return uint(keccak256(now, msg.sender, randNonce)) % _modulus;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第5章-僵尸对战"><a href="#第5章-僵尸对战" class="headerlink" title="第5章: 僵尸对战"></a>第5章: 僵尸对战</h3><p>我们的合约已经有了一些随机性的来源，可以用进我们的僵尸战斗中去计算结果。</p>
<p>我们的僵尸战斗看起来将是这个流程：</p>
<ul>
<li>你选择一个自己的僵尸，然后选择一个对手的僵尸去攻击。</li>
<li>如果你是攻击方，你将有70%的几率获胜，防守方将有30%的几率获胜。</li>
<li>所有的僵尸（攻守双方）都将有一个 <code>winCount</code> 和一个 <code>lossCount</code>，这两个值都将根据战斗结果增长。</li>
<li>若攻击方获胜，这个僵尸将升级并产生一个新僵尸。</li>
<li>如果攻击方失败，除了失败次数将加一外，什么都不会发生。</li>
<li>无论输赢，当前僵尸的冷却时间都将被激活。</li>
</ul>
<p>这有一大堆的逻辑需要处理，我们将把这些步骤分解到接下来的课程中去。</p>
<p><strong>实战演习</strong></p>
<ol>
<li>给我们合约一个 <code>uint</code> 类型的变量，命名为 <code>attackVictoryProbability</code>, 将其值设定为 <code>70</code>。</li>
<li>创建一个名为 <code>attack</code>的函数。它将传入两个参数: <code>_zombieId</code> (<code>uint</code> 类型) 以及 <code>_targetId</code> (也是 <code>uint</code>)。它将是一个 <code>external</code> 函数。</li>
</ol>
<p>函数体先留空吧。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 在这里创建 attackVictoryProbability</span><br><span class="line">  uint attackVictoryProbability = 70;</span><br><span class="line">  function attack(uint _zombieId, uint _targetId) external{</span><br><span class="line">    </span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第6章-重构通用逻辑"><a href="#第6章-重构通用逻辑" class="headerlink" title="第6章: 重构通用逻辑"></a>第6章: 重构通用逻辑</h3><p>不管谁调用我们的 <code>attack</code> 函数 —— 我们想确保用户的确拥有他们用来攻击的僵尸。如果你能用其他人的僵尸来攻击将是一个很大的安全问题。</p>
<p>你能想一下我们如何添加一个检查步骤来看看调用这个函数的人就是他们传入的 <code>_zombieId</code> 的拥有者么？</p>
<p>想一想，看看你能不能自己找到一些答案。</p>
<p>花点时间…… 参考我们前面课程的代码来获得灵感。</p>
<p>答案在下面，在你有一些想法之前不要继续阅读。</p>
<p><strong>答案</strong></p>
<p>我们在前面的课程里面已经做过很多次这样的检查了。 在 <code>changeName()</code>, <code>changeDna()</code>, 和 <code>feedAndMultiply()</code>里，我们做过这样的检查：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(msg.sender == zombieToOwner[_zombieId]);</span><br></pre></td></tr></tbody></table></figure>

<p>这和我们 <code>attack</code> 函数将要用到的检查逻辑是相同的。 正因我们要多次调用这个检查逻辑，让我们把它移到它自己的 <code>modifier</code> 中来清理代码并避免重复编码。</p>
<p><strong>实战演习</strong></p>
<p>我们回到了 <code>zombiefeeding.sol</code>， 因为这是我们第一次调用检查逻辑的地方。让我们把它重构进它自己的 <code>modifier</code>。</p>
<ol>
<li><p>创建一个 <code>modifier</code>， 命名为 <code>ownerOf</code>。它将传入一个参数， <code>_zombieId</code> (一个 <code>uint</code>)。</p>
<p> 它的函数体应该 <code>require</code> <code>msg.sender</code> 等于 <code>zombieToOwner[_zombieId]</code>， 然后继续这个函数剩下的内容。 如果你忘记了修饰符的写法，可以参考 <code>zombiehelper.sol</code>。</p>
</li>
<li><p>将这个函数的 <code>feedAndMultiply</code> 定义修改为其使用修饰符 <code>ownerOf</code>。</p>
</li>
<li><p>现在我们使用 <code>modifier</code>了，你可以删除这行了： <code>require(msg.sender == zombieToOwner[_zombieId]);</code></p>
</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 1. 在这里创建 modifier</span><br><span class="line">  modifier ownerOf(uint _zombieId){</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    _;</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  // 2. 在函数定义时增加 modifier :</span><br><span class="line">  function feedAndMultiply(uint _zombieId, uint _targetDna, string _species) internal ownerOf(_zombieId){</span><br><span class="line">    // 3. 移除这一行</span><br><span class="line">    //require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    require(_isReady(myZombie));</span><br><span class="line">    _targetDna = _targetDna % dnaModulus;</span><br><span class="line">    uint newDna = (myZombie.dna + _targetDna) / 2;</span><br><span class="line">    if (keccak256(_species) == keccak256("kitty")) {</span><br><span class="line">      newDna = newDna - newDna % 100 + 99;</span><br><span class="line">    }</span><br><span class="line">    _createZombie("NoName", newDna);</span><br><span class="line">    _triggerCooldown(myZombie);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第7章-更多重构"><a href="#第7章-更多重构" class="headerlink" title="第7章: 更多重构"></a>第7章: 更多重构</h3><p>在 <code>zombiehelper.sol</code>里有几处地方，需要我们实现我们新的 <code>modifier</code>—— <code>ownerOf</code>。</p>
<p><strong>实战演习</strong></p>
<ol>
<li>修改 <code>changeName()</code> 使其使用 <code>ownerOf</code></li>
<li>修改 <code>changeDna()</code> 使其使用 <code>ownerOf</code></li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 1. 使用 `ownerOf` 修改这个函数:</span><br><span class="line">  function changeName(uint _zombieId, string _newName) external aboveLevel(2, _zombieId) ownerOf(_zombieId){</span><br><span class="line">    //require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    zombies[_zombieId].name = _newName;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  // 2. 对这个函数做同样的事:</span><br><span class="line">  function changeDna(uint _zombieId, uint _newDna) external aboveLevel(20, _zombieId) ownerOf(_zombieId){</span><br><span class="line">    //require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    zombies[_zombieId].dna = _newDna;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第8章-回到攻击！"><a href="#第8章-回到攻击！" class="headerlink" title="第8章: 回到攻击！"></a>第8章: 回到攻击！</h3><p>重构完成了，回到 <code>zombieattack.sol</code>。</p>
<p>继续来完善我们的 <code>attack</code> 函数， 现在我们有了 <code>ownerOf</code> 修饰符来用了。</p>
<p><strong>实战演习</strong></p>
<ol>
<li><p>将 <code>ownerOf</code> 修饰符添加到 <code>attack</code> 来确保调用者拥有<code>_zombieId</code>.</p>
</li>
<li><p>我们的函数所需要做的第一件事就是获得一个双方僵尸的 <code>storage</code> 指针， 这样我们才能很方便和它们交互：</p>
<p> a. 定义一个 <code>Zombie storage</code> 命名为 <code>myZombie</code>，使其值等于 <code>zombies[_zombieId]</code>。</p>
<p> b. 定义一个 <code>Zombie storage</code> 命名为 <code>enemyZombie</code>， 使其值等于 <code>zombies[_targetId]</code>。</p>
</li>
<li><p>我们将用一个0到100的随机数来确定我们的战斗结果。 定义一个 <code>uint</code>，命名为 <code>rand</code>， 设定其值等于 <code>randMod</code> 函数的返回值，此函数传入 <code>100</code>作为参数。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 1. 在这里增加 modifier</span><br><span class="line">  function attack(uint _zombieId, uint _targetId) external ownerOf(_zombieId){</span><br><span class="line">    // 2. 在这里开始定义函数</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    Zombie storage enemyZombie = zombies[_targetId];</span><br><span class="line">    uint rand = randMod(100);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第9章-僵尸的输赢"><a href="#第9章-僵尸的输赢" class="headerlink" title="第9章: 僵尸的输赢"></a>第9章: 僵尸的输赢</h3><p>对我们的僵尸游戏来说，我们将要追踪我们的僵尸输赢了多少场。有了这个我们可以在游戏里维护一个 “僵尸排行榜”。</p>
<p>有多种方法在我们的DApp里面保存一个数值 — 作为一个单独的映射，作为一个“排行榜”结构体，或者保存在 <code>Zombie</code> 结构体内。</p>
<p>每个方法都有其优缺点，取决于我们打算如何和这些数据打交道。在这个教程中，简单起见我们将这个状态保存在 <code>Zombie</code> 结构体中，将其命名为 <code>winCount</code> 和 <code>lossCount</code>。</p>
<p>我们跳回 <code>zombiefactory.sol</code>, 将这些属性添加进 <code>Zombie</code> 结构体.</p>
<p><strong>实战演习</strong></p>
<ol>
<li><p>修改 <code>Zombie</code> 结构体，添加两个属性:</p>
<p> a. <code>winCount</code>, 一个 <code>uint16</code></p>
<p> b. <code>lossCount</code>, 也是一个 <code>uint16</code></p>
<blockquote>
<p>注意： 记住, 因为我们能在结构体中包装<code>uint</code>, 我们打算用适合我们的最小的 <code>uint</code>。 一个 <code>uint8</code> 太小了， 因为 2^8 = 256 —— 如果我们的僵尸每天都作战，不到一年就溢出了。但是 2^16 = 65536 （<code>uint16</code>）—— 除非一个僵尸连续179年每天作战，否则我们就是安全的。</p>
</blockquote>
</li>
<li><p>现在我们的 <code>Zombie</code> 结构体有了新的属性， 我们需要修改 <code>_createZombie()</code> 中的函数定义。</p>
<p> 修改僵尸生成定义，让每个新僵尸都有 <code>0</code> 赢和 <code>0</code> 输。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct Zombie {</span><br><span class="line">      string name;</span><br><span class="line">      uint dna;</span><br><span class="line">      uint32 level;</span><br><span class="line">      uint32 readyTime;</span><br><span class="line">      // 1. 在这里添加新的属性</span><br><span class="line">      uint16 winCount;</span><br><span class="line">      uint16 lossCount;</span><br><span class="line">    }</span><br><span class="line">function _createZombie(string _name, uint _dna) internal {</span><br><span class="line">        // 2. 在这里修改修改新僵尸的创建:</span><br><span class="line">        uint id = zombies.push(Zombie(_name, _dna, 1, uint32(now + cooldownTime),0,0)) - 1;</span><br><span class="line">        zombieToOwner[id] = msg.sender;</span><br><span class="line">        ownerZombieCount[msg.sender]++;</span><br><span class="line">        NewZombie(id, _name, _dna);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第10章-僵尸胜利了-😄"><a href="#第10章-僵尸胜利了-😄" class="headerlink" title="第10章: 僵尸胜利了 😄"></a>第10章: 僵尸胜利了 😄</h3><p>有了 <code>winCount</code> 和 <code>lossCount</code>，我们可以根据僵尸哪个僵尸赢了战斗来更新它们了。</p>
<p>在第六章我们计算出来一个0到100的随机数。现在让我们用那个数来决定那谁赢了战斗，并以此更新我们的状态。</p>
<p><strong>实战演习</strong></p>
<ol>
<li><p>创建一个 <code>if</code> 语句来检查 <code>rand</code> 是不是 *<strong>小于或者等于*</strong> <code>attackVictoryProbability</code>。</p>
</li>
<li><p>如果以上条件为 <code>true</code>， 我们的僵尸就赢了！所以：</p>
<p> a. 增加 <code>myZombie</code> 的 <code>winCount</code>。</p>
<p> b. 增加 <code>myZombie</code> 的 <code>level</code>。 (升级了啦!!!!!!!)</p>
<p> c. 增加 <code>enemyZombie</code> 的 <code>lossCount</code>. (输家!!!!!! 😫 😫 😫)</p>
<p> d. 运行 <code>feedAndMultiply</code> 函数。 在 <code>zombiefeeding.sol</code> 里查看调用它的语句。 对于第三个参数 (<code>_species</code>)，传入字符串 “zombie”. （现在它实际上什么都不做，不过在稍后， 如果我们愿意，可以添加额外的方法，用来制造僵尸变的僵尸）。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function attack(uint _zombieId, uint _targetId) external ownerOf(_zombieId) {</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    Zombie storage enemyZombie = zombies[_targetId];</span><br><span class="line">    uint rand = randMod(100);</span><br><span class="line">    // 在这里开始</span><br><span class="line">    if(rand &lt;= attackVictoryProbability){</span><br><span class="line">      myZombie.winCount++;</span><br><span class="line">      myZombie.level++;</span><br><span class="line">      enemyZombie.lossCount++;</span><br><span class="line">      feedAndMultiply(_zombieId, enemyZombie.dna, "zombie");</span><br><span class="line">    }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第11章-僵尸失败-😞"><a href="#第11章-僵尸失败-😞" class="headerlink" title="第11章: 僵尸失败 😞"></a>第11章: 僵尸失败 😞</h3><p>我们已经编写了你的僵尸赢了之后会发生什么， 该看看 <strong>输了</strong> 的时候要怎么做了。</p>
<p>在我们的游戏中，僵尸输了后并不会降级 —— 只是简单地给 <code>lossCount</code> 加一，并触发冷却，等待一天后才能再次参战。</p>
<p>要实现这个逻辑，我们需要一个 <code>else</code> 语句。</p>
<p><code>else</code> 语句和 JavaScript 以及很多其他语言的 else 语句一样。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (zombieCoins[msg.sender] &gt; 100000000) {</span><br><span class="line">  // 你好有钱!!!</span><br><span class="line">} else {</span><br><span class="line">  // 我们需要更多的僵尸币...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实战演习</strong></p>
<ol>
<li><p>添加一个 <code>else</code> 语句。 若我们的僵尸输了：</p>
<p> a. 增加 <code>myZombie</code> 的 <code>lossCount</code>。</p>
<p> b. 增加 <code>enemyZombie</code> 的 <code>winCount</code>。</p>
</li>
<li><p>在 <code>else</code> 最后， 对 <code>myZombie</code> 运行 <code>_triggerCooldown</code> 方法。这让每个僵尸每天只能参战一次。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function attack(uint _zombieId, uint _targetId) external ownerOf(_zombieId) {</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    Zombie storage enemyZombie = zombies[_targetId];</span><br><span class="line">    uint rand = randMod(100);</span><br><span class="line">    if (rand &lt;= attackVictoryProbability) {</span><br><span class="line">      myZombie.winCount++;</span><br><span class="line">      myZombie.level++;</span><br><span class="line">      enemyZombie.lossCount++;</span><br><span class="line">      feedAndMultiply(_zombieId, enemyZombie.dna, "zombie");</span><br><span class="line">    } // 在这里开始</span><br><span class="line">    else{</span><br><span class="line">      myZombie.lossCount++;</span><br><span class="line">      enemyZombie.winCount++;</span><br><span class="line">      _triggerCooldown(myZombie);</span><br><span class="line">    }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h2 id="lesson5-ERC721-标准和加密收藏品"><a href="#lesson5-ERC721-标准和加密收藏品" class="headerlink" title="lesson5 ERC721 标准和加密收藏品"></a>lesson5 ERC721 标准和加密收藏品</h2><h3 id="第1章-以太坊上的代币"><a href="#第1章-以太坊上的代币" class="headerlink" title="第1章: 以太坊上的代币"></a>第1章: 以太坊上的代币</h3><p>让我们来聊聊 <strong>代币</strong>.</p>
<p>如果你对以太坊的世界有一些了解，你很可能听过人们聊到代币——尤其是 *<strong>ERC20 代币*</strong>.</p>
<p>一个 <strong><em>代币</em></strong> 在以太坊基本上就是一个遵循一些共同规则的智能合约——即它实现了所有其他代币合约共享的一组标准函数，例如 <code>transfer(address _to, uint256 _value)</code> 和 <code>balanceOf(address _owner)</code>.</p>
<p>在智能合约内部，通常有一个映射， <code>mapping(address =&gt; uint256) balances</code>，用于追踪每个地址还有多少余额。</p>
<p>所以基本上一个代币只是一个追踪谁拥有多少该代币的合约，和一些可以让那些用户将他们的代币转移到其他地址的函数。</p>
<p><strong>它为什么重要呢？</strong></p>
<p>由于所有 ERC20 代币共享具有相同名称的同一组函数，它们都可以以相同的方式进行交互。</p>
<p>这意味着如果你构建的应用程序能够与一个 ERC20 代币进行交互，那么它就也能够与任何 ERC20 代币进行交互。 这样一来，将来你就可以轻松地将更多的代币添加到你的应用中，而无需进行自定义编码。 你可以简单地插入新的代币合约地址，然后哗啦，你的应用程序有另一个它可以使用的代币了。</p>
<p>其中一个例子就是交易所。 当交易所添加一个新的 ERC20 代币时，实际上它只需要添加与之对话的另一个智能合约。 用户可以让那个合约将代币发送到交易所的钱包地址，然后交易所可以让合约在用户要求取款时将代币发送回给他们。</p>
<p>交易所只需要实现这种转移逻辑一次，然后当它想要添加一个新的 ERC20 代币时，只需将新的合约地址添加到它的数据库即可。</p>
<p><strong>其他代币标准</strong></p>
<p>对于像货币一样的代币来说，ERC20 代币非常酷。 但是要在我们僵尸游戏中代表僵尸就并不是特别有用。</p>
<p>首先，僵尸不像货币可以分割 —— 我可以发给你 0.237 以太，但是转移给你 0.237 的僵尸听起来就有些搞笑。</p>
<p>其次，并不是所有僵尸都是平等的。 你的2级僵尸”<strong>Steve</strong>“完全不能等同于我732级的僵尸”<strong>H4XF13LD MORRIS 💯💯😎💯💯</strong>“。（你差得远呢，<em>Steve</em>）。</p>
<p>有另一个代币标准更适合如 CryptoZombies 这样的加密收藏品——它们被称为*<strong>ERC721 代币.*</strong></p>
<p>*<strong>ERC721 代币*<strong>是</strong>不</strong>能互换的，因为每个代币都被认为是唯一且不可分割的。 你只能以整个单位交易它们，并且每个单位都有唯一的 ID。 这些特性正好让我们的僵尸可以用来交易。</p>
<blockquote>
<p>请注意，使用像 ERC721 这样的标准的优势就是，我们不必在我们的合约中实现拍卖或托管逻辑，这决定了玩家能够如何交易／出售我们的僵尸。 如果我们符合规范，其他人可以为加密可交易的 ERC721 资产搭建一个交易所平台，我们的 ERC721 僵尸将可以在该平台上使用。 所以使用代币标准相较于使用你自己的交易逻辑有明显的好处。</p>
</blockquote>
<p><strong>实战演习</strong></p>
<p>我们将在下一章深入讨论ERC721的实现。 但首先，让我们为本课设置我们的文件结构。</p>
<p>我们将把所有ERC721逻辑存储在一个叫<code>ZombieOwnership</code>的合约中。</p>
<ol>
<li>在文件顶部声明我们<code>pragma</code>的版本（格式参考之前的课程）。</li>
<li>将 <code>zombieattack.sol</code> <code>import</code> 进来。</li>
<li>声明一个继承 <code>ZombieAttack</code> 的新合约， 命名为<code>ZombieOwnership</code>。合约的其他部分先留空。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 从这里开始</span><br><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import "./zombieattack.sol";</span><br><span class="line"></span><br><span class="line">contract ZombieOwnership is ZombieAttack{</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第2章-ERC721-标准-多重继承"><a href="#第2章-ERC721-标准-多重继承" class="headerlink" title="第2章: ERC721 标准, 多重继承"></a>第2章: ERC721 标准, 多重继承</h3><p>让我们来看一看 ERC721 标准：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">contract ERC721 {</span><br><span class="line">  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);</span><br><span class="line">  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _owner) public view returns (uint256 _balance);</span><br><span class="line">  function ownerOf(uint256 _tokenId) public view returns (address _owner);</span><br><span class="line">  function transfer(address _to, uint256 _tokenId) public;</span><br><span class="line">  function approve(address _to, uint256 _tokenId) public;</span><br><span class="line">  function takeOwnership(uint256 _tokenId) public;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这是我们需要实现的方法列表，我们将在接下来的章节中逐个学习。</p>
<p>虽然看起来很多，但不要被吓到了！我们在这里就是准备带着你一步一步了解它们的。</p>
<blockquote>
<p>注意： ERC721目前是一个 <em>草稿</em>，还没有正式商定的实现。在本教程中，我们使用的是 OpenZeppelin 库中的当前版本，但在未来正式发布之前它可能会有更改。 所以把这 <strong>一个</strong> 可能的实现当作考虑，但不要把它作为 ERC721 代币的官方标准。</p>
</blockquote>
<p><strong>实现一个代币合约</strong></p>
<p>在实现一个代币合约的时候，我们首先要做的是将接口复制到它自己的 Solidity 文件并导入它，<code>import "./erc721.sol";</code>。 接着，让我们的合约继承它，然后我们用一个函数定义来重写每个方法。</p>
<p>但等一下—— <code>ZombieOwnership</code>已经继承自 <code>ZombieAttack</code>了 —— 它如何能够也继承于 <code>ERC721</code>呢？</p>
<p>幸运的是在Solidity，你的合约可以继承自多个合约，参考如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract SatoshiNakamoto is NickSzabo, HalFinney {</span><br><span class="line">  // 啧啧啧，宇宙的奥秘泄露了</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>正如你所见，当使用多重继承的时候，你只需要用逗号 <code>,</code> 来隔开几个你想要继承的合约。在上面的例子中，我们的合约继承自 <code>NickSzabo</code> 和 <code>HalFinney</code>。</p>
<p>来试试吧。</p>
<p><strong>实战演习</strong></p>
<p>我们已经在上面为你创建了带着接口的 <code>erc721.sol</code> 。</p>
<ol>
<li>将 <code>erc721.sol</code> 导入到 <code>zombieownership.sol</code></li>
<li>声明 <code>ZombieOwnership</code> 继承自 <code>ZombieAttack</code> 和 <code>ERC721</code></li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import "./zombieattack.sol";</span><br><span class="line">// 在这里引入文件</span><br><span class="line">import "./erc721.sol";</span><br><span class="line">// 在这里声明 ERC721 的继承</span><br><span class="line">contract ZombieOwnership is ZombieAttack, ERC721 {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第3章-balanceOf-和-ownerOf"><a href="#第3章-balanceOf-和-ownerOf" class="headerlink" title="第3章: balanceOf 和 ownerOf"></a>第3章: balanceOf 和 ownerOf</h3><p>太棒了，我们来深入讨论一下 ERC721 的实现。</p>
<p>我们已经把所有你需要在本课中实现的函数的空壳复制好了。</p>
<p>在本章节，我们将实现头两个方法： <code>balanceOf</code> 和 <code>ownerOf</code>。</p>
<p><strong><code>balanceOf</code></strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function balanceOf(address _owner) public view returns (uint256 _balance);</span><br></pre></td></tr></tbody></table></figure>

<p>这个函数只需要一个传入 <code>address</code> 参数，然后返回这个 <code>address</code> 拥有多少代币。</p>
<p>在我们的例子中，我们的“代币”是僵尸。你还记得在我们 DApp 的哪里存储了一个主人拥有多少只僵尸吗？</p>
<p> <strong><code>ownerOf</code></strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function ownerOf(uint256 _tokenId) public view returns (address _owner);</span><br></pre></td></tr></tbody></table></figure>

<p>这个函数需要传入一个代币 ID 作为参数 (我们的情况就是一个僵尸 ID)，然后返回该代币拥有者的 <code>address</code>。</p>
<p>同样的，因为在我们的 DApp 里已经有一个 <code>mapping</code> (映射) 存储了这个信息，所以对我们来说这个实现非常直接清晰。我们可以只用一行 <code>return</code> 语句来实现这个函数。</p>
<blockquote>
<p>注意：要记得， <code>uint256</code> 等同于<code>uint</code>。我们从课程的开始一直在代码中使用 <code>uint</code>，但从现在开始我们将在这里用 <code>uint256</code>，因为我们直接从规范中复制粘贴。</p>
</blockquote>
<p><strong>实战演习</strong></p>
<p>我将让你来决定如何实现这两个函数。</p>
<p>每个函数的代码都应该只有1行 <code>return</code> 语句。看看我们在之前课程中写的代码，想想我们都把这个数据存储在哪。如果你觉得有困难，你可以点“我要看答案”的按钮来获得帮助。</p>
<ol>
<li>实现 <code>balanceOf</code> 来返回 <code>_owner</code> 拥有的僵尸数量。</li>
<li>实现 <code>ownerOf</code> 来返回拥有 ID 为 <code>_tokenId</code> 僵尸的所有者的地址。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function balanceOf(address _owner) public view returns (uint256 _balance) {</span><br><span class="line">    // 1. 在这里返回 `_owner` 拥有的僵尸数</span><br><span class="line">    return ownerZombieCount[_owner];</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  function ownerOf(uint256 _tokenId) public view returns (address _owner) {</span><br><span class="line">    // 2. 在这里返回 `_tokenId` 的所有者</span><br><span class="line">    return zombieToOwner[_tokenId];</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第4章-重构"><a href="#第4章-重构" class="headerlink" title="第4章: 重构"></a>第4章: 重构</h3><p>嘿嘿！我们刚刚的代码中其实有个错误，以至于其根本无法通过编译，你发现了没？</p>
<p>在前一个章节我们定义了一个叫 <code>ownerOf</code> 的函数。但如果你还记得第4课的内容，我们同样在<code>zombiefeeding.sol</code> 里以 <code>ownerOf</code> 命名创建了一个 <code>modifier</code>（修饰符）。</p>
<p>如果你尝试编译这段代码，编译器会给你一个错误说你不能有相同名称的修饰符和函数。</p>
<p>所以我们应该把在 <code>ZombieOwnership</code> 里的函数名称改成别的吗？</p>
<p>不，我们不能那样做！！！要记得，我们正在用 ERC721 代币标准，意味着其他合约将期望我们的合约以这些确切的名称来定义函数。这就是这些标准实用的原因——如果另一个合约知道我们的合约符合 ERC721 标准，它可以直接与我们交互，而无需了解任何关于我们内部如何实现的细节。</p>
<p>所以，那意味着我们将必须重构我们第4课中的代码，将 <code>modifier</code> 的名称换成别的。</p>
<p><strong>实战演习</strong></p>
<p>我们回到了 <code>zombiefeeding.sol</code> 。我们将把 <code>modifier</code> 的名称从 <code>ownerOf</code> 改成 <code>onlyOwnerOf</code>。</p>
<ol>
<li>把修饰符定义中的名称改成 <code>onlyOwnerOf</code></li>
<li>往下滑到使用此修饰符的函数 <code>feedAndMultiply</code> 。我们也需要改这里的名称。</li>
</ol>
<blockquote>
<p>注意：我们在 <code>zombiehelper.sol</code> 和 <code>zombieattack.sol</code> 里也使用了这个修饰符，但为了不在这节课的重构里花太多时间，我们已经将那些文件里的修饰符名称为你改好了。</p>
</blockquote>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 1. 把修饰符名称改成 `onlyOwnerOf`</span><br><span class="line">  modifier onlyOwnerOf(uint _zombieId) {</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    _;</span><br><span class="line">  }</span><br><span class="line">// 2. 这里也要修改修饰符的名称</span><br><span class="line">  function feedAndMultiply(uint _zombieId, uint _targetDna, string _species) internal onlyOwnerOf(_zombieId) {</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    require(_isReady(myZombie));</span><br><span class="line">    _targetDna = _targetDna % dnaModulus;</span><br><span class="line">    uint newDna = (myZombie.dna + _targetDna) / 2;</span><br><span class="line">    if (keccak256(_species) == keccak256("kitty")) {</span><br><span class="line">      newDna = newDna - newDna % 100 + 99;</span><br><span class="line">    }</span><br><span class="line">    _createZombie("NoName", newDna);</span><br><span class="line">    _triggerCooldown(myZombie);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第5章-ERC721-转移标准"><a href="#第5章-ERC721-转移标准" class="headerlink" title="第5章: ERC721: 转移标准"></a>第5章: ERC721: 转移标准</h3><p>好了，我们将冲突修复了！</p>
<p>现在我们将通过学习把所有权从一个人转移给另一个人来继续我们的 ERC721 规范的实现。</p>
<p>注意 ERC721 规范有两种不同的方法来转移代币：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function transfer(address _to, uint256 _tokenId) public;</span><br><span class="line"></span><br><span class="line">function approve(address _to, uint256 _tokenId) public;</span><br><span class="line">function takeOwnership(uint256 _tokenId) public;</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>第一种方法是代币的拥有者调用<code>transfer</code> 方法，传入他想转移到的 <code>address</code> 和他想转移的代币的 <code>_tokenId</code>。</li>
<li>第二种方法是代币拥有者首先调用 <code>approve</code>，然后传入与以上相同的参数。接着，该合约会存储谁被允许提取代币，通常存储到一个 <code>mapping (uint256 =&gt; address)</code> 里。然后，当有人调用 <code>takeOwnership</code> 时，合约会检查 <code>msg.sender</code> 是否得到拥有者的批准来提取代币，如果是，则将代币转移给他。</li>
</ol>
<p>你注意到了吗，<code>transfer</code> 和 <code>takeOwnership</code> 都将包含相同的转移逻辑，只是以相反的顺序。 （一种情况是代币的发送者调用函数；另一种情况是代币的接收者调用它）。</p>
<p>所以我们把这个逻辑抽象成它自己的私有函数 <code>_transfer</code>，然后由这两个函数来调用它。 这样我们就不用写重复的代码了。</p>
<p><strong>实战演习</strong></p>
<p>让我们来定义 <code>_transfer</code> 的逻辑。</p>
<ol>
<li><p>定义一个名为 <code>_transfer</code>的函数。它会需要3个参数：<code>address _from</code>、<code>address _to</code>和<code>uint256 _tokenId</code>。它应该是一个 <code>私有</code> 函数。</p>
</li>
<li><p>我们有2个映射会在所有权改变的时候改变： <code>ownerZombieCount</code> （记录一个所有者有多少只僵尸）和 <code>zombieToOwner</code> （记录什么人拥有什么）。</p>
<p> 我们的函数需要做的第一件事是为 <strong>接收</strong> 僵尸的人（<code>address _to</code>）增 加<code>ownerZombieCount</code>。使用 <code>++</code> 来增加。</p>
</li>
<li><p>接下来，我们将需要为 <strong>发送</strong> 僵尸的人（<code>address _from</code>）<strong>减少</strong><code>ownerZombieCount</code>。使用 <code>--</code> 来扣减。</p>
</li>
<li><p>最后，我们将改变这个 <code>_tokenId</code> 的 <code>zombieToOwner</code> 映射，这样它现在就会指向 <code>_to</code>。</p>
</li>
<li><p>骗你的，那不是最后一步。我们还需要再做一件事情。</p>
<p> ERC721规范包含了一个 <code>Transfer</code> 事件。这个函数的最后一行应该用正确的参数触发<code>Transfer</code> ——查看 <code>erc721.sol</code> 看它期望传入的参数并在这里实现。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 在这里定义 _transfer()</span><br><span class="line">    function _transfer(address _from, address _to, uint256 _tokenId) private{</span><br><span class="line">        ownerZombieCount[_to]++;</span><br><span class="line">        ownerZombieCount[_from]--;</span><br><span class="line">        zombieToOwner[_tokenId] = _to;</span><br><span class="line">        Transfer(_from, _to, _tokenId);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第6章-ERC721-转移-续"><a href="#第6章-ERC721-转移-续" class="headerlink" title="第6章: ERC721: 转移-续"></a>第6章: ERC721: 转移-续</h3><p>太好了！刚才那是最难的部分——现在实现公共的 <code>transfer</code> 函数应该十分容易，因为我们的 <code>_transfer</code> 函数几乎已经把所有的重活都干完了。</p>
<p><strong>实战演习</strong></p>
<ol>
<li><p>我们想确保只有代币或僵尸的所有者可以转移它。还记得我们如何限制只有所有者才能访问某个功能吗？</p>
<p> 没错，我们已经有一个修饰符能够完成这个任务了。所以将修饰符 <code>onlyOwnerOf</code> 添加到这个函数中。</p>
</li>
<li><p>现在该函数的正文只需要一行代码。它只需要调用 <code>_transfer</code>。</p>
<p> 记得把 <code>msg.sender</code> 作为参数传递进 <code>address _from</code>。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 1. 在这里添加修饰符</span><br><span class="line">  function transfer(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId){</span><br><span class="line">    // 2. 在这里定义方法</span><br><span class="line">    _transfer(msg.sender, _to, _tokenId);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第7章-ERC721-批准"><a href="#第7章-ERC721-批准" class="headerlink" title="第7章: ERC721: 批准"></a>第7章: ERC721: 批准</h3><p>现在，让我们来实现 <code>approve</code>。</p>
<p>记住，使用 <code>approve</code> 或者 <code>takeOwnership</code> 的时候，转移有2个步骤：</p>
<ol>
<li>你，作为所有者，用新主人的 <code>address</code> 和你希望他获取的 <code>_tokenId</code> 来调用 <code>approve</code></li>
<li>新主人用 <code>_tokenId</code> 来调用 <code>takeOwnership</code>，合约会检查确保他获得了批准，然后把代币转移给他。</li>
</ol>
<p>因为这发生在2个函数的调用中，所以在函数调用之间，我们需要一个数据结构来存储什么人被批准获取什么。</p>
<p><strong>实战演习</strong></p>
<ol>
<li><p>首先，让我们来定义一个映射 <code>zombieApprovals</code>。它应该将一个 <code>uint</code> 映射到一个 <code>address</code>。</p>
<p> 这样一来，当有人用一个 <code>_tokenId</code> 调用 <code>takeOwnership</code> 时，我们可以用这个映射来快速查找谁被批准获取那个代币。</p>
</li>
<li><p>在函数 <code>approve</code> 上， 我们想要确保只有代币所有者可以批准某人来获取代币。所以我们需要添加修饰符 <code>onlyOwnerOf</code> 到 <code>approve</code>。</p>
</li>
<li><p>函数的正文部分，将 <code>_tokenId</code> 的 <code>zombieApprovals</code> 设置为和 <code>_to</code> 相等。</p>
</li>
<li><p>最后，在 ERC721 规范里有一个 <code>Approval</code> 事件。所以我们应该在这个函数的最后触发这个事件。（参考 <code>erc721.sol</code> 来确认传入的参数，并确保 <code>_owner</code> 是 <code>msg.sender</code>）</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 1. 在这里定义映射</span><br><span class="line">  mapping(uint =&gt; address) zombieApprovals;</span><br><span class="line">// 2. 在这里添加方法修饰符</span><br><span class="line">  function approve(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId){</span><br><span class="line">    // 3. 在这里定义方法</span><br><span class="line">    zombieApprovals[_tokenId] = _to;</span><br><span class="line">    Approval(msg.sender, _to, _tokenId);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第8章-ERC721-takeOwnership"><a href="#第8章-ERC721-takeOwnership" class="headerlink" title="第8章: ERC721: takeOwnership"></a>第8章: ERC721: takeOwnership</h3><p>太棒了，现在让我们完成最后一个函数来结束 ERC721 的实现。（别担心，这后面我们还会讲更多内容😉）</p>
<p>最后一个函数 <code>takeOwnership</code>， 应该只是简单地检查以确保 <code>msg.sender</code> 已经被批准来提取这个代币或者僵尸。若确认，就调用 <code>_transfer</code>；</p>
<p><strong>实战演习</strong></p>
<ol>
<li><p>首先，我们要用一个 <code>require</code> 句式来检查 <code>_tokenId</code> 的 <code>zombieApprovals</code> 和 <code>msg.sender</code> 相等。</p>
<p> 这样如果 <code>msg.sender</code> 未被授权来提取这个代币，将抛出一个错误。</p>
</li>
<li><p>为了调用 <code>_transfer</code>，我们需要知道代币所有者的地址（它需要一个 <code>_from</code> 来作为参数）。幸运的是我们可以在我们的 <code>ownerOf</code> 函数中来找到这个参数。</p>
<p> 所以，定义一个名为 <code>owner</code> 的 <code>address</code> 变量，并使其等于 <code>ownerOf(_tokenId)</code>。</p>
</li>
<li><p>最后，调用 <code>_transfer</code>, 并传入所有必须的参数。（在这里你可以用 <code>msg.sender</code> 作为 <code>_to</code>， 因为代币正是要发送给调用这个函数的人）。</p>
<blockquote>
<p>注意： 我们完全可以用一行代码来实现第2、3两步。但是分开写会让代码更易读。一点个人建议 :)</p>
</blockquote>
</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function takeOwnership(uint256 _tokenId) public {</span><br><span class="line">    // 从这里开始</span><br><span class="line">    require(msg.sender == zombieApprovals[_tokenId]);</span><br><span class="line">    address owner = ownerOf(_tokenId);</span><br><span class="line">    _transfer(owner, msg.sender, _tokenId);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第9章-预防溢出"><a href="#第9章-预防溢出" class="headerlink" title="第9章: 预防溢出"></a>第9章: 预防溢出</h3><p>恭喜你，我们完成了 ERC721 的实现。</p>
<p>并不是很复杂，对吧？很多类似的以太坊概念，当你只听人们谈论它们的时候，会觉得很复杂。所以最简单的理解方式就是你自己来实现它。</p>
<p>不过要记住那只是最简单的实现。还有很多的特性我们也许想加入到我们的实现中来，比如一些额外的检查，来确保用户不会不小心把他们的僵尸转移给<code>0</code> 地址（这被称作 “烧币”, 基本上就是把代币转移到一个谁也没有私钥的地址，让这个代币永远也无法恢复）。 或者在 DApp 中加入一些基本的拍卖逻辑。（你能想出一些实现的方法么？）</p>
<p>但是为了让我们的课程不至于离题太远，所以我们只专注于一些基础实现。如果你想学习一些更深层次的实现，可以在这个教程结束后，去看看 OpenZeppelin 的 ERC721 合约。</p>
<p><strong>合约安全增强: 溢出和下溢</strong></p>
<p>我们将来学习你在编写智能合约的时候需要注意的一个主要的安全特性：防止溢出和下溢。</p>
<p>什么是 <strong><em>溢出</em></strong> (*<strong>overflow*</strong>)?</p>
<p>假设我们有一个 <code>uint8</code>, 只能存储8 bit数据。这意味着我们能存储的最大数字就是二进制 <code>11111111</code> (或者说十进制的 2^8 - 1 = 255).</p>
<p>来看看下面的代码。最后 <code>number</code> 将会是什么值？</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint8 number = 255;</span><br><span class="line">number++;</span><br></pre></td></tr></tbody></table></figure>

<p>在这个例子中，我们导致了溢出 — 虽然我们加了1， 但是 <code>number</code> 出乎意料地等于 <code>0</code>了。 (如果你给二进制 <code>11111111</code> 加1, 它将被重置为 <code>00000000</code>，就像钟表从 <code>23:59</code> 走向 <code>00:00</code>)。</p>
<p>下溢(<code>underflow</code>)也类似，如果你从一个等于 <code>0</code> 的 <code>uint8</code> 减去 <code>1</code>, 它将变成 <code>255</code> (因为 <code>uint</code> 是无符号的，其不能等于负数)。</p>
<p>虽然我们在这里不使用 <code>uint8</code>，而且每次给一个 <code>uint256</code> 加 <code>1</code> 也不太可能溢出 (2^256 真的是一个很大的数了)，在我们的合约中添加一些保护机制依然是非常有必要的，以防我们的 DApp 以后出现什么异常情况。</p>
<p><strong>使用 SafeMath</strong></p>
<p>为了防止这些情况，OpenZeppelin 建立了一个叫做 SafeMath 的 <strong><em>库</em></strong>(*<strong>library*</strong>)，默认情况下可以防止这些问题。</p>
<p>不过在我们使用之前…… 什么叫做库?</p>
<p>一个**<em>库</em>** 是 Solidity 中一种特殊的合约。其中一个有用的功能是给原始数据类型增加一些方法。</p>
<p>比如，使用 SafeMath 库的时候，我们将使用 <code>using SafeMath for uint256</code> 这样的语法。 SafeMath 库有四个方法 — <code>add</code>， <code>sub</code>， <code>mul</code>， 以及 <code>div</code>。现在我们可以这样来让 <code>uint256</code> 调用这些方法：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">using SafeMath for uint256;</span><br><span class="line"></span><br><span class="line">uint256 a = 5;</span><br><span class="line">uint256 b = a.add(3); // 5 + 3 = 8</span><br><span class="line">uint256 c = a.mul(2); // 5 * 2 = 10</span><br></pre></td></tr></tbody></table></figure>

<p>我们将在下一章来学习这些方法，不过现在我们先将 SafeMath 库添加进我们的合约。</p>
<p><strong>实战演习</strong></p>
<p>我们已经帮你把 OpenZeppelin 的 <code>SafeMath</code> 库包含进 <code>safemath.sol</code>了，如果你想看一下代码的话，现在可以看看，不过我们下一章将深入进去。</p>
<p>首先我们来告诉我们的合约要使用 SafeMath。我们将在我们的 <code>ZombieFactory</code> 里调用，这是我们的基础合约 — 这样其他所有继承出去的子合约都可以使用这个库了。</p>
<ol>
<li>将 <code>safemath.sol</code> 引入到 <code>zombiefactory.sol</code>.</li>
<li>添加定义： <code>using SafeMath for uint256;</code>.</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 1. 在这里引入</span><br><span class="line">import "./safemath.sol";</span><br><span class="line"></span><br><span class="line">contract ZombieFactory is Ownable {</span><br><span class="line"></span><br><span class="line">  // 2. 在这里定义 using safemath </span><br><span class="line">    using SafeMath for uint256;</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第10章-SafeMath-第二部分"><a href="#第10章-SafeMath-第二部分" class="headerlink" title="第10章: SafeMath 第二部分"></a>第10章: SafeMath 第二部分</h3><p>来看看 SafeMath 的部分代码:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">library SafeMath {</span><br><span class="line"></span><br><span class="line">  function mul(uint256 a, uint256 b) internal pure returns (uint256) {</span><br><span class="line">    if (a == 0) {</span><br><span class="line">      return 0;</span><br><span class="line">    }</span><br><span class="line">    uint256 c = a * b;</span><br><span class="line">    assert(c / a == b);</span><br><span class="line">    return c;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  function div(uint256 a, uint256 b) internal pure returns (uint256) {</span><br><span class="line">    // assert(b &gt; 0); // Solidity automatically throws when dividing by 0</span><br><span class="line">    uint256 c = a / b;</span><br><span class="line">    // assert(a == b * c + a % b); // There is no case in which this doesn't hold</span><br><span class="line">    return c;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  function sub(uint256 a, uint256 b) internal pure returns (uint256) {</span><br><span class="line">    assert(b &lt;= a);</span><br><span class="line">    return a - b;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  function add(uint256 a, uint256 b) internal pure returns (uint256) {</span><br><span class="line">    uint256 c = a + b;</span><br><span class="line">    assert(c &gt;= a);</span><br><span class="line">    return c;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>首先我们有了 <code>library</code> 关键字 — 库和 <code>合约</code>很相似，但是又有一些不同。 就我们的目的而言，库允许我们使用 <code>using</code> 关键字，它可以自动把库的所有方法添加给一个数据类型：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">using SafeMath for uint;</span><br><span class="line">// 这下我们可以为任何 uint 调用这些方法了</span><br><span class="line">uint test = 2;</span><br><span class="line">test = test.mul(3); // test 等于 6 了</span><br><span class="line">test = test.add(5); // test 等于 11 了</span><br></pre></td></tr></tbody></table></figure>

<p>注意 <code>mul</code> 和 <code>add</code> 其实都需要两个参数。 在我们声明了 <code>using SafeMath for uint</code> 后，我们用来调用这些方法的 <code>uint</code> 就自动被作为第一个参数传递进去了(在此例中就是 <code>test</code>)</p>
<p>我们来看看 <code>add</code> 的源代码看 SafeMath 做了什么:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function add(uint256 a, uint256 b) internal pure returns (uint256) {</span><br><span class="line">  uint256 c = a + b;</span><br><span class="line">  assert(c &gt;= a);</span><br><span class="line">  return c;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>基本上 <code>add</code> 只是像 <code>+</code> 一样对两个 <code>uint</code> 相加， 但是<u><strong>它用一个 <code>assert</code> 语句来确保结果大于 <code>a</code>。这样就防止了溢出。</strong></u></p>
<p><code>assert</code> 和 <code>require</code> 相似，若结果为否它就会抛出错误。 <code>assert</code> 和 <code>require</code> 区别在于，<u><strong><code>require</code> 若失败则会返还给用户剩下的 gas， <code>assert</code> 则不会</strong></u>。所以大部分情况下，你写代码的时候会比较喜欢 <code>require</code>，<code>assert</code> 只在代码可能出现严重错误的时候使用，比如 <code>uint</code> 溢出。</p>
<p>所以简而言之， SafeMath 的 <code>add</code>， <code>sub</code>， <code>mul</code>， 和 <code>div</code> 方法只做简单的四则运算，然后在发生溢出或下溢的时候抛出错误。</p>
<p><strong>在我们的代码里使用 SafeMath</strong></p>
<p>为了防止溢出和下溢，我们可以在我们的代码里找 <code>+</code>， <code>-</code>， <code>*</code>， 或 <code>/</code>，然后替换为 <code>add</code>, <code>sub</code>, <code>mul</code>, <code>div</code>.</p>
<p>比如，与其这样做:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myUint++;</span><br></pre></td></tr></tbody></table></figure>

<p>我们这样做：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myUint = myUint.add(1);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实战演习</strong></p>
<p>在 <code>ZombieOwnership</code> 中有两个地方用到了数学运算，来替换成 SafeMath 方法把。</p>
<ol>
<li>将 <code>++</code> 替换成 SafeMath 方法。</li>
<li>将 <code>--</code> 替换成 SafeMath 方法。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function _transfer(address _from, address _to, uint256 _tokenId) private {</span><br><span class="line">    // 1. 替换成 SafeMath 的 `add`</span><br><span class="line">    //ownerZombieCount[_to]++;</span><br><span class="line">    ownerZombieCount[_to] = ownerZombieCount[_to].add(1);</span><br><span class="line">    // 2. 替换成 SafeMath 的 `sub`</span><br><span class="line">    //ownerZombieCount[_from]--;</span><br><span class="line">    ownerZombieCount[_from] = ownerZombieCount[_from].sub(1);</span><br><span class="line">    zombieToOwner[_tokenId] = _to;</span><br><span class="line">    Transfer(_from, _to, _tokenId);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第11章-SafeMath-第三部分"><a href="#第11章-SafeMath-第三部分" class="headerlink" title="第11章: SafeMath 第三部分"></a>第11章: SafeMath 第三部分</h3><p>太好了，这下我们的 ERC721 实现不会有溢出或者下溢了。</p>
<p>回头看看我们在之前课程写的代码，还有其他几个地方也有可能导致溢出或下溢。</p>
<p>比如， 在 ZombieAttack 里面我们有：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myZombie.winCount++;</span><br><span class="line">myZombie.level++;</span><br><span class="line">enemyZombie.lossCount++;</span><br></pre></td></tr></tbody></table></figure>

<p>我们同样应该在这些地方防止溢出。（通常情况下，总是使用 SafeMath 而不是普通数学运算是个好主意，也许在以后 Solidity 的新版本里这点会被默认实现，但是现在我们得自己在代码里实现这些额外的安全措施）。</p>
<p>不过我们遇到个小问题 — <code>winCount</code> 和 <code>lossCount</code> 是 <code>uint16</code>， 而 <code>level</code> 是 <code>uint32</code>。 所以如果我们用这些作为参数传入 SafeMath 的 <code>add</code> 方法。 它实际上并不会防止溢出，因为它会把这些变量都转换成 <code>uint256</code>:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function add(uint256 a, uint256 b) internal pure returns (uint256) {</span><br><span class="line">  uint256 c = a + b;</span><br><span class="line">  assert(c &gt;= a);</span><br><span class="line">  return c;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 如果我们在`uint8` 上调用 `.add`。它将会被转换成 `uint256`.</span><br><span class="line">// 所以它不会在 2^8 时溢出，因为 256 是一个有效的 `uint256`.</span><br></pre></td></tr></tbody></table></figure>

<p>这就意味着，我们需要再实现两个库来防止 <code>uint16</code> 和 <code>uint32</code> 溢出或下溢。我们可以将其命名为 <code>SafeMath16</code> 和 <code>SafeMath32</code>。</p>
<p>代码将和 SafeMath 完全相同，除了所有的 <code>uint256</code> 实例都将被替换成 <code>uint32</code> 或 <code>uint16</code>。</p>
<p>我们已经将这些代码帮你写好了，打开 <code>safemath.sol</code> 合约看看代码吧。</p>
<p>现在我们需要在 ZombieFactory 里使用它们。</p>
<p><strong>Putting it to the Test</strong></p>
<p>分配：</p>
<ol>
<li>声明我们将为 <code>uint32</code> 使用<code>SafeMath32</code>。</li>
<li>声明我们将为 <code>uint16</code> 使用<code>SafeMath16</code>。</li>
<li>在 ZombieFactory 里还有一处我们也应该使用 SafeMath 的方法， 我们已经在那里留了注释提醒你。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">contract ZombieFactory is Ownable {</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  // 1. 为 uint32 声明 使用 SafeMath32</span><br><span class="line">  // 2. 为 uint16 声明 使用 SafeMath16</span><br><span class="line">  using SafeMath32 for uint32;</span><br><span class="line">  using SafeMath16 for uint16;</span><br><span class="line">  ………………</span><br><span class="line">  function _createZombie(string _name, uint _dna) internal {</span><br><span class="line">    // 注意: 我们选择不处理2038年问题，所以不用担心 readyTime 的溢出</span><br><span class="line">    // 反正在2038年我们的APP早完蛋了</span><br><span class="line">    uint id = zombies.push(Zombie(_name, _dna, 1, uint32(now + cooldownTime), 0, 0)) - 1;</span><br><span class="line">    zombieToOwner[id] = msg.sender;</span><br><span class="line">    // 3. 在这里使用 SafeMath 的 `add` 方法:</span><br><span class="line">    //ownerZombieCount[msg.sender]++;</span><br><span class="line">    ownerZombieCount[msg.sender] = ownerZombieCount[msg.sender].add(1);</span><br><span class="line">    NewZombie(id, _name, _dna);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第12章-SafeMath-第4部分"><a href="#第12章-SafeMath-第4部分" class="headerlink" title="第12章: SafeMath 第4部分"></a>第12章: SafeMath 第4部分</h3><p>真棒，现在我们已经为我们的 DApp 里面用到的 <code>uint</code> 数据类型都实现了 SafeMath 了。</p>
<p>让我们把 <code>ZombieAttack</code> 里所有潜在的问题都修复了吧。 （其实在 <code>ZombieHelper</code> 里也有一处 <code>zombies[_zombieId].level++;</code> 需要修复，不过我们已经帮你做好了，这样我们就不用再来一章了 😉）。</p>
<p><strong>实战演习</strong></p>
<p>放心大胆去对 <code>ZombieAttack</code> 里所有的 <code>++</code> 操作都使用 SafeMath 方法吧。为了方便你找，我们已经在相应的地方留了注释给你。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import "./zombiehelper.sol";</span><br><span class="line"></span><br><span class="line">contract ZombieBattle is ZombieHelper {</span><br><span class="line">  uint randNonce = 0;</span><br><span class="line">  uint attackVictoryProbability = 70;</span><br><span class="line"></span><br><span class="line">  function randMod(uint _modulus) internal returns(uint) {</span><br><span class="line">    // 这儿有一个</span><br><span class="line">    //randNonce++;</span><br><span class="line">    randNonce = randNonce.add(1);</span><br><span class="line">    return uint(keccak256(now, msg.sender, randNonce)) % _modulus;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  function attack(uint _zombieId, uint _targetId) external onlyOwnerOf(_zombieId) {</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    Zombie storage enemyZombie = zombies[_targetId];</span><br><span class="line">    uint rand = randMod(100);</span><br><span class="line">    if (rand &lt;= attackVictoryProbability) {</span><br><span class="line">      // 这里有三个</span><br><span class="line">      //myZombie.winCount++;</span><br><span class="line">      myZombie.winCount = myZombie.winCount.add(1);</span><br><span class="line">      //myZombie.level++;</span><br><span class="line">      myZombie.level = myZombie.level.add(1);</span><br><span class="line">      //enemyZombie.lossCount++;</span><br><span class="line">      enemyZombie.lossCount = enemyZombie.lossCount.add(1);</span><br><span class="line">      feedAndMultiply(_zombieId, enemyZombie.dna, "zombie");</span><br><span class="line">    } else {</span><br><span class="line">      // 这儿还有俩哦</span><br><span class="line">      //myZombie.lossCount++;</span><br><span class="line">        myZombie.lossCount = myZombie.lossCount.add(1);</span><br><span class="line">      //enemyZombie.winCount++;</span><br><span class="line">        enemyZombie.winCount = enemyZombie.winCount.add(1);</span><br><span class="line">      _triggerCooldown(myZombie);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第13章-注释"><a href="#第13章-注释" class="headerlink" title="第13章: 注释"></a>第13章: 注释</h3><p>僵尸游戏的 Solidity 代码终于完成啦。</p>
<p>在以后的课程中，我们将学习如何将游戏部署到以太坊，以及如何和 Web3.js 交互。</p>
<p>不过在你离开第五课之前，我们来谈谈如何 <strong>给你的代码添加注释</strong>.</p>
<p><strong>注释语法</strong></p>
<p>Solidity 里的注释和 JavaScript 相同。在我们的课程中你已经看到了不少单行注释了：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 这是一个单行注释，可以理解为给自己或者别人看的笔记</span><br></pre></td></tr></tbody></table></figure>

<p>只要在任何地方添加一个 <code>//</code> 就意味着你在注释。如此简单所以你应该经常这么做。</p>
<p>不过我们也知道你的想法：有时候单行注释是不够的。毕竟你生来话痨。</p>
<p>所以我们有了多行注释：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">contract CryptoZombies {</span><br><span class="line">  /* 这是一个多行注释。我想对所有花时间来尝试这个编程课程的人说声谢谢。</span><br><span class="line">  它是免费的，并将永远免费。但是我们依然倾注了我们的心血来让它变得更好。</span><br><span class="line"></span><br><span class="line">   要知道这依然只是区块链开发的开始而已，虽然我们已经走了很远，</span><br><span class="line">   仍然有很多种方式来让我们的社区变得更好。</span><br><span class="line">   如果我们在哪个地方出了错，欢迎在我们的 github 提交 PR 或者 issue 来帮助我们改进：</span><br><span class="line">    https://github.com/loomnetwork/cryptozombie-lessons</span><br><span class="line"></span><br><span class="line">    或者，如果你有任何的想法、建议甚至仅仅想和我们打声招呼，欢迎来我们的电报群：</span><br><span class="line">     https://t.me/loomnetworkdev</span><br><span class="line">  */</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>特别是，最好为你合约中每个方法添加注释来解释它的预期行为。这样其他开发者（或者你自己，在6个月以后再回到这个项目中）可以很快地理解你的代码而不需要逐行阅读所有代码。</p>
<p>Solidity 社区所使用的一个标准是使用一种被称作 *<strong>natspec*</strong> 的格式，看起来像这样：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/// @title 一个简单的基础运算合约</span><br><span class="line">/// @author H4XF13LD MORRIS 💯💯😎💯💯</span><br><span class="line">/// @notice 现在，这个合约只添加一个乘法</span><br><span class="line">contract Math {</span><br><span class="line">  /// @notice 两个数相乘</span><br><span class="line">  /// @param x 第一个 uint</span><br><span class="line">  /// @param y  第二个 uint</span><br><span class="line">  /// @return z  (x * y) 的结果</span><br><span class="line">  /// @dev 现在这个方法不检查溢出</span><br><span class="line">  function multiply(uint x, uint y) returns (uint z) {</span><br><span class="line">    // 这只是个普通的注释，不会被 natspec 解释</span><br><span class="line">    z = x * y;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>@title</code>（标题） 和 <code>@author</code> （作者）很直接了.</p>
<p><code>@notice</code> （须知）向 <strong>用户</strong> 解释这个方法或者合约是做什么的。 <code>@dev</code> （开发者） 是向开发者解释更多的细节。</p>
<p><code>@param</code> （参数）和 <code>@return</code> （返回） 用来描述这个方法需要传入什么参数以及返回什么值。</p>
<p>注意你并不需要每次都用上所有的标签，它们都是可选的。不过最少，写下一个 <code>@dev</code> 注释来解释每个方法是做什么的。</p>
<p><strong>实战演习</strong></p>
<p>如果你还没注意到：CryptoZombies 的答案检查器在工作的时候将忽略所有的注释。所以这一章我们其实无法检查你的 natspec 注释了。全靠你自己咯。</p>
<p>话说回来，到现在你应该已经是一个 Solidity 小能手了。我们就假定你已经学会这些了。</p>
<p>大胆去做些尝试把，给 <code>ZombieOwnership</code> 加上一些 natspec 标签:</p>
<ol>
<li><code>@title</code> — 例如：一个管理转移僵尸所有权的合约</li>
<li><code>@author</code> — 你的名字</li>
<li><code>@dev</code> — 例如：符合 OpenZeppelin 对 ERC721 标准草案的实现</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import "./zombieattack.sol";</span><br><span class="line">import "./erc721.sol";</span><br><span class="line">import "./safemath.sol";</span><br><span class="line"></span><br><span class="line">/// TODO: 把这里变成 natspec 标准的注释把</span><br><span class="line">/// @title 一个管理转移僵尸所有权的合约</span><br><span class="line">/// @author 0xMx1@0</span><br><span class="line">/// @dev 符合 OpenZeppelin 对 ERC721 标准草案的实现</span><br></pre></td></tr></tbody></table></figure>

<h4 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h4><p>这节课里面我们学到了</p>
<ul>
<li>代币, ERC721 标准，以及可交易的物件/僵尸</li>
<li>库以及如何使用库</li>
<li>如何利用 SafeMath 来防止溢出和下溢</li>
<li>代码注释和 natspec 标准</li>
</ul>
<p>在接下来的两节课中，我们将学习如何将游戏部署到以太坊以及和 *<strong>web3.js*</strong> 交互 （这样你就能为你的 DApp 打造一个界面了 ）。</p>
<h2 id="lesson6-应用前端和-Web3-js"><a href="#lesson6-应用前端和-Web3-js" class="headerlink" title="lesson6 应用前端和 Web3.js"></a>lesson6 应用前端和 Web3.js</h2><h3 id="第1章-介绍-Web3-js"><a href="#第1章-介绍-Web3-js" class="headerlink" title="第1章: 介绍 Web3.js"></a>第1章: 介绍 Web3.js</h3><p>完成第五课以后，我们的僵尸 DApp 的 Solidity 合约部分就完成了。现在我们来做一个基本的网页好让你的用户能玩它。 要做到这一点，我们将使用以太坊基金发布的 JavaScript 库 —— *<strong>Web3.js*</strong>.</p>
<p><strong>什么是 Web3.js?</strong></p>
<p>还记得么？以太坊网络是由节点组成的，每一个节点都包含了区块链的一份拷贝。当你想要调用一份智能合约的一个方法，你需要从其中一个节点中查找并告诉它:</p>
<ol>
<li>智能合约的地址</li>
<li>你想调用的方法，以及</li>
<li>你想传入那个方法的参数</li>
</ol>
<p>以太坊节点只能识别一种叫做 <u>*<strong>JSON-RPC*</strong></u> 的语言。这种语言直接读起来并不好懂。当你你想调用一个合约的方法的时候，需要发送的查询语句将会是这样的：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哈……祝你写所有这样的函数调用的时候都一次通过</span></span><br><span class="line"><span class="comment">// 往右边拉…… ==&gt;</span></span><br><span class="line"><span class="punctuation">{</span><span class="attr">"jsonrpc"</span><span class="punctuation">:</span><span class="string">"2.0"</span><span class="punctuation">,</span><span class="attr">"method"</span><span class="punctuation">:</span><span class="string">"eth_sendTransaction"</span><span class="punctuation">,</span><span class="attr">"params"</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">{</span><span class="attr">"from"</span><span class="punctuation">:</span><span class="string">"0xb60e8dd61c5d32be8058bb8eb970870f07233155"</span><span class="punctuation">,</span><span class="attr">"to"</span><span class="punctuation">:</span><span class="string">"0xd46e8dd67c5d32be8058bb8eb970870f07244567"</span><span class="punctuation">,</span><span class="attr">"gas"</span><span class="punctuation">:</span><span class="string">"0x76c0"</span><span class="punctuation">,</span><span class="attr">"gasPrice"</span><span class="punctuation">:</span><span class="string">"0x9184e72a000"</span><span class="punctuation">,</span><span class="attr">"value"</span><span class="punctuation">:</span><span class="string">"0x9184e72a"</span><span class="punctuation">,</span><span class="attr">"data"</span><span class="punctuation">:</span><span class="string">"0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675"</span><span class="punctuation">}</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">"id"</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>幸运的是 Web3.js 把这些令人讨厌的查询语句都隐藏起来了， 所以你只需要与方便易懂的 JavaScript 界面进行交互即可。</p>
<p>你不需要构建上面的查询语句，在你的代码中调用一个函数看起来将是这样：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CryptoZombies.methods.createRandomZombie("Vitalik Nakamoto 🤔")</span><br><span class="line">  .send({ from: "0xb60e8dd61c5d32be8058bb8eb970870f07233155", gas: "3000000" })</span><br></pre></td></tr></tbody></table></figure>

<p>我们将在接下来的几章详细解释这些语句，不过首先我们来把 Web3.js 环境搭建起来。</p>
<p><strong>准备好了么？</strong></p>
<p>取决于你的项目工作流程和你的爱好，你可以用一些常用工具把 Web3.js 添加进来：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 用 NPM</span><br><span class="line">npm install web3</span><br><span class="line"></span><br><span class="line">// 用 Yarn</span><br><span class="line">yarn add web3</span><br><span class="line"></span><br><span class="line">// 用 Bower</span><br><span class="line">bower install web3</span><br><span class="line"></span><br><span class="line">// ...或者其他。</span><br></pre></td></tr></tbody></table></figure>

<p>甚至，你可以从 <a target="_blank" rel="noopener" href="https://github.com/ethereum/web3.js/blob/1.0/dist/web3.min.js">github</a> 直接下载压缩后的 <code>.js</code> 文件 然后包含到你的项目文件中：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=<span class="string">"javascript"</span> type=<span class="string">"text/javascript"</span> src=<span class="string">"web3.min.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>因为我们不想让你花太多在项目环境搭建上，在本教程中我们将使用上面的 <code>script</code> 标签来将 Web3.js 引入。</p>
<p><strong>实战演习</strong></p>
<p>我们为你建立了一个HTML 项目空壳 —— <code>index.html</code>。假设在和 <code>index.html</code> 同个文件夹里有一份 <code>web3.min.js</code></p>
<ol>
<li>使用上面的 <code>script</code> 标签代码把 <code>web3.js</code> 添加进去以备接下来使用。</li>
</ol>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>CryptoZombies front-end<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">"javascript"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- Include web3.js here --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">"javascript"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"web3.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br></pre></td></tr></tbody></table></figure>



<h3 id="第2章-Web3-提供者"><a href="#第2章-Web3-提供者" class="headerlink" title="第2章: Web3 提供者"></a>第2章: Web3 提供者</h3><p>太棒了。现在我们的项目中有了Web3.js, 来初始化它然后和区块链对话吧。</p>
<p>首先我们需要 *<strong>Web3 Provider*</strong>.</p>
<p>要记住，以太坊是由共享同一份数据的相同拷贝的 <strong><em>节点</em></strong> 构成的。 在 Web3.js 里设置 Web3 的 <code>Provider</code>（提供者） 告诉我们的代码应该和 <strong>哪个节点</strong> 交互来处理我们的读写。这就好像在传统的 Web 应用程序中为你的 API 调用设置远程 Web 服务器的网址。</p>
<p>你可以运行你自己的以太坊节点来作为 Provider。 不过，有一个第三方的服务，可以让你的生活变得轻松点，让你不必为了给你的用户提供DApp而维护一个以太坊节点— *<strong>Infura*</strong>.</p>
<p><strong>Infura</strong></p>
<p><a target="_blank" rel="noopener" href="https://infura.io/">Infura</a> 是一个服务，它维护了很多以太坊节点并提供了一个缓存层来实现高速读取。你可以用他们的 API 来免费访问这个服务。 用 Infura 作为节点提供者，你可以不用自己运营节点就能很可靠地向以太坊发送、接收信息。</p>
<p>你可以通过这样把 Infura 作为你的 Web3 节点提供者：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var web3 = new Web3(new Web3.providers.WebsocketProvider("wss://mainnet.infura.io/ws"));</span><br></pre></td></tr></tbody></table></figure>

<p>不过，因为我们的 DApp 将被很多人使用，这些用户不单会从区块链读取信息，还会向区块链 <strong><em>写</em></strong> 入信息，我们需要用一个方法让用户可以用他们的私钥给事务签名。</p>
<blockquote>
<p>注意: 以太坊 (以及通常意义上的 blockchains )使用一个公钥/私钥对来对给事务做数字签名。把它想成一个数字签名的异常安全的密码。这样当我修改区块链上的数据的时候，我可以用我的公钥来 <strong>证明</strong> 我就是签名的那个。但是因为没人知道我的私钥，所以没人能伪造我的事务。</p>
</blockquote>
<p>加密学非常复杂，所以除非你是个专家并且的确知道自己在做什么，你最好不要在你应用的前端中管理你用户的私钥。</p>
<p>不过幸运的是，你并不需要，已经有可以帮你处理这件事的服务了： *<strong>Metamask*</strong>.</p>
<p><strong>Metamask</strong></p>
<p><a target="_blank" rel="noopener" href="https://metamask.io/">Metamask</a> 是 Chrome 和 Firefox 的浏览器扩展， 它能让用户安全地维护他们的以太坊账户和私钥， 并用他们的账户和使用 Web3.js 的网站互动（如果你还没用过它，你肯定会想去安装的——这样你的浏览器就能使用 Web3.js 了，然后你就可以和任何与以太坊区块链通信的网站交互了）</p>
<p>作为开发者，如果你想让用户从他们的浏览器里通过网站和你的DApp交互（就像我们在 CryptoZombies 游戏里一样），你肯定会想要兼容 Metamask 的。</p>
<blockquote>
<p><strong>注意</strong>: Metamask 默认使用 Infura 的服务器做为 web3 提供者。 就像我们上面做的那样。不过它还为用户提供了选择他们自己 Web3 提供者的选项。所以使用 Metamask 的 web3 提供者，你就给了用户选择权，而自己无需操心这一块。</p>
</blockquote>
<p><strong>使用 Metamask 的 web3 提供者</strong></p>
<p>Metamask 把它的 web3 提供者注入到浏览器的全局 JavaScript对象<code>web3</code>中。所以你的应用可以检查 <code>web3</code> 是否存在。若存在就使用 <code>web3.currentProvider</code> 作为它的提供者。</p>
<p>这里是一些 Metamask 提供的示例代码，用来检查用户是否安装了MetaMask，如果没有安装就告诉用户需要安装MetaMask来使用我们的应用。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener('load', function() {</span><br><span class="line"></span><br><span class="line">  // 检查web3是否已经注入到(Mist/MetaMask)</span><br><span class="line">  if (typeof web3 !== 'undefined') {</span><br><span class="line">    // 使用 Mist/MetaMask 的提供者</span><br><span class="line">    web3js = new Web3(web3.currentProvider);</span><br><span class="line">  } else {</span><br><span class="line">    // 处理用户没安装的情况， 比如显示一个消息</span><br><span class="line">    // 告诉他们要安装 MetaMask 来使用我们的应用</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  // 现在你可以启动你的应用并自由访问 Web3.js:</span><br><span class="line">  startApp()</span><br><span class="line"></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>你可以在你所有的应用中使用这段样板代码，好检查用户是否安装以及告诉用户安装 MetaMask。</p>
<blockquote>
<p>注意: 除了MetaMask，你的用户也可能在使用其他他的私钥管理应用，比如 <strong>Mist</strong> 浏览器。不过，它们都实现了相同的模式来注入 <code>web3</code> 变量。所以我这里描述的方法对两者是通用的。</p>
</blockquote>
<p><strong>实战演习</strong></p>
<p>我们在HTML文件中的 <code>&lt;/body&gt;</code> 标签前面放置了一个空的 <code>script</code> 标签。可以把这节课的 JavaScript 代码写在里面。</p>
<ol>
<li>把上面用来检测 MetaMask 是否安装的模板代码粘贴进来。请粘贴到以 <code>window.addEventListener</code> 开头的代码块中。</li>
</ol>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>CryptoZombies front-end<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">"javascript"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">"javascript"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"web3.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">// Start here</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">'load'</span>, <span class="keyword">function</span>(<span class="params"></span>) {</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">// 检查web3是否已经注入到(Mist/MetaMask)</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">if</span> (<span class="keyword">typeof</span> web3 !== <span class="string">'undefined'</span>) {</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">// 使用 Mist/MetaMask 的提供者</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        web3js = <span class="keyword">new</span> <span class="title class_">Web3</span>(web3.<span class="property">currentProvider</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      } <span class="keyword">else</span> {</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">// 处理用户没安装的情况， 比如显示一个消息</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">// 告诉他们要安装 MetaMask 来使用我们的应用</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      }</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">// 现在你可以启动你的应用并自由访问 Web3.js:</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="title function_">startApp</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    })</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br></pre></td></tr></tbody></table></figure>



<h3 id="第3章-和合约对话"><a href="#第3章-和合约对话" class="headerlink" title="第3章: 和合约对话"></a>第3章: 和合约对话</h3><p>现在，我们已经用 MetaMask 的 Web3 提供者初始化了 Web3.js。接下来就让它和我们的智能合约对话吧。</p>
<p>Web3.js 需要两个东西来和你的合约对话: 它的 <strong><em>地址</em></strong> 和它的 ***ABI***。</p>
<p><strong>合约地址</strong></p>
<p>在你写完了你的智能合约后，你需要编译它并把它部署到以太坊。我们将在<strong>下一课</strong>中详述<strong>部署</strong>，因为它和写代码是截然不同的过程，所以我们决定打乱顺序，先来讲 Web3.js。</p>
<p>在你部署智能合约以后，它将获得一个以太坊上的永久地址。如果你还记得第二课，CryptoKitties 在以太坊上的地址是 <code>0x06012c8cf97BEaD5deAe237070F9587f8E7A266d</code>。</p>
<p>你需要在部署后复制这个地址以来和你的智能合约对话。</p>
<p><strong>合约 ABI</strong></p>
<p>另一个 Web3.js 为了要和你的智能合约对话而需要的东西是 ***ABI***。</p>
<p>ABI 意为应用二进制接口（Application Binary Interface）。 基本上，它是以 JSON 格式表示合约的方法，告诉 Web3.js 如何以合同理解的方式格式化函数调用。</p>
<p>当你编译你的合约向以太坊部署时(我们将在第七课详述)， Solidity 编译器会给你 ABI，所以除了合约地址，你还需要把这个也复制下来。</p>
<p>因为我们这一课不会讲述部署，所以现在我们已经帮你编译了 ABI 并放在了名为<code>cryptozombies_abi.js</code>，文件中，保存在一个名为 <code>cryptoZombiesABI</code> 的变量中。</p>
<p>如果我们将<code>cryptozombies_abi.js</code> 包含进我们的项目，我们就能通过那个变量访问 CryptoZombies ABI 。</p>
<p><strong>实例化 Web3.js</strong></p>
<p>一旦你有了合约的地址和 ABI，你可以像这样来实例化 Web3.js。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 实例化 myContract</span><br><span class="line">var myContract = new web3js.eth.Contract(myABI, myContractAddress);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实战演习</strong></p>
<ol>
<li>在文件的 <code>&lt;head&gt;</code> 标签块中，用 <code>script</code> 标签引入<code>cryptozombies_abi.js</code>，好把 ABI 的定义引入项目。</li>
<li>在 <code>&lt;body&gt;</code> 里的 <code>&lt;script&gt;</code> 开头 , 定义一个<code>var</code>，取名 <code>cryptoZombies</code>， 不过不要对其赋值，稍后我们将用这个这个变量来存储我们实例化合约。</li>
<li>接下来，创建一个名为 <code>startApp()</code> 的 <code>function</code>。 接下来两步来完成这个方法。</li>
<li><code>startApp()</code> 里应该做的第一件事是定义一个名为<code>cryptoZombiesAddress</code> 的变量并赋值为<code>"你的合约地址"</code> (这是你的合约在以太坊主网上的地址)。</li>
<li>最后，来实例化我们的合约。模仿我们上面的代码，将 <code>cryptoZombies</code> 赋值为 <code>new</code> <code>web3js.eth.Contract</code> (使用我们上面代码中通过 <code>script</code> 引入的 <code>cryptoZombiesABI</code> 和 <code>cryptoZombiesAddress</code>)。</li>
</ol>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>CryptoZombies front-end<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">"javascript"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">"javascript"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"web3.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 1. Include cryptozombies_abi.js here --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">"javascript"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"cryptozombies_abi.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">// 2. Start code here</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">var</span> cryptoZombies;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">function</span> <span class="title function_">startApp</span>(<span class="params"></span>){</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">var</span> cryptoZombiesAddress = <span class="string">"你的合约地址"</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        cryptoZombies = <span class="keyword">new</span> web3js.<span class="property">eth</span>.<span class="title class_">Contract</span>(cryptoZombiesABI, cryptoZombiesAddress);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      }</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">'load'</span>, <span class="keyword">function</span>(<span class="params"></span>) {</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">// Checking if Web3 has been injected by the browser (Mist/MetaMask)</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">if</span> (<span class="keyword">typeof</span> web3 !== <span class="string">'undefined'</span>) {</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="comment">// Use Mist/MetaMask's provider</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          web3js = <span class="keyword">new</span> <span class="title class_">Web3</span>(web3.<span class="property">currentProvider</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        } <span class="keyword">else</span> {</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="comment">// Handle the case where the user doesn't have Metamask installed</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="comment">// Probably show them a message prompting them to install Metamask</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        }</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">// Now you can start your app &amp; access web3 freely:</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">startApp</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      })</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br></pre></td></tr></tbody></table></figure>



<h3 id="第4章-调用和合约函数"><a href="#第4章-调用和合约函数" class="headerlink" title="第4章: 调用和合约函数"></a>第4章: 调用和合约函数</h3><p>我们的合约配置好了！现在来用 Web3.js 和它对话。</p>
<p>Web3.js 有两个方法来调用我们合约的函数: <code>call</code> and <code>send</code>.</p>
<p><strong>Call</strong></p>
<p><code>call</code> 用来调用 <code>view</code> 和 <code>pure</code> 函数。它只运行在本地节点，不会在区块链上创建事务。</p>
<blockquote>
<p><strong>复习:</strong> <code>view</code> 和 <code>pure</code> 函数是只读的并不会改变区块链的状态。它们也不会消耗任何gas。用户也不会被要求用MetaMask对事务签名。</p>
</blockquote>
<p>使用 Web3.js，你可以如下 <code>call</code> 一个名为<code>myMethod</code>的方法并传入一个 <code>123</code> 作为参数：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myContract.<span class="property">methods</span>.<span class="title function_">myMethod</span>(<span class="number">123</span>).<span class="title function_">call</span>()</span><br></pre></td></tr></tbody></table></figure>

<p><strong>Send</strong></p>
<p><code>send</code> 将创建一个事务并改变区块链上的数据。你需要用 <code>send</code> 来调用任何非 <code>view</code> 或者 <code>pure</code> 的函数。</p>
<blockquote>
<p><strong>注意:</strong> <code>send</code> 一个事务将要求用户支付gas，并会要求弹出对话框请求用户使用 Metamask 对事务签名。在我们使用 Metamask 作为我们的 web3 提供者的时候，所有这一切都会在我们调用 <code>send()</code> 的时候自动发生。而我们自己无需在代码中操心这一切，挺爽的吧。</p>
</blockquote>
<p>使用 Web3.js, 你可以像这样 <code>send</code> 一个事务调用<code>myMethod</code> 并传入 <code>123</code> 作为参数：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myContract.<span class="property">methods</span>.<span class="title function_">myMethod</span>(<span class="number">123</span>).<span class="title function_">send</span>()</span><br></pre></td></tr></tbody></table></figure>

<p>语法几乎 <code>call()</code>一模一样。</p>
<p><strong>获取僵尸数据</strong></p>
<p>来看一个使用 <code>call</code> 读取我们合约数据的真实例子</p>
<p>回忆一下，我们定义我们的僵尸数组为 <code>公开</code>(public):</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Zombie[] public zombies;</span><br></pre></td></tr></tbody></table></figure>

<p><u><strong>在 Solidity 里，当你定义一个 <code>public</code>变量的时候， 它将自动定义一个公开的 “getter” 同名方法</strong></u>， 所以如果你像要查看 id 为 <code>15</code> 的僵尸，你可以像一个函数一样调用它： <code>zombies(15)</code>.</p>
<p>这是如何在外面的前端界面中写一个 JavaScript 方法来传入一个僵尸 id，在我们的合同中查询那个僵尸并返回结果</p>
<blockquote>
<p>注意: 本课中所有的示例代码都使用 Web3.js 的 <strong>1.0 版</strong>，此版本使用的是 Promises 而不是回调函数。你在线上看到的其他教程可能还在使用老版的 Web3.js。在1.0版中，语法改变了不少。如果你从其他教程中复制代码，先确保你们使用的是相同版本的Web3.js。</p>
</blockquote>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getZombieDetails</span>(<span class="params">id</span>) {</span><br><span class="line">  <span class="keyword">return</span> cryptoZombies.<span class="property">methods</span>.<span class="title function_">zombies</span>(id).<span class="title function_">call</span>()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数并做一些其他事情</span></span><br><span class="line"><span class="title function_">getZombieDetails</span>(<span class="number">15</span>)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">result</span>) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"Zombie 15: "</span> + <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(result));</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>我们来看看这里都做了什么</p>
<p><code>cryptoZombies.methods.zombies(id).call()</code> 将和 Web3 提供者节点通信，告诉它返回从我们的合约中的 <code>Zombie[] public zombies</code>，<code>id</code>为传入参数的僵尸信息。</p>
<p>注意这是 <strong>异步的</strong>，就像从外部服务器中调用API。所以 Web3 在这里返回了一个 Promises. (如果你对 JavaScript的 Promises 不了解，最好先去学习一下这方面知识再继续)。</p>
<p>一旦那个 <code>promise</code> 被 <code>resolve</code>, (意味着我们从 Web3 提供者那里获得了响应)，我们的例子代码将执行 <code>then</code> 语句中的代码，在控制台打出 <code>result</code>。</p>
<p><code>result</code> 是一个像这样的 JavaScript 对象：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"H4XF13LD MORRIS'S COOLER OLDER BROTHER"</span>,</span><br><span class="line">  <span class="string">"dna"</span>: <span class="string">"1337133713371337"</span>,</span><br><span class="line">  <span class="string">"level"</span>: <span class="string">"9999"</span>,</span><br><span class="line">  <span class="string">"readyTime"</span>: <span class="string">"1522498671"</span>,</span><br><span class="line">  <span class="string">"winCount"</span>: <span class="string">"999999999"</span>,</span><br><span class="line">  <span class="string">"lossCount"</span>: <span class="string">"0"</span> <span class="comment">// Obviously.</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们可以用一些前端逻辑代码来解析这个对象并在前端界面友好展示。</p>
<p><strong>实战演习</strong></p>
<p>我们已经帮你把 <code>getZombieDetails</code> 复制进了代码。</p>
<ol>
<li><p>先为<code>zombieToOwner</code> 创建一个类似的函数。如果你还记得 <code>ZombieFactory.sol</code>，我们有一个长这样的映射：</p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapping (uint =&gt; address) public zombieToOwner;</span><br></pre></td></tr></tbody></table></figure>

<p> 定义一个 JavaScript 方法，起名为 <code>zombieToOwner</code>。和上面的 <code>getZombieDetails</code> 类似， 它将接收一个<code>id</code> 作为参数，并返回一个 Web3.js <code>call</code> 我们合约里的<code>zombieToOwner</code> 。</p>
</li>
<li><p>之后在下面，为 <code>getZombiesByOwner</code> 定义一个方法。如果你还能记起 <code>ZombieHelper.sol</code>，这个方法定义像这样：</p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function getZombiesByOwner(address _owner)</span><br></pre></td></tr></tbody></table></figure>

<p> 我们的 <code>getZombiesByOwner</code> 方法将接收 <code>owner</code> 作为参数，并返回一个对我们函数 <code>getZombiesByOwner</code>的 Web3.js <code>call</code></p>
</li>
</ol>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Define `zombieToOwner` here</span></span><br><span class="line">     <span class="keyword">function</span> <span class="title function_">zombieToOwner</span>(<span class="params">id</span>){</span><br><span class="line">       <span class="keyword">return</span> cryptoZombies.<span class="property">methods</span>.<span class="title function_">zombieToOwner</span>(id).<span class="title function_">call</span>()</span><br><span class="line">     }</span><br><span class="line">     <span class="comment">// 2. Define `getZombiesByOwner` here</span></span><br><span class="line">     <span class="keyword">function</span> <span class="title function_">getZombiesByOwner</span>(<span class="params">owner</span>){</span><br><span class="line">       <span class="keyword">return</span> cryptoZombies.<span class="property">methods</span>.<span class="title function_">getZombiesByOwner</span>(owner).<span class="title function_">call</span>()</span><br><span class="line">     }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第5章-MetaMask-和账户"><a href="#第5章-MetaMask-和账户" class="headerlink" title="第5章: MetaMask 和账户"></a>第5章: MetaMask 和账户</h3><p>太棒了！你成功地写了一些前端代码来和你的第一个智能合约交互。</p>
<p>接下来我们综合一下——比如我们想让我们应用的首页显示用户的整个僵尸大军。</p>
<p>毫无疑问我们首先需要用 <code>getZombiesByOwner(owner)</code> 来查询当前用户的所有僵尸ID。</p>
<p>但是我们的 Solidity 合约需要 <code>owner</code> 作为 Solidity <code>address</code>。我们如何能知道应用用户的地址呢？</p>
<p><strong>获得 MetaMask中的用户账户</strong></p>
<p>MetaMask 允许用户在扩展中管理多个账户。</p>
<p>我们可以通过这样来获取 <code>web3</code> 变量中激活的当前账户：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> userAccount = web3.<span class="property">eth</span>.<span class="property">accounts</span>[<span class="number">0</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>因为用户可以随时在 MetaMask 中切换账户，我们的应用需要监控这个变量，一旦改变就要相应更新界面。例如，若用户的首页展示它们的僵尸大军，当他们在 MetaMask 中切换了账号，我们就需要更新页面来展示新选择的账户的僵尸大军。</p>
<p>我们可以通过 <code>setInterval</code> 方法来做:</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> accountInterval = <span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="comment">// 检查账户是否切换</span></span><br><span class="line">  <span class="keyword">if</span> (web3.<span class="property">eth</span>.<span class="property">accounts</span>[<span class="number">0</span>] !== userAccount) {</span><br><span class="line">    userAccount = web3.<span class="property">eth</span>.<span class="property">accounts</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 调用一些方法来更新界面</span></span><br><span class="line">    <span class="title function_">updateInterface</span>();</span><br><span class="line">  }</span><br><span class="line">}, <span class="number">100</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>这段代码做的是，每100毫秒检查一次 <code>userAccount</code> 是否还等于 <code>web3.eth.accounts[0]</code> (比如：用户是否还激活了那个账户)。若不等，则将 当前激活用户赋值给 <code>userAccount</code>，然后调用一个函数来更新界面。</p>
<p><strong>实战演习</strong></p>
<p>我们来让应用在页面第一次加载的时候显示用户的僵尸大军，监控当前 MetaMask 中的激活账户，并在账户发生改变的时候刷新显示。</p>
<ol>
<li><p>定义一个名为<code>userAccount</code>的变量，不给任何初始值。</p>
</li>
<li><p>在 <code>startApp()</code>函数的最后，复制粘贴上面样板代码中的 <code>accountInterval</code> 方法进去。</p>
</li>
<li><p>将 <code>updateInterface();</code>替换成一个 <code>getZombiesByOwner</code> 的 <code>call</code> 函数，并传入 <code>userAccount</code>。</p>
</li>
<li><p>在 <code>getZombiesByOwner</code> 后面链式调用<code>then</code> 语句，并将返回的结果传入名为 <code>displayZombies</code> 的函数。 (语句像这样: <code>.then(displayZombies);</code>).</p>
<p> 我们还没有 <code>displayZombies</code> 函数，将于下一章实现。</p>
</li>
</ol>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. declare `userAccount` here</span></span><br><span class="line">      <span class="keyword">var</span> userAccount;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">function</span> <span class="title function_">startApp</span>(<span class="params"></span>) {</span><br><span class="line">        <span class="keyword">var</span> cryptoZombiesAddress = <span class="string">"YOUR_CONTRACT_ADDRESS"</span>;</span><br><span class="line">        cryptoZombies = <span class="keyword">new</span> web3js.<span class="property">eth</span>.<span class="title class_">Contract</span>(cryptoZombiesABI, cryptoZombiesAddress);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. Create `setInterval` code here</span></span><br><span class="line">        <span class="keyword">var</span> accountInterval = <span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line">        <span class="comment">// 检查账户是否切换</span></span><br><span class="line">        <span class="keyword">if</span> (web3.<span class="property">eth</span>.<span class="property">accounts</span>[<span class="number">0</span>] !== userAccount) {</span><br><span class="line">          userAccount = web3.<span class="property">eth</span>.<span class="property">accounts</span>[<span class="number">0</span>];</span><br><span class="line">          <span class="comment">// 调用一些方法来更新界面</span></span><br><span class="line">          <span class="title function_">getZombiesByOwner</span>(userAccount).<span class="title function_">then</span>(displayZombies);</span><br><span class="line">        }</span><br><span class="line">      }, <span class="number">100</span>);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>




















      
    </div>
    <footer class="article-footer">
      
      
      
      
      
      
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item" data-aos="zoom-in"><a class="article-tag-list-link" href="/tags/Solidity/" rel="tag">Solidity</a></li><li class="article-tag-list-item" data-aos="zoom-in"><a class="article-tag-list-link" href="/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/" rel="tag">智能合约</a></li><li class="article-tag-list-item" data-aos="zoom-in"><a class="article-tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" rel="tag">编程语言</a></li></ul>


    </footer>
  </div>
  
  <nav id="article-nav" data-aos="fade-up">
    
      
      <div class="article-nav-link-wrap article-nav-link-left">
        
          
          
            <img data-src="/covers/21.jpg" data-sizes="auto" alt="OpenZeppelin的智能合约攻防挑战题解" class="lazyload">
          
        
        <a href="/2025/08/12/openzeppelin-de-zhi-neng-he-yue-gong-fang-tiao-zhan-ti-jie/"></a>
        <div class="article-nav-caption">Prev</div>
        <h3 class="article-nav-title">
          
            OpenZeppelin的智能合约攻防挑战题解
          
        </h3>
      </div>
    
    
    
    <div class="article-nav-link-wrap article-nav-link-right">
      
        
        
          <img data-src="/covers/7.jpg" data-sizes="auto" alt="Unphishable防钓鱼攻防挑战" class="lazyload">
        
      
      <a href="/2025/08/10/unphishable-fang-diao-yu-gong-fang-tiao-zhan/"></a>
      <div class="article-nav-caption">Next</div>
      <h3 class="article-nav-title">
        
          Unphishable防钓鱼攻防挑战
        
      </h3>
    </div>
    
  </nav>


</article>










</section>
        </div>
        <footer id="footer">
  <div style="width: 100%; overflow: hidden">
    <div class="footer-line"></div>
  </div>
  <div id="footer-info">
    
    <div>
      <span class="icon-copyright"></span>
      
      
      
        2024-2025
      
      <span class="footer-info-sep "></span>
      mX1@0
    </div>
    
      <div>
        Powered by&nbsp;<a href="https://hexo.io/" rel="noopener external nofollow noreferrer" target="_blank">Hexo</a>&nbsp;
        Theme.<a href="https://github.com/D-Sketon/hexo-theme-reimu" rel="noopener external nofollow noreferrer" target="_blank">Reimu</a>
      </div>
    
    
      <div>
        <span class="icon-brush"></span>
        286.1k
        &nbsp;|&nbsp;
        <span class="icon-coffee"></span>
        17:51
      </div>
    
    
    
    
    
      <div>
        <span class="icon-eye"></span>
        <span id="busuanzi_container_site_pv">Number of visits&nbsp;<span id="busuanzi_value_site_pv"></span></span>
        &nbsp;|&nbsp;
        <span class="icon-user"></span>
        <span id="busuanzi_container_site_uv">Number of visitors&nbsp;<span id="busuanzi_value_site_uv"></span></span>
      </div>
    
  </div>
</footer>

        
          <div class="sidebar-top">
            <div class="sidebar-top-taichi rotate"></div>
            <div class="arrow-up"></div>
          </div>
        
        <div id="mask" class="hide"></div>
      </div>
      <nav id="mobile-nav">
  <div class="sidebar-wrap">
    
      
        <div class="sidebar-toc-sidebar"><div class="sidebar-toc">
  <h3 class="toc-title">Contents</h3>
  <div class="sidebar-toc-wrapper toc-div-class" >
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#CryptoZombiesx%E7%9A%84solidity%E5%AD%A6%E4%B9%A0"><span class="toc-text">CryptoZombiesx的solidity学习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Solidity-Beginner-to-Intermediate-Smart-Contracts"><span class="toc-text">Solidity: Beginner to Intermediate Smart Contracts</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lesson1-%E6%90%AD%E5%BB%BA%E5%83%B5%E5%B0%B8%E5%B7%A5%E5%8E%82"><span class="toc-text">lesson1 搭建僵尸工厂</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E5%90%88%E7%BA%A6"><span class="toc-text">第2章: 合约</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B4%E6%95%B0"><span class="toc-text">第3章: 状态变量和整数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97"><span class="toc-text">第4章: 数学运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">第5章: 结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E6%95%B0%E7%BB%84"><span class="toc-text">第6章: 数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><span class="toc-text">第7章: 定义函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-text">第8章: 使用结构体和数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-%E7%A7%81%E6%9C%89-%E5%85%AC%E5%85%B1%E5%87%BD%E6%95%B0"><span class="toc-text">第9章: 私有 &#x2F; 公共函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-%E5%87%BD%E6%95%B0%E7%9A%84%E6%9B%B4%E5%A4%9A%E5%B1%9E%E6%80%A7"><span class="toc-text">第10章: 函数的更多属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-Keccak256-%E5%92%8C-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">第11章: Keccak256 和 类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-%E6%94%BE%E5%9C%A8%E4%B8%80%E8%B5%B7"><span class="toc-text">第12章: 放在一起</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-%E4%BA%8B%E4%BB%B6"><span class="toc-text">第13章: 事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-Web3-js"><span class="toc-text">第14章: Web3.js</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lesson2-%E5%83%B5%E5%B0%B8%E6%94%BB%E5%87%BB%E4%BA%BA%E7%B1%BB"><span class="toc-text">lesson2 僵尸攻击人类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E6%98%A0%E5%B0%84%EF%BC%88Mapping%EF%BC%89%E5%92%8C%E5%9C%B0%E5%9D%80%EF%BC%88Address%EF%BC%89"><span class="toc-text">第2章: 映射（Mapping）和地址（Address）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-Msg-sender"><span class="toc-text">第3章: Msg.sender</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-Require"><span class="toc-text">第4章: Require</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E7%BB%A7%E6%89%BF%EF%BC%88Inheritance%EF%BC%89"><span class="toc-text">第5章: 继承（Inheritance）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E5%BC%95%E5%85%A5%EF%BC%88Import%EF%BC%89"><span class="toc-text">第6章: 引入（Import）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-Storage%E4%B8%8EMemory"><span class="toc-text">第7章: Storage与Memory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E5%83%B5%E5%B0%B8%E7%9A%84DNA"><span class="toc-text">第8章: 僵尸的DNA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-%E6%9B%B4%E5%A4%9A%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-text">第9章: 更多关于函数可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-%E5%83%B5%E5%B0%B8%E5%90%83%E4%BB%80%E4%B9%88"><span class="toc-text">第10章: 僵尸吃什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3"><span class="toc-text">第11章: 使用接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-%E5%A4%84%E7%90%86%E5%A4%9A%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">第12章: 处理多返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-%E5%A5%96%E5%8A%B1-Kitty-%E5%9F%BA%E5%9B%A0"><span class="toc-text">第13章: 奖励: Kitty 基因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-%E6%94%BE%E5%9C%A8%E4%B8%80%E8%B5%B7"><span class="toc-text">第14章: 放在一起</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lesson3-%E9%AB%98%E7%BA%A7-Solidity-%E7%90%86%E8%AE%BA"><span class="toc-text">lesson3 高级 Solidity 理论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-%E6%99%BA%E8%83%BD%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%B0%B8%E5%9B%BA%E6%80%A7"><span class="toc-text">第1章: 智能协议的永固性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-Ownable-Contracts"><span class="toc-text">第2章: Ownable Contracts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-onlyOwner-%E5%87%BD%E6%95%B0%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">第3章: onlyOwner 函数修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-Gas"><span class="toc-text">第4章: Gas</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E6%97%B6%E9%97%B4%E5%8D%95%E4%BD%8D"><span class="toc-text">第5章: 时间单位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E5%83%B5%E5%B0%B8%E5%86%B7%E5%8D%B4"><span class="toc-text">第6章: 僵尸冷却</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-%E5%85%AC%E6%9C%89%E5%87%BD%E6%95%B0%E5%92%8C%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-text">第7章: 公有函数和安全性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%87%BD%E6%95%B0%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">第8章: 进一步了解函数修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-%E5%83%B5%E5%B0%B8%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">第9章: 僵尸修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-%E5%88%A9%E7%94%A8-%E2%80%98View%E2%80%99-%E5%87%BD%E6%95%B0%E8%8A%82%E7%9C%81-Gas"><span class="toc-text">第10章: 利用 ‘View’ 函数节省 Gas</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-%E5%AD%98%E5%82%A8%E9%9D%9E%E5%B8%B8%E6%98%82%E8%B4%B5"><span class="toc-text">第11章: 存储非常昂贵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-For-%E5%BE%AA%E7%8E%AF"><span class="toc-text">第12章: For 循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-%E6%94%BE%E5%9C%A8%E4%B8%80%E8%B5%B7"><span class="toc-text">第13章: 放在一起</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lesson4-%E5%83%B5%E5%B0%B8%E4%BD%9C%E6%88%98%E7%B3%BB%E7%BB%9F"><span class="toc-text">lesson4 僵尸作战系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-%E5%8F%AF%E6%94%AF%E4%BB%98"><span class="toc-text">第1章: 可支付</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E6%8F%90%E7%8E%B0"><span class="toc-text">第2章: 提现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-%E5%83%B5%E5%B0%B8%E6%88%98%E6%96%97"><span class="toc-text">第3章: 僵尸战斗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="toc-text">第4章: 随机数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E5%83%B5%E5%B0%B8%E5%AF%B9%E6%88%98"><span class="toc-text">第5章: 僵尸对战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E9%87%8D%E6%9E%84%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91"><span class="toc-text">第6章: 重构通用逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-%E6%9B%B4%E5%A4%9A%E9%87%8D%E6%9E%84"><span class="toc-text">第7章: 更多重构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E5%9B%9E%E5%88%B0%E6%94%BB%E5%87%BB%EF%BC%81"><span class="toc-text">第8章: 回到攻击！</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-%E5%83%B5%E5%B0%B8%E7%9A%84%E8%BE%93%E8%B5%A2"><span class="toc-text">第9章: 僵尸的输赢</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-%E5%83%B5%E5%B0%B8%E8%83%9C%E5%88%A9%E4%BA%86-%F0%9F%98%84"><span class="toc-text">第10章: 僵尸胜利了 😄</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-%E5%83%B5%E5%B0%B8%E5%A4%B1%E8%B4%A5-%F0%9F%98%9E"><span class="toc-text">第11章: 僵尸失败 😞</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lesson5-ERC721-%E6%A0%87%E5%87%86%E5%92%8C%E5%8A%A0%E5%AF%86%E6%94%B6%E8%97%8F%E5%93%81"><span class="toc-text">lesson5 ERC721 标准和加密收藏品</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%B8%8A%E7%9A%84%E4%BB%A3%E5%B8%81"><span class="toc-text">第1章: 以太坊上的代币</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-ERC721-%E6%A0%87%E5%87%86-%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-text">第2章: ERC721 标准, 多重继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-balanceOf-%E5%92%8C-ownerOf"><span class="toc-text">第3章: balanceOf 和 ownerOf</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E9%87%8D%E6%9E%84"><span class="toc-text">第4章: 重构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-ERC721-%E8%BD%AC%E7%A7%BB%E6%A0%87%E5%87%86"><span class="toc-text">第5章: ERC721: 转移标准</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-ERC721-%E8%BD%AC%E7%A7%BB-%E7%BB%AD"><span class="toc-text">第6章: ERC721: 转移-续</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-ERC721-%E6%89%B9%E5%87%86"><span class="toc-text">第7章: ERC721: 批准</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-ERC721-takeOwnership"><span class="toc-text">第8章: ERC721: takeOwnership</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-%E9%A2%84%E9%98%B2%E6%BA%A2%E5%87%BA"><span class="toc-text">第9章: 预防溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-SafeMath-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86"><span class="toc-text">第10章: SafeMath 第二部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-SafeMath-%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86"><span class="toc-text">第11章: SafeMath 第三部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-SafeMath-%E7%AC%AC4%E9%83%A8%E5%88%86"><span class="toc-text">第12章: SafeMath 第4部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-%E6%B3%A8%E9%87%8A"><span class="toc-text">第13章: 注释</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B"><span class="toc-text">总结一下</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lesson6-%E5%BA%94%E7%94%A8%E5%89%8D%E7%AB%AF%E5%92%8C-Web3-js"><span class="toc-text">lesson6 应用前端和 Web3.js</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-%E4%BB%8B%E7%BB%8D-Web3-js"><span class="toc-text">第1章: 介绍 Web3.js</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-Web3-%E6%8F%90%E4%BE%9B%E8%80%85"><span class="toc-text">第2章: Web3 提供者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-%E5%92%8C%E5%90%88%E7%BA%A6%E5%AF%B9%E8%AF%9D"><span class="toc-text">第3章: 和合约对话</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E8%B0%83%E7%94%A8%E5%92%8C%E5%90%88%E7%BA%A6%E5%87%BD%E6%95%B0"><span class="toc-text">第4章: 调用和合约函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-MetaMask-%E5%92%8C%E8%B4%A6%E6%88%B7"><span class="toc-text">第5章: MetaMask 和账户</span></a></li></ol></li></ol></li></ol>
      
  </div>
</div>
</div>
        <div class="sidebar-common-sidebar hidden"><div class="sidebar-author">
  <img data-src="/avatar/avatar.webp" data-sizes="auto" alt="mX1@0" class="lazyload">
  <div class="sidebar-author-name">mX1@0</div>
  <div class="sidebar-description"></div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>Post</div>
    <div class="sidebar-state-number">54</div>
  </div>
  <div class="sidebar-state-category">
    <div>Category</div>
    <div class="sidebar-state-number">25</div>
  </div>
  <div class="sidebar-state-tag">
    <div>Tag</div>
    <div class="sidebar-state-number">65</div>
  </div>
</div>
<div class="sidebar-social">
  
    <div class="icon-twitter sidebar-social-icon">
      <a href=https://x.com/0xMx1a0 itemprop="url" target="_blank" aria-label="twitter" rel="noopener external nofollow noreferrer"></a>
    </div>
  
</div>
<div class="sidebar-menu">
  
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/" aria-label="首页"></a>
        <div class="sidebar-menu-icon icon rotate">
          
            &#xe62b;
          
        </div>
        <div class="sidebar-menu-link">首页</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/archives" aria-label="归类"></a>
        <div class="sidebar-menu-icon icon rotate">
          
            &#xe62b;
          
        </div>
        <div class="sidebar-menu-link">归类</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/about" aria-label="关于"></a>
        <div class="sidebar-menu-icon icon rotate">
          
            &#xe62b;
          
        </div>
        <div class="sidebar-menu-link">关于</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/friend" aria-label="友链"></a>
        <div class="sidebar-menu-icon icon rotate">
          
            &#xe62b;
          
        </div>
        <div class="sidebar-menu-link">友链</div>
      </div>
    
  
</div>
</div>
      
    
  </div>
  
    
      <div class="sidebar-btn-wrapper">
        <div class="sidebar-toc-btn current"></div>
        <div class="sidebar-common-btn"></div>
      </div>
    
  
</nav>

    </div>
    
    
    
    
<script src="https://npm.webcache.cn/lazysizes@5.3.2/lazysizes.min.js" integrity="sha384-3gT&#x2F;vsepWkfz&#x2F;ff7PpWNUeMzeWoH3cDhm&#x2F;A8jM7ouoAK0&#x2F;fP&#x2F;9bcHHR5kHq2nf+e" crossorigin="anonymous"></script>


<script src="https://npm.webcache.cn/clipboard@2.0.11/dist/clipboard.min.js" integrity="sha384-J08i8An&#x2F;QeARD9ExYpvphB8BsyOj3Gh2TSh1aLINKO3L0cMSH2dN3E22zFoXEi0Q" crossorigin="anonymous"></script>





<script src="/js/script.js"></script>



  
<script src="/js/aos.js"></script>

  <script>
    var aosInit = () => {
      AOS.init({
        duration: 1000,
        easing: "ease",
        once: true,
        offset: 50,
      });
    };
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', aosInit);
    } else {
      aosInit();
    }
  </script>



<script src="/js/pjax_script.js" data-pjax></script>







  
<script src="https://npm.webcache.cn/mouse-firework@0.1.1/dist/index.umd.js" integrity="sha384-8LyaidD9GPxQQgLJO&#x2F;WRw&#x2F;O2h3BoNq&#x2F;ApI&#x2F;ecpvM6RsrCz2qP2ppBXUKihP4V&#x2F;2d" crossorigin="anonymous"></script>

  <script>
    window.firework && window.firework(JSON.parse('{"excludeElements":["a","button"],"particles":[{"shape":"circle","move":["emit"],"easing":"easeOutExpo","colors":["var(--red-1)","var(--red-2)","var(--red-3)","var(--red-4)"],"number":20,"duration":[1200,1800],"shapeOptions":{"radius":[16,32],"alpha":[0.3,0.5]}},{"shape":"circle","move":["diffuse"],"easing":"easeOutExpo","colors":["var(--red-0)"],"number":1,"duration":[1200,1800],"shapeOptions":{"radius":20,"alpha":[0.2,0.5],"lineWidth":6}}]}'))
  </script>










<div id="lazy-script">
  <div>
    
      
      
      <script data-pjax>
        window.REIMU_POST = {
          author: "mX1@0",
          title: "CryptoZombiesx的Solidity学习",
          url: "http://example.com/2025/08/10/cryptozombiesx-de-solidity-xue-xi/",
          excerpt: "",
          description: "",
          stripContent: "CryptoZombiesx的solidity学习Solidity: Beginner to Intermediate Smart Contractslesson1 搭建僵尸工厂第2章: 合约从最基本的开始入手: Solidity 的代码都包裹在合约里面. 一份合约就是以太应币应用的基本模块， 所有的变量和函数都属于一份合约, 它是你所有应用的起点. 一份名为 HelloWorld 的空合约如下: 123contract HelloWorld {}  版本指令 所有的 Solidity 源码都必",
          date: "Sun Aug 10 2025 23:38:00 GMT+0800",
          updated: "Wed Aug 20 2025 17:38:52 GMT+0800",
          cover: "/images/%E7%8E%9B%E8%8E%8E%E6%8B%89%E8%92%82.jpg",
        };
      </script>
       
    
    
      
        
<script src="/js/insert_highlight.js" data-pjax></script>

        
      
    
    
      <script type="module" data-pjax>
        const PhotoSwipeLightbox = (await safeImport("https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe-lightbox.esm.min.js", "sha384-DiL6M/gG+wmTxmCRZyD1zee6lIhawn5TGvED0FOh7fXcN9B0aZ9dexSF/N6lrZi/")).default;
        
        const pswp = () => {
          if (_$$('.article-entry a.article-gallery-item').length > 0) {
            new PhotoSwipeLightbox({
              gallery: '.article-entry',
              children: 'a.article-gallery-item',
              pswpModule: () => safeImport("https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8+oTJ7m3DfYEWX1fu1scuS4+s")
            }).init();
          }
          if(_$$('.article-gallery a.article-gallery-item').length > 0) {
            new PhotoSwipeLightbox({
              gallery: '.article-gallery',
              children: 'a.article-gallery-item',
              pswpModule: () => safeImport("https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8+oTJ7m3DfYEWX1fu1scuS4+s")
            }).init();
          }
          window.lightboxStatus = 'done';
          window.removeEventListener('lightbox:ready', pswp);
        }
        if(window.lightboxStatus === 'ready') {
          pswp()
        } else {
          window.addEventListener('lightbox:ready', pswp);
        }
      </script>
      
        








      
    
  </div>
</div>


  <script>
    console.log(String.raw`%c 
 ______     ______     __     __    __     __  __    
/\  == \   /\  ___\   /\ \   /\ "-./  \   /\ \/\ \   
\ \  __<   \ \  __\   \ \ \  \ \ \-./\ \  \ \ \_\ \  
 \ \_\ \_\  \ \_____\  \ \_\  \ \_\ \ \_\  \ \_____\ 
  \/_/ /_/   \/_____/   \/_/   \/_/  \/_/   \/_____/ 
                                                  
`,'color: #ff5252;')
    console.log('%c Theme.Reimu v' + '1.9.0' + ' %c https://github.com/D-Sketon/hexo-theme-reimu ', 'color: white; background: #ff5252; padding:5px 0;', 'padding:4px;border:1px solid #ff5252;')
  </script>
  



  
<script src="https://npm.webcache.cn/busuanzi@2.3.0/bsz.pure.mini.js" integrity="sha384-0M75wtSkhjIInv4coYlaJU83+OypaRCIq2SukQVQX04eGTCBXJDuWAbJet56id+S" crossorigin="anonymous" async></script>




<script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.getRegistrations().then((registrations) => {
      for (let registration of registrations) {
        registration.unregister();
      }
    });
  }
</script>









    
  </body>
  </html>

